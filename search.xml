<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[20191029模拟-xgc]]></title>
    <url>%2Fposts%2Fc4054fc6.html</url>
    <content type="text"><![CDATA[xgc的场 「雅礼集训 2018 Day2」颜色题意：给出一个长度为n的序列，q次强制在线询问，每次给出若干区间，回答这些区间一共有多少不同的数，$n,区间个数和 \le 1e5$，时限1.5s，空间20M 请先思考后再展开 $n（值域）=1e5，m（长度、询问数）=1e5$ 因为是每次多个区间，我们要想办法快速合并信息，所以肯定不是直接用前缀和而是用bitset 不太好搞的合并信息，可以考虑一下根号算法，先给序列分块 如果每个块直接一个bitset到时候合并肯定时不行的，一个自然的想法是预处理每个块区间的bitset 直接这样做就是$(\frac{m}{T})^2*\frac{n}{w}+m*(2T+\frac{n}{w})$，注意到时间勉强（3亿）可以而空间是主要矛盾，现在是$(\frac{m}{T})^2*\frac{n}{w}$ 注意到时间复杂度上，我们是$O(1)$获取了整块区间bitset，而其实改成$\frac{n}{w}$都是没有问题的，能否牺牲这个换空间？ 再考虑核心矛盾主要用来存储范围是$\frac{m}{T}$的所有区间信息的合并，然而$[l,r]=[l,xx] \cup [xx+1,r]$，这些区间信息是可以通过预处理省去不少的 通俗来说就是ST表预处理，于是时间复杂度为$\frac{n}{w}*(\frac{m}{T})log(\frac{m}{T})+m*(2T+\frac{n}{w})$，空间复杂度为$\frac{n}{w}*(\frac{m}{T})log(\frac{m}{T})$，为了空间限制时间为2亿 其实可以进一步优化，回到题目的特性是多少不同的数，对于只出现一次的数，一个前缀和完事，于是$n（值域）=5e4，m（长度、询问数）=1e5$，于是块大小大概300就行了 XSY #3478 取石子题意：一开始小A有x个石子，小B有y个石子。给出长为n的序列表示进行n轮游戏，奇数轮小A从小B那取走$a_i$个，偶数轮小B从小A那取走$a_i$个，如果某次取不了这么多就取到没有为止。多次询问，每次询问前修改x、y、a的某位，$n,q \le 1e6$ 请先思考后再展开 $$\\显然总和sum一定，只需要关注小A手上的石子，B_i=A_i*(i奇?1:-1)，x=max(min(x+B_i,sum),0)\\设B的和S，最小前缀和mi，最大前缀和mx，则如果mx-mx \ge S，答案与x无关\\否则，答案为 min(max(x+S,0+(S-mi)),sum-(mx-S))$$将上述内容放到线段树上即可支持维护，查询就在上面二分，$O(nlogn)$ loj6558「CERC2018」Game of Stones此题为候选，最后并没有出 请先思考后再展开 首先我不是特别懂sg的那套理论，本来想用点小聪明，通过设置两维状态来规避公平组合游戏中双方可行操作相同的限制，但似乎gg了 分类讨论，A=B直接巴什博弈；否则，大致思路是考虑尼姆博弈，即考虑将局面变成都在$C=min(A,B)$以内，然后考虑能否随心所欲掌控sg值，记住各个游戏间，操作顺序并没有意义 一、A&gt;B设只有一堆超过C，那么归纳或者感受一下可以发现，最后总是可以给对方一个【都在C内，sg异或和=0】的局面，因为自己的可行操作数严格大于对手；多堆的话，其他堆乱玩即可 二、A&lt;B假如只有一堆，那么能获胜当且仅当能一步把局面变成【都在C内，sg异或和=0】给对手。如果有多堆，那一定输，思维同上 code CF1096E终于有我会做的题了…… 请先思考后再展开 $$\\分子=\sum_{mx=r} \sum_{i=1} C_{n-1}^{i-1}/i*f(sum-i*mx,n-i,mx) ，分母=\sum_{mx} f(sum-mx,n-1)=\sum_{mx} C_{sum-mx+n-2}^{n-2}=C_{sum-r+n-1}^{n-1}\\f表示和、数量、上界（开区间），f(sum,0,mx)=[sum=0],f(sum,n,mx)=\sum_{i=0}^n (-1)^i C_{n}^{i} C_{sum-i*mx+n-1}^{n-1}\\分子=\frac{1}{n}*\sum_{mx=r}^{sum}[sum-n*mx=0] +\sum_{i=1}^{n-1} \sum_{j=0}^{n-i} C_{n-1}^{i-1}/i*(-1)^j C_{n-i}^j \sum_{mx=r}^{sum} C_{sum-(i+j)*mx+n-i-1}^{n-i-1},最坏O(Sn^2)\\似乎除了fft也没啥再能优化的了，让我们回到最顶上那个式子\\考虑分子算出来东西的本质，就是C_{n-1}^{最大值个数-1}/最大值个数*【剩下&lt;最大值的方案数】=\frac{1}{n} *C_{n}^{最大值个数}*【剩下&lt;最大值的方案数】\\注意到后面的部分其实就是【最大值 \ge r】的方案数，直接调用一次f求，单组询问O(n)$$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cojR13]]></title>
    <url>%2Fposts%2F66eeb7d6.html</url>
    <content type="text"><![CDATA[Sourcecommetoj R13 D「火鼠的皮衣 -不焦躁的内心-」请先思考后再展开 首先想到的是求出二次剩余，即$ans=\sum_{i=0}^n [i\%2=0] C_n^i (\sqrt a)^i b^{n-i}=((b+\sqrt a)^n+(b-\sqrt a)^n)/2$ 如果每个数都有二次剩余的话直接CRT就好了，但众所周知有一半的数都没有二次剩余 还好这时灵光一闪想到了拓域，即$(i,j)=i*\sqrt a+j$去快速幂，和的二元组中一定$i=0$ 然后这里2可能没有逆元，一个经典的解决办法就是$P*=2$（我见识少不知道，还好xgc会），code 当然其实也可以分析一下，考虑一下二元组中j是怎么被贡献出来的，显然此时根号的次幂是个偶数，所以-1会被消掉，上面的两个二元组的j其实是一样的，只求一个，不用/2，code E 「燕的子安贝 -永命线-」请先思考后再展开 如果我们知道直线的斜率，那就是要两条距离为2d的平行线内点尽量多，一定存在一种最优方案使得两条平行线其中一条上有点 于是我们枚举在其中一条平行线上的点A去更新答案，考虑哪些斜率（不妨规定其方向为，能使另一条平行线在右侧的方向）能覆盖点B：$$\\ \alpha=atan2(B_y-A_y,B_x-A_x),\beta=asin(\frac{2d}{|AB|})\\ 对于|AB| \le 2d即B在圆内，[\alpha,\alpha+\pi]\\ 对于|AB|&gt;2d，[\alpha,\alpha+\beta] \cup [\alpha+\pi-\beta,\alpha+\pi]$$见图知真相（对顶角）： 然后就是在各个角度中选择被覆盖最多的即可，注意到虽然角度是个环但并没什么卵用，跨环啥的直接拆开来就行了 我是直接用map作为差分的，这样的话记得要合并差&lt;eps的部分；其他做法不太清楚，$O(n^2logn)$，code F「蓬莱的弹枝 -七色的弹幕-」请先思考后再展开 这题是在大家讨论的熏陶下想到的 对序列分块，每个块存里面元素的链表、值域的桶（开short即可，unorder很慢会tle） 那么操作1就是移动根号次链表的端点，操作2就是区间打个lazy标记，操作3就是直接询问桶 只要把链表维护好就很好写了，然而硬是写了1.5h，调了1h，比赛结束才刚过样例没开拍，然后车队里的xgc要写平衡树（不影响复杂度），直到目前都还没调出来…… $O((n+q) \sqrt n)$，code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CFR596]]></title>
    <url>%2Fposts%2F6d278cf9.html</url>
    <content type="text"><![CDATA[CFR596 div1 好题：CF1246C Rock Is Push、CF1246E To Make 1 比赛的时候C做了1h，导致没时间做D，其实还是很可做的 CF1246A p-binary题意：给出$1 \le n \le 1e9和-1e3 \le p \le 1e3，问最小的t使得n为t个可以相同的【2^{非负}+p】之和$ 请先思考后再展开 对于一个t，考虑如何判断是否可行；$n-tp&lt;0$显然无解，然后至少是$__builtin_popcount(n-tp)$，至多是n-tp，而只要在这之内，肯定能用t个$2^{非负}表示出n-tp$；于是显然t没有必要超过logn，直接枚举t即可，code CF1246B Power Products题意：给出n个数$a_i$，统计$\sum_{i=1}^n \sum_{j=i+1}^n [\exists x^k=a_i*a_j ]$，$a_i,n \le 1e5$ 请先思考后再展开 和agc003D - Anticube有点像，把每个数分解质因数，指数模k，称得到的数为这个数的最简式（显然不大于），于是能和这个数匹配的最简式是唯一确定的，直接拿个东西计数，边输入边找即可 $O(分解质因数+nlogn)$，code CF1246C Rock Is Push题意：给出一个有石子的表格，n行m列（$n,m \le 2e3$），要从$(1,1)到(n,m)$，然后像这样走，要求只能向右或下，石子不能被推出去，求方案数模1e9+7 请先思考后再展开 一脸dp计数的样子，而且因为只能向右或向下，你会发现向下的时候这一行的石子就没用了，向右的时候这一列也没用了，然后为了能准确得到例如正在向下时下面有多少石子，有点套路地每次强制【向右至少1次+向下至少1次】$$\\设从(a,b) \to (i,j)，预处理出g[i][j]表示第i行中第j个后面的石子数，h[j][i]表示第j列中第i个后面的石子数\\f(i,j) = \sum_{a&lt;i} \sum_{b&lt;j} f(a,b)，能过来的充要条件明显是g[a][b+1] \le m-j,h[j][a+1] \le n-i$$因为g和h是单调的，决策集合明显是个区间，可以双指针维护，递增枚举列j，移动每行的b的双指针（当时写了二分）并记录这行的合法转移的f和，然后递增枚举行i并维护仅对于这一列的指针a，利用前面处理的f和求出能转移过来的总和fsum即可 $O(n^2)$，code upd：其实没必要每次走两步来着，钦定转向也是可以的，就是多加入一维表示方向，代码复杂度的话可能不会差太多 CF1246D Tree Factory题意：给出一个n个节点0为根的树（保证父亲标号比自己小），要求构造一条链并求出最小的k，在k步内将这条链变成这棵树并输出每一步；操作为选择一个有祖父的节点，然后将自己的父亲改为祖父；保证$n \le 1e5,操作数 \le 1e6$ 请先思考后再展开 一脸贪心的样子，而且很明显倒过来想从树搞成链，每次选一个有兄弟的节点将父亲调整为兄弟（显然链的根还是0） 一开始的想法：从下往上考虑，对于x的每个孩子已经成链，现在要合并链，其实等价于n个数每次选两个合并成新数为其和，最后成一个，每步的代价为min，显然是贪心做，排序后从大往小合并，代价和=总代价和-最大数 冷静想想这并不是很对，考虑x的一个孩子y和孩子z，z的链应该先合到y最大链上，y最大链再往前 那其实修一修就好了，这其实等价于求长链剖分的长链长度，从下往上做排序即可 至于输出方案要正着输出，那么就是从下往上，同一个节点的孩子从小到大做，code CF1246E To Make 1题意：给出n个数$a_i$和一个常数K，保证初始n个数都不是k的倍数，做n-1次每次选两个数为其和，并将其中K的次幂除掉，构造方案（每次输出合并的两个值）或判断无解，$n \le 16,k,\sum a_i \le 2e3$ 请先思考后再展开 考虑每个数在和中的系数，最后一定满足等式$1=\sum_{i=1}^n a_i*K^{-b_i}$结论：任意满足上式的b，都能够构造出方案，可以用归纳+构造证明当$n=1，肯定a_1=1,b_1=0$；对于长度为n的b，考虑得出对于这个局面第一步操作是什么，$B=max\ b_i$，一定存在至少两个$b_i=B$（反证只有一个，变形成$K^B=1+\sum_{i \ne one} a_i*K^{B-b_i&gt;0}$，显然左边是K的倍数而右边不是）将这个作为最后一次的操作，合并起来，$newb=B-times_of_k(a_i+a_j)$，然后剩下n-1个，继续给他们构造操作$$\\于是我们就能做一个较低复杂度的状压dp维护b了，倒推\\f(S,now=\sum a_i*K^{-b_i}),f(\emptyset,0)=true\\f(S|2^i,now+a_i)|=f(S,now);f(S,now)|=f(S,now*K)\\第一种转移的复杂度为2^nn*sum/32,第二种为2^n*sum$$ code CF1246F Cursor Distance咕咕咕]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191026模拟-lhy]]></title>
    <url>%2Fposts%2F174ef833.html</url>
    <content type="text"><![CDATA[lhy的场 「ZJOI2017」线段树请先思考后再展开 答案的组成需要考虑广义线段树的结构，如果学过zkw可能会很熟悉：定位出$x=[l-1,l-1]和y=[r+1,r+1]$，也就是变成开区间（要将$[0,0]$和$[n+1,n+1]$放进去），那么答案就是【x到lca路径上，作为左孩子时统计右孩子】+【y到lca路径上，作为右孩子时统计左孩子】 考试的时候想到了转成开区间，但对于具体怎么统计不太记得了，就先跳了这题，不过确实也不好写 核心代码很短： 12345678910111213141516171819202122232425262728293031fo(x,1,rt) val1[ !isleft[x] ][x]--,val1[ !isleft[x] ][ff[x]]++,val2[ !isleft[x] ][x]-=dep[x],val2[ !isleft[x] ][ff[x]]+=dep[x];//小容斥，树上差分//----------------------------ll solve(int wt,int u,int x,int lca,int LCA)&#123; ll sum1,sum2,ans=0; if(in(LCA,lca))//LCA在lca子树中 &#123; sum1=val1[wt][x]-val1[wt][LCA];sum2=val2[wt][x]-val2[wt][LCA]; ans+=sum2+sum1*(dep[u]-2*dep[lca]); &#125; else//lca!=LCA &#123; sum1=val1[wt][x]-val1[wt][lca];sum2=val2[wt][x]-val2[wt][lca]; if(sz(son[lca]) and in(x,son[lca][wt])) sum1++,sum2+=dep[son[lca][wt]];//想容斥去掉lca，现在不需要了 ans+=sum1*(dep[u]-dep[lca]*2)+sum2; sum1=val1[wt][lca]-val1[wt][LCA];sum2=val2[wt][lca]-val2[wt][LCA]; if(sz(son[lca])) &#123; if(in(x,son[lca][wt])) sum1--,sum2-=dep[son[lca][wt]];//错误地将son[lca][wt]计入答案 else if(in(u,son[lca][wt])) ans-=2;//son[lca][wt]并不需要上去再下来 &#125; ans+=sum1*(dep[u]+2)-sum2; &#125; return ans;&#125;//----------------------------ll ans=0;if(x!=LCA) ans+=solve(1,u,x,getlca(x,u),LCA);if(y!=LCA) ans+=solve(0,u,y,getlca(y,u),LCA);write2(ans); 复杂度瓶颈为求lca，完整code CF878E Numbers on the blackboard题意：给出一个长为n的序列，q次询问合并一段区间成一个数的最大值，合并操作为选相邻的两个数$x,y \to x+2y$，$n,q \le 2e5$ 请先思考后再展开 首先很明显每个数的系数都是2的次幂，而且除了第一个数是1外至少是2，接下来忽略第一个数 考试的时候只想到了从后往前的做法，然而不太能优化：考虑$[l,r]中的r，如果a_r&lt;0肯定是solve(l,r-1)+2*a_r；否则一定是a_{r-1}+=a_r,solve(l,r-1)$ 然后部分分有提示下我想搞出一个从前往后的，根据上面的想法，考虑树形结构，每次加入最后一个数后维护树形结构 然后就自闭了……其实就是想成树形结构后不太会快速维护了……因为看起来势能不明显，改成栈结构就不一样了。 引入块的概念：注意到我们上面序列的理解时，将这个数和上个数合并，那现在从左往右做的话，就是每次不断取出最后面的一个块，如果和非负，合并到上一个块中（需要记录每个块的长度来处理新系数），这样就是维护栈的过程，于是我们得到了一个从左往右而且结构清晰的做法 那我们如此追求从前往后做，究竟是得出了什么性质方便处理区间询问？按右端点排序，对于一个左端点l所在的块（设l及左边是A，l右边是B），这个B一定是不会与后面合并或裂开的，不合并显然，如果裂开成a和b，显然b&lt;0，显然当时就不会把b放到这个块中，所以也不存在 于是二分找到这个块，查询后缀和即可（栈结构，所谓维护前缀和即可），关于原数，我们只关心与0的大小关系，注意到只有非负数会向前累计且乘上系数（至少2），所以负数不会很小，非负数的话如果太大可以永久设置为inf（一旦超过2e9就不会再低于） $O(nlogn)$ 1234567891011121314151617181920212223242526272829303132const ll MXNUM=2e9;ll val[N],bin[N];pr sta[N];int top;ll sum[N];//块的前缀和ll a[N],b[N];ll getnum(int l,int r)&#123;return (b[l]+MOD-b[r+1]*bin[r-l+1]%MOD)*2%MOD;&#125;vc&lt;pr&gt; qes[N];int ans[N];void main()&#123; int n=qread(),q=qread();fo(i,1,n) a[i]=qread(); bin[0]=1;fo(i,1,n) bin[i]=bin[i-1]*2%MOD; fd(i,n,1) b[i]=(b[i+1]*2+MOD+a[i])%MOD; fo(i,1,q) &#123;int l=qread(),r=qread();qes[r].PB(MP(l,i));if(r==1) ans[i]=a[1];&#125; fo(r,2,n) &#123; sta[++top]=MP(r,r);val[top]=a[r]*2; while(top&gt;1 and val[top]&gt;=0) &#123; int ln=sta[top-1].SE-sta[top-1].FR+1; if((ln&gt;31 and val[top]&gt;0) or (val[top-1]+(val[top]&lt;&lt;ln)&gt;MXNUM)) val[top-1]=MXNUM; else val[top-1]=val[top-1]+(val[top]&lt;&lt;ln); top--;sta[top].SE=r; &#125; sum[top]=(sum[top-1]+val[top])%MOD; for(auto qq:qes[r]) &#123; int l=qq.FR,id=qq.SE,pos=upper_bound(sta+1,sta+top+1,MP(l+1,INF))-sta-1; ans[id]=(sum[top]-sum[pos]+getnum(l+1,sta[pos].SE)+a[l])%MOD; &#125; &#125; fo(i,1,q) write2((ans[i]+MOD)%MOD);&#125; 附赠一组数据： 123456789101139 2-323234955 -13554851 -123440597 472130426 672108688-653249727 277910975 -828753454 -114968816 -565464233-306030157 229718280 -93206797 186181819 -12895015320850407 -996529151 -960614046 571549914 11489791154330123 -893571971 875707713 -31932276 19688743689434767 -475230657 -672819122 225392755 -958315585-954084193 13933650 265536646 -956977269 -123437282-48757209 -32931396 345935203 -4019200407 3910 33]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20191024模拟-rose]]></title>
    <url>%2Fposts%2Ff3401588.html</url>
    <content type="text"><![CDATA[rose的场 loj2351「JOI 2018 Final」毒蛇越狱请先思考后再展开 首先一个$2^{cnt?}$的做法就是直接枚举每个？的值 然后你会发现你还可以想到一个$2^{cnt1}$的做法，就是先预处理出高维前缀和，将问号看做1，0看做0，枚举1的子集作为0去询问高维前缀和（求子集和），做一个简单容斥，式子我就不写了；然后很明显类似地求补集和，枚举0的子集去作为1，问号看做0，1看做1，就能得到一个$2^{cnt0}$的做法 复杂度均衡一下，就是$q*2^{n/3}$，code uoj46【清华集训2014】玄学见这里 AGC008E Next or Nextnext请先思考后再展开 强如rose才能想出这种高端性质题吧，确实是一道合适的防ak题 对于排列p，一个自然的想法是考虑其p图$i \to p_i$，那么题目就是问有多少个这样的带标号p图，满足i跳1步或2步后到ai 然而这样不好挖掘性质，考虑怎么更好地利用给出的a去理解，对于p图的限制，换而言之就是用a图$i \to a_i$去统计p图 注意，我们只关心图的结构（显然p图是若干个环，a图是基环树森林），然后我们知道是带标号的，但具体标号并不重要 首先，考虑p图中一个环可以存在多少个对应的a图（以下为题解的图，左边为p图，重标号成$p_i=i+1$）： 第一种是直接连，完全相同 第二种是奇环上所有人跳两步才连到a，可见a图奇环（除了一元环）可以选择形成一个不同构的环； 第三种是偶环上所有人跳两步才连到a，可见a图两个相同的环可以合并，且合并后不参与其他合并 第四种是变成一个基环树，注意这个基环树如果是合法的，一定满足环上节点最多2入边，非环节点最多1入边也就是只挂着链 于是我们回到a图中，分开处理环和基环树（因为之间不能合并）；对于环，奇环可以选择变换形态，如果合并一定是两个大小相同的（显然方案数为大小），将相同大小的一起处理，用这种环数量的复杂度做个简单dp即可 问题是如何求出每个基环树对应多少个p图（基环树间显然不能合并），你发现我们只需要考虑怎么把链贴上去，就能统计出所有形态了，然后最多有两种情况，即考虑链的第一条边是跳几步（右边是p图，每个点都是连向左边，黑色表示如何到达ai）： 我们用边数考虑长度、距离；设这条链的长度为l1，这个链头与下个链头的距离为l2，当$l1=l2$时只能选择第一种，因为第二种会导致下一条链与其a距离&gt;2；当$l1&gt;l2$无解 综上所述，$O(n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int a[N],cnt[N],in[N],len[N],tim[N];vc&lt;int&gt; cir[N];int id;bool oncir[N];int tl[N];ll f[N];void main()&#123; int n=qread();fo(i,1,n) a[i]=qread(),in[a[i]]++; fo(rt,1,n) if(!in[rt])//处理基环树 &#123; int now=rt;tim[rt]=rt;while(!tim[a[now]]) now=a[now],tim[now]=rt;//a[now]为链头 if(tim[a[now]]==rt)//新找到的基环树 &#123; cir[++id].PB(now);for(int i=now;a[i]!=now;i=a[i]) cir[id].PB(a[i]); for(auto x:cir[id]) oncir[x]=1; &#125; else if(!oncir[a[now]] or tl[a[now]]) &#123;puts("0");return;&#125;//非法的基环树 int ln=0;for(int i=rt;i!=a[now];i=a[i]) ln++;tl[a[now]]=ln; &#125; fo(rt,1,n) if(!tim[rt])//环 &#123; int ln=0;for(int i=rt;!tim[i];i=a[i]) ln++,tim[i]=rt; cnt[ln]++; &#125; ll ans=1; fo(siz,1,n)//环 &#123; int m=cnt[siz];f[0]=1;f[1]=(1+(siz&amp;1 and siz&gt;1)); fo(i,2,m) f[i]=(f[i-1]*f[1]+f[i-2]*siz*(i-1))%MOD; ans=ans*f[m]%MOD; &#125; fo(i,1,id)//基环树 &#123; int m=sz(cir[i]);reverse(all(cir[i])); cir[i].resize(m+m); fo(j,m,m+m-1) cir[i][j]=cir[i][j-m]; int lstpos=INF; fd(j,m+m-1,0) if(tl[cir[i][j]]&gt;0) &#123; if(j&lt;m) &#123; int l1=tl[cir[i][j]],l2=lstpos-j; if(l1&gt;l2)ans=0; else ans=ans*(1+(l1!=l2))%MOD; &#125; lstpos=j; &#125; &#125; write(ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Global Round 5]]></title>
    <url>%2Fposts%2F6536cd98.html</url>
    <content type="text"><![CDATA[Global Round 5 好题：F CF1237E Balanced Binary Search Trees请先思考后再展开 明明很接近了……拼14的时候一开始以为可以，草稿纸略乱，后来发现不行后忘记划掉了，然后后面就懵逼了……而且思考的时候没有从最大节点深度去分层思考，直接讨论节点个数来思考转移区间，所以不是很明显 首先知道转移的条件是从上一层选a、b，奇偶性要求$rt(a)=(a+1) \oplus 1,rt(b)=0$，然后你会发现每层只有两个 code CF1237F Balanced Domino Placements请先思考后再展开 先考虑空棋盘怎么放，随便想想发现如果现在在某行放了个横，那么会分割成两个相互影响的部分，如果直接看做一部分需要把【有竖跨过这行】去掉，不太好搞，但注意到现在的矛盾是横与竖之间的，这启发我们分开考虑竖和横 设有i个竖，j个横，设$f(n,cnt)=长度为n的表格，放若干不重叠骨牌方案数$，则$ans=竖f(n,i)*横f(m,j)*P_{m-2j}^i*P_{n-2i}^j$ 空棋盘的f随便dp，不空其实也随便dp，求答案中排列数的下标改成剩下可选的行、列即可，$O(n^2)$，code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[csp2019前后]]></title>
    <url>%2Fposts%2F1634d012.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>赛事</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cojR12]]></title>
    <url>%2Fposts%2F11e98740.html</url>
    <content type="text"><![CDATA[Sourcecommetoj R12 好题：E D XOR Pair请先思考后再展开 二进制数相减，不要考虑借位，而是允许-1存在 那么$x \oplus y=n$，考虑每一位，如果是0则x-y这一位是0，否则x-y这一位是1或-1，于是消除了一个限制 那么相当于，原数为-n，现在有若干个可选的位置去$+2^{bit+1}$，最后绝对值不超过m，等价于增量$\Delta \in [n-m,n+m]$，差分求解 然后如果是不可选的位置，x=y=0/1，判一下即可 如果是可以选的位置，选1（x=1，y=0）或0（x=0，y=1），其他位置为0，最后数字不超过R，数位dp即可（注意现在加数、与A和B比较是在pos位，但加数形成的1其实在pos+1位），设$f(pos,topR,topA,topB)$表示三个数在更高位是否都是顶上界的 code E Ternary String Counting请先思考后再展开 出题人增强自hdu6578$$设f(n,x,y)表示填了n个，与最后颜色不同的另外两种分别最后出现在x、y(x&gt;y) \\那么相当于每个位置的合法x、y都有上下界限制，每次清掉非法状态 \\f(n+1,x,n),f(n+1,y,n),f(n+1,x,y) \leftarrow f(n,x,y)，O(n^3) \\考虑将后面两维理解为表格，第三个就是原封不动，前两个就是对行、列求和并放在第n列 \\合法状态形如矩形，则对于每列而言合法的区间是连续且只变小的，可以存下来，维护好行、列和 \\枚举列去清空，O(n^2)，可能需要注意一些常数$$code F Substring Query咕咕咕]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LGR-060 2019洛谷10月月赛I]]></title>
    <url>%2Fposts%2F4269b7e7.html</url>
    <content type="text"><![CDATA[LGR-060 2019洛谷10月月赛I 小猪佩奇玩游戏请先思考后再展开 一个经典的期望模型：给出一个dag，删除一个点就会把所能到达的所有点删除，每次随机选择一个没有被删除的点删除，问期望步数。考虑一个点被选择的概率，等价于对期望的贡献，设有k个点可到达自己，感性理解一下应该和别的点无关，$\frac{1}{k+1}$ 考虑如何计算一个点可以被到达多少次，枚举题意中k，$\sum_{k=2} \sum_{i=2}^{log_k n} 更新i^k$，丢hash表里即可，最后hash表大小仅32669，明显能过 12345678910111213unordered_map&lt;int,int&gt; cnt;typedef unordered_map&lt;int,int&gt;::iterator IT;void main()&#123; fo(k,2,30) for(int i=2;pow(i,k)&lt;=1e9;i++) cnt[pow(i,k)]++; int T=qread(); while(T--) &#123; int n=qread(),oth=n;double ans=0; for(IT a=cnt.begin();a!=cnt.end();a++) if(a-&gt;FR&lt;=n) oth--,ans+=1.0/(a-&gt;SE+1); ans+=oth;printf("%lf\n",ans); &#125;&#125; 赛车游戏、CF241E Flights请先思考后再展开 首先将1不可达或不可达n的点去掉，剩下的如果有解一定是个dag $1 \le d_y-d_x \le 9$，直接差分约束，bellman-ford即可 code 小猪佩奇学数学请先思考后再展开 $$先考虑k=1，ans=\sum_{i=0}^n C_n^i p^i*i=pn*\sum_{i=0}^{n-1} C_{n-1}^i p^i=pn*(p+1)^{n-1} \\受此启发，ans=\sum_{i=0}^n C_n^ip^i* \frac{i-i\%k}{k}=\frac{1}{k}*(pn*(1+p)^{n-1}-\sum_{r=0}^{k-1} r*\sum_{i=0}^n [i\%k=r]C_n^ip^i ) \\单位根反演，a_i=C_n^ip^i,f(x)=\sum_{i=0}^{\infty} a_i x^i=(px+1)^n\\ \sum_{r=0}^{k-1} r*\sum_{i=0}^n [i\%k=r]C_n^ip^i=\frac{1}{k}\sum_{r=0}^{k-1} r*\sum_{i=0}^n a_i \sum_{t=0}^{k-1} \omega_{k}^{(i-r)t}=\frac{1}{k}\sum_{r=0}^{k-1} r*\omega_k^{-rt}*\sum_{t=0}^{k-1} \sum_{i=0}^n a_i \omega_{k}^{it} \\=\frac{1}{k}\sum_{r=0}^{k-1} r*\omega_k^{-rt}*\sum_{t=0}^{k-1} f(\omega_{k}^{t})=\frac{1}{k}\sum_{t=0}^{k-1} f(\omega_{k}^{t}) (\sum_{r=0}^{k-1} r*\omega_k^{-rt})，后面是个差比数列求和 \\ans=\frac{1}{k}*(pn*(p+1)^{n-1}- \frac{1}{k}\sum_{t=0}^{k-1} f(\omega_{k}^{t})*getsum(\omega_k^{-t},k) ) \\getsum(A,n)=\sum_{i=0}^{n-1} iA^i=[A=1]\frac{(n-1)n}{2} +[A \ne 1]\frac{1}{1-A} (\frac{A^n-1}{A-1}-A^n(n-1)-1)，O(nlogn)$$ 没有优化常数，跑得很慢；另外直接写个IDFT应该也是可以的 12345678910111213141516ll getsum(int A,int n)&#123; if(A==1) return (ll(n-1)*n/2)%MOD; ll x=(qpower(A,n)-1)*invm(A-1)%MOD; return (x-qpower(A,n)*(n-1)%MOD-1)%MOD*invm(1-A)%MOD;&#125;ll getomega(int n,int k)&#123;return qpower(3,(MOD-1)/n*k);&#125;ll n,p,k;ll getf(int x)&#123;return qpower( (p*x%MOD+1)%MOD,n);&#125;void main()&#123; n=qread(),p=qread(),k=qread(); ll ans=p*n%MOD*qpower( (p+1)%MOD ,n-1)%MOD; fo(t,0,k-1) &#123;ll w=getomega(k,t);ans-=invm(k)*getf(w)%MOD*getsum(invm(w),k)%MOD,ans%=MOD;&#125; ans=ans*invm(k)%MOD;write((ans+MOD)%MOD);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tkppc2016题解]]></title>
    <url>%2Fposts%2F454d426a.html</url>
    <content type="text"><![CDATA[Source技術室奥プログラミングコンテスト#2 tkppc2016 tkppc2016 D エンブレム（Emblem）题意：从前有个wxh的网格，$从左下角(0,0)射出一条向(K,h)$的光线不断反射，求最后形成的路径中光线重合的点的个数 请先思考后再展开 在某条边上反射等价于将这个网格沿那条边对称作图后继续按直线射，所以一定会到某个网格角结束反射 然后对于不互质的$(w,h)$，明显可以把$gcd*gcd$看做一个块，答案显然不变，故现在得到$(W,H),gcd(W,H)=1$ 结论：若$W*H且gcd(W,H)=1$的网格左下角射出$(0,0)\to(1,1)$的光线，则$\forall x,y \in N,(x+y)\%2=0,(x,y)会被经过$，其中不在边框上的点会被经过多次，且上述结论是充要的，$ans(W*H)=\frac{(W+1)(H+1)}{2}-(W+1)-(H+1)+四个角被多算$ $在(W,H)中射(k,H)，等价于(W*H/k,H)中射45度$，如果边长不是整数放缩一下即可，code tkppc2016 H デバッグ（Debug）题意：n点m边无向图，求每个点出发，长度为4的简单路径数，$n,m \le 1e5$ 请先思考后再展开 woshiwang 三元环、四元环计数见这里，设$g(x,k)$表示经过x的k元环个数；接下来就是讨论，设$f(x,ln)$表示从x出发长度为ln的简单路径计数$$f(x,2)=\sum [f(y,1)-1] \\f(x,3)=\sum [f(y,2)-(deg_x-1)]-g(x,3)*2 \\f(x,4)=\sum [f(y,3)]-g(x,4)*2-g(x,3)*2*(deg_x-2)-(f(x,2)*(deg_x-1)-g(x,3)*2) \\分别表示在四元环上、三元环上、二元环上，注意二元环可能计重，一开始没意识到$$code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iroha2019-day4题解]]></title>
    <url>%2Fposts%2F20f8cb82.html</url>
    <content type="text"><![CDATA[Sourceいろはちゃんコンテスト Day4iroha2019day4 好题：E、H、K iroha2019day4 E 芽生え（原题为下面题意的补） 题意1：n个变量，其中$x_i \in [0,k_i]$，求异或和=0的方案数，$n \le 1e6,k_i \le 1e18$ 题意2：n个变量，其中$x_i \in [0,k]$，求异或和=0的方案数，$n,k \le 1e18$ 请先思考后再展开 对于题意2，比较直接的$O(nlogk)$做法，已经能通过本题： 考虑最高位$2^w$，考虑有i个数没有顶上界，除了其中一个其他任意选而这个负责适应其他人；如果全部没有顶就递归到下一位 $\sum_{i=1}^n [(n-i)\%2=0]C_n^i(2^w)^{i-1}(k-2^w+1)^{n-i}$， 1234567ll solve(int n,ll k,int w)&#123; if(w&lt;0) return 1; int t=((k&amp;bin(w))?n:0);ll ans=(t%2==0?solve(n,k,w-1):0); if(t) fo(i,1,n) if((n-i)%2==0) add(ans,C(n,i)*qpower(bin(w)%MOD,i-1)%MOD*qpower(1+k%bin(w)%MOD,n-i)%MOD); return ans;&#125; 这个是可以用类似单位根反演（d=2下也可以不看作是单位根反演）优化的 对于题意1，就是若干个生成函数卷起来（仅那些$k_i \ge 2^w$，其他放外面搞）： $f(x)=\frac{1}{2^w} (\prod(2^w+(k_i-2^w+1)x)-\prod(k_i-2^w+1)),ans=\frac{f(1)+f(-1)}{2},O(nlogk)$ 回到题意2：$$f(x)=\sum_{i=1}^n C_n^i(2^w)^{i-1}(k-2^w+1)^{n-i} x^{n-i}=\frac{1}{2^w}*((2^w+x(k-2^w+1))^n-(k-2^w+1)^nx^n)\\ans=\frac{f(1)+f(-1)}{2},O(logn*logk)$$ iroha2019day4 H 永遠に题意：构造一个n*n的方阵，使得每行、每列都不存在子序列是个长度&gt;2的等差数列 请先思考后再展开 如果会一维，二维直接搞个二元组$(i,j)=(i-1)n+j$，然后例如第i行就是$(p_i,p_1)..(p_i,p_n)$ 一维的话，可以【奇数】+【偶数】，递归构造，code iroha2019day4 K 世界線题意：给出一个排列求多少种方案能搞出这个排列；初始一个n，每次选一个没插的数插入，要求插的位置左边比自己大；两个方案不同当且仅当某次插入的数或插入位置不同 请先思考后再展开 结论：给定一棵树结构，每个点标号，要求每个点的编号比子树其他点小,合法方案个数=$\frac{n!}{\prod siz_i}$ 不难发现总是有解的，例如倒序插入；考虑这个排列带来哪些限制 对于$p_i$，找到左边第一个更大的数$p_j$，则$p_{j+1..i-1}$需要在$p_i$前插入 注意到【左边第一个更大数】（可以用单调栈或链表求）显然形成一棵树，然后我们令每个节点的孩子按照在排列中位置排序，那么每个点的孩子显然是递增的 所谓$p_{j+1..i-1}$实际上就是节点x在fa中，孩子序列上左边的点子树内所有点 而这个限制也形成了一棵树形结构，即每个点向其所在孩子序列中右边第一个点连边，如果已经是最后一个就向父亲连边 那么用上面的结论就好了，下界$O(n)$，code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jsc2019-final题解]]></title>
    <url>%2Fposts%2F5ee1ed15.html</url>
    <content type="text"><![CDATA[Source第一回日本最強プログラマー学生選手権決勝Japanese Student Championship 2019jsc2019 好题：A、C、F、H 这一场基本是一些思维+数据结构题 不过提醒一下，出题人的习惯很鬼畜，所有编号从0开始，而且区间都是左闭右开…… jsc2019 A Equal Weight题意（改）：给出两个序列a和b，构造一组解满足$a_q-a_p=b_x-b_y,n,a_i,b_i \le 1e7$ 请先思考后再展开 移项，判$vis[a_i+b_j]$，找到退出的话，复杂度为$O(a_i)$ 12345678910111213141516bitset&lt;N&gt; a[N],to[N],limit[N];char str[N];void main()&#123; int n=qread(); fo(i,1,n) &#123;scanf("%s",str+1);fo(j,1,n) to[i][j]=str[j]-'0';&#125; fo(i,1,n) &#123;scanf("%s",str+1);fo(j,1,n) limit[i][j]=str[j]-'0';&#125; fo(i,1,n) fo(j,1,n) if(to[i][j]) a[j]|=~limit[i]; fo(i,1,n) a[i]=~a[i]; fo(i,1,n) &#123; bitset&lt;N&gt; tmp;tmp.reset(); fo(j,1,n) if(to[i][j]) tmp|=a[j]; fo(j,1,n) if(tmp[j]!=limit[i][j]) &#123;puts("-1");return;&#125; &#125; fo(i,1,n)&#123;fo(j,1,n) write(a[i][j]);puts("");&#125;&#125; jsc2019 B Reachability题意（改）：有3n个点分成X,Y,Z三个部分，从X向Y连边，从Y向Z连边，现在告诉你X到Y的可达情况、X到Z的可达情况，构造⼀种合法的Y到Z的可达情况，$n \le 1e3$ 请先思考后再展开 其实就是给出n个集合，i am the king给出n个限制形如集合的子集，并给出他们的并，构造每个集合具体元素 每个条件相当于提供补集作为不可达限制，bitset优化即可，$O(n*n*n/32)$ 123456789101112pr vis[N];int a[N],b[N];void main()&#123; int n=qread(),m=qread(); fo(i,1,n) a[i]=qread();fo(i,1,m) b[i]=qread(); fo(i,1,n) fo(j,1,m) if(vis[a[i]+b[j]]!=vis[0]) &#123; printf("%d %d %d %d",vis[a[i]+b[j]].FR-1,vis[a[i]+b[j]].SE-1,i-1,j-1); return; &#125; else vis[a[i]+b[j]]=MP(i,j); puts("-1");&#125; jsc2019 C Maximize Minimum题意：数轴$[0,L]$上X处放一个棋子，随后n次操作每次给出位置$A_i$反转上面是否有棋子（保证操作后至少两个），操作完询问美丽值，即可以选择一些移动到$L-A_i$(如果已经有就不能移动)，希望让最接近的棋子尽量远。$n \le 2e5$ 请先思考后再展开 考虑对一个局面如何求其美丽值，二分可行但意义不大，直接贪心，一定是排序后奇数左边偶数右边，然后再给最中间两个取min 用一个堆维护所有有贡献的距离，当插入时，设左边两个为a和b，右边两个为c和d，则断开$a \to c,b \to d$然后连上$a \to now,now \to d,b \to c$，$O(nlogn)$ 123456789101112131415161718192021222324252627282930313233struct Heap&#123; priority_queue&lt; ll,vc&lt;ll&gt;,greater&lt;ll&gt; &gt; A,B; void upd()&#123;while(sz(A) and sz(B) and A.top()==B.top()) A.pop(),B.pop();&#125; void push(ll num,int op)&#123;GG(num&lt;0)if(op)A.push(num);else B.push(num);&#125; ll top()&#123;upd();return A.top();&#125;&#125;hp;int L;multiset&lt;ll&gt; ss,real;typedef multiset&lt;ll&gt;::iterator IT;void solve(int num)&#123; int op=!real.count(num); if(op) real.insert(num); else real.erase(num); num=min(num,L-num); if(op) ss.insert(num); IT now=ss.upper_bound(num);now--; IT b=now,c=now;b--;c++;IT a=b,d=c;a--;d++; ll fa=*a,fb=*b,fc=*c,fd=*d; if(fc==INF+INF) hp.push(L-fb-fa,op^1),hp.push(L-num-fb,op); else if(fd==INF+INF) hp.push(L-fc-fb,op^1),hp.push(L-fc-num,op); hp.push(fc-fa,op^1);hp.push(fd-fb,op^1); hp.push(num-fa,op);hp.push(fd-num,op);hp.push(fc-fb,op); if(!op) ss.erase(now);&#125;void main()&#123; int n=qread();L=qread(); ss.insert(-INF-INF);ss.insert(-INF);ss.insert(INF+INF);ss.insert(1ll*INF+INF+INF); hp.push(INF*4ll,1);hp.push(INF*4ll,1); solve(qread());fo(i,1,n) solve(qread()),write2(hp.top());&#125; jsc2019 D Minimize Maximum题意：sbt给出两个序列满足$a_i \le b_i$，每次从后面插入一组a和b，每次求一个序列c满足$a_i \le c_i \le b_i，且最小化max\ c_i-c_{i-1}$，$n \le 2e5$ 请先思考后再展开 明显二分mid，具体写出式子 $c_i=min(c_{i-1}+mid,b_i)=min_{j=1}^i b_j+(i-j)mid$ 合法条件为：$\forall j&lt;i, b_j+(i-j)mid \ge a_i，即mid \ge \frac{a_i-b_j}{i-j}$，即最大斜率，维护凸壳，三分即可 $O(nlog_{1.5}n)$ 1234567891011121314151617181920212223242526272829namespace Convex&#123; pr q[N];int cnt; void insert(int x,int y) &#123; while(cnt&gt;=2 and (q[cnt].SE-q[cnt-1].SE)/(q[cnt].FR-q[cnt-1].FR)&gt;=(y-q[cnt].SE)/(x-q[cnt].FR) ) cnt--; q[++cnt]=MP(x,y); &#125; #define slope(pos) 1.0*(y-q[pos].SE)/(x-q[pos].FR) int solve(int x,int y) &#123; int fl=1,fr=cnt;double mx=-INF; while(fr-fl&gt;=20) &#123; int ln=fr-fl+1,mid1=fl+ln/3,mid2=mid1+ln/3;GG(mid2&gt;fr) double a=slope(mid1),b=slope(mid2);GG(a==b) if(a&lt;b) chmax(mx,b),fl=mid1+1; else chmax(mx,a),fr=mid2-1; &#125; fo(i,fl,fr) chmax(mx,slope(i)); return ceil(mx); &#125;&#125;;int a[N],b[N];void main()&#123; int n=qread();fo(i,1,n) a[i]=qread();fo(i,1,n) b[i]=qread(); Convex::insert(1,b[1]);int ans=-INF; fo(i,2,n) chmax(ans,Convex::solve(i,a[i])),write2(ans),Convex::insert(i,b[i]);&#125; jsc2019 E Nearest String题意：可以花X的代价删除前或后一个字符，或花Y的代价在末尾加入一个字符，给出两个字符串集合A和B，对某个集合中每个求到另一个集合的最小距离（变成里面元素的代价），字符串总长5e5 请先思考后再展开 考虑如何从A到B，设B中最长的在A出现的前缀长度ln，肯定先删再加 因为会形成B的前缀，考虑ac自动机里面塞B，枚举A的前缀令后面的删掉 设当前在ac自动机上匹配到节点x，设ss表示trie子树内补齐成一个B的最短距离 则答案为$min_{fail链上y} ss(y)*Y+(|A|-dep_y)*X$，贡献拆一下就能预处理了，code jsc2019 F Count Permutations Many Times题意：给出长为n的序列a，q次询问一个区间，问有多少n的排列满足$\forall i \in [l,r], p_i \ne a_i,n,q \le 2e3$ 请先思考后再展开 这题挺有趣的 显然容斥，如果选出集合有重复是没有意义的，从颜色角度考虑生成函数，设区间内c的出现次数为$cnt_c$ $F(x)=\prod_c (1+cnt_c x),ans=\sum_{i=0}^n (-1)^i(n-i)! [x^i]F(x)$ 无脑分治ntt是$O(qnlog^2n)$，应该过不去；区间询问套个莫队，多项式与二项式做乘除法是线性的，$O(n^{5/2})$ 12345678910111213141516171819202122232425const int B=45;struct Qes&#123;int l,r,id;&#125;qes[N];bool cmp(Qes a,Qes b)&#123;return a.l/B&lt;b.l/B or (a.l/B==b.l/B and a.r&lt;b.r);&#125;ll ans[N];int n,a[N],cnt[N];ll f[N];void move(int pos,int op)&#123; fo(i,1,n) f[i]=mm(f[i]+MOD-f[i-1]*cnt[a[pos]]%MOD); cnt[a[pos]]=mm(cnt[a[pos]]+MOD+op);//debug 隐式的减法 fd(i,n,1) f[i]=mm(f[i]+f[i-1]*cnt[a[pos]]%MOD);&#125;ll fac[N];void main()&#123; fac[0]=1;fo(i,1,N-1) fac[i]=fac[i-1]*i%MOD; n=qread();int q=qread();fo(i,1,n) a[i]=qread()+1; fo(i,1,q)&#123;int l=qread()+1,r=qread();qes[i]=(Qes)&#123;l,r,i&#125;;&#125;sort(qes+1,qes+q+1,cmp); int fl=1,fr=1;f[0]=1;f[1]=1;cnt[a[1]]=1; fo(i,1,q) &#123; while(fl&lt;qes[i].l) move(fl++,-1);while(fl&gt;qes[i].l) move(--fl,1); while(fr&lt;qes[i].r) move(++fr,1);while(fr&gt;qes[i].r) move(fr--,-1); fo(j,0,n) add(ans[qes[i].id],(j&amp;1?MOD-1:1)*fac[n-j]%MOD*f[j]%MOD ); &#125; fo(i,1,q) write2(ans[i]);&#125; jsc2019 G Nearest String题意：n个点的树，维护初始为空的点集S（保证询问的时候不为空），q天每天反转一个点x的状态，最后输出每条边共有多少天在点集S的虚树内，$n \le 2e5$ 请先思考后再展开 一个经典结论：对于一个点集的虚树，就是dfs序上相邻两点即最前后两点路径的和，且每条边会被统计恰好两次 于是dfs序上维护点集，每次就是加入、删除$O(1)$条路径，可以用树上差分实现统计，$O(nlogn)$，复杂度瓶颈为set 123456789101112131415161718192021222324252627282930313233343536373839404142434445vc&lt;pr&gt; to[N];int dfnid=0,dfn[N],rev[N],dep[N],ff[N][30];void pre(int x,int fa)&#123; rev[dfn[x]=++dfnid]=x; dep[x]=dep[fa]+1;ff[x][0]=fa;fo(i,1,20) ff[x][i]=ff[ff[x][i-1]][i-1]; for(auto y:to[x]) if(y.FR!=fa) pre(y.FR,x);&#125;int getlca(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); fd(i,20,0) if(bin(i)&lt;=dep[x]-dep[y]) x=ff[x][i]; if(x==y) return x; fd(i,20,0) if(ff[x][i]!=ff[y][i]) x=ff[x][i],y=ff[y][i]; return ff[x][0];&#125;int sum[N],ans[N];void push(int x,int fa)&#123; for(auto y:to[x]) if(y.FR!=fa) push(y.FR,x),sum[x]+=(ans[y.SE]=sum[y.FR]);&#125;void solve(int x,int y,int val) &#123;sum[x]+=val;sum[y]+=val;sum[getlca(x,y)]-=val*2;&#125;set&lt;int&gt; ss;typedef set&lt;int&gt;::iterator IT;//circlevoid main()&#123; int n=qread(),q=qread(); fo(i,1,n-1)&#123;int x=qread()+1,y=qread()+1;to[x].PB(MP(y,i));to[y].PB(MP(x,i));&#125;pre(1,0); fd(tim,q,1) &#123; int x=qread()+1,op=(ss.count(dfn[x])?-1:1); if(sz(ss)==1 and op&gt;0)&#123;solve(rev[*ss.begin()],x,tim*op*2);ss.insert(dfn[x]);continue;&#125; if(sz(ss)==2 and op&lt;0)&#123;ss.erase(dfn[x]);solve(rev[*ss.begin()],x,tim*op*2);continue;&#125; if(op&gt;0) ss.insert(dfn[x]);//sz&gt;=3 IT now=ss.find(dfn[x]),tl=now,tr=now; if(now==ss.begin()) tl=--ss.end(); else tl--; tr++;if(tr==ss.end()) tr=ss.begin(); solve(rev[*tl],rev[*tr],-tim*op); solve(rev[*tl],x,tim*op);solve(x,rev[*tr],tim*op); if(op&lt;0) ss.erase(dfn[x]); &#125; push(1,0);fo(i,1,n-1) write2(ans[i]/2);&#125; jsc2019 H Distinct Integers题意：⽀持单点修改，区间询问有多少个子区间的数字两两不同，$n,q \le 5e5$ 请先思考后再展开 不同数字，套路地求出nxt表示这个位置的数下一次出现位置，对于一个左端点l，$r \le min_{i=l}^{n-1} nxt_i$ 于是对于区间$[fl,fr]$，合法子区间个数就是$\sum_{l=fl}^{fr} min(min_{i=l}^{fr} nxt_i,fr+1)-l$，只需要求出区间后缀min的和 考虑已知nxt序列如何求答案，考虑分治求 1234solve(l,r,以kr开始的后缀min)= [l=r] min(kr,nxt[l]) [kr&lt;=min(mid+1..r)] solve(l,mid,kr)+(r-mid)*kr [otherwise] solve(l,mid,min(mid+1..r))+solve(mid+1,r,kr) 于是可以用李超树解决，调用solve的复杂度为$O(logn)$，线段树上将询问区间分成log段，故$O(nlog^2n)$ 现在考虑修改操作，最多修改3个位置，需要最小值、维护右儿子答案，调用log次solve 总复杂度$O(nlog^2n+nlog^2n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ll ans;namespace SGT&#123; #define lc x*2 #define rc x*2+1 #define mid (l+r)/2 ll ltag[N*4];int mi[N*4]; ll solve(int x,int l,int r,int kr) &#123; if(l==r) return min(mi[x],kr); if(kr&lt;=mi[rc]) return solve(lc,l,mid,kr)+ll(r-mid)*kr; return ltag[x]+solve(rc,mid+1,r,kr); &#125; int ask(int x,int l,int r,int fl,int fr,int kr)//返回min(区间,kr) &#123; if(l==fl and r==fr) &#123;ans+=solve(x,l,r,kr);return min(mi[x],kr);&#125; if(fr&lt;=mid) return ask(lc,l,mid,fl,fr,kr); if(fl&gt;mid) return ask(rc,mid+1,r,fl,fr,kr); int tmp=ask(rc,mid+1,r,mid+1,fr,kr); return ask(lc,l,mid,fl,mid,tmp); &#125; void change(int x,int l,int r,int pos,int num) &#123; if(l==r) &#123;mi[x]=num;return;&#125; if(pos&lt;=mid) change(lc,l,mid,pos,num); else change(rc,mid+1,r,pos,num); mi[x]=min(mi[lc],mi[rc]);ltag[x]=solve(lc,l,mid,mi[rc]); &#125;&#125;;int n,a[N];set&lt;int&gt; pos[N];typedef set&lt;int&gt;::iterator IT;int getright(set&lt;int&gt; &amp;a,IT b)&#123;b++;return b==a.end()?n+1:*b;&#125;void main()&#123; n=qread();int q=qread(); fo(i,1,n) a[i]=qread(),pos[a[i]].insert(i); fo(i,1,n) SGT::change(1,1,n,i,getright(pos[a[i]],pos[a[i]].find(i))); while(q--) &#123; int op=qread(),x=qread(),y=qread(); if(!op) &#123; x++;IT now=pos[a[x]].find(x); if(now!=pos[a[x]].begin()) &#123;int right=getright(pos[a[x]],now);SGT::change(1,1,n,*(--now),right);&#125; pos[a[x]].erase(x);a[x]=y;pos[a[x]].insert(x); now=pos[a[x]].find(x);SGT::change(1,1,n,x,getright(pos[a[x]],now)); if(now!=pos[a[x]].begin()) SGT::change(1,1,n,*(--now),x); &#125; else &#123; int fl=x+1,fr=y; ans=0,SGT::ask(1,1,n,fl,fr,fr+1); write2(ans-1ll*(fl+fr)*(fr-fl+1)/2); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[coj2019国庆欢乐赛]]></title>
    <url>%2Fposts%2Fc7da7568.html</url>
    <content type="text"><![CDATA[Sourcecommetoj 2019国庆欢乐赛 F 高速公路请先思考后再展开 考虑求出每个点的真实上界mm，我们称$a_i=mm_i$为关键点，那么超速一定是在关键点； 考虑mm怎么求，注意到其实$mm_i=min(mm_{i-1},a_i,mm_{i+1})$，左往右再右往左扫即可求出 设第i个关键点的位置为$pos_i$，枚举在第i个关键点超速，那么其实变化的只有$(pos_{i-1},pos_{i+1})$，重新算即可，$O(n)$ H 二人桌游请先思考后再展开 如果是个dag，显然从终止状态直接建边，拓扑倒推，存必胜必败情况，$O(n^2)$接下来我们主要关心环、平局这两个玩意，其实他们是一个问题先老实写出转移是怎么转的：若当前点只能去必胜态，那么只能去必败态若当前点能到达必败态，则必胜注意从必败态转移，我们能直接判断当前点的状态，所以平局不可能可以到达必败态 注意怎样才会是平局：要么去的两个点都是平局，要么去的一个点是平局，一个点是必胜态，而没有人会愿意前往一个必胜态来让对手必胜，所以平局一定成环，所以没拓扑到的点一定是平局]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[10月做题记录]]></title>
    <url>%2Fposts%2Fd9e23b83.html</url>
    <content type="text"><![CDATA[10月做题记录最后一个10月份了，年份都不用写了；即使实力不强也希望这份题单能给后人一些帮助 这个月主要在做课件，整体质量不错 好题：「HNOI2016」网络、HDU6634 Salty Fish、HDU5709 Claris Loves Painting loj2049「HNOI2016」网络请先思考后再展开 注意到求的是不经过而不是经过，判断一堆路径中是否有不经过可以转化为x是否在路径的交上，求路径交是可以$O(1)$的 做法一（好写，在线，$O(nlog^3n)$）：无脑树剖+线段树，每个节点开可删堆 做法二（难写，离线，$O(nlog^3n)$）：无脑线段树分治+树剖+线段树+撤回末尾操作，因为更新max的标记是可以快速合并的 做法三（难写，离线，$O(nlog^2n)$）：考虑二分，转化为判断是否所有路径都经过x，考虑路径交；依然线段树分治，预处理线段树每个节点权值顺序后缀路径交（这部分两个log），每次在上面log个节点上二分后取max；或者也可以另外写个权值线段树，区间与一个路径求并，询问在上面二分，这个需要写撤回末尾 做法四（好写，离线，$O(nlog^2n)$）：整体二分，支持插入删除维护路径交就是一个差分+树状数组求子树和来判断次数是否和所有相等 做法五（好写，在线，$O(nlogn)$）：其实上面都在假设删除不好搞，所以用线段树分治；或者用整体二分套数据结构辅助二分 但其实经过上面感受到路径交对二分的便利性后，其实是可以考虑直接按时间顺序在线做，每次二分回答的。考虑到二分需要求值域后缀的路径交，如果放到值域线段树上二分，其实是可以便利地处理删除的——在叶子节点修改，然后合并上去即可；可以用值互不相同的离散化实现 HDU6634 Salty Fish请先思考后再展开 明显最小割（割苹果表示舍弃，割监控表示hack），转化为求最大流 注意到是个二分图，而且连边的形式很特殊，范围又特别大，考虑贪心i am the king 注意到每次都会优先流深度最深的可以流的节点，将入边放到树上，等于每次找深度范围内能搞的流出去 注意到对于子树内的出边，只和深度有关，考虑长链剖分，搞个map存每个深度，还没有流完的，借助upper_bound和erase可以保证复杂度即$O(nlogn)$，code CF997E Good Subsegments请先思考后再展开 这题似乎可以析合树，然而我并不会构造树，就不这样搞了；口胡一下另一种做法 注意到允许离线，那么把询问挂在右端点上，对于每个右端点给其合法左端点打上标记，那么回答询问就是查询这个和 连续段满足$min(mx-mi+l)=r$，所以维护好这东西的话就可以用线段树给最小值位置打标记 mx和mi可以通过单调栈找到并更新，需要支持区间加减（这样应该更好维护？），区间询问标记和，应该可以$O(nlogn)$ HDU5709 Claris Loves Painting题意：n个有色点的树，q次询问一个点的子树中与这个点距离不超过d的点的颜色有多少种，强制在线，$\sum n,\sum q \le 5e5$ 请先思考后再展开 数颜色题可能有个套路是每个颜色贡献到它第一次出现 先求出每个子树内，某个颜色第一次出现的位置，可以用启发式合并map求，$O(nlog^2n)$ 但现在要计数的话，就是区间询问在这个深度出现的颜色数，直接合并肯定是不行的，但我们可以在做上面那玩意的时候，如果发现重复颜色修改对应深度颜色数，这样的修改只有颜色数即n次，然后每个深度的颜色数也用启发式合并map的话，也是$O(nlog^2n)$ 复杂度不优秀而且是离线算法，将两个启发式合并都改成线段树合并，这样就是$O(nlogn)$的，code CF1209G2 Into Blocks题意：长度为n的序列，q次单点修改后询问序列美丽值。美丽值为通过每次修改某颜色所有位置为另一颜色，最后使得整个序列任意颜色都是连续一段，的最小修改量，$n,q\le 2e5$ 请先思考后再展开 首先很明显easy就是让我们找到不带修时的做法，挖掘一些性质然后hard用一些数据结构维护，然而我还是不会 对于无修改，设值c的出现区间为$[fl_c,fr_c]$，最后$fl_c…fr_c-1$都要和下一个相同，设$f_i$为被如此统计的次数 那么$f_i=0$的位置就是一个段的结尾，将每种颜色的出现次数贡献到最左边的位置并记为$cnt_i$ $ans=n-\sum_{每个段} cnt[fl_{出现最多次的值}]$，现在就是对这玩意求和，无修改直接扫一遍即可。 考虑线段树能否维护，【最小值为0维护以0分割连续段的信息】经典转化成【区间以最小值分割的连续段的信息】 其实已经可以做了，如果你还是不会维护可以继续往下看，用一棵还是两棵线段树维护无所谓 我们只需要保证对于$mif=0$的区间算出的信息是正确的，设一个段$[kl,kr]$，记区间询问最大cnt为变量mxc，然后区间所有段的mxc和为sum，mif不为0的区间得出的sum并没有直接意义 如何合并两侧的信息？发现需要记录$mif、mif最左边的点mifl、最右边的点mifr$ 对于两侧最小值不同的情况： $sum[x]=sum[lc]+sum[rc]-mxc(mifr[lc]+1..mid)-mxc(mid+1..mifl[rc])+mxc(mifr[lc]+1..mifl[rc])$ 若$mif[lc]&lt;mif[rc]$：$sum[x]=sum[lc]-mxc(mifr[lc]+1,mid)+mxc(mifr[lc]+1,r)$ 若$mif[lc]&gt;mif[rc]$：$sum[x]=sum[rc]-mxc(mid+1,mifr[rc])+mxc(l,mifr[rc])$ 最后$ans=n-sum[root]$，修改就是【单点改cnt而改mxc，更新包含这个点的区间的f和sum】、【区间加减f，sum不变，记录加法标记tag即可】 维护sum需要调用log次查询mxc，$O(qlog^2n)$，code CF97E Leaders题意： n个点m条边的简单无向图，q次询问两点间是否存在长度为奇数的简单路径，$n,m,q \le 1e5$ 请先思考后再展开 一般图两点间路径会想到处理出一棵生成树，那肯定是选择dfs搜索树方便，因为没有横叉边 结论：对于无向图，一个点双内如果有奇环，那么内部每条边都至少在一个奇环中；点双内有奇环的充要条件是在dfs搜索树上存在一个【一条非树边+若干树边】组成的奇环（这个奇环上所有边一定都在同一个点双内）； 两个点间存在奇数长度简单路径的充要条件是：两点树上距离为奇数，或，两点树上路径中至少一条边在至少一个奇环中 两个点间存在偶数长度简单路径的充要条件是：两点树上距离为偶数，或，两点树上路径中至少一条边在至少一个奇环中 于是搞出搜索树，对于每个点记录回溯边，每个点双只是用回溯边找奇环确保复杂度，然后树上差分回答询问即可 $O(n)$，code CF917D Stranger Trees题意：给出一棵n个节点的带标号树，要求对于每个k，求出有多少棵生成树满足恰好有k条边与原树相同，$n \le 1e2$请先思考后再展开 如果直接搞多项式，x的指数表示多少条重复的边，直接换元矩阵树定理+拉格朗日插值，$O(n^4+n^3)$ 然后因为一开始做的时候并不会基尔霍夫，接下来介绍如何容斥计数 设f恰好g至少i条边被使用，$g_i=\sum_{j=i}^{n-1}C_j^i f_j，二项式反演得，f_i=\sum_{j=i}^{n-1} (-1)^{j-i} C_j^i g_j$ 然后一开始想着用Cayley公式的推论，结果因为还要背包度数，复杂度一路直接炸到$O(n^6)$，还不知道怎么优化…… 高妙一点的做法，拓展一下Cayley公式：设缩成k个块，设块大小为$siz_t$，我们做$k-2$次找叶子块，每次找到的时候考虑连向点，那么就是$n^{k-2}$，然后这样我们已经直接连了k-2条边，剩下的两个块之间还要连一条边，已经连的边还没有确定从自己里面哪个点伸出去，所以乘上$\prod_{t=1}^k siz_t$$$明显可以直接树形背包，设f(x,cnt,siz_t)表示目前变成cnt个块（不包括子树根节点），子树根节点所在块大小为siz_t \\new-f(x,cnt1+cnt2,siz1+siz2)+=f(x,cnt1,siz1)*f(son,cnt2,siz2)\\new-f(x,cnt1+cnt2+1,siz1)+=f(x,cnt1,siz1)*f(son,cnt2,siz2)*siz2\\g_{n-k}=\sum f(1,k,siz)*siz*n^{n-k-2}，经典树形背包，O(n^4) \\观察发现可以设ff(x,cnt)=\sum_{siz} f(x,cnt,siz),g(x,cnt)=\sum_{siz} f(x,cnt,siz)*siz \\new-g(x,cnt1+cnt2)+=g(x,cnt1)*ff(son,cnt2)+ff(x,cnt1)*g(son,cnt2) \\new-ff(x,cnt1+cnt2)+=ff(x,cnt1)*ff(son,cnt2) \\new-g(x,cnt1+cnt2+1)+=g(x,cnt1)*g(son,cnt2) \\new-ff(x,cnt1+cnt2+1)+=ff(x,cnt1)*g(son,cnt2) \\g_{n-k}=g(1,k-1)*n^{n-k-2}，复杂度降低为O(n^2)$$ code loj2575 「TJOI2018」party请先思考后再展开 如果给出两个串求最长公共子序列，就是经典的dp即$f(i,j)=max\ f(i-1,j-1)+[S_i=T_j],f(i-1,j)$ 注意到A长B短，考虑把dp状态放到状态里面（所谓dp套dp？）计数，$f(|A|,state)=dp状态恰为state的A的数量$ 考虑state怎么设计，注意到$f(a,b)最多比f(a,b-1)多1$，在state里面放差分后的$f(|A|,b)$，状态数为$2^{|B|}$ 注意还要求A中不能有NOI，再多加一维0/1/2表示末尾与NOI的匹配长度 预处理好每种状态的3种转移以快速转移，dp的时候只需要枚举下一个字符$O(n2^m3*3)$，code loj2048「HNOI2016」最小公倍数请先思考后再展开 其实就是询问只用$【a_i \le a且b_i \le b】的边$形成连通块，x和y是否在相同连通块且连通块内$max(a_i)=a,max(b_i)=b$ 首先max其实没啥用，因为并查集轻松维护这个信息 一开始以为把边做成两个序列分别按a和b排序，然后莫队，只在第二次碰到时加入，第一次去掉时删除，然而仔细想想发现这东西并不是并查集的末尾撤回，光荣假掉 但我们可以考虑一下将边按照a分块，每个块内b递增，然后询问也挂到块上，设块大小为B 那么回答每个块的时候，前面的边只需要维护一个指针将前缀的边加入，每次询问都暴力扫块内的边并加入再回撤 $O((\frac{m}{B}*m+qB)logn)=O(m \sqrt qlogn)$，code CF76A Gift题意：给出一个有重边有自环的n点m边无向图，每条边有两个权值$a_i,b_i$，自定义参数A和B以最小化$A*G+B*S且只用[a_i \le A,b_i \le B]$的边能使图连通，$n \le 2e2,m \le 5e4$ 请先思考后再展开 枚举A，维护一个A以内按照B排序，存b的最小生成树边，重构的复杂度为n，总复杂度为$O(mn)$ CF892E Envy题意：给出一个n个点m条边的无向图，q次询问一个边集能否同时在一个mst中。$n,m,\sum |边集| \le 5e5$ 请先思考后再展开 mst的一些性质 那么把每个询问按照边的权值分若干组，离线后依次处理某个权值的所有询问组，一组询问合法当且仅当只加入权值更小的边和这组询问的边，没有成环；一种实现是写可撤回末尾操作的并查集，$O(mlogm+qlogn)$，另一种实现是对每种权值把前面的并查集缩点后建新图，dfs判环，这样就能路径压缩，$O(mlogm+q* \alpha (n))$，可以出更大的q CF743E Vladik and cards题意：给定值域为$[1,8]$的序列求最长子序列——满足每两种数字的出现次数相差不超过1，每种数字在子序列中连续，$n \le 2e3$ 请先思考后再展开 枚举较小的出现次数a，设$f(a)$表示能否实现，二分出最大可实现的a后摆动一下即可求答案，接下来只说怎么check，设C为颜色数 考虑每种数字是a还是a+1，枚举数字的出现次数，贪心跳（记录数字i的第j个在哪里，以及自己是第几个），$O(logn*C!*2^C)$，应该已经能通过本题，接下来讨论一些更优秀的做法 对于更大的C，阶乘肯定要想办法去掉，而且指数级枚举也很不好，注意到对于某个颜色，并不关心其他颜色的顺序、是a还是a+1，明显可以考虑dp，设$f(n,S)$表示处理了前n个，使用过的颜色集合为S的最大子序列长度，转移考虑是否用这一位，$O(logn*n2^C)$，C可以出到13 CF599E Sandy and Nuts题意：统计有多少棵满足条件的、以1为根的n个点的树；给出树边中的m条、q组两点的lca，$m&lt;n \le 13,q \le 1e2$ 请先思考后再展开 设$f(x,S)$表示以x为根，子树点集为S（不包括x）的方案数，每次枚举编号最小节点所在子树集合T 然后考虑怎么check转移合法性： 对于lca的限制$(a,b,c)，若c=x,则ab不能同时在T中，若c \ne x，则ab不能在这个点分开$ 对于树边的限制$(a,b),确认(a,b) \ne (x,y)后，若a在T内而b不在，则非法$ $O(n*3^{n-2}*(nm+q))$，code 可能有看起来稍微更好的$O(n*3^{n-2}*(n+q))$做法，但意义不大，常数极小，因为限制不会真的很多，否则记忆化下可达状态很少 CF595E Edo and Magnets题意：给定平面上n个可重点（坐标为$(\frac{x1+x2}{2},\frac{y1+y2}{2})$），删除最多k个点，求用平行于坐标轴的边长为正整数的矩形覆盖剩下的点所需的最小面积，$n \le 1e5,k \le 10$ 请先思考后再展开 明显这么多点是来卖萌的，只有横或纵坐标在前、后10的点可能被删掉，有用的最多40个点 然后明显某维坐标肯定是删除连续的前后缀，直接4个for枚举删多少即可，code CF908D New Year and Arbitrary Arrangement题意：在一个空序列上 ，给定概率p末尾加A，否则末尾加B，当子序列AB数量$\ge k$的时候停止，求最后AB数量的期望，$k \le 1e3$ 请先思考后再展开 $$\\设f(t,aa)=子序列个数为t，共计aa个A的概率，倒推正推都行\\对于t+aa&lt;k，f(t+aa,aa)+=f(t,aa)*(1-p),f(t,aa+1)+=f(t,aa)*p\\注意如果序列第一个元素是B，直接忽略，故f(0,1)=1\\对于t+aa \ge k，再加入一个B就结束，可以直接计算E(剩下的长度)=\sum_{i=0}^\infty i*p^i(1-p)=\frac{p}{1-p}\\ans=\sum_{t+aa \ge k} f(t,aa)*(t+aa+\frac{p}{1-p} ),O(k^2)$$code CF1174E Ehab and the Expected GCD Problem题意：设一个n的排列的权值为前缀gcd的不同数量，求多少个n的排列的权值在所有n的排列中是最大的，$n \le 1e6$ 请先思考后再展开 先考虑怎么求最大值，设第一个数为fir，那么上界就是fir的标准分解质因子个数+1，而显然这个上界是可以达到的 直觉上fir肯定很少，打个表理性分析果然发现对于任意n，最多只有两个合法的$fir=2^k,2^{k-1}*3$，第一种的g仅一种，第二种最多k种g序列，枚举每种计算，下面以2为例，3并没有太大区别 将每个数按照其可行贡献放到每个g位置上（例如$2^4可以放在2^4、2^3…2^0$，这个可行后缀位置可以$O(1)$求出），那么每个组都能够选择放在后面（更小）的格子中，只要保证不会有某个格子留空。从后往前处理每个数，这样每个数的可选方案数和前面的数的选择无关，留空可以用容斥计算（即所有数都不插在最左边数左侧的空位） $O((1+19)n)$，没看懂建议看代码，code，复杂度瓶颈在于对于每个g序列，找到每个数的后缀贡献位置并放到具体组里面，感觉这个经过一些讨论可能能优化到线性？ CF506D Mr. Kitayuta’s Colorful Graph题意：n点m边连通无向图，边有颜色，但保证重边的颜色互不相同，q次询问一组点对，问多少颜色可以只使用这种颜色使两点连通，$n,m \le 1e5$ 请先思考后再展开 基本思路肯定是每种颜色都建dsu，怎么建没有所谓，不影响复杂度，关键是求答案 做法一（显式根号分治）：考虑每种颜色，如果内部的点数&lt;B，枚举点对更新答案；每次回答询问的时候枚举每种大颜色统计即可，$O((\sum in)*B+q \frac{m}{B})=O(m \sqrt q)$，code 做法二（隐式根号分治）：考虑一个点在$c_x$种颜色中，询问$(x,y),c_x \le c_y$去重，枚举$c_x$中每种颜色check 对于$c_x \ge B,最多min(q,B^2)次，复杂度上界为(\sum c_x)*\frac{m}{B}=\frac{m^2}{B}；其他情况每次check的复杂度为B，O(\frac{m^2}{B}+qB)=O(m \sqrt q)$ code GYM101102D Rectangles题意：给出一个矩形，问有多少个子矩形满足内部只有一种元素，$n,m \le 1e3$ 请先思考后再展开 对于每列，把相同元素缩成一个块；枚举矩形的上边界，求出以这个上边界为起点向下，每列能延伸多少 下边界从下往上扫，记录当前的答案，每次通过预处理的东西精准找到【再往上都是完全相同元素】的列，用并查集合并同色可用块并更新当前答案，每个下边界都把答案累计到总和里面。$O(n*(n+m)*\alpha (m))$，code loj6609 无意识的石子堆请先思考后再展开 经典转化为m点n边，点和边都带标号，每条边度数不超过2，有重边无自环无向图计数；那么一定是若干个环（重边就是二元环，但要特判）、链（一个点算是链，但要特判）组成，具体而言，一定是m-n条链，若干个环；然后只要图形态确定且点带标号且先不考虑二元环，边的标号可以最后再乘上$n!$，下文不考虑边，且边少考虑以边为上标、下标$$对于n=m，一个大小为s的环有f(2)=1/2（因为边最后标号）,f(s&gt;2)=(s-1)!/2\\递推式ff(n)=\sum_{i=2}^n C_{n-1}^{i-1} ff(n-i)*f(i)=\frac{(n-1)!}{2}*\sum_{i=2}^n \frac{ff(n-i)}{(n-i)!}，O(n)计算 \\链有g(0)=1,g(s)=(s+1)!/2,与一般的EGF稍有不同 \\考虑到EGF本质上是多重集的染色，A= \sum_{i=0}^{\infty} \frac{g(i)}{(i+1)!} x^i，G(边数t,链的个数k)=A^k[x^t]/k!*(t+k)!\\A^k=\frac{1}{2^k}*(2-x)^k* \frac{1}{(1-x)^k}=(\sum_{i=0}^k C_k^i (-1/2)^i x^i )*(\sum_{i=0}^{\infty} C_{i+k-1}^{k-1} x^i )，原根为7，FFT即可\\ans=n! * \sum_{a=0}^n ff(a)*G(n-a,m-n)*C_m^a，O(nlogn)$$code 另外出题人zjt还有一种做法，感觉一般性没有上面的好，而且看了半天没看懂 CF1236E Alice and the Unfair Game题意：n个盒子，一个小球，长度为m的序列a，要求时刻t的时候$a_t$中不能有小球，最开始、每个时刻结束时都可以将小球移动到相邻的盒子，问有多少个合法的二元组$(x,y)$，表示第一次操作前放在x，时刻m结束被操作后放在y，$n,m \le 1e5$ 请先思考后再展开 问题等价于初始在$(0,x)$上放球，每次$(i,j) \to (i+1,j-1/j/j+1)$，$(t,a_t)$是障碍点，问能到达哪些$(m+1,y)$ 不难发现因为时刻0和时刻m末尾都能移动，对于每个x，可行的y都是一段连续区间，所以可以分别求出左右端点，以求左边为例 那么一个简单的dp就是$f(m+1,i)=i,f(t,1)=1$ $f(i,j)=f(i+1,j-1),如果存在障碍点(t,a_t),f(t-1,a_t+1)=f(t,a_t+1),f(t,a_t)=\infty$ 发现只需要除了特殊点，只需要移动一下下标，可以指针实现，$O(n+m)$ 要特判n=1……因为是空集，code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZR集训]]></title>
    <url>%2Fposts%2F7533b27f.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cojR11]]></title>
    <url>%2Fposts%2Fffe7e66c.html</url>
    <content type="text"><![CDATA[Sourcecommetoj R11 好题：E D请先思考后再展开 先想了想这题二分、可持久化并查集之类的，似乎都不太行，那就kruskal重构树，设边权为max 点编号即可 那么每次回答询问就是倍增跳到不能跳为止，然后回答子树积，这个拿个树状数组维护即可，$O(qlogn)$ 坑点：权值可能一开始就超过mod，需要判0的次数 E请先思考后再展开 这道题还是很可做的 注意到$n*m$小而b大，然后考虑到对于伤害和S敌人的分配方案，根据隔板法=$C_{S-1}^{n-1}$，S会很大但n不大，基于这个考虑把隔板分配到人中，也就是把隔板数作为卷积上标，分配到每种人中。设$F_k(x)$表示第k种的OGF，那么$ans=[x^{n-1}]\prod_k F_k^{a_i}(x)$，如果求出F的话，多项式求幂（系数放缩一下即可），复杂度为$O(nmlogn)$ 当不放隔板的时候，即$F_k(0)=b_k$；然后隔板的话我们需要允许对于每个人伤害序列的末尾也能放隔板，特判掉$k=m时F_m^{a_m-1}(x)*Special(x)$即可。 对于造成多少伤害，$F_k(x)[x^i]=\sum_{j=i}^{b_k} C_j^i=C_{b_k+1}^{i+1}$，可以快速求；$Special(x)[x^i]=\sum_{j=i+1}^{b_m} C_{j-1}^i=C_{b_m}^{i+1}$ code F请先思考后再展开 前不久才研究过dag计数，但完全没状态，想到了把分母3提出来，却没看出$2^{T \to S\setminus T}=2^{in(S)-in(T)-in(S\setminus T)}$ 多么经典的转化啊……才写过博客来着，服了自己了 想到这个直接子集卷积就好了，$O(2^nn^2)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AGC021到030]]></title>
    <url>%2Fposts%2F919438ff.html</url>
    <content type="text"><![CDATA[AGC021到AGC030题解合集 0/10 AGC028agc028E - High Elements code 请先思考后再展开 为了方便我的实现改为考虑更小的元素；设E集合为全局的前缀最小值 考虑逐位确定，那么我们需要判断的就是可行性，$设前面i个已经填完，前面的mi_0,mi_1，前面的长度c_0,c_1，后面的前缀最小值个数cnt$ 对于两个集合只考虑下降部分，因为其他数总是至少有一种让它没用的分配方案（每个数丢到左边第一个更小的数所在集合即可） 将元素分为来自E的A类、其他B类，那么能等效地转化为至少一个集合的下降是只有A类的（设为集合0） $c_0+cnt-a=c_1+a+b即2a+b=c_0-c_1+cnt$ 即要求存在一个【开头&lt;mx，满足权值（A贡献2，B贡献1）为定值】的下降序列 因为一定能$a–$，所以对于某个奇偶性求最长的即可，考虑一个维护前缀max的支持撤销树状数组，询问也是前缀 从后往前插入元素来维护$f(num)$表示以num为开头的最长下降子序列，插入就是一个链修改，因为端点一直往后移动，这种东西是可以撤回的 时空复杂度 $O(nlogn)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code festival 2017 qualb题解]]></title>
    <url>%2Fposts%2Fb5b79302.html</url>
    <content type="text"><![CDATA[Sourcecode festival 2017 qualb E请先思考后再展开 此题不难，网上的题解搞得玄乎得一匹都不知道在说啥qwq，code 浅层分析：注意到一定存在一种方案，使得使用s或t的时候是为蓝色球服务的，所以我们更关心某一时刻能否选蓝色；而这个也是分阶段的，就是【仅红】、【t蓝】、【仅红】、【s蓝】、【仅红】；然后由贪心，我们可以强制t为第一次取蓝球的位置，同时这个球也是最前面的蓝球 考虑求$solve(A,B)$，枚举$t=1..A+1$，那么序列以$A+1-t$ 个红球和$1$个蓝球开始，不重不漏；此时剩下$t-1$个红球和$B-1$个蓝球，随后的$B-1$次任意选颜色（可能红色用完）；设最后剩下共$t-1$个球，转化为子问题 $$首先有x个红球和y个蓝球的多重集排列数=\frac{(x+y)!}{x!y!}=C_{x+y}^y，设pp(y,x)=\sum_{i=0}^x C_y^i \\solve1(A,0)=1,solve1(A,B&gt;0)=\sum_{t=1}^{A+1} \sum_{i=0}^{t-1} C_{B-1}^i=\sum_{t=0}^{A} pp(B-1,t)，本质上是前缀和 \\solve2(A,0)=1,solve2(A,B&gt;0)=\sum_{t=1}^{A+1} \sum_{i=0}^{t-1} C_{B-1}^i solve1(t-1-i,i)，O(n^2)$$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AGC031到040]]></title>
    <url>%2Fposts%2F127faea6.html</url>
    <content type="text"><![CDATA[AGC031到AGC040题解合集 好题：agc038E、agc039E 5/10 AGC031old_link AGC032old_link AGC037old_link AGC038人傻做法傻，大家散了吧 agc038A - 01 Matrix 请先思考后再展开 code 枚举任意一组i和j满足$i(m-A)+(n-i)A=j(n-B)+(m-j)B$即1的个数相同，然后考虑每列，每次贪心选1最多的行，$O(n^2logn)$ 正常人的做法是右上角和左下角是1之类的 agc038B - Sorting a Segment code 请先思考后再展开 看完题意考虑按题意模拟，就是区间排序，从左往右枚举这个区间，用个线段树维护值域hash即可，其实不难写，就是要写双hash才行，错的点有些多我还以为我是错的，$O(nlogn)$ 正常人的做法是考虑【i开始】和【i+1开始】相同，当且仅当ai为【i开始】中最小且a[i+m]为【i+1开始】最大，可能还有些特殊情况要判 agc038C - LCMs code agc038D - Unique Path code 请先思考后再展开 先把op=0的点并查集在一起成一条链（m–），顺序不重要，主要是以后参与其他东西只能派唯一一个点，相当于缩点 然后考虑op=1的边，新建图，并查集起来，对于siz=2的需要找一个外援，m-=3，然后siz&gt;2的就m-=siz，相当于最小代价，然后还需要判上界，这个需要按一些顺序算 正常人的做法是必须用的边其实是n条（包括两类），上界是所有缩点成环后补边，大概是这样吧，见rose代码 agc038E - Gachapon 做法一code 请先思考后再展开 期望有个套路的转化，就是如果求恰好到达的状态的概率*步数之和，等价于所有未到达的状态的概率之和，这个你可以通过【把当前概率推到上面的步数个祖先上】理解 做法一：min-max容斥，那么考虑对于某个元素的集合State，就是$ans=\sum_{State \ne \emptyset} (-1)^{|State|+1} min(State)$ 对于本做法，恰好到达指恰好有一个元素的出现次数为bi，其他都更小；则未到达为所有都在bi-1以内 然后你会发现基本做完了，大致思路基本上就是推推式子，dp优化之类的，这个是min-max容斥的常见套路 对于每个未到达状态，显然按每种State内元素的出现个数表示（记为数组c，和为C） 记$sumA=\sum_{i \in State} A_i,P\ of\ min(State)=\frac{C!}{sumA^{C+1}/S} \prod_{i \in State} \frac{A_i^{c_i}}{c_i!}$，这里是为了方便先只考虑State内元素的期望步数，然后乘上$\frac{1}{p}=\frac{S}{sumA}$放缩，即现实中这么多步顶里面一步 设$f(n,sum_A,C)$表示考虑前n个数，类似二维背包那样dp，第一维可以去掉 转移的复杂度为bi，故复杂度为$O((\sum a_i)*(\sum b_i)^2)$ 做法二：生成函数 对于本做法，恰好到达指每个元素都是bi次出现，则写出答案的指数型生成函数$$计算至少一个元素没有出现bi次的概率之和，F=e^x-\prod_i(e^x-\sum_{t&lt;b_i} p_i^t \frac{x^t}{t!}) \\设卷出来的东西是若干个带系数的x^B e^{Cx},每个单项式对答案的贡献为 f(B,C)=\sum_{i=0}^{\infty}\frac{C^i}{i!} (i+B)! \\无限和式考虑扰动法，(1-C)f(B,C)=\sum_{i=0}^{\infty} C^i*(i+B-1)^{\underline {B-1}}*B \\f(0,C)=\frac{1}{1-C}，f(B,C)=\frac{B}{1-C}*f(B-1,C)，展开递推得f(B,C)=\frac{B!}{(1-C)^{B+1}} \\复杂度瓶颈为展开多项式O(nBC)，与a无关$$ agc038F - Two Permutations code 请先思考后再展开 注意到选择的形式很特殊：$i或P_i$，将P看做置换，则等价于一个若干个轮换的图，选择若干个轮换，将其改为$i \to i$ 注意到时限很大，考虑用最小割求解，对每个i分类讨论，因为决策是对于整个轮换的，所以要缩点保证依然是排列 设P中轮换选的话在st集合不选ed，Q与其相反$$\begin{aligned}&amp; 1)p_i=i=q_i，直接忽略,\\&amp; 2)p_i=i\ne q_i，对q改则-1，st \to Q\\&amp; 3)p_i\ne i = q_i，对p改则-1，P \to ed\\&amp; 4)p_i=q_i \ne i，改的状态相同则-1（给原答案+1），P \leftrightarrow Q \\&amp; 5)互不相同，都改则-1，P \to Q\end{aligned}$$需要加个当前弧 AGC039agc039A - Connection and Disconnection code，忘记判n=1；其实复制一遍会好写很多 agc039B - Graph Partition code，只有偶环，这样搞肯定合法且是上界 agc039C - Division by Two with Something 请先思考后再展开 注意到每个数都能被到达，所以一定是若干个环组成，考虑如何计算一个数所在环的环长 转化一下操作，每次就是把最后一个字符0/1去掉并在最前面加上1/0 设rev为01反转，在A+rev(A)+A中选取最右边一个段使得和原串相同，距离就是环长 做2n次肯定能回到自己，考虑更短的那些有什么特性，欢乐玩耍一下发现：rev(A)+A一定存在一个循环节（也是环长）2d，并且$\frac{2n}{2d}$一定是奇数（否则断点都在串里面，等价于rev(A)=A，显然不可能），而且这个2d一定形如B+rev(B) 考虑枚举d求有$f(d)$个串满足存在循环节2d（环长可能是d的约数*2，莫反解决） 注意到确定了d和B整个串就确定了，而B是受到题目中上界的限制， 对于每个d，随便判一下就能求出有多少个合法的B，复杂度不超过$O(n^{3/2})$，code agc039 D - Incenters 请先思考后再展开 三角形五心复习 那么现在就是求圆弧中点形成三点坐标之和，贡献拆开，枚举两点i和j，统计中间圆弧中点被统计次数，讨论一下在哪一侧即可 $O(n^2)$，code agc039 E - Pairing Points 题意补充：所谓树形结构，考虑的是线不成环，跟点没关系 请先思考后再展开 考虑怎么理解、应用直线上的树形结构；特判n=1后相邻不能连边 设$1 \to pp$为根，画出若干条一级孩子，你发现这些孩子的子树用的点一定是连续的两个区间$$设f(l,r,k)表示l到r区间的点，并且k号点向区间外配对，ans=\sum_{pp} f(2,2n,pp) \\f(l,r,k)=\sum_{x=l}^{k-1} \sum_{y=k+1}^r [(x \to y) \in Edges]\sum_{a=x}^{k-1} \sum_{b=k+1}^y f(l,a,x)*f(a+1,b-1,k)*f(b,r,y)$$$O(n^7)$且常数很小，实际跑得飞快，code agc039 F - Min Product Sum 请先思考后再展开 题意转化，对于矩阵A的权值，其实就等价于填一个B满足$B[i][j] \le min(A[i][1..m],A[1..n][j])$的方案数 每个位置都考虑其行列有点恶心，再转化一下，$B[i][1..m] \le min\ A[i,1..m],B[1..n][j] \le min\ A[1..n][j]$ 然后如果你直接填A找B或填B找A，似乎都至少要$O(n^5)$，下面直接给出正解做法（需要整体看理解正确性）：$$设B第t行的mx为X_t,A第t列的mi为Y_t，考虑同时填A和B \\f(u,i,j)表示处理了i行j列，之前确定过的X,Y \le u \\枚举增加ad行X_t=u+1，考虑每行新产生什么信息，系数^{ad}*C_{n-i}^{ad} 即可\\对于Y_t \le u的那j个位置，A中必须要填&gt;u的数，即(K-u)^j；\\对于另外的m-j个位置，B中必须填\le u+1的数且至少一个u+1，即(u+1)^{m-j}-u^{m-j} \\接着枚举ad列Y_t=u+1，考虑每列新产生什么信息，和上面类似 \\对于X_t \le u的那i个位置，A中必须填&gt;u且至少一个u+1，即(K-u)^i-(K-u-1)^i\\对于另外的n-i个位置，B中必须填\le u+1的数，即(u+1)^{n-i} \\ans=f(K,n,m)，行和列的增加是u到u+1的两个阶段，增加一维0/1即可 \\预处理系数（行与i无关，列与j无关）或者直接预处理((A+1)^{B}-u^{B})^C，O(n^4)$$ 未优化版，懒得优化了（这个好看）： 123456789101112131415f[0][0][0][0]=1;fo(u,0,K-1)&#123; fo(i,0,n) fo(j,0,m) fo(ad,0,n-i) &#123; int ss=qpower(K-u,j)*mm(pp[u+1][m-j]+MOD-pp[u][m-j])%MOD;ss=qpower(ss,ad); add(f[u][1][i+ad][j],f[u][0][i][j]*C[n-i][ad]%MOD*ss%MOD ); &#125; fo(i,0,n) fo(j,0,m) fo(ad,0,m-j) &#123; int ss=qpower(u+1,n-i)*mm(pp[K-u][i]+MOD-pp[K-u-1][i])%MOD;ss=qpower(ss,ad); add(f[u+1][0][i][j+ad],f[u][1][i][j]*C[m-j][ad]%MOD*ss%MOD ); &#125;&#125;write(f[K][0][n][m]); 并没有看懂这个做法]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC001到010]]></title>
    <url>%2Fposts%2Fe1875d00.html</url>
    <content type="text"><![CDATA[AGC001&#x5230;AGC010&#x9898;&#x89E3;&#x5408;&#x96C6; 4/10 AGC001old-link AGC002old-link AGC003agc003A - Wanna go back home code agc003B - Simplified mahjong code agc003C - BBuBBBlesort! code &#x6CE8;&#x610F;&#x5230;&#x64CD;&#x4F5C;&#x4E8C;&#x7684;&#x8BDD;&#x5947;&#x4F4D;&#x7F6E;&#x548C;&#x5076;&#x4F4D;&#x7F6E;&#x662F;&#x72EC;&#x7ACB;&#x7684;&#xFF0C;&#x800C;&#x4E14;&#x4EFB;&#x610F;&#x7528;&#xFF0C;&#x90A3;&#x5C31;&#x662F;&#x6C42;&#x90A3;&#x4E9B;&#x4EBA;&#x9700;&#x8981;&#x5230;&#x53E6;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#x53BB; agc003D - Anticube code &#x8BF7;&#x5148;&#x601D;&#x8003;&#x540E;&#x518D;&#x5C55;&#x5F00; &#x5C45;&#x7136;&#x80FD;&#x72EC;&#x7ACB;&#x505A;&#x51FA;D&#xFF0C;&#x548C;&#x5927;&#x591A;&#x6570;&#x4EBA;&#x505A;&#x6CD5;&#x4E0D;&#x540C;&#xFF0C;&#x4F3C;&#x4E4E;&#x6211;&#x7684;&#x590D;&#x6742;&#x5EA6;&#x4F18;&#x8D8A;&#x4E00;&#x70B9;&#xFF08;&#x4E0D;&#x8003;&#x8651;hash&#xFF09;&#x3002; &#x9996;&#x5148;&#x663E;&#x7136;&#x628A;&#x6BCF;&#x4E2A;&#x6570;&#x7684;&#x8D28;&#x56E0;&#x5B50;&#x7684;&#x6307;&#x6570;%=3&#xFF0C;&#x4E24;&#x4E2A;&#x6570;&#x4E0D;&#x80FD;&#x5728;&#x4E00;&#x8D77;&#x5F53;&#x4E14;&#x4EC5;&#x5F53;&#x4ED6;&#x4EEC;&#x7684;&#x8D28;&#x56E0;&#x5B50;&#x7EC4;&#x6210;&#x76F8;&#x540C;&#xFF0C;&#x4E14;&#x6BCF;&#x4E2A;&#x8D28;&#x56E0;&#x5B50;&#x7684;&#x6307;&#x6570;&#x4E00;&#x4E2A;&#x662F;1&#x4E00;&#x4E2A;&#x662F;2&#x3002;&#x8003;&#x8651;&#x679A;&#x4E3E;&#x5176;&#x8D28;&#x56E0;&#x5B50;&#x96C6;&#x5408;&#x7EC4;&#x6210;&#x7684;&#x6570;i&#xFF0C;&#x6700;&#x591A;&#x6709;7&#x4E2A;&#x4E0D;&#x540C;&#x8D28;&#x56E0;&#x5B50;&#xFF0C;&#x82B1;&#x8D39;$\sqrt a_i*2^7$&#x7684;&#x65F6;&#x95F4;&#x627E;&#x5230;&#x4E92;&#x65A5;&#x7684;&#x4E00;&#x5BF9;&#x6570;&#xFF0C;&#x7B54;&#x6848;&#x5373;$\sum max(times_i,times_j)$&#xFF0C;&#x6CE8;&#x610F;&#x7279;&#x5224;1&#xFF0C;&#x4EE5;&#x53CA;&#x6700;&#x540E;&#x8981;&#x628A;&#x6CA1;&#x5904;&#x7406;&#x8FC7;&#x7684;&#x5927;&#x8D28;&#x6570;&#x641E;&#x6389;&#xFF1B;&#x4E0D;&#x9700;&#x8981;&#x624B;&#x5199;hash&#x8868;&#xFF0C;&#x7528;map&#x5373;&#x53EF;&#x901A;&#x8FC7;&#x672C;&#x9898; agc003E - Sequential operations on Sequence code &#x8BF7;&#x5148;&#x601D;&#x8003;&#x540E;&#x518D;&#x5C55;&#x5F00; &#x5176;&#x5B9E;&#x4E0D;&#x662F;&#x5F88;&#x96BE;&#xFF0C;&#x53EF;&#x60DC;&#x6CA1;&#x60F3;&#x5230; &#x9996;&#x5148;&#x5982;&#x679C;$q_i \ge q_{i+1}&#xFF0C;i+1$&#x5C31;&#x662F;&#x6CA1;&#x7528;&#x7684;&#xFF0C;&#x5355;&#x8C03;&#x6808;&#x5904;&#x7406;&#x6210;&#x9012;&#x589E;&#xFF08;$q_o=n$&#xFF09; &#x8003;&#x8651;i&#x5728;&#x7B54;&#x6848;&#x4E2D;&#x4F1A;&#x8D21;&#x732E;&#x591A;&#x5C11;&#x6B21;&#xFF0C;&#x5012;&#x63A8;&#xFF1B;&#x8BBE;$f(i,ln,val)$&#x8868;&#x793A;&#x7B2C;i&#x884C;&#x7684;&#x524D;ln&#x4E2A;&#xFF0C;&#x5E76;&#x4E14;&#x8003;&#x8651;&#x5230;&#x91CD;&#x590D;&#xFF0C;&#x8BBE;val&#x4E3A;&#x8D21;&#x732E;&#x7684;&#x6743;&#x503C;&#xFF08;&#x5373;val&#x500D;&#xFF09; $ans=f(q,ln_q,1),&#x63A8;&#x5230;f(0,ln,val)$&#x7684;&#x65F6;&#x5019;&#x7528;&#x5DEE;&#x5206;&#x66F4;&#x65B0;&#x7B54;&#x6848;&#xFF0C;&#x6BCF;&#x6B21;&#x53EF;&#x80FD;&#x8FD8;&#x9700;&#x8981;&#x9012;&#x5F52;$f(i-1,ln\%q_{i-1},val)$&#xFF0C;&#x8003;&#x8651;&#x5230;&#x4E00;&#x4E2A;&#x6570;&#x6700;&#x591A;&#x88AB;&#x6709;&#x6548;&#x6A21;log&#x6B21;&#xFF0C;&#x6BCF;&#x6B21;&#x65B0;&#x63D2;&#x5165;&#x4E00;&#x4E2A;&#x6570;$q_i$&#xFF0C;&#x90A3;&#x4E48;&#x94FE;&#x6570;&#x4E3A;$O(nlogn)$&#xFF0C;&#x4F46;&#x8FD9;&#x6837;&#x590D;&#x6742;&#x5EA6;&#x5E76;&#x4E0D;&#x662F;&#x5BF9;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x6BCF;&#x6761;&#x94FE;&#x53EF;&#x80FD;&#x5F88;&#x957F;&#xFF1B;&#x8003;&#x8651;&#x5230;&#x5927;&#x90E8;&#x5206;&#x65F6;&#x5019;&#x5411;&#x4E0A;&#x662F;&#x4E00;&#x6761;&#x957F;&#x5EA6;&#x6CA1;&#x53D8;&#x5316;&#x7684;&#x5355;&#x94FE;&#xFF0C;&#x7528;&#x4E8C;&#x5206;&#x627E;&#x5230;&#x672C;&#x8D28;&#x4E0D;&#x540C;&#x7684;&#x5730;&#x65B9;&#xFF08;$q_j&lt; ln$&#xFF09;&#xFF0C;&#x7528;map&#x5408;&#x5E76;&#x4E00;&#x5C42;&#x76F8;&#x540C;&#x7684;ln&#xFF08;&#x4E0D;&#x5408;&#x5E76;&#x590D;&#x6742;&#x5EA6;&#x4E0D;&#x5BF9;&#xFF0C;&#x6BCF;&#x6B21;&#x4E0D;&#x6B62;&#x63D2;&#x5165;&#x4E00;&#x4E2A;&#x6570;&#xFF09;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x4E3A;$O(nlog^2n)$ agc003F - Fraction of Fractal code &#x8BF7;&#x5148;&#x601D;&#x8003;&#x540E;&#x518D;&#x5C55;&#x5F00; &#x8BBE;pp=&#x9ED1;&#x8272;&#x6570;&#xFF1B;&#x82E5;&#x5B58;&#x5728;&#x4E00;&#x5217;&#x4E0A;&#x4E0B;&#x90FD;&#x662F;&#x9ED1;&#x5219;&#x4E0A;&#x4E0B;&#x8FDE;&#x901A;&#xFF0C;&#x5B58;&#x5728;&#x4E00;&#x884C;&#x5DE6;&#x53F3;&#x90FD;&#x662F;&#x9ED1;&#x5219;&#x5DE6;&#x53F3;&#x8FDE;&#x901A;&#xFF1B; k=0/1&#x3001;&#x90FD;&#x8FDE;&#x901A;ans=1&#xFF1B;&#x90FD;&#x4E0D;&#x8FDE;&#x901A;$ans=pp^{k-1}$&#xFF1B;&#x4E8E;&#x662F;&#x53EA;&#x5269;&#x67D0;&#x79CD;&#x8FDE;&#x901A;&#xFF0C;&#x6570;&#x91CF;&#x8BBE;&#x4E3A;cnt &#x5C06;&#x6700;&#x5C0F;&#x5206;&#x5F62;&#x770B;&#x505A;&#x70B9;&#xFF0C;&#x5219;&#x5F62;&#x5982;&#x6811;&#xFF0C;&#x8FDE;&#x901A;&#x5757;&#x6570;=&#x70B9;&#x6570;&#xFF08;$pp^{k-1}$&#xFF09;-&#x8FB9;&#x6570;&#xFF0C;&#x6545;&#x8003;&#x8651;&#x6BCF;&#x7EA7;&#x5206;&#x5F62;&#x5185;&#x90E8;&#x8FB9;&#x6570;$F_k$ &#x82E5;&#x4E0A;&#x4E0B;&#x8FDE;&#x901A;&#xFF0C;&#x7EDF;&#x8BA1;&#x6BCF;&#x5217;&#x8FDE;&#x7EED;&#x9ED1;&#x5757;&#x4E4B;&#x548C;&#xFF0C;&#x5426;&#x5219;&#x7EDF;&#x8BA1;&#x6BCF;&#x884C;&#xFF0C;&#x8BBE;&#x4E3A;S&#xFF1B;$F_k=F_{k-1}*pp+S*cnt^{k-1}$&#xFF0C;&#x76F4;&#x63A5;&#x77E9;&#x4E58;&#x5373;&#x53EF; AGC004agc004A - Divide a Cuboid code agc004B - Colorful Slimes code &#x8F6C;&#x5316;&#x4E3A;&#x4EE3;&#x4EF7;&#x5E8F;&#x5217;&#x5DE6;&#x79FB;&#xFF0C;&#x679A;&#x4E3E;&#x603B;&#x5171;&#x79FB;&#x52A8;&#x591A;&#x5C11;&#x6B21;&#xFF0C;&#x7136;&#x540E;&#x7ED9;&#x6BCF;&#x4E2A;&#x6570;&#x627E;&#x88AB;&#x8C01;&#x641E;&#x5373;&#x53EF;&#xFF0C;$O(nlogn)$ agc004 C - AND Grid &#x8FD9;&#x9898;&#x770B;&#x5B98;&#x65B9;&#x9898;&#x89E3;&#x5427; agc004 D - Teleporter code &#x7ECF;&#x5178;&#x6811;&#x4E0A;&#x8D2A;&#x5FC3;&#xFF0C;&#x9996;&#x5148;1&#x80AF;&#x5B9A;&#x8981;&#x8FDE;&#x5411;&#x81EA;&#x5DF1;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x662F;&#x6BCF;&#x6B21;&#x5728;&#x4E0D;&#x5F97;&#x4E0D;&#x641E;&#x7684;&#x65F6;&#x5019;&#x628A;&#x81EA;&#x5DF1;&#x8FDE;&#x5411;1 agc004 E - Salvage Robots &#x8FD9;&#x9898;&#x4E0D;&#x597D;&#x73A9; agc004 F - Namori code &#x8BF7;&#x5148;&#x601D;&#x8003;&#x540E;&#x518D;&#x5C55;&#x5F00; &#x8303;&#x56F4;&#x660E;&#x663E;&#x8BA8;&#x8BBA;&#x505A;&#xFF0C;&#x7136;&#x540E;&#x8BBE;&#x56FE;&#x4E3A;&#x6709;&#x5411;&#x7684;&#xFF0C;&#x79FB;&#x52A8;&#x3001;&#x5220;&#x9664;&#x6570;&#x91CF;&#x5141;&#x8BB8;&#x8D1F;&#x6570; &#x5BF9;&#x4E8E;&#x6811;&#xFF0C;&#x5148;&#x8F6C;&#x5316;&#x6A21;&#x578B;&#xFF0C;&#x9ED1;&#x767D;&#x67D3;&#x8272;&#x540E;&#x5728;&#x9ED1;&#x70B9;&#x4E0A;&#x653E;&#x786C;&#x5E01;&#xFF0C;&#x6BCF;&#x6B21;&#x4EFB;&#x610F;&#x79FB;&#x52A8;&#x786C;&#x5E01;&#xFF08;&#x53EF;&#x80FD;&#x53E0;&#x8D77;&#x6765;&#xFF09;&#xFF0C;&#x6700;&#x540E;&#x6240;&#x6709;&#x786C;&#x5E01;&#x90FD;&#x8981;&#x4E0D;&#x91CD;&#x53E0;&#x5730;&#x653E;&#x5728;&#x6240;&#x6709;&#x767D;&#x70B9;&#x4E0A;&#xFF0C;&#x76F4;&#x63A5;&#x8003;&#x8651;&#x6BCF;&#x6761;&#x8FB9;&#x7684;&#x8D21;&#x732E;&#xFF08;&#x5B50;&#x6811;&#x9ED1;&#x767D;&#x4E2A;&#x6570;&#x5DEE;&#xFF09;&#x5373;&#x53EF;&#xFF0C;&#x82E5;&#x767D;&#x70B9;&#x6570;&#x548C;&#x786C;&#x5E01;&#x6570;&#x4E0D;&#x540C;&#x5219;&#x65E0;&#x89E3; &#x5BF9;&#x4E8E;&#x5947;&#x73AF;&#x6811;&#xFF0C;&#x968F;&#x4FBF;&#x65AD;&#x5F00;&#x4E00;&#x6761;&#x8FB9;&#xFF0C;&#x8FDE;&#x63A5;&#x7684;&#x662F;&#x540C;&#x8272;&#x70B9;&#xFF0C;&#x4F5C;&#x7528;&#x5373;&#x4E24;&#x4FA7;&#x540C;&#x65F6;&#x5220;&#x9664;&#x589E;&#x52A0;&#x786C;&#x5E01;&#xFF0C;&#x6545;&#x5947;&#x5076;&#x6027;&#x4E0D;&#x540C;&#x5219;&#x65E0;&#x89E3;&#xFF1B;&#x5426;&#x5219;&#x4FEE;&#x6539;&#x4E24;&#x4FA7;&#x70B9;&#x4E0A;&#x786C;&#x5E01;&#x6570;&#x540E;&#x50CF;&#x6811;&#x4E00;&#x6837;&#x8DD1;&#x5373;&#x53EF; &#x5BF9;&#x4E8E;&#x5076;&#x73AF;&#x6811;&#xFF0C;&#x90A3;&#x6761;&#x7279;&#x6B8A;&#x8FB9;&#xFF08;$S\to T$&#xFF09;&#x4E5F;&#x80FD;&#x8FD0;&#x8F93;&#xFF08;&#x8BBE;&#x6B21;&#x6570;&#x4E3A;k&#xFF09;&#xFF0C;&#x6545;&#x767D;&#x70B9;&#x6570;&#x548C;&#x786C;&#x5E01;&#x6570;&#x4E0D;&#x540C;&#x5219;&#x65E0;&#x89E3;&#xFF1B;&#x90A3;&#x4E48;&#x73B0;&#x5728;&#x7684;&#x4EE3;&#x4EF7;&#x5C31;&#x662F;$|k|+\sum_{x} |use_x+ct_xk|&#xFF0C;&#x5176;&#x4E2D;ct_x\in[-1,1]$&#x8868;&#x793A;&#x7279;&#x6B8A;&#x8FB9;&#x5BF9;&#x51B3;&#x7B56;&#x7684;&#x5F71;&#x54CD;&#xFF0C;&#x628A;ct=0&#x53BB;&#x6389;&#x540E;&#x662F;&#x4E00;&#x4E2A;&#x5178;&#x578B;&#x7684;&#x4E2D;&#x4F4D;&#x6570;&#x95EE;&#x9898;&#xFF1B;&#x6C42;&#x6BCF;&#x4E2A;&#x70B9;&#x7684;t&#x53EF;&#x4EE5;t[S]++,t[T]--&#x540E;&#x6C42;&#x5B50;&#x6811;&#x548C; AGC005AGC005A - STring code AGC005B - Minimum Sum &#x8003;&#x8651;&#x6BCF;&#x4E2A;&#x70B9;&#x4F5C;&#x4E3A;&#x6700;&#x5C0F;&#x503C;&#x591A;&#x5C11;&#x6B21;&#xFF0C;&#x53EF;&#x4EE5;&#x7528;&#x5355;&#x8C03;&#x6808;&#x4E4B;&#x7C7B;&#x627E;&#x5230;&#x5DE6;&#x53F3;&#x4E24;&#x4FA7;&#x7B2C;&#x4E00;&#x4E2A;&#x66F4;&#x5927;&#x7684; AGC005C - Tree Restoring code &#x5148;&#x628A;&#x76F4;&#x5F84;&#x7684;&#x4E24;&#x4E2A;&#x7AEF;&#x70B9;&#x62FF;&#x51FA;&#x6765;&#xFF0C;&#x8BA8;&#x8BBA;&#x76F4;&#x5F84;&#x7684;&#x957F;&#x5EA6;&#x5373;&#x53EF; AGC005D - ~K Perm Counting code&#x8BF7;&#x5148;&#x601D;&#x8003;&#x540E;&#x518D;&#x5C55;&#x5F00; $ans=\sum_{i=0}^n (-1)^i(n-i)!g(i)$ &#xFF0C;&#x8FD9;&#x6837;&#x6211;&#x4EEC;&#x5C31;&#x53EA;&#x5173;&#x5FC3;&#x90A3;&#x4E9B;&#x975E;&#x6CD5;&#x7684;&#x5BF9;&#x4E8E;&#x975E;&#x6CD5;&#x7684;&#x70B9;&#xFF0C;&#x5728;%k&#x610F;&#x4E49;&#x4E0B;&#x662F;&#x76F8;&#x90BB;&#x7684;&#xFF0C;&#x5BF9;&#x6BCF;&#x4E2A;&#x5269;&#x4F59;&#x7CFB;&#x505A;dp&#x5373;&#x53EF;$&#xFF0C;O(n^2)$ AGC005E - Sugigma: The Showdown AGC005F - Many Easy Problems code&#x8BF7;&#x5148;&#x601D;&#x8003;&#x540E;&#x518D;&#x5C55;&#x5F00; &#x6700;&#x5C0F;&#x8FDE;&#x901A;&#x5757;&#xFF0C;&#x5957;&#x8DEF;&#x5730;&#x679A;&#x4E3E;&#x6BCF;&#x6761;&#x8FB9;&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x6761;&#x8FB9;&#x6709;&#x8D21;&#x732E;&#x7684;&#x60C5;&#x51B5; $f(k)=\sum_{x \ne 1} (C_n^k-C_{siz_x}^k-C_{n-siz_x}^k)+C_n^k&#xFF08;&#x8FB9;+1=&#x70B9;&#xFF09;$ &#x7136;&#x540E;&#x4E0A;&#x5E1D;&#x7ED9;&#x4E86;&#x6211;&#x5207;&#x6389;&#x8FD9;&#x9898;&#x7684;&#x673A;&#x4F1A;&#xFF0C;&#x6211;&#x5374;&#x6CA1;&#x6709;&#x597D;&#x597D;&#x73CD;&#x60DC;qwq&#xFF0C;&#x660E;&#x660E;&#x770B;&#x5230;&#x8F93;&#x51FA;&#x6BCF;&#x4E2A;k&#x5DF2;&#x7ECF;&#x60F3;&#x5230;fft&#xFF0C;&#x5374;&#x6CA1;&#x628A;&#x6700;&#x7B80;&#x5355;&#x7684;&#x4E00;&#x6B65;&#x770B;&#x51FA;&#x6765; &#x5176;&#x5B9E;&#x7EDF;&#x8BA1;&#x6BCF;&#x4E2A;siz&#x7684;&#x51FA;&#x73B0;&#x6B21;&#x6570;&#xFF0C;&#x5C31;&#x662F;&#x4E2A;&#x5377;&#x79EF;&#x7684;&#x5F62;&#x5F0F;&#x4E86;&#xFF0C;$O(nlogn)$ AGC006AGC006A - Prefix and Suffix code AGC007AGC007A - Shik and Stone code AGC008AGC008A - Simple Calculator code AGC008E - Next or Nextnext &#x89C1;&#x8FD9;&#x91CC; AGC009AGC009A - Multiple Array AGC010]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC011到020]]></title>
    <url>%2Fposts%2F6000e5d.html</url>
    <content type="text"><![CDATA[AGC011到AGC020题解合集 0/10 AGC013agc013E - Placing Squares code 请先思考后再展开 考虑题意转化：注意到总和固定，那就是有n个盒子，盒子间如果位置不属于S可插隔板；权值是个平方，和noi2010管道取珠类似，转化为每两个隔板间都要在盒子中恰好放一个红球和蓝球。 那么设 $f(i,0/1/2)$表示放完第i个位置后，最新一段目前有多少个球，用矩乘优化转移，分当前位置能否转移写两个矩阵 $O(2*3^3*mlogn)$ AGC018agc018C - Coins 请先思考后再展开 先将a从大到小，然后枚举a最小那个位置那么x个位置都在左边了因为选择了x和y个，剩下那种不用计算，可以把所有属性减去c，最后补上即可，这样比较好思考 那么注意到左边一定不会选择0，也就是z只在右边那么左右两边直接贪心选择就好了（通过差值判断即可） 需要一个数据结构，维护左右两边的前k大、小之和，这个随便维护即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI]]></title>
    <url>%2Fposts%2F72b2.html</url>
    <content type="text"><![CDATA[HAOI2019：0/?HAOI2018：2/? HAOI2018奇怪的背包请先思考后再展开 以前写的题解 染色请先思考后再展开 简单容斥$$设f_i为恰好i个颜色出现次数为ss，g_i为至少i个颜色出现次数为ss，且满足g_i=\sum_{j=i}^n C_j^if_j \\ans=\sum_{i=0}^m w_if_i， 二项式反演得ans=\sum_{i=0}^mw_i\sum_{j=i}^m (-1)^{j-i}C_j^ig_j，那么求出g就可以fft优化卷积了 \\g_i=C_m^iC_n^{is} \frac{(is)!}{(s!)^k} (m-k)^{n-is}，O(n+mlogm)$$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CEOI]]></title>
    <url>%2Fposts%2F2558.html</url>
    <content type="text"><![CDATA[CEOI2019：4/6CEOI2018：0/?CEOI2017：0/?CEOI2016：0/?质量不错 CEOI2019CEOI2019 D1T2 Dynamic Diameter Loj3163 动态直径请先思考后再展开 就是线段树nlogn动态维护直径的裸题，这里有教程 CEOI2019 D1T3 Cubeword Loj3164 立方填词请先思考后再展开 这题的关键在于注意到最后一个subtask只有16分，所以一定做法差不多，就是搞点特技这叫由数据分布知出题人心态（雾 首先要转化奇葩题意，通过和6个样例快乐van耍后发现：先按照单词长度分组，对每组求出结果求和；然后把每组的单词正反都插入某个字典，去重后求val(a,b)表示两段字母分别为a和b下可选单词方案数。现在有一个立方体的8个格点（带标号），每个格点可以填62种字母，然后每个方案的权值就是立方体12条边的权值乘积。subtask2：5次方的，一种是如官方题解般，如下图所示编号，然后考虑完i就可以丢掉i-5的信息了；或者像我想的，以某个点为1，然后bfs分成4层（1+3+3+1），画一下具体哪些边，发现也是保存某4个的信息转移。subtask3：优化到4次方的话，其实上面的第二种应该是更接近的（然而我并没有想到），不过如果你从立方体分割成5个四面体的角度考虑说不定第一种好想？不过与我这种立体几何极差的人无关……因为你看到第二种就知道他是有层的，例如可以搞成二分图，考虑某侧的4个点（$a,b,c,d$），然后你把边具体地画出来！！你惊讶地发现，外面每个点会过来选3个点覆盖，故每个方案的方案数就是$f(a,b,c)f(a,b,d)f(a,c,d)f(b,c,d)$其中f表示任意选一个外面的点t覆盖这三个点的方案数，故是四次方的然后 我脑抽就直接写了交上去只有84，因为漏考虑前面还有一个7的常数了，而且是满的复杂度，会被卡subtask4：这里结合分数的分布其实不难想。正经来说就是考虑你只关心这4个点的组合而不是所有方案，枚举的时候只需要枚举$a \le b \le c \le d$，系数就是多重集，这样常数/24，不过我的代码并没有怎么重视常数优化code CEOI2019 D2T1 Dynamic Diameter Loj3165 游乐园题意补充：一对点间最多会有一条边 请先思考后再展开 首先你需要看过或能自己yy出dag的计数 记$no(S)=点集生成子图无边,ned(T\to S\setminus T)=连过去翻转了多少边，然后下面所有转移的条件都是T \subseteq S,no(T)=1,T \ne \emptyset$ 那么不难写出一个dp式：$f(S,cnt)=\sum_T (-1)^{|T|+1}f(S \setminus T,cnt-ned(T \to S \setminus T))$，这个是非常经典的容斥，因为若T能转移，则T的子集也能 方法一（$2^nn^2$）：考虑观察一下题目的性质，一个dag方案所有边翻转还是个dag，他们的权值和=m，所以我们只需要计算出方案数，然后$*m/2$即可；方案数的计算会非常简单：$f(S)=\sum_T (-1)^{|T|+1}f(S \setminus T)$ ，这个搞个子集卷积就好了，见fwt教程及州区划分 看了看zsy的代码，并没有看懂……好像是个求逆？ 方法二（$3^n$）：这个方法复杂度对本题不是最优，但如果改改这道题，废掉上面那个性质，就必须这样做了（也就是拓展性较强，才不是因为我太菜没想到上面的性质），而且这个做法的容斥，我曾一度以为是错的（容斥太差 看着dp方程，自然想怎么省掉一维，很自然的思路是 $设g(S)=权值和$ $g(S)=\sum_T (-1)^{|T|+1}(g(S \setminus T)+f(S \setminus T)*ned(T \to S \setminus T))$，这个怎么$3^n$？对每个S存一下$record(T)=ned(T \to S \setminus T)$，每次从去掉lowbit的地方转移过来即可 接下来分析正确性，你注意到这不是普通的方案容斥，而是带权值的；但注意到其权值满足$\forall A满足条件且\subseteq T,val(T)=val(A)+val(T \setminus A)，因为no(A)=1$ 设当前根集合为T，设容斥系数$pp_i$表示集合大小为i（显然只和大小有关），那么我们希望： $val=\sum_{a=1}^{贡献边数} (\sum_{i=1}^{|T|}pp_iC_{n-1}^{i-1}+\sum_{i=1}^{|T|}pp_iC_{n-1}^{i} )=val*\sum_{i=1}^{|T|}pp_iC_n^i$，即考虑在本次被包含或在下一次被包含，然后这就是经典的容斥系数了，$pp_i=(-1)^{i+1}$；这里漏想了括号里右边的部分，所以以为是错误的做法…… code，这个做法因为有模常数稍大，需要常数优化才能通过 CEOI2019 D2T2 Magic Tree Loj3166 魔法树请先思考后再展开 这题一开始乱想了想都不太行，然后立刻第一直觉就是dsu on tree，确实猜对了设dp(x,time)然后先考虑序列，再考虑树，发现转移如下：每次对每棵孩子的子树的整个dp序列做前缀mx，然后把各个孩子一一对应加起来，此时是递增的然后如果x上有果实(time,val)，那么dp(x,time)+=val，就是可能凸出来 为了让复杂度和子树大小相关，考虑只存储与前面不同的地方，并且仔细观察转移发现我们应当存储的是前缀mx后的结果方向一：直接存储具体的值，那么需要写一个动态开点权值线段树，然后到时候启发式合并就是后缀加然后考虑x上果实的时候需要找到下一个比dp(x,time)+val更大的地方，中间删除，这个利用单调的特性是可以求的这种写法应该是可行的，但码量较大，考虑怎么减小方向二：考虑差分，这个我确实没想到，主要是观察到我们需要的是后缀加，同时注意到差分后我们只需要处理val，而且中间要被删除考虑每个数只会被删除一个，所以是可以暴力删除的，可以用map或者set来写，非常好写 上述两个方向的复杂度都是log方 12345678910111213141516171819202122232425262728293031const int N=1e5+10;int fa[N],now[N];map&lt;int,ll&gt; mp[N];typedef map&lt;int,ll&gt;::iterator IT;int merg(int x,int y)&#123; if(mp[x].size()&gt;mp[y].size()) swap(x,y); for(IT it=mp[x].begin();it!=mp[x].end();it++) mp[y][it-&gt;FR]+=(it-&gt;SE); return y;&#125;pr a[N];void main()&#123; int n=qread(),m=qread();qread(); for(int i=1;i&lt;=n;i++) now[i]=i; for(int i=2;i&lt;=n;i++) fa[i]=qread(); for(int i=1;i&lt;=m;i++)&#123;int x=qread(),t=qread(),val=qread();a[x]=MP(t,val);&#125; for(int i=n;i&gt;=2;i--) &#123; int t=now[i],ti=a[i].FR;ll val=a[i].SE,bkup=val; mp[t][ti]+=val;IT gg=mp[t].find(ti);gg++; while(gg!=mp[t].end()) &#123; IT tmp=gg;if(val&lt;gg-&gt;SE)&#123;mp[t][gg-&gt;FR]-=val;break;&#125; val-=gg-&gt;SE;gg++;mp[t].erase(tmp); &#125; now[fa[i]]=merg(now[fa[i]],t); &#125; ll ans=0;for(IT it=mp[now[1]].begin();it!=mp[now[1]].end();it++) ans+=(it-&gt;SE); write(ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树上启发式</tag>
        <tag>线段树</tag>
        <tag>好题</tag>
        <tag>容斥</tag>
        <tag>fwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OZY退役邀请赛]]></title>
    <url>%2Fposts%2F1f5d.html</url>
    <content type="text"><![CDATA[OZY退役邀请赛 比赛链接 C 学前班数学题题意：T组询问，每组询问给定两个正整数X，Z你要找到最小的Y满足LCM(X,Y)=Z。保证有解$T≤10^6，X,Z\le10^{18}$ 唯一要解决的问题就是$gcd (\frac{z}{x},\frac{x}{d})=1$ 最大化d 我只想到log方的，就是x不断/gcd 正解是log的，就是x也同时乘gcd 123456789101112131415void main()&#123; int T=qread(); while(T--) &#123; ll x=qread(),z=qread(); ll a=z/x,b=x; while(1) &#123; ll d=gcd(a,b);b/=d;a*=d; if(gcd(a,b)==1)break; &#125; write2((z/x)*(x/b)); &#125;&#125; 51nod2030 Zbox的刷题II首先题意是带标号的n道题 zsy的做法：正确性比较显然$$考虑对每个子集统计贡献，设大小为i的子集贡献系数为bi（显然只跟集合大小有关） \\\sum_{i=1}^n C_n^ib_i(P^{0i}+P^{1i}…)=\sum_{i=1}^n \frac{C_n^i b_i}{1-P^i} \\a_0=0,a_n=\sum_{i=0}^n C_n^ib_i,b_n=\sum_{i=0}^n(-1)^{n-i}C_n^ia_i，NTT求b，O(nlogn)$$ 出题人做法： 先说怎么做，就是把ai看做连续点值求这个多项式的下降幂 loj2417 bzoj4576 「USACO 2016 US Open, Platinum」262144我的做法：从小到大考虑，孤立的点会变成分界点，但分割这东西我不会怎么写成函数，只能硬着头皮写了1h+，过的时候真的成就感满满（因为担心做法假）大概就是维护一段区间，然后每次扫同一个值的所有东西，然后向上合并，然后如果这一段长度是奇数，在中间建立分割点，然后因为题目只需要求最大值是什么，所以相互独立进行两组实验，告诉左边【我舍弃了最右边那个】，告诉右边【我舍弃了最左边那个】（xgc的优秀idea）时间复杂度为 $O(n值域)$ 这个复杂度和正解一样，但不满，所以loj登顶了，code；然后发现也有人和我一样的做法的正解：code 非常好写…… LOJ3014 「JOI 2019 Final」独特的城市设直径端点为S和T，按照与谁近划分两点的地盘，则节点x的独特城市一定在x到管理x的端点另一个的路径上 那么我们分别以S和T为根建树，然后最后用所属端点来决定输出哪个答案 如果用dfs遍历节点并用栈保存到根路径上所有当前合法的点，容易发现到其孩子的话最多增加一个节点x本身 那么我们现在得到一个暴力做法：依次遍历每个孩子，然后将栈内到x距离&lt;=【其他孩子能贡献最长到x的链】的节点删除并加入x，回溯的时候还原；等所有节点都处理完了，再求出x的答案（用x的最长链更新后） 发现这样复杂度无法保证，但先别急着换做法；注意到如果那个更新的阈值递减就不用还原了，也就是说我们先用次长链更新，然后访问长孩子，再用最长链更新访问其他孩子，这样就没有还原了，于是就能保证复杂度，即每个点加入度数次，复杂度为线性；code 小学生网格题题目题意：n*m四连通的网格，一个格子被控制满足下面两个条件之一:1：这个格子被标记2：这个格子相邻的格子都被标记给出每个格子控制的收益和标记的代价，求最大收益-代价1≤n,m≤100 规模、值域很小，费用流好像不是很可行，考虑最小割 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;namespace mine&#123; #define double long double typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=950009857; inline ll qpower(ll x,ll e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; inline ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int N=1e3+10; int hou[N*N]; struct Edge&#123;int y,g,c;&#125;e[N*N]; int ln=0;int oth(int k)&#123;return k&amp;1?k+1:k-1;&#125; void ins(int x,int y,int c) &#123; // printf("(%d-&gt;%d,%d)\n",x,y,c); e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0&#125;;hou[y]=ln; &#125; int st,ed; int h[N*N];queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,sizeof h);q.push(st);h[st]=1; while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(!h[y] and e[k].c) h[y]=h[x]+1,q.push(y); &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int flow) &#123; if(x==ed or !flow) return flow; int tt=0; // printf("dfs(%d,%d)\n",x,flow); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c) &#123; int out=dfs(y,min(flow-tt,e[k].c)); e[k].c-=out;e[oth(k)].c+=out;tt+=out; &#125; if(tt==flow) break; &#125; if(!tt) h[x]=0; return tt; &#125; const int dx[4]=&#123;0,0,-1,1&#125;; const int dy[4]=&#123;-1,1,0,0&#125;; int cost[N][N],beneft[N][N];char str[N]; int to(char c)&#123;return ('0'&lt;=c and c&lt;='9'?c-'0':('a'&lt;=c and c&lt;='z'?10+c-'a':36+c-'A'));&#125; void main() &#123; int n=qread(),m=qread(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=m;j++) cost[i][j]=to(str[j]); &#125;int ans=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=m;j++) beneft[i][j]=to(str[j]),ans+=beneft[i][j]; &#125; st=0,ed=N*N-1;int T=m+10,TT=T*(n+2)+10; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; int id=T*i+j; for(int pp=0;pp&lt;4;pp++) &#123; int tx=i+dx[pp],ty=j+dy[pp];if(tx&lt;1 or tx&gt;n or ty&lt;1 or ty&gt;m) continue; if((i+j)&amp;1) ins(TT*2+id,TT*3+T*tx+ty,INF); else ins(T*tx+ty,TT+id,INF); &#125; if((i+j)&amp;1) ins(st,id,cost[i][j]),ins(id,TT+id,INF),ins(TT+id,TT*2+id,beneft[i][j]); else ins(TT+id,TT*2+id,beneft[i][j]),ins(TT*2+id,TT*3+id,INF),ins(TT*3+id,ed,cost[i][j]); &#125; while(bfs()) ans-=dfs(st,INF); write(ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125; 中学生网格题题目题意：n*m的网格，每个格子可以填1~k定义两行是相似的，当将各行中的数升序排序后，完全一致问使得各行两两不相似的方案数对1e9+7取模 做法一：理论运算次数5亿，常数拉满且带模，不过我卡过去了（943ms），分享一下 考虑一行的合法情况，如果枚举m的分拆数（2e5），那么会产生 $tmp=\frac{tot!}{\prod (cnt_i!)}*C_k^{tot}$ 个本质不同的行（注意不是P，因为分拆方案可能某数字多次出现），但他们的可选择方案数都是$pp=\frac{m!}{\prod (a_i!)}$ （a是m的分拆，cnt是某个数字i在a中出现次数，tot为拆分成多少个不同的数），正确性自己思考一下，就是多重集排列；于是每次做一个n方的dp，考虑在这种拆分下选多少个 123456789101112131415161718192021222324252627282930#define double long double//不加会wa一个点double ff[N];ll f[N],fac[N],facinv[N],inv[N],gg[N];int n,m,k;void dfs(int now,int mi,ll pp,ll tot,ll tmp,double real)&#123; if(tot&gt;k) return; if(now==0)//tmp种本质不同的行，这些行的方案每个都是pp种 &#123; tmp=tmp*facinv[k-tot]%MOD;real=real/ff[k-tot]; gg[0]=1;for(int i=1;i&lt;=n;i++) gg[i]=gg[i-1]*(tmp+MOD-i+1)%MOD*inv[i]%MOD*pp%MOD; for(int i=n;i&gt;=1;i--) for(int j=i-1;j&gt;=0;j--) &#123; if(i-j&gt;real) break; f[i]=(f[i]+f[j]*gg[i-j])%MOD; &#125; return; &#125; for(int i=mi;i&lt;=now;i++) for(int cnt=1,pp2=pp*facinv[i]%MOD;cnt*i&lt;=now and tot+cnt&lt;=k;cnt++,pp2=pp2*facinv[i]%MOD) dfs(now-i*cnt,i+1,pp2,tot+cnt,tmp*facinv[cnt]%MOD,real/ff[cnt]);&#125;void main()&#123; fac[0]=1;for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%MOD; facinv[N-1]=invm(fac[N-1]);for(int i=N-2;i&gt;=0;i--) facinv[i]=facinv[i+1]*(i+1)%MOD; inv[1]=1;for(int i=2;i&lt;N;i++) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD; ff[0]=1;for(int i=1;i&lt;N;i++) ff[i]=ff[i-1]*i; n=qread(),m=qread(),k=qread(); f[0]=1;dfs(m,1,fac[m],0,fac[k],ff[k]);write(f[n]*fac[n]%MOD);&#125; 做法二：$O(n^4)$，注意到枚举具体分拆限制了复杂度，考虑用dp而不是dfs 首先做一个简单dp搞出$g(n)$表示n行相似的方案数，转移考虑枚举每种数字出现次数就好了，$O(n^4) $ 然后考虑容斥dp，将行分拆成若干组，每组内相似，组间互不相似；你发现我们只需要计算组大小形如$1,1,1…lst(lst \ge1)$这样的分拆就可以了 设$f(a,lst)$表示前面有a个1，考虑前面哪个和最后那个相似，$f(a,lst)=f(a-1,1)*g(lst)-a*f(a-1,lst+1)$ $ans=f(n-1,1)，O(n^2)$ 123456789101112131415161718192021ll fac[N],facinv[N],fi[N][N];ll g[N],tmp[N],f[N][N];void main()&#123; fac[0]=1;for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%MOD; facinv[N-1]=invm(fac[N-1]);for(int i=N-2;i&gt;=0;i--) facinv[i]=facinv[i+1]*(i+1)%MOD; for(int i=0;i&lt;N;i++) &#123;fi[i][1]=facinv[i];for(int j=2;j&lt;N;j++)fi[i][j]=fi[i][j-1]*fi[i][1]%MOD;&#125; int n=qread(),m=qread(),k=qread(); for(int i=1;i&lt;=n;i++) &#123; memset(tmp,0,sizeof tmp);tmp[0]=1; for(int num=1;num&lt;=k;num++) for(int x=m;x&gt;=1;x--) for(int y=0;y&lt;x;y++) tmp[x]=mm(tmp[x]+tmp[y]*fi[x-y][i]%MOD); g[i]=tmp[m]*qpower(fac[m],i)%MOD; &#125; for(int lst=1;lst&lt;=n;lst++) f[0][lst]=g[lst]; for(int i=1;i&lt;n;i++) for(int lst=1;lst&lt;=n;lst++) f[i][lst]=(f[i-1][1]*g[lst]+MOD-i*f[i-1][lst+1]%MOD)%MOD; write(f[n-1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[清华集训合集]]></title>
    <url>%2Fposts%2Fc7f8.html</url>
    <content type="text"><![CDATA[2/? UOJ46【清华集训2014】玄学请先思考后再展开 首先$(a,b)=ax+b$这种信息是可以快速合并的，但是不满足交换律 如果可以离线的话，可以直接线段树分治，$时间O(nlog^2n)-空间O(nlogn)$ 如果模数是质数，$a \ne 0$的时候，我们可以通过求出前r个操作、前l-1个操作来得到中间的操作的二元组，可以用主席树实现，$a=0$的话可以额外维护个线段树，$时间O(nlogn)-空间O(nlogn)$ 然而模数不是质数的话，本来想CRT，但发现需要额外的空间存每个质因子相关的信息，时空都乘上10，对于本身就大空间的主席树来说不太可行 通过上面这么多失败的尝试，我们发现实际上要求我们找到一种只有合并的做法 考虑对于时间分块，那么散块直接枚举，完整的块内会有$O(siz)$个不同的区间，区间内打的标记是相同的，回答询问可以通过二分找到具体影响这个位置的标记贡献，按照时间顺序合并标记即可，$O(\frac{chg}{T}*T^2+qes*\frac{chg}{T}*log T)=O(m^{3/2}*log \sqrt m)$ 将分块换成线段树，修改只在插满的时候向上合并，询问的时候二分或lowerbound，$时间O(nlog^2n)-空间O(nlogn)$ code UOJ269 【清华集训2016】如何优雅地求和请先思考后再展开 关于连续点值，你可能需要对下降幂多项式有所了解，总之我们可以nlogn求出$f(x)$的下降幂形式 $$特殊情况：\sum_{k=0}^nC_n^kx^k(1-x)^{n-k}=1 \\a^{\underline b}(a&lt;b)=0, Q(x^{\underline C})=\sum_{k=C}^n k^{\underline C} C_n^k x^k (1-x)^{n-k}=\sum_{k=C}^n k^{\underline C} \frac{n^{\underline C}*(n-C)!}{k^{\underline C}*(k-C)!(n-k)!} x^C x^{k-C} (1-x)^{n-k} \\=n^{\underline C}x^C (\sum_{k=C}^n C_{n-C}^{k-C}x^{k-C}(1-x)^{n-k})=n^{\underline C}x^C (\sum_{k=0}^{n-C} C_{n-C}^{k}x^{k}(1-x)^{n-k-C})=n^{\underline C}x^C \\f(x)=\sum_i a_ix^{\underline i},Q(f)=\sum_{i=0}^m a_in^{\underline i}x^i,O(nlogn)$$ code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>下降幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFR583]]></title>
    <url>%2Fposts%2F5fd4.html</url>
    <content type="text"><![CDATA[CFR583题号开头为CF1214 A Optimal Currency Exchangecode B Badgescode C Bad Sequencecode D Treasure Island请先思考后再展开 fst on test 233，因为以为对路径数取998244353不能被卡首先答案的上界是2，为了节省时间我的想法是尽量不建图，例如转对偶图、求点双什么的那么就是你要找到必经点，这个的话你就看到st和到ed的乘积是否是总路径数就好了CF上以后碰到自己选模数的时候一定要选双模数code E Petya and Construction Set请先思考后再展开 构造题，我的做法我不会证明，代码很短很好懂，可自行看code F Employment请先思考后再展开 咕咕咕 G Feeling Good请先思考后再展开 咕咕咕 H Tiles Placement请先思考后再展开 咕咕咕]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9月做题记录]]></title>
    <url>%2Fposts%2F8884.html</url>
    <content type="text"><![CDATA[9月做题记录最后一个9月份了，年份都不用写了；即使实力不强也希望这份题单能给后人一些帮助 这个月主要在做课件，整体质量不错 loj6338「SDWC2018 Day2」优秀、CF301E Yaroslav and Arrangements请先思考后再展开 先题目转化： 首先值可以平移到从1开始，然后乘上(m-mx+1)即可 拆环，在n+1处放个1 k很小可以放状态里面，明显计数dp考虑从小到大插入数字，一开始一坨1，每两个1中间需要插2，每两个2又要插3$f(mx,now,pp,cnt)$表示长度now，pp个空位，生成cnt个良好数列转移枚举插入T个数，$f(mx+1,now+T,T-pp,cnt*C_{T-1}^{pp-1})+=f(mx,now,pp,cnt)$ code CF947E Perpetual Subtraction请先思考后再展开 生成函数做法：$$考虑f（生成函数为F）转移到ff（生成函数为FF），通过化式子使其支持快速重复\\FF=\sum_{i=0}^n(\sum_{j=i}^nf_j/(j+1))x^i=\sum_{j=0}^n \frac{f_j}{j+1}*\frac{x^{j+1}-1}{x-1}=\frac{\int_1^x F(t)dt}{x-1}\\考虑设G(x)=F(x+1)，GG(x)=\frac{\int_0^xG(t)dt}{x},gg_i=\frac{g_i}{i+1}，每次操作可快速转移 \\那么只需要考虑开始和最后同阶f和g怎么转化，\sum_{i=0}^n g_ix^i=\sum_{i=0}^nf_i(x+1)^i$$二项式展开+二项式反演+ntt，卷积方式和第一类斯特林log卷的方法类似，就翻转一下就好了，code可见本做法的核心在于巧妙地构造G，得到一个很好用的转移式；这个做法并不是很好想，然而另一种做法更鬼畜…… 线性代数做法： 其实有了线性代数基础知识，并不难看懂Vectorxj题解、官方题解、scb的题解 然而这个特征值好推，特征向量不好推啊，似乎scb有有理有据的中文推导，然而并没有太大耐心去看了 51nod1229 序列求和 V2题意：求$f_k(n)=\sum_{i=1}^n i^kR^i$ 请先思考后再展开 $$(R-1)f_k(n)=n^kR^{n+1}+\sum_{i=1}^n R^i((i-1)^k-i^k)二项式定理\\=n^kR^{n+1}+\sum_{i=1}^n R^i(\sum_{j=0}^{k-1} C_k^j i^j(-1)^{k-j} )=n^kR^{n+1}+\sum_{j=0}^{k-1} (-1)^{k-j}C_k^j \sum_{i=1}^{n} i^j R^i\\=n^kR^{n+1}+\sum_{j=0}^{k-1} (-1)^{k-j}C_k^j f_j(n)，可以O(k^2)递推$$记得R=1要特判，自然数幂和 51nod1822 序列求和 V5这题不建议开 请先思考后再展开 R=1同样先判了，要求$O(k)$可以插值或伯努利，详见这里 实话说，本题的做法几乎每一步除了神还是神，我只能理解其正确性，而没法逻辑上推导，见谅。 $$1)f_k(n)=R^{n}F_k(n)-F_k(0)，这里F_k是个k次多项式，正确性很好证明，上面的递推式+归纳法即可 \\那么我们现在的目标就是求出F_k的点值然后插出来，再探索一些关系 \\2)f_k(n+1)-f_k(n)=(n+1)^k R^{n+1}，这个也是上面的递推式+归纳法可证 \\同时f_k(n+1)-f_k(n)=R^{n+1} F_k(n+1)-R^nF_k(n)，可得F_k(n+1)=(n+1)^k+F_k(n)/R即递推式 \\3)根据牛顿插值法或自行思考一下，任何关于x的k次多项式都可以被表示为\sum_{i=0}^k a_i C_x^i，有可以看做系数放了分母的下降幂多项式 \\\sum_{i=0}^{k+1} (-1)^i C_{k+1}^i F_k(i)=\sum_{i=0}^{k+1} (-1)^i C_{k+1}^i \sum_{j=0}^ka_jC_i^j=\sum_{j=0}^ka_j(\sum_{i=j}^{k+1} (-1)^i C_{k+1}^i C_i^j=0)=0 \\证明：\sum_{i=j}^{k+1} (-1)^i C_{k+1}^j C_{k+1-j}^{i-j}=\sum_{t=0}^{k+1-j} (-1)^{j+t} C_{k+1}^j C_{k+1-j}^{t}=C_{k+1}^j (-1)^j (\sum_{t=0}^{k+1-j} (-1)^t C_{k+1-j}^{t}=[j=k+1]=0)=0 \\4)于是我们获得了k+1条方程，能求出至少一组解，点值数量也超过k \\设A=F_k(0)然后表示出F_k(1..k+1)从而求出A，然后用2的递推式求出点值，再插值即可$$ 总复杂度$O(\sum k)$ uoj193【UR#14】人类补完计划题意：给出一个n个点m条边的无向图，求所有基于边集的生成子图是一棵连通基环树的方案权值和，一个方案的权值为$2^{非叶子节点个数}$ 请先思考后再展开 Rose的做法：和CEOI2019游乐园有点像，一定要分清哪些东西你需要考虑进容斥系数的选择而哪些不用 $$首先考虑环，不妨从编号最小的点开始，这样每个环会记两次，设link(S,ed)然后转移到比mi(S)大的点，O(2^nn^2)\\f(S)表示连通基环树方案数，用link(S)/2初始化，设cnt(T\to S \setminus T)边方案，可以用类似游乐园的方法O(1)处理切换 \\f(S)=\sum_{T\ne \emptyset,T\subset S} (-1)^{|T|+1}f(S \setminus T)*cnt(T\to S \setminus T),ans=\sum_{S} \sum_{T\subset S可空} pp(|S|,|T|) 2^{|S|-|T|} f(S \setminus T)*cnt(T\to S \setminus T) \\我们希望2^{n-i}=\sum_{j=0}^{i} C_i^j pp(i,j)*2^{n-j}，即1=\sum_{j=0}^{i} C_i^j pp(i,j)*2^{i-j}，考虑pp(i,j)=(-1)^j，O(3^n)$$低级推广一下，设权值为$a^{非叶子个数}，则pp(i,j)=(1-a)^j$即可 至于官方题解的做法能进一步怎么推广并没有细看，感兴趣的可以看看，另外还有zx的$2^nn^3$做法 luogu5162 WD与积木请先思考后再展开 难受，又被教做人……脑子是个好东西，我也想要一个 比较直接的思路：$ans=\frac{f_n=\sum_{i=1}^nS_2(n,i)i!*i}{g_n=\sum_{i=1}^n S_2(n,i)i!}$ ，然后就止于$O(Tnlogn)$了 换个思路，考虑dp，$g_n=\sum_{i=1}^nC_n^ig_{n-i}+[n=0],f_n=g_n+\sum_{i=1}^nC_n^if_{n-i}$ 妈呀这居然变成生成函数裸题了……$G=e^x*G-G+1,G=(2-e^x)^{-1};F=G+e^xF-F,F=(2-e^x)^{-2}，O(nlogn)$ uoj50【UR #3】链式反应请先思考后再展开 是我鲁莽了……以为不搞有根树就行了，$F=x(F^2G/2+1)$，仔细想想才发现是错的，还是应该老老实实从dp式开始写$$f_n=[n=1]+ \frac{1}{2} \sum_{t \in G} \sum_{i=1}^n C_{n-1}^{t} C_{n-t-1}^{i} f_{i} f_{n-t-i}=[n=1]+(n-1)! \sum_{t \in G} \frac{g_{n-t-1}}{t!},g_n=\frac{1}{2} \sum_{i=1}^n \frac{f_if_{n-i}}{i!(n-i)!}$$到这里已经可以分治FFT了，$O(nlog^2n)$，rk1和2似乎都是这个做法，这种自己卷自己的分治FFT不会写见yyb的code或这里 接下来介绍一种理论复杂度nlogn的做法 写成生成函数就是：$\frac{d}{dx} F=1+F^2G/2$，也就是一个一阶微分方程（接下来符号换来换去的……f是函数，F是形式幂级数，B是这一层的，b是上一层的） 即现在已知常多项式G，已知函数$f(b)=Gb^2/2+1$，求解$\frac{d}{dx} B=f(B)$；考虑怎么给牛顿迭代修锅 详见生成函数-解微分方程，代码咕了 AGC018E Sightseeing Plan题意补充：在给定3个无交矩形内选3个点，对【连接3点路径数】求和 请先思考后再展开 $$设f(a,b)表示从(0,0)\to(a,b)的方案数，显然f(a,b)=C_{a+b}^a \\于是 \sum_{x=X_1}^{X_2}\sum_{y=Y_1}^{Y_2} f(x,y)=f(X_2+1,Y_2+1)-f(X_2+1,Y_1)-f(X_1,Y_2+1)+f(X_1,Y_1) \\枚举4*4种关键点选择方案，问题转化成统计(0,0) \to (dx,dy)的路径权值和，一条路径的权值为与矩阵([X_1,X_2],[Y_1,Y_2])的交的长度 \\注意到这个长度其实就是在矩形中的终点T与起点S的哈密顿距离，T_x+T_y-S_x-S_y+1$$然后这个东西是可以拆开计算贡献的，考虑会被作为起点多少次即可；而且起点终点关键点只有$4e6$个 CF286E Ladies’ Shop题意：现在有序列a，问是否存在序列p满足对p做值域m以内的完全背包后=a 请先思考后再展开 又被教育了是什么鬼啊……虽然暴力多项式快速幂应该能过，但存在nlogn做法 首先【有解】与【a是解】是等价的，如果无解则a也不是解；那么我们现在只需要知道是否存在一个k使得能被a表示而不在a中；考虑第一个这样的k，你发现一定$\exists i,j\le n,a_i+a_j=k$，因为比k更小的不在a中的数都是不可表的；于是我们对a做多项式平方即可判断是否无解。 考虑最小的p，这个p一定是a的子集（剩下类似NOIP2018D1T2），对于每个数【在p中】等价于【不可被前面的表出】，思考一下发现也是一定$\exists i,j\le n,a_i+a_j=a_t$，因为已经保证有解了，那么如果需要超过两个数表示（可能有重复，不关心怎么组成），那么那些数的子集和一定都是a中的；于是对a做多项式平方即可。 $O(mlogm)$ Topcoder SRM613 TaroCheckers题意：n行m列的棋盘，放允许超过2n个棋子；每行的前lefti和后righti都要各放恰好一个棋子，且每列最多一个棋子，问方案数；$n \le50,m \le 200,left_i+right_i \le m$ 请先思考后再展开 考虑从左往右处理每列，设$f(i,a,b)$表示处理了i列，有a列可用，有b行需要处理right 转移的时候，可选择把这一列放在b个行中；另外如果这一列是k个left的终止位置，则需要在剩下的a中选择k个 $O(m^2n)$，code Topcoder SRM625 Seatfriends题意：有一张N个带标号位置的圆桌，现在有K个无标号人按顺序来坐下，左右相邻将产生连通块，要求任意时刻不超过G个连通块，问分配方案数。$N,K,G\le 2e3$ 请先思考后再展开 这题牛皮 先看K人无区别，设$f(m,k)$表示m个人划分为k个集合，然后我们先不考虑空位，等划分完后再插入，这样是对的 $合并f(m+1,k-1)、单独f(m+1,k+1)+=f(m,k)*k，两侧f(m+1,k)+=f(m,k)*2k$； $ans=N\sum_{k=1}^G f(K,k)C_{N-K-1}^{k-1}$，也就是旋转圆排列、剩下N-K个空格划分为k个非空组 $O(KG)$，注意要特判N=K的情况；code loj547「LibreOJ β Round #7」匹配字符串请先思考后再展开 会28pt不会52pt的制杖估计只有我了吧……$f_i表示以0结束=\sum_{j=i-m}^{i-1}f_j，常系数递推O(m^2logm)$ 注意到模数小的跟死者一样，那我们可能需要推个式子，基本都能很方便地计算，问题是怎么推 上面已经有了一个跟m相关的算法，考虑数据分治，看看能不能搞个n/m的 你可以直接容斥，为了保证不重叠前面加个0，$ans=\sum_{i=0}^{n/(m+1)} (-1)^i 2^{n-(m+1)i} C_{n-(m+1)i+(i+1)-1}^{(i+1)-1}，O(n/m)$ 题解给出了一种有趣的思路，考虑上面的递推式，注意到上面的递推式系数与i无关 设$s_i=\sum_{j=1}^i f_i,s_i-s_{i-1}=s_{i-1}-s_{i-m-1},s_i=2s_{i-1}-s_{i-m-1},s_0=1$ 考虑一个巧妙的题意转化：i连向i+m+1一条-1，连向i+1一条2，路径权值为边的积，求0到n权值和 枚举用了多少个长边，也能得到上面的式子 $当n=2^{36},m取2^{11}，min(m^2logm+n/m)可通过本题$，感觉没必要像题解那样写全家桶 至于zyy的$O(m^3logm)$的矩乘代码，其常数应该是小到了非常夸张的地步 bzoj5058 期望逆序对题意：对初始序列任意交换两个不同的数k次后所有方案逆序对和 请先思考后再展开 考虑只关注A和B两个位置（不失一般性认为上面现在就是A和B），然后你发现对于另外的某个元素C，所构成的所有情况种类（见下）与具体哪个C无关，因为任何一个C此时在哪里对我们现在关注的东西、操作没有任何影响；那么对这些状态做矩乘预处理操作k次的转移矩阵（矩阵不是自己写的，故用行向量，大概理解意思后自己推即可，写代码推也行） $$A=C_{n-2}^2*E（单位矩阵）+\left[\begin{matrix}0 &amp; n-2 &amp; 1 &amp; 0 &amp; 0 &amp; n-2 &amp; 0 \\1 &amp; n-3 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; n-3 \\1 &amp; 0 &amp; 0 &amp; n-2 &amp; n-2 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; n-3 &amp; 0 &amp; 1 &amp; n-3 \\0 &amp; 1 &amp; 1 &amp; 0 &amp; n-3 &amp; 1 &amp; n-3 \\1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; n-3 &amp; n-3 \\0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2(n-4)+1\end{matrix}\right] \\转移：\left[\begin{matrix}(A,B)&amp;(C,B)&amp;(B,A)&amp;(C,A)&amp;(B,C)&amp;(A,C)&amp;(C,C)\end{matrix}\right]*A \\设f(State)表示这种情况的系数，考虑到初始矩阵为[1,0,0,0,0,0,0]，f(State)即第一行系数$$ 然后枚举每个y作为B，考虑每种情况的系数，$ans=\sum_y g_y(State)f(State)$； 这部分搞了很久没看懂别人写的题解，按自己的理解想了个就过了qwq$$g(A,B)=\sum_{x&lt;y,a_x&gt;a_y},g(B,A)=\sum_{x&lt;y,a_x&lt;a_y} \\然后涉及C的，上面统计的是所有C而现在是具体的，所以g_y(State)/=n-2 \\g(C,B)=\sum_{x&lt;y}\sum_{i \ne x,a_i&gt;a_y},g(B,C)=\sum_{x&lt;y}\sum_{i \ne x,a_i&lt;a_y} \\g(C,A)=\sum_{x&lt;y}\sum_{i \ne y,a_i&gt;a_x},g(A,C)=\sum_{x&lt;y}\sum_{i \ne y,a_i&lt;a_x} \\最后再计g(C,C)=C_n^2/2*f(C,C)，因为所有可能的合法C之和恰为1/2 \\$$上面的条件非常好维护，搞个树状数组维护$x&lt;y且a_x&lt;a_y$的个数即可，$O(nlogn)$，code uoj390【UNR #3】百鸽笼注意只有小写n，并没有保证总和在30以内，上面的大写N是没用的…… 请先思考后再展开 好题，正解复杂度均为$O(n^3m^2)$，前置：PKUWC2018猎人杀的题意转化 现在求第k列的答案，考虑容斥，固定至少m个非法列在第k列放完后仍未满$$我们只关心固定列，设形成一个长为L的序列，则最后一个元素一定是k\\然后考虑每在这个序列上填一个数字，非固定列的贡献=\frac{1}{n} \sum_{i=0}^{\infty} (\frac{n-m-1}{n})^i=(m+1)^{-1} \\F_k=\frac{x^{a_k-1}}{(a_k-1)!} *\prod_{t \ne k} (1+y\sum_{i=1}^{a_t-1} \frac{x^i}{i!}),ans_k=\sum L!*(m+1)^{-(L+1)}*(-1)^m *[x^L y^m]F \\设f(L,m)=[x^L y^m]F，插入某列是O(状态n^2m*转移m)，那么无脑每次都放进去是O(n^4m^2)的 \\注意到对于求ans_k，我们其实是把其他n-1个卷起来，那一开始卷好n个后面删除掉k就行了 \\复杂度降低至O(n^3 m^2)，其中删除从背包撤回角度比较好理解 \\$$至于生成函数做法，我觉得难度、实现、本质上都差不多，就是推导的时候繁琐一点，因为我们在很早前就把式子里的n给消掉了，至于展开$x^Ae^{Bx}$对普通生成函数的贡献见这里的推导：agc038E - Gachapon HDU5181 numbers题意：1到n依次入栈，给出m个限制，$A_i 要早于 B_i 出栈$，求多少合法出栈序列，$n \le 3e2$ 请先思考后再展开 入栈出栈序列是可以表示为树形结构的，节点x的子树大小为k，则表示x先入栈，然后子树内的元素为$[x,x+k-1]$且都更晚入栈更早出栈。根据这棵树考虑一下条件$(A&lt;B)$，当$A&lt;B等价于A+siz_A-1&lt;B$；当$A&gt;B等价于B+siz_B-1 \ge A$ 那么就可以做dp了，$f(x,k)表示以x为根子树大小为k，枚举最右边的子树大小，f(x,k)=\sum_{left=1} f(x,left)*f(x+left,k-left)$，每次做完一个点就把他的非法状态清零 本质上就是区间dp，$O(n^3)$，code loj6041「雅礼集训 2017 Day7」事情的相似度请先思考后再展开 首先各种做法复杂度都是$O(nlog^2n)$ 这题在外面天马行空了1h，有许多idea可惜没肝出来，回来看了看题解表示有道理，再仔细想想发现我的做法改改就是对的了 这个做法没在网上见到，个人认为是最自然的，分享一下： 翻转字符串sa排序后缀，经典套路并查集从大到小合并，连通块存set启发式合并 set存储的是下标而不是排名，合并的时候考虑贪心，用set找到左右两侧新产生的关键点对，共有$O(nlogn)$个 一种思路是存下来作为一个点，那么询问就是要回答矩形最大值，这个离线就是经典的树状数组做 另一种思路复杂些（我脑残了），用【树上最短路】那题的思想，区间放到线段树上，现在对于一个区间要找到所有包含它的区间并删除，考虑用左端点单点查询找到包含左端点的所有区间，每个区间在当初插入的时候按右端点从小到大vector存，这样每次判vector最后的并删除掉，这样每个区间会被访问log次 code，这个做法是卡在了存下标这个小trick，而这个恰好是没啥替代方式的按我目前的思路，其他基本都想到了 下面是两个网上的sam做法，看题的时候到这个翻转后询问后缀的就主要在想sa，因为做题少sam以前都是拿来处理子串信息的所以没怎么考虑过 做法二：sam，两个前缀的最长公共后缀就是其lca的len，树结构上set存right集合启发式合并，然后和上面类似 做法三：sam，考虑怎么真正利用树形结构，询问点x与前面的点的lca就是让x向上跳，碰到标记的时候处理，同时从贪心的角度覆盖经过节点的标记，发现这个过程就是个access；那么离线询问按右端点递增回答，每次查询左端点后面的最大值，因为没有删除可以用树状数组维护，access的时候顺便维护好标记即可。 HDU5822 color请先思考后再展开 首先考虑给出的是有根树，那么所谓同构只需要考虑直接孩子间，可以用树hash搞，设$f(x)$表示以x为根的本质不同染色方案数，现在对每个同构的孩子等价类考虑，设其大小为a，因为同构每个孩子的染色方案数都是相同的，设为pp；现在等价于把a分成pp个可空组，即$C_{a+pp-1}^{pp-1}=C_{(n+pp-1)\%p}^a$，考虑到a的总和为n，直接暴力算即可 然后对于有向基环树，现在把有根树dp完后就是一个有向环，相当于一个大小为s的项链，每个珠子有颜色（hash值）和权值（方案数），每个珠子任选权值中的一个数，这东西的置换群是所有合法的旋转，合法当且仅当旋转前后珠子的颜色是对应的，设幅度a合法，则循环长度为$lca(a,n)/a$，循环节大小为$gcd(a,n)$，故根据polya定理可得$ans=\sum_{合法a} f(cir_a)^{gcd(a,n)}$；合法旋转可以用序列hash判定。 复杂度瓶颈为树hash的复杂度，怎么搞见「JSOI2016」独特的树叶 CF135E Weak Subsequence洛谷翻译太抠脚了 正经翻译：给出字符集大小k和一个值w，求有多少字符串P（设长度为n）满足其最长的满足条件的连续子串s长度为w。条件为能在原字符串中选一个不是连续子串的子序列，使得其等于s。 请先思考后再展开 一些浅层的性质（大致递进）： 若L合法，则L-1也合法；若L-1不合法，则L不合法 不存在w+1的合法串的充要条件：对于任意长度至少为w的子串(l,r)，l-1的字符在左侧一定独一无二，r+1同理（没发现这一条，结果没一个题解看懂的qwq，还好rose救命） P的左边n-w个字符互不相同，右边n-w也是 $n \in [w+1,w+k]$ 合法的长度w的串s，一定是P的前驱或后继 以前驱为例，$\exists i \in [w+1,n],P[w]=P[i]$ 你会发现可做了很多，分情况讨论下（建议自行画个图），主要思路是容斥 $n-w&lt;w,首先是(P_k^{n-w})^2(n-w)k^{w-(n-w)-1}*2$，容斥的话如果$w-(n-w)&gt;1,则为-(p_k^{n-w})^2(n-w)^2k^{2w-n-2}$ 若为$w-(n-w)=1，这种情况最多一次，-\sum_{i=1}^k C_k^i*i*C_{k-i}^{2(n-w-i)} C_{2(n-w-i)}^{n-w-i}((n-w)!)^2$ $n-w=w,(P_k^w)^2-P_k^w(k-w)P_{k-2}^{w-1}$ $n-w&gt;w,P_k^{n-w}P_{k-(n-2w)}^w$，容斥掉非法情况$-P_k^{n-w}(k-(n-w))P_{k-(n-2w+1+1)}^{w-1}$ code CF995F Cowmpany Cowmpensation请先思考后再展开 先写个dp式：$s(x,i)=\sum_{j=1}^i f(x,i),f(x,i)=\prod s(son,i)$，接下来展示两个优化至$O(n^2)$的做法 做法一：拉格朗日插值，code 考虑$f(x,i)$是一个关于i的多项式，考虑怎么理解 边界$f(leaf,i)=1$是个0次多项式，$s(leaf,i)$是个1次多项式，似乎最高次是子树大小？ $s(x,i)$这个前缀和显然也是i的多项式且次数=f次数+1，f由s转移就是若干个多项式卷起来，最高次之和=子树大小-1，成立 做法二：容斥，code 考虑离散化dp，即设j为选的数中第j大的值，然后用容斥来纠正不同数个数更小的非法情况 先用$O(n^2)$把离散化dp做完，设gi为恰有i个不同数，$g_i=f(1,i)-\sum_{j=1}^{i-1} g_j C_{i-1}^{j-1},ans=\sum_{i=1}^{min(D,n)} C_D^ig_i$ 可见上面两个做法的dp部分是一样的 51nod1690 区间求和2请先思考后再展开 注意到那东西很像卷积，但是跟长度相关 因为只求一个和肯定是考虑每对数的贡献，然后也不难想到把长度2的区间特判掉，剩下的就是奇数；感觉很可能就是像万径人踪灭那样，把数对卷积到中间点取。问题是怎么把长度去掉，如果没有质数这个限制，那么就讨论$i+j与n$的大小关系，看被统计次数是被左边还是右边统计分成两段，然后看到质数就感觉可能是没啥关系的，但没推出来qwq 其实上面已经把该想的都想完了，设s为质数前缀和，考虑数对i和j的系数，你发现就是个卷积了 $若i+j \le n，就是S(i+j-1)-S(j-i)；若i+j&gt;n，就是S(2n-(i+j)+1)-S(j-i)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PKUSC2018题解]]></title>
    <url>%2Fposts%2F71bd.html</url>
    <content type="text"><![CDATA[当时太菜了没有去，题解合集 CF1204E Natasha, Sasha and the Prefix Sums请先思考后再展开 这题不是PKUSC2018的，但有兴趣的可以看看$$考虑在第一个max处计数，f(a,b)表示前缀 \le0，g(a,b)表示后缀&gt;0的方案数 \\f(a&gt;b)=0,f(a,b)=C_{a+b}^a-C_{a+b}^{b+1}，类似卡特兰数的推导方式 \\g(0,0)=g(a&lt;b)=0,在后面先放一个1，g(a,b)=C_{a+b-1}^{a-1}-C_{a+b-1}^a \\然后枚举前缀mx，前面g后面f拼接起来，O(n^2)，g和f也可以dp计算$$code$$k(a,b)=a个1，b个-1下f&lt;0的方案数 \\k(a&gt;b)=0,k(a&lt;b)考虑从后面添加=k(a-1,b)+k(a,b-1) \\其实用类似卡特兰数的推导方式可知 k(a&lt;b)=C_{a+b}^a-C_{a+b}^{a-1} \\f(a,0)=a,f(0,b)=0,考虑从前面添加（奇妙的思路） \\f(a,b)=(f(a-1,b)+C_{a+b-1}^b)+(f(a,b-1)-(C_{a+b-1}^a-k(a,b-1)))$$code 线性做法：就是求一个至少i+1，可以看【OI之路】03数学-7组合数学中Catalan数拓展部分1234567for(int i=0;i&lt;=n;i++)&#123; int x=n,y=m+i+1;//注意要这样比大小 if(min(x,n+m-x)&lt;min(y,n+m-y)) continue; cnt[i]=C[n+m][x]-C[n+m][y];&#125;ll ans=0;for(int i=1;i&lt;=n;i++) ans+=(cnt[i]-cnt[i-1])*i,ans%=MOD;write((ans+MOD)%MOD); 最大前缀和请先思考后再展开 和上题做法类似，不过需要注意一个细节，整个S的和不算是后缀和的一部分，否则前缀和可能取在题面中i=0code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC037题解]]></title>
    <url>%2Fposts%2F6c6a.html</url>
    <content type="text"><![CDATA[SourceAGC037 感谢官方题解和xyx的博客 好题：D、F A Dividing a String请先思考后再展开 显然长度不会超过2，直接判即可code B RGB Balls请先思考后再展开 感觉似曾相识首先在任何最优方案中，【R、G、B】不可能同时出现，【RG、RB、GB】不可能同时出现（但RG和GR可能同时出现，我们将其看做一类）想通了上面这点，就没有了，该合并的合起来就完事了code C Numbers on a Circle请先思考后再展开 倒着考虑，然后你会发现做减法的话思考一些东西会很方便对于一个数，如果比两边大，那么就没法对两边做操作，所以考虑每次取出当前最大的值思考即可$O(nlognlog num)$code D Sorting a Grid请先思考后再展开 首先每个数看做一个二元组$(i,j)$表示应该到第i行第j列 倒过来思考，第二次做完后必须满足这一行的i相等且就在第i行，那么第二次做完后就是要求每一列所有元素的i是一个排列，然后直接构造好像不太能构造 。 因为列本质上是一样的，一列列搞出来就好了，然后每次显然就是左n个点代表行，右n个点代表值，如果第a行有数字b就连 a-&gt;b，然后你发现这满足hall定理，可以网络流、匈牙利算法构造合法解 时间复杂度为 $O(n*n^2 \sqrt n)$ E Reversing and Concatenating请先思考后再展开 玩耍一下操作，考虑最小字母a的情况，最优策略：保留最长的a在末端一段，每次长度翻倍，在最后一次取翻转的那个所以这个a的长度是 $min(n,2^{k-1}L)$ ，L表示第一次形成的U中a的最长段然后现在要字典序最小，那么在第一轮的U中找到a最长中字典序最小的，后面就不用找了时间复杂度 $O(n^2+nlogn)$ ，应该可以用sa优化到nlogncode F Counting of Subarrays请先思考后再展开 首先考虑怎么快速判断一个序列是否合法若ln=1，合法；取一个只有最小元素a的极长区间，若ln&lt;L非法替换成$floor(ln/L)个a+1$，重复上述过程此过程为 $O(nlog_Ln)$ 注意到复杂度比较高了已经，但每个序列的判断过程相对机械化，考虑同时处理所有序列来优化速度那么就是从小到大处理某个元素a，取出每个极长连续段来处理，设长度为ln，合并起来（取出极长段的话，要维护在原序列中的占用区间$(fl,fr)$）然后考虑序列怎么计数，考虑将每个合法序列贡献到【合并完的最大值】上唯一计数，因为此时该合并的已经合并了当最大值合并完，状态就是只有若干个最大值+1，但每个数字其实代表了若干个可选的端点故考虑系数$l_i和r_i$表示选它作为左、右端点的系数，那么每次统计就维护一个左边的和，从左往右扫右端点就好了，但注意不能统计到【在当前的序列中长度&lt;L】的区间，因为由上可知是非法区间 那么考虑合并的时候怎么计算新的系数，不妨将多的放在最后一段，且不妨只考虑左系数，右系数肯定类似；设合并起来是cnt个，那么对于段k，只有【与该段右端点的长度 $\ge L$ 】的旧$l_i$能贡献到新的 $l_k$ 中；但注意到我们其实会计重：左右端点都在【新产生的序列】中（注意是仅由当前处理的连续段产生的部分），故计算完系数要把这部分答案斥掉 $O(nlog_Ln)$code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【jsc2019-qual F】Candy Retribution]]></title>
    <url>%2Fposts%2F5056.html</url>
    <content type="text"><![CDATA[Source and Judgejsc2019-qual F Analysis请先思考后再展开 $$记g(n,m)=将n划分为m个可空段=C_{n+m-1}^{m-1}，然后显然我们求solve(R)-solve(L-1) \\考虑有序下B，注意到 B_m=B_{m+1} 明显没有 B_m \neq B_{m+1} 好做，故容斥 \\计数的时候用 B_{m+1}来唯一统计序列，枚举B_{m+1}=t \\然后你发现直接等不好处理，转化成不等号则方案数为f(t-1,t)-f(t-1,t+1) \\容斥求f(B_m \leq a,B_{m+1}\geq b)=C_n^m \sum_{i=0}^m (-1)^iC_m^i g(R-i(a+1)-(n-m)b,n+1) \\n+1的1表示可以丢掉，且注意到i \leq min(m,R/t)，复杂度为调和级数 O(RlogR)$$ code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cojR9 & X Round 3]]></title>
    <url>%2Fposts%2F430f.html</url>
    <content type="text"><![CDATA[Source好题：D、E 和xgc合作愉快，靠D拿到rk10，过的时候还剩15min，当场就所有人激动得大吼出来…… 主要是comet的王太多了……终于拿到短裙给lxgay穿了嘻嘻（可惜不能给tyb穿了） D 系统设计请先思考后再展开 题解做法（log）： 考虑处理好从根到当前节点的hash值Sx，每次询问就在数据结构（如线段树）上二分，然后把Sx与now合并，放到S的hash表里面询问就好了 我的做法（log方）： 考虑跳的过程考虑怎么加速，如果能快速做重链，那么只会有log次重链，而重链是可以剖的，得到连续的dfs序，然后你注意到树是静态的，而序列会修改，考虑即树上节点的aa为这个节点重儿子的编号排名，于是就是一个匹配的问题，考虑怎么快速匹配，无脑二分+线段树是log方的，加上外面的重链就是log3方的，考虑怎么在线段树上二分 首先线段树上区间hash维护好，记real为dfs序上当前从哪里开始与起点st匹配且长度限制为mxlen如果设计函数gethash(l,r)来获得st-&gt;mid上的hash判，这样依然是log3方的2333 如果把gethash去掉，就更gg了，因为它不是普通的区间修改，你啥也不判的话一次就是nlogn的；但我们可以考虑怎样让它的复杂度和区间修改一样，如果st是当前线段树区间的左端点，用区间hash判断掉完全匹配的情况；于是如果没断开，他就是区间修改的立刻返回，而断开了则调用它的那些母函数就不会往右走了，所以复杂度是对的。 总之这道题其实70%的idea都是xgc想的，我就是一只猿其实细节不算特别多，也不算真的很难写，但我再次一个sb错误调一年…… code E Namid[A]me请先思考后再展开 首先怎么快速计算 $x^x(\%p)$ ，其实连题面都提示了原根是10了且模数很小，预处理指数后费马小定理即可 因为是按位与，对于某个端点，肯定是只有位数（w）段不同的取值，显然就是存每个状态的数量 然后我就自闭了……只能想到log方的做法 瞎选一个点作为根，dfs递归处理，维护w段取值，向上保留的话很好维护；考虑合并链的情况，暴力合并的话要做$d^2$次，每次是$w^2$，但你需要敏锐地意识到一个上界： $min(d^2w^2,n^2) \geq \sqrt {(dwn)^2}=dwn$，然后每次扫完一个子树合并状态要 $O(nwlogw)$ code F请先思考后再展开 一看就没法直接做……让我们分析一下用bitset做的复杂度…… 首先如果求出S，那么就是 $(S\&amp;(S&gt;&gt;1)\&amp;(S&gt;&gt;2)).count()$ 考虑怎么求，枚举每个元素，如果小于32就搞个lcm求出多少个int是循环节，手写bitset来做或运算，否则暴力跳 $O(n|S|/w+稍微大一点的常数*n/w)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Manthan, Codefest 19]]></title>
    <url>%2Fposts%2Fed65.html</url>
    <content type="text"><![CDATA[Manthan, Codefest 19题号开头为CF1208 A XORinaccicode B Uniquenesscode C Magic Grid请先思考后再展开 这题把节奏打崩了，真心教做人n是4的倍数，而0~15组成一个矩形的解很简单，然后二进制前面加上同样的数字都没有问题所以枚举每个$4*4$的方格，按顺序填就好了，因为长度为4前面的数字会被抵消code D Restore Permutation请先思考后再展开 $$我想了个很蠢的做法，考虑从后往前递推，S_n=\sum1 \to p_n-1 从而求出pn \\类似的 S_{n-1}=\sum1 \to p_{n-1}-1并去掉p_n，考虑这个“去掉”怎么搞 \\维护后面每个S在当前1 \to i范围内的值（去掉i+1 \to n的影响，可以用bit+差分） \\这样就可以根据当前S_i与后面S_j的大小关系（bit上二分），判断出后面哪些p_j比我小 \\从而在当前S_i中去掉这些p_j的贡献（可以另外维护一个bit，存p_j的前缀和） \\（注意后面S_j的大小关系与p_j大小关系一样，以p_j为下标存S的差分找到对应位置即可）$$然后这个做法想了半天才想到，写起来也不太好写，有一些细节需要考虑 时间复杂度下界也是log，不过比赛写的是log方的：code 比较好想好写的做法是，每次找最后一个0，第一次找到1，更新后面，第二次找到的就是2了，经典线段树即可，长但无脑不易错 upd：现在冷静下来想想，发现我sb了……泥萌还是看官方题解的代码吧（Approach 2），很简短…… E Let Them Slide请先思考后再展开 当时看完题第一想法想到就写了，因为只剩15min，最后也没调出来就是从大到小处理每条直线，然后用一个set维护已经被覆盖的区间，然后每次这个新区间，用while找到能贡献的地方不过直接这样显然复杂度不对，因为可能有很多中间没有空隙的地方被反复枚举但很好改，稍微思考一下就会发现，每次碰到这种就把 两个合并起来，这样复杂度就是对的了因为set不能用stl的lower_bound研究了一上午为啥tlecode F Bits And Pieces请先思考后再展开 考虑求答案我们需要什么，从高到低枚举每一位，设当前期望答案为ans，考虑的位置掩码为mask；考虑枚举i，则要求另一边（两数与）是 $(a_i \ xor \ ans)\&amp;mask$ 的超集（当ans某个位=0，则一定找不到一个合法方案使得ai某个位=1，所以对做法正确性没有影响）对于每种$a_i\&amp;a_j$的结果，发现只需要存最后两个ai和aj，以这个为状态做一个类似fwt的简单dp即可code G Polygons请先思考后再展开 显然选择了num，就会选择num的所有约数，那么不妨设 $f(num)$ 表示选择num新产生的点数，考虑把点表示成 $\frac{1}{num}+\frac{2}{num}…\frac{num-1}{num}$ ，显然 $f(num)=\varphi(num)$ ，再考虑到 $\varphi(num) \geq \varphi(d|num)$ ，故把1到n的phi排序然后对前k+2个求和+1就好了；然而当k=1时并不会选择2的倍数，特判123456void main()&#123; pre(); int n=qread(),k=qread()+2;if(k==3) &#123;write(3);return;&#125; sort(phi+1,phi+n+1);ll ans=0;for(int i=1;i&lt;=k;i++) ans+=phi[i];write(ans+1);&#125; H Red Blue Tree咕咕咕]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bubble Cup 9]]></title>
    <url>%2Fposts%2F32e3.html</url>
    <content type="text"><![CDATA[Bubble Cup 9 跟着akc做题；还有一个blog CF717A Festival Organization请先思考后再展开 $$\begin{aligned}ans&amp;=solve(r+2)-solve(l+1) \\solve(n)&amp;=\sum_{i=0}^n C_{fib(i)}^k=\frac{1}{k!} \sum_{i=0}^n fib(i)^{\underline k}\\&amp;=\frac{1}{k!} \sum_{i=0}^k (-1)^{k-j} S_2(k,j)[ \sum_{i=0}^n fib^j(i) ] \\pp&amp;=\frac{1+\sqrt{5}}{2},fib(i)=\frac{pp^i+(-1)^{i+1}pp^{-i}}{\sqrt{5}} \\\sum_{i=0}^n fib^j(i)&amp;=(1/\sqrt{5})^j \sum_{t=0}^j C_j^t \sum_{i=0}^n (-1)^{(i+1)t} (pp^{(j-2t)})^i \\&amp;=(1/\sqrt{5})^j \sum_{t=0}^j C_j^t (-1)^t \sum_{i=0}^n (A=pp^{j-2t}(-1)^t)^i \\&amp; 时间复杂度为 O(k^2)，类似复数去存就好了\end{aligned}$$ B请先思考后再展开]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二项式定理</tag>
        <tag>fib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cojR8]]></title>
    <url>%2Fposts%2Fb2c5.html</url>
    <content type="text"><![CDATA[Source好题：E、F E请先思考后再展开 几乎是抄了一遍题解系列……$$\begin{aligned}ans&amp;=\sum_{i=1}^n ( \prod p_t^{\lfloor k_t/2 \rfloor} )=\sum_{i=1}^n ( i/\prod p_t^{\lceil k_t/2 \rceil} ) \\&amp;=\sum_{i=1}^n \sum_{j=1}^i[i|j^2]=\sum_{i=1}^n \sum_{j=1}^i \sum_{k=1}^{j^2} [ik=j^2] \\&amp;看到乘积为完全平方数，考虑最大公约数\\&amp;=\sum_{d=1}^n \sum_{i=1}^{n/d} \sum_{k=1}^i [gcd(i,k)=1] [i,k为完全平方数] \\&amp;=\sum_{d=1}^n \sum_{i=1}^{\sqrt{n/d}} \sum_{k=1}^i [gcd(i^2,k^2)=1] \\&amp;=\sum_{d=1}^n \sum_{i=1}^{\sqrt{n/d}} \varphi(i^2)=\sum_{i=1}^n \varphi(i) \lfloor n/i^2 \rfloor\end{aligned}$$ F 黄金体验请先思考后再展开 有个不会证明但找不到反例的结论：k可以由k-1增量得到那么如果静态的话，不难想到可以先求出k=2即带权直径，搞出一个端点作为根，然后k-1次找当前贡献最大的链并加入仔细思考发现这东西本质上就是带权长剖，这种链的信息可以用lct来维护：按照到根权值和从小到大access每个节点，得出带权长链，前k-1大长链之和就是答案 现在考虑怎么动态维护，更改一个节点，那么唯一的改动就是向上的长链可以类似access那样，直到无法从轻儿子变为重儿子，这个过程中会有一系列长链的权值改动，要用segt维护还有一个问题就是修改以后带权直径会变，但考虑到新的根可以从新带权直径任意一个端点中选择而新直径一定会保留原本直径中的某个端点，以那个为根的话长链的结构是没有变化的，这方面在access的时候特判就好了 时间复杂度为 $O(qlog^2n)$代码好写归好写，花了一上午，一个错误调一年 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; #define double long double typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; int MOD=998244353; void add(ll &amp;a,ll b)&#123;a+=b;a=(a&gt;=MOD?a-MOD:(a&lt;=-MOD?a+MOD:a));&#125; ll qpower(ll x,ll e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int N=2e5+10; namespace PP &#123; priority_queue&lt;ll&gt; a,b; ll top() &#123; while(a.size() and b.size() and a.top()==b.top()) a.pop(),b.pop(); return a.top(); &#125; void insert(ll num)&#123;a.push(num);&#125; void del(ll num)&#123;b.push(num);&#125; &#125;; namespace SGT &#123; #define MID (l+r)/2 struct Nod&#123;int lc,rc,siz;ll sum;&#125;p[N*80]; int id=0,rt; void add(int &amp;x,ll l,ll r,ll pos,int c) &#123; if(!x) x=++id; p[x].siz+=c;p[x].sum+=pos*c; if(p[x].siz&lt;0) puts("error"); if(l==r) return; if(pos&lt;=MID) add(p[x].lc,l,MID,pos,c); else add(p[x].rc,MID+1,r,pos,c); &#125; ll ask(int x,ll l,ll r,int k) &#123; if(!x) return 0; if(l==r) return l*min(k,p[x].siz);//debug int rr=p[p[x].rc].siz; if(k&lt;=rr) return ask(p[x].rc,MID+1,r,k); return ask(p[x].lc,l,MID,k-rr)+p[p[x].rc].sum; &#125; void change(ll pos,int c)&#123;add(rt,0,1e15,pos,c);&#125; &#125;; ll w[N]; namespace LCT &#123; int fa[N],son[N][2];ll sum[N]; int lc(int x)&#123;return son[x][0];&#125;int rc(int x)&#123;return son[x][1];&#125; bool tag[N];void rev(int x)&#123;tag[lc(x)]^=1;tag[rc(x)]^=1;swap(son[x][0],son[x][1]);tag[x]=0;&#125; void pushup(int x)&#123;sum[x]=w[x]+sum[lc(x)]+sum[rc(x)];&#125; bool sn(int x)&#123;return rc(fa[x])==x;&#125; bool isrt(int x)&#123;return son[fa[x]][sn(x)]!=x;&#125; void rotate(int x) &#123; int f=fa[x],ff=fa[f];if(!isrt(f))son[ff][sn(f)]=x; int w=sn(x),gson=son[x][w^1];son[f][w]=gson;son[x][w^1]=f; fa[x]=ff;fa[f]=x;if(gson)fa[gson]=f;pushup(f);pushup(x); &#125; vc&lt;int&gt; tmp; void splay(int x) &#123; tmp.clear();int now=x;tmp.PB(now);while(!isrt(now)) tmp.PB(now=fa[now]); for(int t=(int)tmp.size()-1;t&gt;=0;t--) if(tag[tmp[t]]) rev(tmp[t]); for(int f=fa[x];!isrt(x);rotate(x),f=fa[x]) if(!isrt(f)) sn(x)^sn(f)?rotate(x):rotate(f); &#125; void add(int x,int val) &#123; splay(x);SGT::change(sum[x],-1);w[x]+=val;sum[x]+=val; ll now=sum[x];//debug int lst=x,nxt=fa[x]; while(nxt) &#123; splay(nxt); if(fa[nxt]==0 and sum[lc(nxt)]&lt;sum[rc(nxt)] and now&gt;sum[lc(nxt)])//rt &#123; SGT::change(sum[nxt],-1);SGT::change(sum[lc(nxt)],1); int oth=nxt;while(1)&#123;if(tag[oth])rev(oth);if(!rc(oth))break;oth=rc(oth);&#125;//debug splay(oth);tag[oth]^=1;splay(nxt);son[nxt][1]=lst;break; &#125; ll old=sum[rc(nxt)];if(now&lt;=old) break; SGT::change(sum[nxt],-1);SGT::change(old,1); now+=w[nxt]+sum[lc(nxt)];son[nxt][1]=lst; lst=nxt;nxt=fa[nxt]; &#125; splay(x);SGT::change(sum[x],1); &#125; &#125;; vc&lt;int&gt; to[N]; void pre(int x,int fa) &#123; LCT::fa[x]=fa; for(int t=0;t&lt;(int)to[x].size();t++) if(to[x][t]!=fa) pre(to[x][t],x); &#125; void main() &#123; int n=qread(); for(int i=1;i&lt;n;i++)&#123;int x=qread(),y=qread();to[x].PB(y);to[y].PB(x);&#125; SGT::change(0,n);pre(1,0);for(int i=1;i&lt;=n;i++) LCT::add(i,qread()),PP::insert(w[i]); int q=qread(); while(q--) &#123; int op=qread(); if(op==0)&#123;int x=qread();PP::del(w[x]);LCT::add(x,qread());PP::insert(w[x]);&#125; else &#123; int k=qread(); if(k==1) write2(PP::top()); else write2(SGT::ask(SGT::rt,0,1e15,k-1)); &#125; &#125; &#125;//x+MOD&#125;;int main()&#123; freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APIO（2016后）]]></title>
    <url>%2Fposts%2F5f55.html</url>
    <content type="text"><![CDATA[1/? APIO2016 划艇请先思考后再展开 注意到值域大n小，考虑区间离散化设dp(i,j,k)表示处理了前i个，最后一个选的人在第j个区间且目前该区间有k人选，没人选j=0然后剩下就没什么了，但要注意不要像我一样一开始写满的复杂度，被卡成27，思考怎么让他不满就能过了然后现在想想，应该插入a和b+1，这样可以把mx减小一半来着]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4231】回忆树]]></title>
    <url>%2Fposts%2Fa9a.html</url>
    <content type="text"><![CDATA[Sourcebzoj4231 Hint请先思考后再展开 首先肯定把树上路径拆分成两段，中间拉出来用kmp之类的算一算就好了 Solution请先思考后再展开 方法一：在线，log方建出trie然后建广义sam（这样复杂度是对的），线段树合并求出每个节点right集合，然后每个询问用树剖划分为log段区间询问方法二：离线，log方和上面差不多，把询问串建成ac自动机，然后把树放上去匹配注意很重要的一点，ac自动机建完后要预处理出每种字母失配后到达哪里（有些板子本来就有可以忽略），否则很好卡方法三：离线，log考虑把刚才向上的路径再次拆分成两段到根节点的路径设当前询问串长度为|S|，向上k，则为pp(x)-pp(fa(x,k-|S|))那么还是把整棵树放上去ac自动机上跑，然后因为询问是要求来自x到根路径所以充分利用dfs的特性，子树和（用树状数组维护）只存向上的点产生的影响即可（最后这点没有想到，卡了很久）]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>ac自动机</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFRPi]]></title>
    <url>%2Fposts%2F780d.html</url>
    <content type="text"><![CDATA[CFRPi（我才不会告诉你这是我做这套的理由）题号开头为CF567我的id是Zory，所以不贴代码了好题：F A Lineland MailB Berland National LibraryC Geometric ProgressionD One-Dimensional Battle Ships直接看代码 E President and Roads请先思考后再展开 首先正反跑一遍dij，这样就能知道每条边是否在最短路径上然后转双向边，判断割边来找必经边，这就是我的写法 然后其实也可以用最短路计数，选个合适的模数就好了（并没有想到这么简洁的写法……） F Mausoleum请先思考后再展开 这是一个还行但没想出来的dp（说来都尴尬因为是个单峰，按照从小到大放数字就好了 状态就是 $f(l,r)$ 表示现在l到r还没有填数字，然后可以计算出当前i，限制的话搞个链表存一下就好了 $O(n^2+nk)$ code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>最短路</tag>
        <tag>割边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFR576]]></title>
    <url>%2Fposts%2Fac11.html</url>
    <content type="text"><![CDATA[CFR576题号开头为CF1198我的id是Zory，所以不贴代码了好题：C、D A MP3B Welfare State直接看我的代码 C Matching vs Independent SetIn particular, if there are both a matching of size n, and an independent set of size n, then you should print exactly one of such matchings or exactly one of such independent sets.请先思考后再展开 因此，枚举所有的边，每次能选就选，最后剩下来的点集一定是独立集如果匹配成功了就输出；否则设当前失败的匹配大小为k&lt;n，则独立集大小为 3n-2k&gt;n，也满足条件（所以其实没有impos情况 D Rectangle Painting 1请先思考后再展开 我的做题思路：先分析一下，发现肯定只画正方形，而且可以把每个连通区域转化为一个矩形，然后只画一次，正方形可以在某个方向对矩形滑动假如矩形都是正方形，那么就不会滑动，那么对于某个二维区间，只看大的一维，如果投影到那一维上不是满的，那么就应沿着那条线裂开可以用类似整体二分的写法，这样子的复杂度极低，然而没法处理滑动 想来想去这个滑动可能还是要靠合适的dp解决，而不是单纯的策略，但就是想不到……结果正解是直接基于图而不是分析矩形啥之类的……就是f(l1,l2,r1,r2)然后O(n)枚举分界线转移，常数挺小的 E Rectangle Painting 2注意这次代价是min而不是max请先思考后再展开 既然是min，肯定一次选一行或一列，拆成二分图，离散化后最小点覆盖，用网络流实现即可边数为n方]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFR548]]></title>
    <url>%2Fposts%2F9890.html</url>
    <content type="text"><![CDATA[CFR548题号开头为CF1139 A Even SubstringsB ChocolatesC Edgy Trees直接看我的代码 D Steps to One请先思考后再展开 这东西我复杂度算错了，好jb菜啊 显然是建出nlogn条边的dag，在dag上计算期望，然后主要是边权怎么求$$g(x,y)=\sum [gcd(x/y,i/y)=1]=\sum_{d|\frac{x}{y}} \mu(d)\lfloor \frac{m}{dy} \rfloor$$然后其实直接枚举约数计算就好了，根本不需要优化，我就说为什么放在E那个煞笔题前面 时间复杂度为 $O(nlogn 约数个数)$ 复杂度不满 1234567891011121314151617181920212223242526272829303132vc&lt;int&gt; dd[MAX_N];map&lt;int,int&gt; g[MAX_N];int f[MAX_N];void main()&#123; pre(); int m=qread(); for(int d=1;d&lt;=m;d++) for(int num=d;num&lt;=m;num+=d) dd[num].PB(d); for(int y=1;y&lt;=m;y++) for(int x=y;x&lt;=m;x+=y) &#123; int now=0; for(int t=0;t&lt;(int)dd[x/y].size();t++) &#123; int d=dd[x/y][t]; add(now,mu[d]*(m/d/y)); &#125; g[x][y]=(ll)now*inv(m)%MOD; &#125; f[1]=0;int ans=1; for(int x=2;x&lt;=m;x++) &#123; f[x]=1; for(int t=0;t&lt;(int)dd[x].size();t++) &#123; int y=dd[x][t];if(y==x) continue; add(f[x],(ll)f[y]*g[x][y]%MOD); &#125; f[x]=f[x]*inv(1-g[x][x])%MOD; add(ans,(ll)f[x]*inv(m)%MOD); &#125; write((ans+MOD)%MOD);&#125; E Maximize Mex请先思考后再展开 直接网络流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e3+10; const ll MOD=998244353; void add(ll &amp;x,ll y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; ll qpower(ll x,ll e) &#123; ll ans=1;x%=MOD; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv2(ll x)&#123;return qpower(x,MOD-2);&#125; int hou[MAX_N*2]; struct Edge&#123;int y,c,g;&#125;e[MAX_N*10]; int ln;int oth(int x)&#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y) &#123; e[++ln]=(Edge)&#123;y,1,hou[x]&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,0,hou[y]&#125;;hou[y]=ln; &#125; int st,ed; int h[MAX_N*2],cur[MAX_N*2];queue&lt;int&gt; q; bool bfs() &#123; // memset(cur,0,sizeof cur); memcpy(cur,hou,sizeof hou); memset(h,0,sizeof h); h[st]=1;q.push(st); while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0) h[y]=h[x]+1,q.push(y); &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int ff) &#123; if(x==ed) return ff; int flow=0; for(int k=cur[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0) &#123; int out=dfs(y,min(e[k].c,ff-flow)); e[k].c-=out;e[oth(k)].c+=out;flow+=out; &#125; if(e[k].c==0) cur[x]=e[k].g; if(flow==ff) break; &#125; if(ff==0) h[x]=0; return flow; &#125; int now=0; void update() &#123; while(bfs()) now+=dfs(st,INF); &#125; pr a[MAX_N];int ban[MAX_N];bool vis[MAX_N]; int ans[MAX_N]; void main() &#123; int n=qread(),m=qread();st=5000+m+2;ed=5000+m+1; for(int i=1;i&lt;=n;i++) a[i].FR=qread(); for(int i=1;i&lt;=n;i++) a[i].SE=qread(); int dd=qread();for(int i=1;i&lt;=dd;i++) ban[i]=qread(),vis[ban[i]]=1; for(int i=1;i&lt;=m;i++) ins(5000+i,ed); for(int i=1;i&lt;=n;i++) if(!vis[i]) ins(a[i].FR,5000+a[i].SE); int wt=0;ins(st,wt); for(int i=dd;i&gt;=1;i--) &#123; update(); while(now==wt+1) wt++,ins(st,wt),update()/*,printf("i=%d wt=%d\n",i,wt)*/; ans[i]=wt; int x=ban[i];ins(a[x].FR,5000+a[x].SE); &#125; for(int i=1;i&lt;=dd;i++) write2(ans[i]); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; F Dish Shopping请先思考后再展开 看到允许log方就写的log方$p_i \leq inc_j \leq s_i,|pref_j-b_i| \leq inc_j-p_i$然后有个套路，看到这里是点取出所有覆盖自己的区间恰好一次，可以把区间放到线段树上，然后单点询问取出区间相当于是log个区间、log个点，离线后对每个线段树点直接两次cdq即可 然后log的做法也是有的，观察发现每道菜就是一个三角形，如果在pi处加入si处删除，按横坐标顺序处理三角形和询问把拆分为上直线和下直线，要求是在上直线之下或者在下直线之上，注意到至少满足一个，分别求然后就是A+B-nowline可以开两棵bit维护，复杂度为 O(nlogn) code为log方的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int N=2e6+10;pr all[N];int ans[N];pr tmp[N];bool cmp1(pr a,pr b)&#123;return all[a.FR].SE&lt;all[b.FR].SE or (all[a.FR].SE==all[b.FR].SE and a.SE&lt;b.SE);&#125;struct CDQ&#123; vc&lt;pr&gt; qq;//(id,op),op=1为询问 bool cmp(pr a,pr b,int op)&#123;return a.FR+a.SE*op&lt;=b.FR+b.SE*op;&#125; void cdq(int l,int r,int op) &#123; if(l&gt;=r) return; cdq(l,mid,op);cdq(mid+1,r,op); int now=l,j=l-1; for(int i=mid+1,add=0;i&lt;=r;i++) &#123; while(j+1&lt;=mid and cmp(all[qq[j+1].FR],all[qq[i].FR],op)) j++,tmp[now++]=qq[j],add+=(qq[j].SE==0); tmp[now++]=qq[i];if(qq[i].SE) ans[qq[i].FR]+=add; &#125; while(now&lt;=r) tmp[now++]=qq[++j]; for(int i=l;i&lt;=r;i++) qq[i]=tmp[i]; &#125; void solve() &#123; int n=qq.size(); sort(qq.begin(),qq.end(),cmp1);cdq(0,n-1,-1); sort(qq.begin(),qq.end(),cmp1);reverse(qq.begin(),qq.end());cdq(0,n-1,1); &#125;&#125;cdq[N];void modify(int x,int l,int r,int fl,int fr,int id)&#123; if(l==fl and r==fr) &#123;cdq[x].qq.PB(MP(id,0));return;&#125; if(fr&lt;=mid) modify(lc,l,mid,fl,fr,id); else if(fl&gt;mid) modify(rc,mid+1,r,fl,fr,id); else modify(lc,l,mid,fl,mid,id),modify(rc,mid+1,r,mid+1,fr,id);&#125;void ask(int x,int l,int r,int pos,int id)&#123; cdq[x].qq.PB(MP(id,1)); if(l==r) return; if(pos&lt;=mid) ask(lc,l,mid,pos,id); else ask(rc,mid+1,r,pos,id);&#125;int fl[N],fr[N],lsh[N];int getnum(int cnt,int num)&#123;return lower_bound(lsh+1,lsh+cnt+1,num)-lsh;&#125;void main()&#123; int n=qread(),m=qread(); for(int i=1;i&lt;=n;i++) fl[i]=qread(),lsh[i]=fl[i]; for(int i=1;i&lt;=n;i++) fr[i]=qread(),lsh[n+i]=fr[i]; for(int i=1;i&lt;=n;i++) all[m+i]=MP(fl[i],qread()); for(int i=1;i&lt;=m;i++) lsh[2*n+i]=all[i].FR=qread(); for(int i=1;i&lt;=m;i++) all[i].SE=qread(); sort(lsh+1,lsh+n+n+m+1); for(int i=1;i&lt;=n;i++) modify(1,1,n+n+m,getnum(n+n+m,fl[i]),getnum(n+n+m,fr[i]),m+i); for(int i=1;i&lt;=m;i++) ask(1,1,n+n+m,getnum(n+n+m,all[i].FR),i); for(int i=1;i&lt;N;i++) cdq[i].solve(); for(int i=1;i&lt;=m;i++) write1(ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cf985G】Team Players【bzoj5407】girls]]></title>
    <url>%2Fposts%2F7f6.html</url>
    <content type="text"><![CDATA[Sourcecf985Gbzoj5407 Hint请先思考后再展开 一开始想着按照某种特殊的顺序依次处理每条限制，然后答案减去新产生的非法三元组那么就是要求【目前x和y都能连的点和】，然后不会维护……或许有人会？正解是容斥，然后三元环计数类似【Jsoi2017】原力 Solution请先思考后再展开 $$\begin{aligned}&amp; 考虑容斥推系数，ans=f0-f1+f2-f3 \\&amp; f0=\sum_i i(A*C_{n-i}^2+B*(i-1)(n-i)+C*C_{i-1}^2) \\&amp; f1，枚举每条边考虑每种情况 \\&amp; f2的话维护每个点不能去的数量与编号和sm_{0/1}(x)、bg_{0/1}(x)，枚举每个点考虑每种情况 \\&amp; f3，设阈值T，然后度数&gt;T为A类，&lt;=T为B类；如果AAA直接枚举，(\frac{2m}{T})^3 \\&amp; 否则，枚举一个B，枚举其两条边，注意ABB要/2，BBB要/3，复杂度上界为 mT \\&amp; T=2\sqrt m时复杂度接近m^{3/2}\end{aligned}$$除f3外都是线性的 还有就是hash的部分，如果用普通的hash不知道是不是我的姿势有点问题只能在bzoj过然后去CF学习了一下，就是利用A很少的性质处理个bitset，然后为了判BBB，在BB的时候y扫一遍后再扫x即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=19930726; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int N=2e5+10; typedef unsigned long long ull; bitset&lt;N&gt; hash[1000];int id[N];vc&lt;ull&gt; AA;bool v[N]; ull GG(ull n)&#123;return (n&amp;1)?((n-1)/2*n):(n/2*(n-1));&#125; ull sm[2][N],bg[2][N];vc&lt;ull&gt; smm[N],bgg[N],go[N]; void writegg(ull num) &#123; if(num&gt;=10) writegg(num/10); putchar('0'+num%10); &#125; void main() &#123; ull n,m,A,B,C;scanf("%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;A,&amp;B,&amp;C);ull ans=0; for(ull i=0;i&lt;n;i++) ans+=i*(GG(n-1-i)*A+i*(n-1-i)*B+GG(i)*C); for(ull i=1;i&lt;=m;i++) &#123; ull x=qread(),y=qread();if(x&gt;y)swap(x,y); bg[0][x]++;bg[1][x]+=y;sm[0][y]++;sm[1][y]+=x; bgg[x].PB(y);smm[y].PB(x);go[x].PB(y);go[y].PB(x); ull ss=x; ans-=A*GG(ss)+ss*(B*x+C*y); ull mm=y-x-1;ans-=B*(GG(mm)+(x+1)*mm)+mm*(A*x+C*y); ull bb=n-y-1;ans-=C*(GG(bb)+(y+1)*bb)+bb*(A*x+B*y); &#125; for(ull i=0;i&lt;n;i++) &#123; sort(smm[i].begin(),smm[i].end());sort(bgg[i].begin(),bgg[i].end()); ull s=sm[0][i];ans+=GG(s)*C*i;for(ull a=0;a&lt;s;a++)ans+=smm[i][a]*(A*(s-1-a)+B*a); ull b=bg[0][i];ans+=GG(b)*A*i;for(ull a=0;a&lt;b;a++)ans+=bgg[i][a]*(B*(b-1-a)+C*a); ans+=s*b*B*i+sm[1][i]*A*b+bg[1][i]*C*s; &#125; ull T=2*sqrt(m); for(ull i=0;i&lt;n;i++) if(sm[0][i]+bg[0][i]&gt;T) &#123; AA.PB(i);id[i]=AA.size(); for(int t=0;t&lt;(int)go[i].size();t++) hash[id[i]][go[i][t]]=1; &#125; for(int i=0;i&lt;(int)AA.size();i++)for(int j=i+1;j&lt;(int)AA.size();j++) for(int k=j+1;k&lt;(int)AA.size();k++)ans-=A*AA[i]+B*AA[j]+C*AA[k]; for(ull x=0;x&lt;n;x++) if(!id[x]) &#123; sort(go[x].begin(),go[x].end()); for(int i=0;i&lt;(int)go[x].size();i++) &#123; ull y=go[x][i]; if(!id[y]) for(int j=0;j&lt;(int)go[y].size();j++) v[go[y][j]]=1; for(int j=i+1;j&lt;(int)go[x].size();j++) &#123; ull z=go[x][j]; if(!id[y] and id[z] and (!(x&lt;y) or !hash[id[z]][y]))continue; if(id[y] and !id[z] and (!(x&lt;z) or !hash[id[y]][z]))continue; if(!id[y] and !id[z] and (!(z&lt;x) or !v[z]))continue; if(id[y] and id[z] and !hash[id[y]][z])continue; if(x&lt;y) ans-=A*x+B*y+C*z; else if(x&lt;z) ans-=A*y+B*x+C*z; else ans-=A*y+B*z+C*x; &#125; if(!id[y]) for(int j=0;j&lt;(int)go[y].size();j++) v[go[y][j]]=0; &#125; &#125; writegg(ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【abc135】Strings of Eternity]]></title>
    <url>%2Fposts%2F6068.html</url>
    <content type="text"><![CDATA[Sourceabc135 Hint请先思考后再展开 同余最长路或者像我一样思考一些奇奇怪怪的做法 Solution请先思考后再展开 设函数kmp(n,m)=k表示长为n的A与长为m的B匹配，最长出现连续k次B先判断出，kmp(nn,m)&gt;0的nn，讨论n与m的大小关系计算123456789101112131415const int N=1e7+10;void pre(int m) xxxxint kmp(int n,int m) xxxxvoid main()&#123; scanf("%s%s",A+1,B+1);int n=strlen(A+1),m=strlen(B+1); for(int i=n+1;i&lt;N;i++) A[i]=A[(i-1)%n+1]; for(int i=m+1;i&lt;N;i++) B[i]=B[(i-1)%m+1];pre(N-1); int k=max(ceil(1.0*m/n),2.0),nn=n*k,gg=kmp(nn,m); if(gg==0) &#123;puts("0");return;&#125; int qq=kmp(nn*3,m),pp=kmp(nn*4,m); if(pp!=qq) puts("-1"); else write(pp);&#125; 事实证明，这个做法不是特别显然比较人类思维然而没想到的做法是，找到每个能匹配的位置，连向(p+t)%n然后如果是dag就是最长路]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>kmp</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物流运输]]></title>
    <url>%2Fposts%2Feb00.html</url>
    <content type="text"><![CDATA[Sourcejisuanke Hint请先思考后再展开 方向一：无脑cdq是log方的，考虑怎么降低方向二：路径两端-A，lca+2A，求子树和 Solution请先思考后再展开 首先求路径的次大值肯定是倍增的了，nlogn，这没什么好说的第二部分想了很久，除了cdq啥也没想到，只好开写，写的过程中感觉很接近log，但就是有个二分不知道怎么优化先给出双log的代码，都是cdq的基本操作了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=19930726; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int N=1e5+10,M=5e5+10; ll sum[N]; struct Data &#123; int fl,fr; int ll,rr; int op,id;//0边，id表示边的编号 &#125;; bool cmp(Data x,Data y)&#123;return x.fl&lt;y.fl;&#125; bool cmp1(Data x,Data y) &#123; if(x.ll!=y.ll) return x.ll&lt;y.ll; return x.op&lt;y.op; &#125; bool cmp2(Data x,Data y) &#123; if(x.rr!=y.rr) return x.rr&gt;y.rr; return x.op&lt;y.op; &#125; ll ss[M*4]; struct CDQ &#123; vc&lt;Data&gt; qq; void cdq(int l,int r) &#123; if(l&gt;=r) return; int mid=(l+r)&gt;&gt;1; cdq(l,mid);sort(qq.begin()+l,qq.begin()+mid+1,cmp); cdq(mid+1,r);sort(qq.begin()+mid+1,qq.begin()+r+1,cmp); ss[l-1]=0;for(int i=l;i&lt;=mid;i++) ss[i]=ss[i-1]+qq[i].op; for(int i=mid+1;i&lt;=r;i++) if(qq[i].id&gt;0) &#123; int x=lower_bound(qq.begin()+l,qq.begin()+mid+1,qq[i],cmp)-qq.begin(); int y=upper_bound(qq.begin()+l,qq.begin()+mid+1,(Data)&#123;qq[i].fr,0,0,0,0,0&#125;,cmp)-qq.begin()-1; if(x&lt;=y) sum[qq[i].id]+=ss[y]-ss[x-1]; &#125; &#125; void solve() &#123; int n=qq.size(); sort(qq.begin(),qq.end(),cmp1);cdq(0,n-1); sort(qq.begin(),qq.end(),cmp2);cdq(0,n-1); &#125; &#125;cdq[M*2]; int bin[30];int f[N][30];pr up[N][30]; pr merg(pr a,pr b) &#123; if(a.FR!=b.FR) &#123; if(a.FR&gt;b.FR) return MP(a.FR,max(a.SE,b.FR)); return MP(b.FR,max(b.SE,a.FR)); &#125; else return MP(a.FR,max(a.SE,b.SE)); &#125; vc&lt;pr&gt; son[N];int dep[N],dfn[N],id=0,siz[N]; void pre(int x,int fa) &#123; dep[x]=dep[fa]+1;dfn[x]=++id;siz[x]=1; f[x][0]=fa;for(int i=1;i&lt;=20;i++) &#123;f[x][i]=f[f[x][i-1]][i-1],up[x][i]=merg(up[x][i-1],up[f[x][i-1]][i-1]);/*if(f[x][i])printf("f(%d,%d)=%d\n",x,i,f[x][i]);*/&#125; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t].FR,c=son[x][t].SE;if(y==fa)continue; up[y][0]=MP(c,0);pre(y,x);siz[x]+=siz[y]; cdq[c].qq.PB((Data)&#123;dfn[y],dfn[y]+siz[y]-1,dfn[y],dfn[y]+siz[y]-1,0,y&#125;); &#125; &#125; pr ask(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); pr now=MP(0,0);for(int i=20;i&gt;=0;i--) if(bin[i]&lt;=dep[x]-dep[y]) now=merg(now,up[x][i]),x=f[x][i]; if(x==y) return now; for(int i=20;i&gt;=0;i--) if(f[x][i]!=f[y][i]) now=merg(now,merg(up[x][i],up[y][i])),x=f[x][i],y=f[y][i]; return merg(now,merg(up[x][0],up[y][0])); &#125; void main() &#123; int n=qread(),m=qread(); for(int i=1;i&lt;n;i++) &#123;int x=qread(),y=qread(),c=qread();son[x].PB(MP(y,c));son[y].PB(MP(x,c));&#125; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; pre(1,0); ll ans=0; for(int i=1;i&lt;=m;i++) &#123; int x=qread(),y=qread();pr now=ask(x,y);ans+=now.FR; cdq[now.FR].qq.PB((Data)&#123;dfn[x],dfn[x],dfn[y],dfn[y],now.FR-now.SE,0&#125;); cdq[now.FR].qq.PB((Data)&#123;dfn[y],dfn[y],dfn[x],dfn[x],now.FR-now.SE,0&#125;); &#125; for(int i=0;i&lt;M*2;i++) cdq[i].solve(); ll mx=0;for(int i=1;i&lt;=n;i++) mx=max(mx,sum[i]); write(ans-mx); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125; 这个二分说大也不大，说小也不小，感觉很能优化但又不太会……后来仔细一想，发现前缀和那句是可以拆开来的就是说跑两次cdq分别计算，这样就是单log的了，然后顺便修了点bug（越界问题）复杂度虽然是对的，但常数略大，开o2是1s，不开就要5s，主要是stl用的有点多……（重度依赖症123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=19930726; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int N=1e5+10,M=5e5+10; ll sum[N]; struct Data &#123; int fl,fr; int ll,rr; int op,id;//0边，id表示边的编号 &#125;; bool cmp1(Data x,Data y) &#123; if(x.ll!=y.ll) return x.ll&lt;y.ll; return x.op&lt;y.op; &#125; bool cmp2(Data x,Data y) &#123; if(x.rr!=y.rr) return x.rr&gt;y.rr; return x.op&lt;y.op; &#125; ll ss[M*4]; Data tmp[M*4]; struct CDQ &#123; vc&lt;Data&gt; qq; bool cmp(Data a,Data b,int op) &#123;return ((op&lt;0 and !a.op)?a.fr:a.fl)&lt;((op&lt;0 and !b.op)?b.fr:b.fl);&#125; void cdq(int op,int l,int r) &#123; if(l&gt;=r) return; int mid=(l+r)&gt;&gt;1;cdq(op,l,mid);cdq(op,mid+1,r); ss[l-1]=0;for(int i=l;i&lt;=mid;i++) ss[i]=ss[i-1]+qq[i].op; if(op&gt;0)//左端点 &#123; int now=l; for(int i=mid+1;i&lt;=r;i++) if(qq[i].id&gt;0) &#123; while(now&lt;=mid and qq[now].fl&lt;qq[i].fl) now++; sum[qq[i].id]-=ss[now-1]; &#125; &#125; else &#123; int now=l-1; for(int i=mid+1;i&lt;=r;i++) if(qq[i].id&gt;0) &#123; while(now+1&lt;=mid and qq[now+1].fl&lt;=qq[i].fr) now++; sum[qq[i].id]+=ss[now]; &#125; &#125; int now=l,xx=l,yy=mid+1; while(xx&lt;=mid and yy&lt;=r) tmp[now++]=(cmp(qq[xx],qq[yy],op)?qq[xx++]:qq[yy++]); while(xx&lt;=mid) tmp[now++]=qq[xx++];while(yy&lt;=r) tmp[now++]=qq[yy++]; for(int i=l;i&lt;=r;i++) qq[i]=tmp[i]; &#125; void solve() &#123; int n=qq.size();if(n==1) return; sort(qq.begin()+1,qq.end(),cmp1);cdq(1,1,n-1); sort(qq.begin()+1,qq.end(),cmp1);cdq(-1,1,n-1); sort(qq.begin()+1,qq.end(),cmp2);cdq(1,1,n-1); sort(qq.begin()+1,qq.end(),cmp2);cdq(-1,1,n-1); &#125; &#125;cdq[M*2]; int bin[30];int f[N][30];pr up[N][30]; pr merg(pr a,pr b) &#123; if(a.FR!=b.FR) &#123; if(a.FR&gt;b.FR) return MP(a.FR,max(a.SE,b.FR)); return MP(b.FR,max(b.SE,a.FR)); &#125; else return MP(a.FR,max(a.SE,b.SE)); &#125; vc&lt;pr&gt; son[N];int dep[N],dfn[N],id=0,siz[N]; void pre(int x,int fa) &#123; dep[x]=dep[fa]+1;dfn[x]=++id;siz[x]=1; f[x][0]=fa;for(int i=1;i&lt;=20;i++) f[x][i]=f[f[x][i-1]][i-1],up[x][i]=merg(up[x][i-1],up[f[x][i-1]][i-1]); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t].FR,c=son[x][t].SE;if(y==fa)continue; up[y][0]=MP(c,0);pre(y,x);siz[x]+=siz[y]; cdq[c].qq.PB((Data)&#123;dfn[y],dfn[y]+siz[y]-1,dfn[y],dfn[y]+siz[y]-1,0,y&#125;); &#125; &#125; pr ask(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); pr now=MP(0,0);for(int i=20;i&gt;=0;i--) if(bin[i]&lt;=dep[x]-dep[y]) now=merg(now,up[x][i]),x=f[x][i]; if(x==y) return now; for(int i=20;i&gt;=0;i--) if(f[x][i]!=f[y][i]) now=merg(now,merg(up[x][i],up[y][i])),x=f[x][i],y=f[y][i]; return merg(now,merg(up[x][0],up[y][0])); &#125; void main() &#123; for(int i=0;i&lt;M*2;i++) cdq[i].qq.PB((Data)&#123;0,0,0,0,0,0&#125;);//debug int n=qread(),m=qread(); for(int i=1;i&lt;n;i++) &#123;int x=qread(),y=qread(),c=qread();son[x].PB(MP(y,c));son[y].PB(MP(x,c));&#125; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; pre(1,0); ll ans=0; for(int i=1;i&lt;=m;i++) &#123; int x=qread(),y=qread();pr now=ask(x,y);ans+=now.FR; cdq[now.FR].qq.PB((Data)&#123;dfn[x],dfn[x],dfn[y],dfn[y],now.FR-now.SE,0&#125;); cdq[now.FR].qq.PB((Data)&#123;dfn[y],dfn[y],dfn[x],dfn[x],now.FR-now.SE,0&#125;); &#125; for(int i=0;i&lt;M*2;i++) cdq[i].solve(); ll mx=0;for(int i=1;i&lt;=n;i++) mx=max(mx,sum[i]); write(ans-mx); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125; 方向一的写法可能大家会嫌麻烦……不过确实没想到更好的 方向二就好写很多了一种思路是半夜睡不着想到的，首先点代表到父亲的那条边，用点建c棵虚树，然后每条路径上去打标记最后推一推那么我们就是要找到一个点在虚树上最近的点，然后我猜了个结论，就是把虚树上的点按照欧拉序排序，然后把这个点的欧拉序用来询问左右两侧第一个点，答案就是其中一个（假如这个结论是假的麻烦在下面评论……但感觉挺对的那么复杂度就是 O(mlogn) 然后其实用下标区间为1到c的动态开点权值线段树合并也是可以的据说空间略大，不过应该也挺好写的，都是比较常规的操作 最后就是题解的最简洁做法了，按颜色离线，然后就可以用树状数组代替线段树了，空间为n，时间依然是mlogn没看懂可以看代码，非常好懂以下给出的是std的（不是我）的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;ctime&gt;#define LL long long#define mp(x,y) make_pair(x,y)#define pii pair&lt;int,int&gt;using namespace std;inline char nc() &#123; static char buf[1000000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;&#125;inline int read(void) &#123; char ch=nc(); int sum=0; while(!(ch&gt;='0'&amp;&amp;ch&lt;='9')) ch=nc(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+(ch^48),ch=nc(); return sum;&#125;int wsta[20],wtp;inline void write(LL x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x==0)&#123;putchar('0');return ;&#125; wtp=0; while(x)wsta[++wtp]=x%10,x/=10; while(wtp)putchar(wsta[wtp--]+'0');&#125;inline void pr1(int x)&#123;write(x);putchar(' ');&#125;inline void pr2(LL x)&#123;write(x);putchar('\n');&#125;const int MAXN=100005;const int MAXM=500005;const int MAXC=1000005;struct edge&#123;int x,y,c,next;&#125;a[2*MAXN];int len,last[MAXN];void ins(int x,int y,int c)&#123;len++;a[len].x=x;a[len].y=y;a[len].c=c;a[len].next=last[x];last[x]=len;&#125;struct node&#123; int first,second; node()&#123;&#125; node(int _first,int _second)&#123;first=_first;second=_second;&#125;&#125;;int in[MAXN],ot[MAXN],id,dep[MAXN];int fa[18][MAXN],cal[2][18][MAXN],bin[25];int mx[3],g[5];inline node merge(int u1,int u2,int u3,int u4)&#123; g[1]=u1;g[2]=u2;g[3]=u3;g[4]=u4; sort(g+1,g+1+4); int nw=3; while(g[nw]==g[nw+1])nw--; return node(g[4],g[nw]);&#125;void dfs(int x)&#123; in[x]=++id; for(int i=1;bin[i]&lt;=dep[x];i++) &#123; fa[i][x]=fa[i-1][fa[i-1][x]]; node u=merge(cal[0][i-1][x],cal[1][i-1][x],cal[0][i-1][fa[i-1][x]],cal[1][i-1][fa[i-1][x]]); cal[0][i][x]=u.first;cal[1][i][x]=u.second; &#125; for(int k=last[x];k;k=a[k].next) &#123; int y=a[k].y; if(y!=fa[0][x]) &#123; fa[0][y]=x; dep[y]=dep[x]+1; cal[0][0][y]=a[k].c; dfs(y); &#125; &#125; ot[x]=id;&#125;int Lg[MAXN];inline int lca(int x,int y)&#123; mx[1]=mx[2]=0; if(dep[x]&lt;dep[y])swap(x,y); for(int i=Lg[dep[x]];i&gt;=0;i--)if(bin[i]&lt;=dep[x]&amp;&amp;dep[fa[i][x]]&gt;=dep[y]) &#123; node u=merge(mx[1],mx[2],cal[0][i][x],cal[1][i][x]); mx[1]=u.first;mx[2]=u.second; x=fa[i][x]; &#125; if(x==y)return x; for(int i=Lg[dep[x]];i&gt;=0;i--)if(bin[i]&lt;=dep[x]&amp;&amp;fa[i][x]!=fa[i][y]) &#123; node u=merge(cal[0][i][x],cal[1][i][x],cal[0][i][y],cal[1][i][y]); node v=merge(mx[1],mx[2],u.first,u.second); mx[1]=v.first;mx[2]=v.second; x=fa[i][x],y=fa[i][y]; &#125; node u=merge(cal[0][0][x],cal[0][0][y],mx[1],mx[2]); mx[1]=u.first;mx[2]=u.second; return fa[0][x];&#125;int n,m,L;struct EDGE&#123;int x,y,c;&#125;E[MAXN];bool cmp(EDGE n1,EDGE n2)&#123;return n1.c&lt;n2.c;&#125;LL S[MAXN];int lowbit(int x)&#123;return x&amp;-x;&#125;void modify(int x,int c)&#123;for(;x&lt;=n;x+=lowbit(x))S[x]+=c;&#125;LL qry(int x)&#123;LL ret=0;for(;x&gt;=1;x-=lowbit(x))ret+=S[x];return ret;&#125;vector&lt;pii&gt; vec[MAXC];int main()&#123; freopen("gcakioi10.in","r",stdin); freopen("gcakioi10.out","w",stdout); for(int i=2;i&lt;MAXN;i++)Lg[i]=Lg[i&gt;&gt;1]+1; bin[0]=1;for(int i=1;i&lt;=20;i++)bin[i]=bin[i-1]&lt;&lt;1; n=read();m=read(); for(int i=1;i&lt;n;i++) &#123; int x=read(),y=read(),c=read(); E[i].x=x;E[i].y=y;E[i].c=c; ins(x,y,c);ins(y,x,c); &#125; dfs(1); LL sum=0; for(int i=1;i&lt;=m;i++) &#123; int S=read(),T=read(); int LA=lca(S,T); sum+=mx[1];int lst=mx[1]-mx[2]; vec[mx[1]].push_back(mp(in[S],lst)); vec[mx[1]].push_back(mp(in[T],lst)); vec[mx[1]].push_back(mp(in[LA],-2*lst)); &#125; LL ans=(1LL&lt;&lt;63-1); sort(E+1,E+n,cmp); for(int ls=0,i=1;i&lt;n;i++) &#123; if(E[i].c!=ls) &#123; for(int j=0;j&lt;vec[ls].size();j++)modify(vec[ls][j].first,-vec[ls][j].second); ls=E[i].c; for(int j=0;j&lt;vec[ls].size();j++)modify(vec[ls][j].first,vec[ls][j].second); &#125; int x=E[i].x,y=E[i].y; if(dep[x]&lt;dep[y])swap(x,y); LL del=qry(ot[x])-qry(in[x]-1); ans=min(ans,sum-del); &#125; pr2(ans); return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【abc134F】Permutation Oddness]]></title>
    <url>%2Fposts%2F3455.html</url>
    <content type="text"><![CDATA[Sourceabc134F Hint请先思考后再展开 $\sum |w(i)-i|=2\sum_{w(i)&gt;i} w(i)-i$考虑怎么把费用拆分计算首先思路是先考虑怎么设计一个dp能支持把阶乘拆分，最后通过这个dp成功算出阶乘，然后再加入第三维去计算注意到位置和上面的数地位平等，所以应当看做是两个递增的序列然后连线，上面位置下面数 Solution这题让lxj教了我很久才会……很久没有这种体验了请先思考后再展开 为了方便方案数的计算，不妨规定将系数放在右边计算，特判竖线(就是上i连下i，因为两个都是最右的嘛)（因为没有题解我们是看代码的，然后没有上面这句话理解起来非常操蛋，以为把阶乘拆成了平方，其实只是恰好要算两条）然后状态设计也很奇妙，主要是f(i,j)，表示从左到右处理了2i个点，然后两端都在i内的有j对转移就是考虑当前的两个新点（上i和下i），然后讨论连接他们的节点是朝哪个方向的来转移（此时考虑的都是斜线而不是竖线）定义【左+右】表示上面连向下面i左边，下面连向上面i右边（与【右+左】简称【1左1右】）123456for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=i;j++) if(f[i][j])&#123; f[i+1][j+1]+=f[i][j]*( (i-j)*2+1 );//【1左1右】、【竖线】转移系数都相同 f[i+1][j+2]+=f[i][j]*(i-j)*(i-j);//【左+左】 f[i+1][j]+=f[i][j];//【右+右】&#125; 填充一下：12345678910111213ll f[N][N][N*N*2];#define F(a,b,c) f[a][b][c+N*N]void main()&#123; int n=qread(),K=qread();F(0,0,0)=1; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=i;j++) for(int k=-2500;k&lt;=2500;k++) if(F(i,j,k)) &#123; add(F(i+1,j+1,k),F(i,j,k)*( (i-j)*2+1 )%MOD);//【1左1右】、【竖线】 add(F(i+1,j+2,k+i),F(i,j,k)*(i-j)%MOD*(i-j)%MOD);//左+左 add(F(i+1,j,k-i),F(i,j,k));//右+右 &#125; if(K&amp;1) puts("0"); else write( F(n,n,K/2) );&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSerxhs和Serval的退役纪念赛]]></title>
    <url>%2Fposts%2Fde05.html</url>
    <content type="text"><![CDATA[SSerxhs和Serval的退役纪念赛 幼儿园篮球题有n个球，其中m个是红色的，其余的是蓝色的从中随机选出k个，若选出了x个红球则得分为 $x^L$ ，求期望得分模998244353。共T组数据，每组数据的L是相同的T≤200,L≤2×10^5,m,k≤n≤2×10^7请先思考后再展开 纯粹推式子题$$\begin{aligned}ans &amp;=\sum_{i=0}^{mx} C_{n-m}^{k-i}C_m^i i^L，次幂转斯特林 \\&amp;=\sum_{j=1}^k S2(L,j)j! ( \sum_{i=j}^k C_m^i C_i^j C_{n-m}^{k-i} ) \\&amp;=\sum_{j=1}^k S2(L,j)j! ( \sum_{i=j}^k C_m^j C_{m-j}^{i-j} C_{n-m}^{k-i} ) \\&amp;=\sum_{j=1}^k S2(L,j)j! C_m^j ( \sum_{pp=i-j=0}^{k-j} C_{m-j}^{pp} C_{n-m}^{(k-j)-pp} )，范德蒙德卷积 \\&amp;=\sum_{j=1}^k S2(L,j)j! C_m^j C_{n-j}^{k-j} \\\end{aligned}$$ 注意到循环的上界其实是 min(L,k,m)，求整行斯特林数即可时间复杂度为 $O(LlogL+Ls)$ 幼儿园唱歌题题意：给出一个2e5的串，2e5次询问是串S[l1,r1]的前缀且是串S[l2,r2]的后缀的最长回文串长度请先思考后再展开 对正串反串建广义pam，然后找到lca的len即可 幼儿园跳舞题给出一个n个点的dag，q次询问不经过点k下x到y距离范围允许n^3、nq做法请先思考后再展开 前置知识：floyd的原理这题的关键是想清楚dag到底有什么用观察数据范围应该是个3方的算法，可能是floyd，也可能是其他加点外循环再加点特技；同时还应当注意nq是可行的，可能是预处理先考虑第一种，如果是个普通的图，你可能曾经像我一样想过处理f和g分别表示使用了前缀、后缀的点但随后考虑到路径上不一定是单调的，所以就被否决了但dag可以帮助我们搞出一个单调的东西————拓扑序于是就是 $O(n^3+nq)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4671】异或图]]></title>
    <url>%2Fposts%2F2956.html</url>
    <content type="text"><![CDATA[Sourcebzoj4671 Hint请先思考后再展开 f(n)表示恰好n个连通块，g(n)表示至少n个连通块且g中统计系数为第二类斯特林数 Solution请先思考后再展开 由斯特林反演可得$g_k=\sum_{i=k}^n S2(i,k)f_i \leftrightarrow f_k=\sum_{i=k}^n S1(i,k)(-1)^{i-k}g_i$$ans=\sum_{i=1}^n (-1)^{i-1}(i-1)!g_i$因为是至少，会好算很多：枚举每一种分组情况（约120000个），那么相当于限制了一个mask是=0的于是在mask意义下做线性基，贡献为 $2^{图数量-线性无关个数}$ 时间复杂度 $120000*m*ln，3亿但跑不满$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=1e9+7; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int N=11,M=50; int n,m,to[N][N]; typedef ll bs;bs bin[65],pp[65],fine;//bin曾经开小了 namespace lin &#123; bs now[M];int qq;void clear()&#123;memset(now,0,sizeof now);qq=0;&#125; void insert(bs num) &#123; for(int i=0;i&lt;M;i++) if(fine&amp;bin[i] and num&amp;bin[i]) &#123; if(now[i]!=0) num^=now[i]; else &#123;qq++;now[i]=num;break;&#125; &#125; &#125; &#125;; ll ans=0,fac[65];int blg[N]; void dfs(int now,int cnt) &#123; if(now==n+1) &#123; fine=0;for(int x=1;x&lt;=n;x++) for(int y=x+1;y&lt;=n;y++) if(blg[x]!=blg[y]) fine|=bin[to[x][y]]; lin::clear();for(int i=1;i&lt;=m;i++) lin::insert(pp[i]); ans+=((cnt&amp;1)?1:-1)*fac[cnt-1]*bin[m-lin::qq]; return; &#125; for(int i=1;i&lt;=cnt+1;i++) blg[now]=i,dfs(now+1,cnt+(i==cnt+1)); &#125; char str[M]; void main() &#123; bin[0]=1;for(int i=1;i&lt;65;i++) bin[i]=bin[i-1]&lt;&lt;1; fac[0]=1;for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i; m=qread(); for(int t=1;t&lt;=m;t++) &#123; scanf("%s",str);int ss=strlen(str);n=1+sqrt(2*ss); if(t==1) &#123;int tmp=0;for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) to[i][j]=tmp,tmp++;&#125; for(int i=0;i&lt;ss;i++) pp[t]|=bin[i]*(str[i]-'0'); &#125; dfs(1,0);write(ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>斯特林反演</tag>
        <tag>难度2</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF919E】Congruence Equation]]></title>
    <url>%2Fposts%2F16c0.html</url>
    <content type="text"><![CDATA[SourceCF919E Hint请先思考后再展开 $(n\%p)a^{n\%(p-1)}=b$考虑枚举指数求系数，然后判断n的合法性 Solution请先思考后再展开 $n=A(p-1)+i=Bp+j$exgcd解 $A(p-1)-Bp=j-i$并不需要真的exgcd时间复杂度 $O(nlogn)$12345678910111213void main()&#123; ll a=qread(),b=qread();MOD=qread();ll mx=qread(); ll cnt=0; for(ll i=0,now=1;i&lt;MOD-1;i++,now=now*a%MOD) &#123; ll j=b*invm(now)%MOD; ll B=-(j-i),n=B*MOD+j,t=MOD-1,gg=MOD*t;n=(n%gg+gg)%gg; if(n==0) n=gg; if(n&gt;=1 and n&lt;=mx) cnt+=1+(mx-n)/gg; &#125; write(cnt);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2019]]></title>
    <url>%2Fposts%2Fc0a6.html</url>
    <content type="text"><![CDATA[NOI2019还没填完d2题解 D1T1 回家路线请先思考后再展开 本题不知什么原因没有和mq区分开好像分差只有5，让我想起狗血的【优秀的拆分】（数据是人出的，人是懒的……） 在我看来权值的计算方式几乎是赤果果的暗示斜率优化把每个点按时间拆分，然后每个时间拆入和出那么点内部的等待就是斜率优化模板（有助于帮助老年文化课选手恢复水平……）点间的移动就是朴素的dag上dp，用map处理有用的点即可c++11下算法复杂度下限为线性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,ll&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=1e9+7; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=1e6+10; map&lt;int,int&gt; pt[MAX_N][2];//pt[x][op]=id int cnt=0,pos[MAX_N]; int newid(int x,int t,int op) &#123; if(pt[x][op][t]&gt;0) return pt[x][op][t]; pos[++cnt]=x;return pt[x][op][t]=cnt; &#125; vc&lt;int&gt; fm[MAX_N];//fm[id]=id vc&lt;int&gt; in[MAX_N],out[MAX_N];//in[time]=id ll dis[MAX_N];//dis[id] double slope(pr a,pr b) &#123; return (b.SE-a.SE)*1.0/(b.FR-a.FR); &#125; struct qq &#123; vc&lt;pr&gt; q;int tou,wei; qq()&#123;tou=0;wei=-1;&#125; void insert(pr now) &#123; while(tou&lt;wei and slope(q[wei-1],q[wei])&gt;=slope(q[wei],now)) wei--; wei++;if((int)q.size()-1&lt;wei) q.PB(now); else q[wei]=now; &#125; void popf(ll k) &#123; while(tou&lt;wei and slope(q[tou],q[tou+1])&lt;=k) tou++; &#125; ll getb(ll k) &#123; if(tou&gt;wei) return (ll)INF*INF; return q[tou].SE-k*q[tou].FR; &#125; &#125;pp[MAX_N];//凸壳pp[x]=(x,y) void main() &#123; int n=qread(),m=qread();ll A=qread(),B=qread(),C=qread(); for(int i=1;i&lt;=m;i++) &#123; int x=qread(),y=qread(),p=qread(),q=qread(); int a=newid(x,p,1),b=newid(y,q,0);fm[b].PB(a); out[p].PB(a);in[q].PB(b); &#125; memset(dis,0x3f,sizeof dis);ll ans=dis[0]; dis[ newid(1,0,1) ]=0;pp[1].insert(MP(0,0ll)); for(int ti=1;ti&lt;=1000;ti++) &#123; sort(in[ti].begin(),in[ti].end()); in[ti].resize(unique(in[ti].begin(),in[ti].end())-in[ti].begin()); for(int t=0;t&lt;(int)in[ti].size();t++) &#123; int x=in[ti][t],ps=pos[x];//id for(int t2=0;t2&lt;(int)fm[x].size();t2++) dis[x]=min(dis[x],dis[fm[x][t2]]+C); // printf("in ti=%d ps=%d dis=%lld\n",ti,ps,dis[x]); pp[ps].insert(MP(ti,(ll)ti*ti*A+dis[x])); if(ps==n) ans=min(ans,dis[x]+ti); &#125; sort(out[ti].begin(),out[ti].end()); out[ti].resize(unique(out[ti].begin(),out[ti].end())-out[ti].begin()); for(int t=0;t&lt;(int)out[ti].size();t++) &#123; int x=out[ti][t],ps=pos[x];//id pp[ps].popf(A*2*ti+B); dis[x]=pp[ps].getb(A*2*ti+B)+A*ti*ti+B*ti; // printf("out ti=%d ps=%d dis=%lld\n",ti,ps,dis[x]); &#125; &#125; write(ans); &#125;&#125;;int main()&#123; freopen("route.in","r",stdin); freopen("route.out","w",stdout); srand(time(0)); mine::main();&#125; D1T2 机器人请先思考后再展开 第二题还是比较中规中矩的NOI题，暴力DP有50分然后考虑离散化，同一段里面用CF995F的处理方式，插值或者维护下降幂多项式不过插值会被卡常数到85~95分，下降幂多项式能过代码有些复杂，可以区分出一些基本功扎实的选手 50分dp：考虑最右边的最大值，发现可选位置很少，以此为基础dp(l,r,mx)然后枚举mx的位置来转移复杂度为大常数MB，M为实际访问到的区间（记忆化），据说本题M最大200010分无限制：枚举实际用了多少个数即可 12 D1T3 序列请先思考后再展开 暴力DP有32分，然后我一开始想了一个错结论，以为上面取最大的K个（记为X），下面取最大的K个（记为Y），X∩Y定全选，然后2个小时调不出来。。。实际上是X∩Y要么上下都选要么上下都不选，X-Y选了下面就要选上面，Y-X选了上面就要选下面。。。这样就可以分成三块搞了。由于我不擅长贪心，用网络流的思想做的。一共做了3个小时。我猜现役选手应该会比我熟练地多吧。 12 D2T1 弹跳请先思考后再展开 这道题其实有点像树上的最短路不同之处在于省去了取出路径的部分，然后把树上路径改为了矩形但本质上是一样的，至少在工具上，从树上压缩的并查集改为 数状数组套权值线段树或者kdtree维护0/1空间上都是足够的，时间的话二维线段树调用次数是弹跳装置个数，复杂度为 $O(mlog^2H)$ 可能是没怎么写过，但迫于空间压力写了数状数组套权值线段树然后写了很久，树状数组这玩意套东西拓展起来很麻烦现在想想感觉写四叉树随便写，空间其实也不大……果然数据结构基础知识不扎实是硬伤upd：好像sgt套set也不错123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=1e9+7; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=7e4+10,MAX_M=2e5+10; int n,m,w,h; map&lt;pr,int&gt; getid;pr pt[MAX_N];bool out[MAX_N]; namespace Gao//log^2 &#123; struct Nod&#123;int lc,rc,zz;&#125;p[20000000]; int id=0;int rt[MAX_N];//每棵线段树根 #define mid ((l)+(r))/2 void s_change(int &amp;x,int l,int r,int pos,int op) &#123; if(!x) x=++id,p[x]=(Nod)&#123;0,0,0&#125;; p[x].zz+=op; if(l==r) return; if(pos&lt;=mid) s_change(p[x].lc,l,mid,pos,op); else s_change(p[x].rc,mid+1,r,pos,op); &#125; int lowbit(int x)&#123;return x&amp;-x;&#125; void modify(int x,int y,int val)&#123;while(x&lt;=w) s_change(rt[x],1,h,y,val),x+=lowbit(x);&#125; int s_ask(int x,int l,int r,int pos) &#123; if(!x) return 0; if(l==r) return p[x].zz; if(pos&lt;=mid) return s_ask(p[x].lc,l,mid,pos); else return s_ask(p[x].rc,mid+1,r,pos); &#125; int askx(int x1,int y) &#123; int wt=0;x1--;while(x1&gt;=1) wt+=s_ask(rt[x1],1,h,y),x1-=lowbit(x1); int now=0,left=0;//最后一个zz[now]&lt;=wt的now+1 for(int i=17;i&gt;=0;i--) &#123; now+=(1&lt;&lt;i);if(now&gt;w) &#123;now-=(1&lt;&lt;i);continue;&#125; int tmp=s_ask(rt[now],1,h,y); if(left+tmp&gt;wt) now-=(1&lt;&lt;i); else left+=tmp; &#125; return now+1; &#125; int u[2][MAX_N],u2[20][2][MAX_N]; void clear(int x,int op)&#123;while(x&gt;=1) u[op][x]=rt[x],x-=lowbit(x);&#125; void turnl(int x,int op)&#123;while(x&gt;=1) u[op][x]=p[u[op][x]].lc,x-=lowbit(x);&#125; void turnr(int x,int op)&#123;while(x&gt;=1) u[op][x]=p[u[op][x]].rc,x-=lowbit(x);&#125; void backup(int x,int op,int dep)&#123;while(x&gt;=1) u2[dep][op][x]=u[op][x],x-=lowbit(x);&#125; void goback(int x,int op,int dep)&#123;while(x&gt;=1) u[op][x]=u2[dep][op][x],x-=lowbit(x);&#125; int getl(int x,int op)&#123;int sum=0;while(x&gt;=1) sum+=p[ p[u[op][x]].lc ].zz,x-=lowbit(x);return sum;&#125; int getsum(int x,int op)&#123;int sum=0;while(x&gt;=1) sum+=p[ u[op][x] ].zz,x-=lowbit(x);return sum;&#125; int asky(int dep,int x1,int x2,int l,int r,int fl,int fr) &#123; if(l==fl and r==fr) &#123; if(getsum(x2,1)==getsum(x1-1,0)) return 0; if(l==r) return l; if(getl(x2,1)-getl(x1-1,0)) &#123;turnl(x1-1,0);turnl(x2,1);return asky(dep+1,x1,x2,l,mid,l,mid);&#125; else &#123;turnr(x1-1,0);turnr(x2,1);return asky(dep+1,x1,x2,mid+1,r,mid+1,r);&#125; &#125; if(fr&lt;=mid) &#123;turnl(x1-1,0);turnl(x2,1);return asky(dep+1,x1,x2,l,mid,fl,fr);&#125; else if(fl&gt;mid) &#123;turnr(x1-1,0);turnr(x2,1);return asky(dep+1,x1,x2,mid+1,r,fl,fr);&#125; else &#123; backup(x1-1,0,dep);backup(x2,1,dep); turnl(x1-1,0);turnl(x2,1); int tmp=asky(dep+1,x1,x2,l,mid,fl,mid); if(tmp) return tmp; goback(x1-1,0,dep);goback(x2,1,dep); turnr(x1-1,0);turnr(x2,1); return asky(dep+1,x1,x2,mid+1,r,mid+1,fr); &#125; &#125; &#125;; struct Edge&#123;int t,x1,x2,y1,y2;&#125;pp[MAX_M]; vc&lt;int&gt; e[MAX_N];int dis[MAX_N]; priority_queue&lt; pr,vc&lt;pr&gt;,greater&lt;pr&gt; &gt; q; void dij() &#123; memset(dis,0x3f,sizeof dis);dis[1]=0;q.push(MP(0,1)); while(q.size()) &#123; pr now=q.top();q.pop();int x=now.SE; if(x&gt;n) &#123; int id=x-n; while(1) &#123; Gao::clear(pp[id].x1-1,0);Gao::clear(pp[id].x2,1); int y=Gao::asky(0,pp[id].x1,pp[id].x2,1,h,pp[id].y1,pp[id].y2);if(y==0) break; y=getid[MP(Gao::askx(pp[id].x1,y),y)]; if(out[y]==0) Gao::modify(pt[y].FR,pt[y].SE,-1),out[y]=1; dis[y]=now.FR;q.push( MP(dis[y],y) ); &#125; &#125; else &#123; if(dis[x]&lt;now.FR) continue; if(out[x]==0) Gao::modify(pt[x].FR,pt[x].SE,-1),out[x]=1; for(int t=0;t&lt;(int)e[x].size();t++) &#123; int to=e[x][t]; q.push( MP(dis[x]+pp[to].t,n+to) ); &#125; &#125; &#125; &#125; void main() &#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;w,&amp;h); for(int i=1;i&lt;=n;i++) &#123; pt[i].FR=qread(),pt[i].SE=qread(),getid[pt[i]]=i; Gao::modify(pt[i].FR,pt[i].SE,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,t,x1,x2,y1,y2;scanf("%d%d%d%d%d%d",&amp;x,&amp;t,&amp;x1,&amp;x2,&amp;y1,&amp;y2); pp[i]=(Edge)&#123;t,x1,x2,y1,y2&#125;;e[x].PB(i); &#125; dij();for(int i=2;i&lt;=n;i++) write2(dis[i]); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); // freopen("jump.in","r",stdin); // freopen("jump.out","w",stdout); srand(time(0)); mine::main();&#125; D2T2 斗主地请先思考后再展开 12 D2T3 I 君的探险请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFR573]]></title>
    <url>%2Fposts%2Fafd1.html</url>
    <content type="text"><![CDATA[CFR573好题：B、C、E A请先思考后再展开 按题意模拟1234567891011121314ll a[MAX_N],gg=0,k;ll pos(ll num) &#123;return (num-gg)/k;&#125;void main()&#123; ll n=qread(),m=qread();k=qread();//[0,n-1] for(int i=1;i&lt;=m;i++) a[i]=qread()-1; int cnt=0; for(int i=1;i&lt;=m;) &#123; int j=i;while(j+1&lt;=m and pos(a[i])==pos(a[j+1])) j++; cnt++;gg=j;i=j+1; &#125; write(cnt);&#125; B请先思考后再展开 题目中提到先手的一个责任是把局面变成无冲突的，先判掉$$ cnt[0]&gt;1 cnt[x]&gt;1 and cnt[x-1]&gt;0 \sum[cnt[x]&gt;1] &gt;1 cnt[x]&gt;2$$假如成功那么最后一刻一定是0到n-1的排列，数差的绝对值即可123456789101112131415161718map&lt;int,int&gt; cnt;void gg()&#123;puts("cslnb");exit(0);&#125;void main()&#123; int n=qread(); for(int i=1;i&lt;=n;i++) cnt[qread()]++; if(cnt[0]&gt;1) gg(); int sum=0;ll sum2=-(ll)(n-1)*n/2; for(map&lt;int,int&gt;::iterator it=cnt.begin();it!=cnt.end();it++) &#123; int x=it-&gt;FR,pp=it-&gt;SE;if(pp&gt;2) gg(); if(cnt[x-1]&gt;0 and pp&gt;1) gg(); sum+=(pp&gt;1);sum2+=(ll)x*pp; &#125; if(sum&gt;1) gg(); if(sum2&amp;1) puts("sjfnb"); else puts("cslnb");&#125; C请先思考后再展开 注意到操作是可逆的，如果没有一步登天就没法赢因此，如果第一步不能赢，那么先手不能赢；如果先手下的任意一种情况后手不能一步赢，那么就是平局 D请先思考后再展开 显然是从上到下扫，维护一个数据结构支持插入，查询某个数第k大然后刚从文化课回来啥都不会了，居然码了个splay还写错一个小地方调到结束……其实树状数组就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB pushback #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=1e9+7; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=2e5+10; namespace Splay &#123; struct Nod&#123;int son[2],fa,siz,d;&#125;p[MAX_N]; int root=0,id=0; #define lc p[x].son[0] #define rc p[x].son[1] bool son(int x)&#123;return p[p[x].fa].son[1]==x;&#125; void pushup(int x)&#123;p[x].siz=1+p[lc].siz+p[rc].siz;&#125; void rotate(int x) &#123; int f=p[x].fa,ff=p[f].fa,c=son(x);if(ff)p[ff].son[son(f)]=x; int tson=p[x].son[c^1];p[f].son[c]=tson;p[x].son[c^1]=f; p[x].fa=ff;p[f].fa=x;if(tson) p[tson].fa=f; pushup(f);pushup(x); &#125; void splay(int x) &#123; for(int f=p[x].fa;p[x].fa&gt;0;rotate(x),f=p[x].fa) if(p[f].fa&gt;0) son(x)^son(f)?rotate(x):rotate(f); root=x; &#125; int findip(int d) &#123; int x=root; while(p[x].d!=d) &#123; if(d&lt;p[x].d) &#123;if(lc==0) return x;x=lc;&#125; else &#123;if(rc==0) return x;x=rc;&#125; &#125; return x; &#125; void insert(int d) &#123; if(root==0) &#123;p[root=++id]=(Nod)&#123;0,0,0,1,d&#125;;return;&#125; int x=findip(d);if(p[x].d==d) return; int y=++id;p[y]=(Nod)&#123;0,0,x,1,d&#125;;p[x].son[d&gt;p[x].d]=y;splay(y); &#125; int getrk(int d) &#123;int x=findip(d);splay(x);return p[lc].siz+1;&#125; &#125;; pr pt[MAX_N];set&lt;int&gt; hash; bool cmp(pr a,pr b) &#123;return a.SE&gt;b.SE or (a.SE==b.SE and a.FR&lt;b.FR);&#125; ll pp(ll x) &#123;return (x+1)*x/2;&#125; void main() &#123; int n=qread(); for(int i=1;i&lt;=n;i++) &#123;int x=qread(),y=qread();pt[i]=MP(x,y);&#125; sort(pt+1,pt+n+1,cmp); ll ans=0; for(int i=1;i&lt;=n;) &#123; int j=i;while(j+1&lt;=n and pt[i].SE==pt[j+1].SE) j++; using namespace Splay; for(int t=i;t&lt;=j;t++) &#123; insert(pt[t].FR); if(t&gt;i) ans-=pp(getrk(pt[t].FR)-getrk(pt[t-1].FR)-1); &#125; ans+=pp(p[root].siz); int x=findip(pt[i].FR);splay(x);ans-=pp(p[p[x].son[0]].siz); int y=findip(pt[j].FR);splay(y);ans-=pp(p[p[y].son[1]].siz); i=j+1; &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125; E题意：要求用最多m条之间与原点围成的凸包内不包含给定的n个点，并最大化凸包到原点的距离（min 每条线到原点距离）请先思考后再展开 二分答案，相当于求需要多少条切线把所有点隔离求出每个点被隔离的角度范围（切线），那么问题转化为一个圆周上若干个区间，求最小点覆盖如果在直线上显然贪心，然后可爱的靖靖居然说用差分约束但这玩意具有启发性意义：加个二分的话就是d[st]-d[ed]&lt;=mid-1，以及原有的d[360]&lt;=mid但这做法比下面介绍的多一个spfa的时间，不太稳 显然拆环是可行的，借鉴直线上贪心的思想去预处理也就是考虑加速直线上的过程，其实就只需要找到第一个位置，然后往后跳到下一个ar&lt;bl的地方这个过程可以用倍增加速，那么就是要预处理倍增，然后滚动区间，每个区间的判定时间为log故总复杂度为 $O(nlognlogDIS)$ F咕咕咕]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2007】砝码]]></title>
    <url>%2Fposts%2Fa960.html</url>
    <content type="text"><![CDATA[SourcePOI2007bzoj1110 Hint请先思考后再展开 方向一：本质不同的砝码只有log个方向二：进制思想 Solution请先思考后再展开 做法一：贪心 $O(nlog^2)$做法就是二分后从大到小处理每个砝码，放在能放的地方即可，然后合并相同的来加速这个贪心的正确性，核心在于为什么大砝码放在哪里对于本次二分结果没有影响这个问题我想了很久都没想通，总觉得很复杂不知道怎么分析，还是ozy一语点醒了我就是因为存在倍数关系这个限制，浪费的空间可以看作%mm，而能放就放不会本质上改变这个123456789101112131415161718192021222324252627282930313233int n,m,a[MAX_N],aa[MAX_N],cnt=0;pr b[MAX_N];int sum[40];bool check(int mid)&#123; int lst=lower_bound(sum+1,sum+cnt+1,mid)-sum; memcpy(aa,a,sizeof a); for(int i=lst;i&gt;=1;i--) &#123; int now=b[i].SE;if(i==lst) now=mid-sum[lst-1]; for(int j=1;j&lt;=n;j++) &#123; int pp=min(aa[j]/b[i].FR,now); aa[j]-=pp*b[i].FR;now-=pp; &#125; if(now&gt;0) return 0; &#125; return 1;&#125;void main()&#123; n=qread(),m=qread(); for(int i=1;i&lt;=n;i++) a[i]=qread(); for(int i=1;i&lt;=m;i++) b[i]=MP(qread(),1);sort(b+1,b+m+1); for(int i=1;i&lt;=m;i++) if(i==1 or b[i-1].FR!=b[i].FR) b[++cnt]=b[i]; else b[cnt].SE++; for(int i=1;i&lt;=cnt;i++) sum[i]=sum[i-1]+b[i].SE; int l=0,r=m,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,l=mid+1; else r=mid-1; &#125; write(ans);&#125; 做法二：nlogn1234567891011121314151617181920212223int n,m,a[MAX_N],b[MAX_N],c[40],cnt=0;int now[40];bool push(int pos)&#123; for(int i=pos+1;i&lt;=cnt;i++) if(now[i]&gt;0) &#123;now[pos]+=c[i]/c[pos],now[i]--;return 1;&#125; return 0;&#125;void main()&#123; n=qread(),m=qread(); for(int i=1;i&lt;=n;i++) a[i]=qread(); for(int i=1;i&lt;=m;i++) b[i]=qread();sort(b+1,b+m+1); for(int i=1;i&lt;=m;i++) if(i==1 or b[i]!=b[i-1]) c[++cnt]=b[i]; for(int i=1;i&lt;=n;i++) for(int j=cnt;j&gt;=1;j--) now[j]+=a[i]/c[j],a[i]%=c[j]; for(int i=1;i&lt;=m;i++) &#123; int pos=lower_bound(c+1,c+cnt+1,b[i])-c; if(now[pos]&gt;0 or push(pos)) now[pos]--; else &#123;write(i-1);return;&#125; &#125; write(m);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客信息学4月提高组模拟赛]]></title>
    <url>%2Fposts%2F21f3.html</url>
    <content type="text"><![CDATA[计蒜客信息学4月提高组模拟赛 A 男左女右分类讨论，考思维清晰、细节明确 核心思想就是分n的奇偶性和当前先手奇偶性仔细讨论 123456789101112int T=qread();while(T--)&#123; scanf("%s",str+1);int ln=strlen(str+1),op=qread(); if(ln==1 and str[1]-'0'==2) &#123; printf("%d\n",op); continue; &#125; if((str[ln]-'0')%2==0 and op==0) printf("%d\n",op^1); else printf("%d\n",op);&#125; B 漫天飞刺考虑如何把 $O(n^3logINF^2)$ 的log去掉，很自然地想到先把当前最大子矩阵求出来 然后修改那个位置就枚举，通过预处理（稍微改一改最大子矩阵的求法）求出这种方案的 $max( 不包括此点的mx，包括此点的mx-old+new) )$ 时间复杂度为 $O(n^3)$ C 旋转茶杯 bzoj3579破冰派对 loj2155「POI2011 R1」同谋者 Conspiracy题意：给出一个无向图，求子图满足【选的点是团，没选的点是独立集】；问最大权值的子图或问合法子图方案数 这种乱搞题的核心：要么搞出一种复杂度正确的方法，要么证明没有这种情况 如果我们能求出任意一个方案，那么其他的方案一定是： 从团中删除一个点 向团中加入一个点 从团中删除一个点再加入一个点 考虑如何求出一个合法解，直接建 $n^2$ 的边去2-sat似乎没有优化空间 将所有点按照度数从大到小排序，按顺序加入点，如果某次发现x无法加入到团中，那么就停下 此时如果和后面有边相连，那就没有合法解（假设x往前连a个往后b个，这b个点都要加入团中内部一定也是团，则 $b\leq 后面 \leq a+b$即往前的度数&lt;=a，同样gg）无论如何都可以退出了，因为既然现在有合法解，那么b=0，全部往前都不够，后面的自然也不够了 然后关于这个合法方案还有一个遗留问题，就可能独立集里面有非法边，然后为此前面某个团中的点x自愿退出来让后面的t加入；这种情况实际上是不存在的，还是分析一下度数，原本团a，x的连边为a+b，则团新大小为a+b，而后面这个能加入的点至少为 $a+b+1$ 得到合法方案后（一定是一段in+一段out），按照上面说的考虑调整，核心就是尽量让复杂度和m相关 第二种情况在本做法中显然是没有的，第一种直接枚举，第二种想不到可看代码，很好懂 复杂度下界为 $O(n+m)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; const ll MOD=998244353; void add(int &amp;x,int y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=1e5+10; int cas,n; int a[MAX_N],deg[MAX_N];vc&lt;int&gt; to[MAX_N]; int q[MAX_N];bool cmp(int x,int y)&#123;return deg[x]&gt;deg[y];&#125; bool in[MAX_N]; bool getone() &#123; int pp=0; for(int i=1;i&lt;=n;i++) &#123; int cnt=0,x=q[i]; for(int t=0;t&lt;(int)to[x].size();t++) cnt+=in[to[x][t]]; if(cnt==pp) in[x]=1,pp++; else if(deg[x]-cnt&gt;0) return 0; &#125; for(int x=1;x&lt;=n;x++) if(!in[x]) for(int t=0;t&lt;(int)to[x].size();t++) if(!in[to[x][t]]) return 0; return 1; &#125; vc&lt;int&gt; A; bool on[MAX_N*5];int pos[MAX_N],king[MAX_N]; void solve() &#123; int sum=0;for(int i=1;i&lt;=n;i++) if(in[i]) A.PB(i),pos[i]=A.size()-1,sum+=a[i]; int m=A.size(); int ans=(m&gt;0 and m&lt;n);cas=1;//bzoj// int ans=cas&amp;1?1:sum; for(int x=1;x&lt;=n;x++) if(in[x]) &#123; //从团中删除一个点 bool ok=1; for(int tt=0;tt&lt;(int)to[x].size();tt++) &#123; int y=to[x][tt]; if(!in[y]) &#123;ok=0;break;&#125; &#125; if(ok) &#123; if(cas&amp;1) &#123; if(m&gt;1)//bzoj ans++; &#125; else chmax(ans,sum-a[x]); &#125; &#125; //从团中删除一个点再加入一个点 for(int t=0;t&lt;m;t++) &#123; int x=A[t],yy,cnt=0; for(int i=0;i&lt;(int)to[x].size();i++) &#123; int y=to[x][i];if(in[y]) continue; cnt++;yy=y; &#125; if(cnt==0) king[x]=-666; else king[x]=yy; &#125; for(int y=1;y&lt;=n;y++) if(!in[y]) &#123; int cnt=0;for(int t=0;t&lt;(int)to[y].size();t++) cnt+=in[to[y][t]]; if(cnt==m-1) &#123; for(int i=0;i&lt;m;i++) on[i]=0; for(int t=0;t&lt;(int)to[y].size();t++) on[pos[to[y][t]]]=1; for(int i=0;i&lt;m;i++) if(!on[i]) &#123; int x=A[i];if(king[x]!=y and king[x]!=-666) continue; if(cas&amp;1) &#123; if(m&gt;0 and m&lt;n)//bzoj ans++; &#125; else chmax(ans,sum-a[x]+a[y]); &#125; &#125; &#125; write2(ans); &#125; int ct[MAX_N]; void main() &#123; int T=qread(); while(T--) &#123; cas=1;n=qread();int m=qread(); memset(in,0,sizeof in); memset(king,0,sizeof king); memset(deg,0,sizeof deg);A.clear(); for(int i=1;i&lt;=n;i++) to[i].clear(); while(m--) &#123; int x=qread(),y=qread(); deg[x]++;deg[y]++; to[x].PB(y);to[y].PB(x); &#125;// cas=qread(),n=qread();// for(int i=1;i&lt;=n;i++) a[i]=qread();// for(int x=1;x&lt;=n;x++)// &#123;// int cnt=qread();deg[x]+=cnt;// while(cnt--)// &#123;// int y=qread();deg[y]++;// to[x].PB(y);to[y].PB(x);// &#125;// &#125; memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[deg[i]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) q[n-(ct[deg[i]]--)+1]=i; if(getone()) solve(); else write2(0); &#125; &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PKUSC2019前后]]></title>
    <url>%2Fposts%2F99ca.html</url>
    <content type="text"><![CDATA[PKUSC2019准备很匆忙，再次体验了下OI的快乐 CF1146F Leaf Partition一开始的想法是f(x,0/1)表示x这个点当前已占用或钦定后面占用，但似乎后面没法确保被合并掉 换个角度，设0/1表示x向上这条变是否会被使用 实现的时候，f为0，g为1$$f(x)=f(x)f(y)+g(x)g(y)\\tt(x)=\prod f(y) \\g(x)=g(x)g(y)+g(x)f(y)+tt(x)g(y)$$g的转移用tt是因为f中，可能节点x已经被占用 时间复杂度为线性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; const ll MOD=998244353; void add(int &amp;x,int y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=2e5+10; vc&lt;int&gt; son[MAX_N]; ll f[MAX_N],g[MAX_N],tt[MAX_N];//这个点是否被用到 void dp(int x) &#123; tt[x]=1; if(son[x].size()==0) f[x]=g[x]=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];dp(y); if(t==0) f[x]=tt[x]=f[y],g[x]=g[y]; else &#123; ll ff=f[x]*f[y]+g[x]*g[y];ff%=MOD; ll gg=g[x]*g[y]%MOD+g[x]*f[y]%MOD+tt[x]*g[y]%MOD;gg%=MOD; f[x]=ff,g[x]=gg;tt[x]=tt[x]*f[y]%MOD; &#125; &#125; &#125; void main() &#123; int n=qread();for(int x=2;x&lt;=n;x++)&#123;int fa=qread();son[fa].PB(x);&#125; dp(1);write(f[1]); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; Loj2136 「ZJOI2015」地震后的幻想乡一开始考虑排名的期望做的，但太菜了似乎没搞出来；还有就是下述状压用到经典的【考虑集合内编号最小节点所在连通块】 众所周知，一个图的最小生成树具有【最大边权最小】的特性，所以最大边的期望=【最小的，只需要比这个更小的边就能让图连通】的期望 然后期望这东西众所周知是可以转化为概率密度函数的积的，即求 $\int_0^1 P(t)，P(t)为只使用t以内的边导致不连通的概率$$$f(集合S,t)=\sum_{最小编号所在集合SS} (1-f(SS,t))(1-t)^{cnt=SS与S-SS间的边数} \\\int_0^1 f(S,t)dt=\sum \int_0^1 (1-f(SS,t))(1-t)^{cnt}dt=\sum \frac{1}{1+cnt}-\int_0^1 f(SS,t)(1-t)^{cnt}dt \\同理\int_0^1 (1-t)^Tf(S,t)dt=\sum \frac{1}{1+T+cnt}-\int_0^1 f(SS,t)(1-t)^{T+cnt}dt \\$$于是就可以dp了，设 $g(S,T) ，符号意思如上，g(S,T)=\sum \frac{1}{1+T+cnt}-g(SS,T+cnt),ans=g(all,0)$ 时间复杂度为 $O(3^nn^2)$，受限于处理两集合间边数量 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int qread()&#123; int num=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') num=num*10+c-'0',c=getchar(); return num;&#125;const int MAX_N=12,MAX_M=110;int bin[MAX_N],siz[1&lt;&lt;MAX_N],mark[MAX_N];double g[1&lt;&lt;MAX_N][MAX_M];int main()&#123; bin[0]=1;for(int i=1;i&lt;MAX_N;i++) bin[i]=bin[i-1]&lt;&lt;1; for(int i=1;i&lt;bin[MAX_N-1];i++) siz[i]=siz[i&gt;&gt;1]+(i&amp;1); int n=qread(),m=qread(); for(int i=1;i&lt;=m;i++) &#123; int x=qread()-1,y=qread()-1; mark[x]|=bin[y];mark[y]|=bin[x]; &#125; for(int T=m;T&gt;=0;T--) for(int S=1;S&lt;bin[n];S++) &#123; int mi=(S&amp;-S),wt=S^mi;if(S==mi) continue; for(int SS=(wt-1)&amp;wt;SS&gt;=0;SS=(SS-1)&amp;wt) &#123; int a=mi^SS,b=S^a,cnt=0; for(int i=0;i&lt;n;i++) if(a&amp;bin[i]) cnt+=siz[mark[i]&amp;b]; if(T+cnt&lt;=m) g[S][T]+=1.0/(1+T+cnt)-g[a][T+cnt]; if(SS==0) break; &#125; &#125; printf("%.6lf",g[bin[n]-1][0]);&#125; upd：徐国王教了我一种新做法 首先有个很妙的题意转化，就是$ans=\sum_{选边到恰好连通的情况} \frac{边数}{m+1}=\sum_{非法选边方案} \frac{1}{m+1}$ 于是就可以dp了，$非法g(S,i)=\sum_{T \subset S,mi(S) \in T} 连通f(T,j)C_{edge(S-T)}^{i-j},g(S,i)+f(S,i)=C_{edge(S)}^i,ans=\frac{g(U,i)}{(m+1)C_{m}^i}$ 注意到一个方案可能是若干个其他方案的子集，需要多次计数，统计答案的系数必须这样搞 PKUSC2018真实排名细节：ai相同、=0（特判） 若x不变，则 $[x/2,x)不变，ans=C_{all-cnt-1}^k$ 若x变，则 $[x,2x)变，ans=C_{all-cnt}^{k-cnt}$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int qread()&#123; int num=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') num=num*10+c-'0',c=getchar(); return num;&#125;#define MP make_pairtypedef long long ll;const int MOD=998244353;const int MAX_N=1e5+10;ll fac[MAX_N],inv[MAX_N],facinv[MAX_N];ll C(int n,int m)&#123;if(n&lt;m or m&lt;0)return 0;return fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;&#125;int a[MAX_N],b[MAX_N];int main()&#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; inv[1]=1;for(int i=2;i&lt;MAX_N;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=facinv[i-1]*inv[i]%MOD; int n=qread(),k=qread(); for(int i=1;i&lt;=n;i++) a[i]=b[i]=qread(); sort(b+1,b+n+1); for(int i=1;i&lt;=n;i++) &#123; int ans=0,x=a[i]; if(x==0) ans=C(n,k); else &#123; int aa=lower_bound(b+1,b+n+1,x)-1-lower_bound(b+1,b+n+1,(int)ceil(x/2.0))+1; int bb=lower_bound(b+1,b+n+1,2*x)-1-lower_bound(b+1,b+n+1,x)+1; ans=C(n-aa-1,k)+C(n-bb,k-bb); &#125; printf("%d\n",(ans%MOD+MOD)%MOD); &#125;&#125; Day1t1明显就是在直接逆序对的基础上改了改（题意修正=强烈暗示），时间倒流+启发式合并+主席树就好了，$O(nlog^2n)$ t2花了很久debug假做法，然后爽快一分没有 正解的压法挺不错，对于每个数，把它小的设为0，大的设为1，那么状态为 $3^n$ 然后只有01的情况需要枚举0/1，复杂度应该是 $O(n^2m4^n)$ t3还不会 Day2t1应该会47分，但太难写了（3个代码）就没有写，玩了玩t3感觉不好搞就跑路了 然后就玩了一整场t2，先把菊花写了，然后二叉树玩半天终于发现了一种有解策略，因为不知道有没有更优的情况所以就先写了，gg后又玩了半天，从数轴开始逐步考虑，把二叉树的做法搞出来了（把dfs换成bfs），此时剩1.7h；然后此时回去看看t1发现还是不会，有点小难受，然后这个t2我不知道为什么做法不能拓展到正解，想半天觉得应该是插入顺序什么的，瞎jb试了各种方法都不行，不太会理性分析，于是就滚粗了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>赛事</tag>
        <tag>PKUSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019省选前做的题]]></title>
    <url>%2Fposts%2F90dc.html</url>
    <content type="text"><![CDATA[2019省选前做的题 好题：THUSC2015 解密运算、CF1155F Delivery Oligopoly 【Snoi2013】Quare CF371E Sonya Partymaker我目前认为，把最长段转到n-1间是错误的做法，但不知为何得到AC且没能拍出错误，故只给出代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int m,n,st;pr mx;int f[MAX_N][2],a[MAX_N];void dp(int T,int op)&#123; for(int i=st+1+op;i&lt;=st+n-1;i++) &#123; if(f[i-1][0]&gt;=a[i]-T) chmax(f[i][0],a[i]+1); if(f[i-1][1]&gt;=a[i]-T) chmax(f[i][0],max(a[i-1]+T+1,a[i]+1) ); int tmp=max(f[i-1][0],f[i-1][1]);if(tmp&gt;=a[i]) chmax(f[i][1],a[i]+T+1); chmax(f[i][0],tmp);chmax(f[i][1],tmp); &#125;&#125;bool check(int T)&#123; int st=mx.SE;//printf("st=%d\n",st); //left &#123; memset(f,-0x3f,sizeof f);f[st][0]=a[st]+1;dp(T,0); if( max(f[st+n-1][0],f[st+n-1][1])&gt;=a[st]+m-T ) return 1; &#125; //right &#123; memset(f,-0x3f,sizeof f);f[st][1]=a[st]+T+1;dp(T,0); if( max(f[st+n-1][0],f[st+n-1][1])&gt;=a[st]+m ) return 1; &#125; //right2 if(a[st]+T+1&gt;=a[st+1]) &#123; memset(f,-0x3f,sizeof f);f[st+1][0]=max(a[st]+T+1,a[st+1]+1);dp(T,1); if( max(f[st+n-1][0],f[st+n-1][1])&gt;=a[st+1]+m-T ) return 1; &#125; return 0;&#125;void main()&#123; m=qread(),n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); mx=MP(a[1]-1+m-a[n]+1,1);for(int i=2;i&lt;=n;i++) mx=max(mx,MP(a[i]-a[i-1],i));st=mx.SE; for(int i=1;i&lt;=n;i++) a[n+i]=a[i]+m; int l=0,r=mx.FR-1,ans=mx.FR; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; write(ans);&#125; 比较合理的做法应该是移动到1和2之间，从1开始dp，这样能避免很多奇怪的情况。 第一次dp，不考虑所有人在n-1段的贡献，得出还差长度ln，然后第二次dp，dp的初始值要求覆盖ln，然后判能否合上 不是很想再写一次了，所以口胡跑路了…… 51nod1838 Jabby的网格 限制：$步长 \leq M，不能同时为(x_K,y_K)（G的倍数），恰好走R步到达(T_x,T_y)$$$\begin{aligned}&amp; pp(a,b)=将b划分为a个非负数=C_{a+b-1}^{a-1} \\&amp; f_x(a,b)=考虑x坐标，a步走了b且满足步长限制=\sum_{k=0}^{min(b/(M_x+1),a)} (-1)^k C_a^k pp(a,b-(M_x+1)k) \\&amp; g(k,t)=走了k次非法到达(tG,tG)，这个可以 O(KRT_x/G) \\&amp; ans=\sum_{k=0}^R (-1)^k C_r^k \sum_{t=0}^{T_x/G} g(k,t)f_x(R-k,T_x-tG)f_y(R-k,T_y-tG)\end{aligned}$$总复杂度为 $O(R^2T_x/G)$ 1234567891011121314151617181920212223242526272829303132int pp(int a,int b)&#123;return C(a+b-1,a-1);&#125;int g[MAX_N][210];int T[2],M[2],R,G;vc&lt;int&gt; ban;int getf(int op,int a,int b)&#123; int ans=0; for(int k=0,t=1;k&lt;=min(b/(M[op]+1),a);k++,t=-t) add(ans,(MOD+(ll)t*C(a,k)*pp(a,b-(M[op]+1)*k)%MOD)%MOD ); return ans;&#125;void main()&#123; fac[0]=1;for(int i=1;i&lt;MAX_M;i++) fac[i]=(ll)fac[i-1]*i%MOD; inv[1]=1;for(int i=2;i&lt;MAX_M;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_M;i++) facinv[i]=(ll)facinv[i-1]*inv[i]%MOD; scanf("%d%d%d%d%d%d",&amp;T[0],&amp;T[1],&amp;M[0],&amp;M[1],&amp;R,&amp;G); int K=qread();while(K--) ban.PB(qread());ban.PB(0); sort(ban.begin(),ban.end());ban.resize(unique(ban.begin(),ban.end())-ban.begin()); g[0][0]=1; for(int pp=0;pp&lt;R;pp++) for(int t=0;t&lt;=100;t++) for(int s=0;s&lt;(int)ban.size();s++) add(g[pp+1][t+ ban[s]/G ],g[pp][t]); int ans=0; for(int k=0;k&lt;=R;k++) &#123; int now=0; for(int t=0;t&lt;=min(T[0],T[1])/G;t++) add(now, (ll)g[k][t]*getf(0,R-k,T[0]-t*G)%MOD*getf(1,R-k,T[1]-t*G)%MOD ); add(ans,ll(MOD+(k&amp;1?-1:1)*C(R,k))*now%MOD); &#125; write(ans);&#125; 51nod1965 奇怪的式子zjy神仙的题，但模数特别狗……（min25筛类算法不说复杂度系列）$$\begin{aligned}&amp; 设 S(n)=n(n+1)/2；不妨把答案拆成两个部分 \\&amp; Part A\\&amp; \prod \sigma_0(i)^i=\prod_i \prod_t^{P_i^t \leq N} (t+1)^{ S(N/P_i^t)P_i^t-S(N/P_i^{t+1})P_i^{t+1} } \\&amp; 这个对于P_i^2&lt;N，直接计算；否则t=1（为实现方便第一部分不统计t=1） \\&amp; 2^{ \sum_i S(N/P_i)P_i } ，这个东西可以直接数论分块，借助min25筛出来的素数前缀和即可 \\&amp; Part B\\&amp; 设g(n,j)=\sum_{minp(i) \geq P_j或i \in P} \mu(i)质因数个数(i)，ans=2^{ g(N,1) } ，设T(n,j)=\sum \mu(i) 辅助转移 \\&amp; T(n,j)=T(n,j-1)+(-1)( T(n/P_j,j+1)-(-j) )[P_j^2 \leq n] \\&amp; g(n,j)=g(n,j-1)+(-1)( g(n/P_j,j+1)+T(n/P_j,j+1)-2(-j) )[P_j^2 \leq n] \\\end{aligned}$$卡常卡不动，跑路了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e6+10; /*ll qmul(ll x,ll y,ll MOD) &#123; x=(x%MOD+MOD)%MOD,y=(y%MOD+MOD)%MOD; ll tmp=(ll)((double)x*y/MOD+1e-8)*MOD; return (x*y-tmp+MOD)%MOD;//允许溢出 &#125;*/ ll qmul(ll x,ll y,ll P) &#123;return (x*y-(ll)((double)x/P*y+0.3)*P+P)%P;&#125;//更快的版本 const ll MOD=1e12+39,MOD2=MOD-1; void add(ll &amp;x,ll y)&#123;x+=y;if(x&gt;=MOD2)x-=MOD2;if(x&lt;0)x+=MOD2;&#125; ll qpower(ll x,ll e) &#123; ll ans=1;x%=MOD;e=e%MOD2+MOD2; while(e) &#123; if(e&amp;1) ans=qmul(ans,x,MOD); x=qmul(x,x,MOD)%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll S(ll n)&#123;return (n&amp;1)?qmul(n,(n+1)/2,MOD2):qmul(n/2,n+1,MOD2);&#125; bool mark[MAX_N];int pp=0,p[MAX_N];ll sum[MAX_N]; void pre() &#123; for(int i=2;i&lt;MAX_N;i++) &#123; if(!mark[i]) p[++pp]=i,sum[pp]=sum[pp-1]+i; for(int j=1;j&lt;=pp and i*p[j]&lt;MAX_N;j++) &#123; mark[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125; &#125; ll N,md,a[MAX_N]; #define id(x) ((x)&lt;=md?a[(x)]:a[md+N/(x)]) vector&lt;ll&gt; num; ll p1[MAX_N],p2[MAX_N],g[MAX_N],T[MAX_N]; ll xx[100]; void main() &#123; pre(); int cs=qread(); while(cs--) &#123; memset(a,0,sizeof a);num.resize(0);memset(xx,0,sizeof xx); N=qread();md=sqrt(N)+1; for(ll l=1,r;l&lt;=N;l=r+1) r=N/(N/l),id(N/l)=num.size(),num.PB(N/l); int m=num.size(); for(int t=0;t&lt;m;t++) &#123; p1[t]=(num[t]-1)%MOD2; p2[t]=(num[t]&amp;1)?qmul(num[t]+2,(num[t]-1)/2,MOD2):qmul((num[t]+2)/2,num[t]-1,MOD2); &#125; for(int j=1;j&lt;=pp;j++) for(int t=0;t&lt;m and (ll)p[j]*p[j]&lt;=num[t];t++) &#123; add(p1[t],-(p1[id(num[t]/p[j])]-(j-1))%MOD2 ); add(p2[t],-qmul(p2[id(num[t]/p[j])]-sum[j-1],p[j],MOD2) ); &#125; for(int t=0;t&lt;m;t++) T[t]=g[t]=-p1[t]; for(int j=pp;j&gt;=1;j--) for(int t=0;t&lt;m and (ll)p[j]*p[j]&lt;=num[t];t++) &#123; int go=id(num[t]/p[j]);if(go==t) puts("error2"); add(T[t],-(T[go]+j)%MOD2);add(g[t],-(g[go]+T[go]+j*2)%MOD2); &#125; ll ans=1;xx[2]=g[0]; for(int j=1;j&lt;=pp and (ll)p[j]*p[j]&lt;=N;j++) for(ll t=1,now=p[j];now&lt;=N;t++,now=now*p[j]) add(xx[t+1], (qmul(S(N/now),now,MOD2)-qmul(S(N/now/p[j]),(ll)p[j]*now,MOD2))%MOD2 ); ll sq=0;while((sq+1)*(sq+1)&lt;=N) sq++; for(ll l=1,r;l&lt;=N;l=r+1) &#123; r=N/(N/l); if(r&gt;sq) add(xx[2], qmul(S(N/l),p2[id(r)]-p2[id( max(sq,l-1) )],MOD2) ); &#125; for(int t=2;t&lt;=50;t++) ans=qmul(ans,qpower(t,xx[t]),MOD); write2((ans+MOD)%MOD); &#125; &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; THUSC2015 解密运算先考虑所有字符都不同的情况，我们能立刻知道最后一个字符，然后根据字符找到排名，就能找到上一个字符是什么 那现在字符可能相同，考虑其特性，我们现在是希望得到以这个字符开始的排名 那对于以这个字符开头的那些串，字典序其实只跟下个字符开头相关，也就是按照作为结尾的那个排名 所以按【字符为第一关键字，排名为第二关键字】给字符重排即可 12345678910111213141516171819pr tmp[MAX_N];int a[MAX_N];int ans[MAX_N];void main()&#123; int n=qread();qread(); for(int i=1;i&lt;=n+1;i++) &#123; a[i]=qread(); tmp[i]=MP(a[i],i); &#125; sort(tmp+1,tmp+n+1+1); for(int i=1;i&lt;=n+1;i++) a[tmp[i].SE]=i; for(int t=n,now=1;t&gt;=0;t--) &#123; ans[t]=tmp[a[now]].FR; now=a[now]; &#125; for(int i=1;i&lt;=n;i++) write1(ans[i]);&#125; PA2014 Fiolki每次合并新建节点，那么就是二叉树森林 把反应放到lca上处理，可以无脑线段树合并，也可以直接做 时间复杂度 $O(nlogn)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455vector&lt;int&gt; son[MAX_N];bool v[MAX_N];int ff[MAX_N][20],dep[MAX_N];void pre(int x,int fa)&#123; v[x]=1; ff[x][0]=fa;for(int i=1;i&lt;20;i++) ff[x][i]=ff[ff[x][i-1]][i-1]; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t]; dep[y]=dep[x]+1;pre(y,x); &#125;&#125;int getlca(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;i--) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) x=ff[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(ff[x][i]!=ff[y][i]) x=ff[x][i],y=ff[y][i]; return ff[x][0];&#125;vector&lt;pr&gt; pp[MAX_N];ll a[MAX_N],ans=0;void solve(int x)&#123; v[x]=1; for(int t=0;t&lt;(int)son[x].size();t++) solve(son[x][t]); for(int t=0;t&lt;(int)pp[x].size();t++) &#123; int tx=pp[x][t].FR,ty=pp[x][t].SE; ll tmp=min(a[tx],a[ty]);a[tx]-=tmp;a[ty]-=tmp;ans+=tmp*2; &#125;&#125;int fa[MAX_N];int findfa(int x)&#123;return x==fa[x]?x:fa[x]=findfa(fa[x]);&#125;void main()&#123; int n=qread(),m=qread(),tt=qread(); for(int i=1;i&lt;=n;i++) a[i]=qread(),fa[i]=i; int cnt=n; while(m--) &#123; int x=findfa(qread()),y=findfa(qread()); cnt++;son[cnt].PB(x);son[cnt].PB(y); fa[x]=fa[y]=fa[cnt]=cnt; &#125; for(int i=cnt;i&gt;=1;i--) if(!v[i]) pre(i,0); pre(cnt,0); while(tt--) &#123; int x=qread(),y=qread(); pp[getlca(x,y)].PB(MP(x,y)); &#125; memset(v,0,sizeof v); for(int i=cnt;i&gt;=1;i--) if(!v[i]) solve(i); write(ans);&#125; CF1041F Ray in the tube题意转化为：$k为偶，A在y=kx+b上有整数解，B在y=kx+k/2+b上有整数解$ 枚举k，那么搞个map即可；考虑 $k=2^i \times 奇数c$，发现对于每个i取c=1能覆盖最多的点，故只有log个k 123456789101112131415161718192021222324int n,m,a[MAX_N],b[MAX_N];map&lt;int,int&gt; mp;int check(int k)&#123; mp.clear();int mx=0; for(int i=1;i&lt;=n;i++) &#123; int now=a[i];if(k&gt;0) now%=k; mp[now]++;chmax(mx,mp[now]); &#125; for(int i=1;i&lt;=m;i++) &#123; int now=b[i]+k/2;if(k&gt;0) now%=k; mp[now]++;chmax(mx,mp[now]); &#125; return mx;&#125;void main()&#123; n=qread();qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); m=qread();qread();for(int i=1;i&lt;=m;i++) b[i]=qread(); int ans=0;chmax(ans,check(0)); for(ll k=2;k&lt;=INF*2;k*=2) chmax(ans,check(k)); write(ans);&#125; CF869D The Overdosing Ubiquity真正影响方案计算的只有那2m个点向上的所有点（mlogn个），然后其他点是用来计算当前搜出来的路径的系数的 把那些点和边建成一个新图，在上面枚举起点计算简单路径，每个节点会被计算 $2^mm!$ 次，总复杂度为 $2^mm! (mlogn)^2$ CF1151E Number of Components我的做法是考虑每条边的贡献，就是说对于每个连通块，左右两条线段都把他计算一次，除2即可 然后这样的话边界是只有1次的，还有就是单个点要分开计算 容易写错，所以强行写了很久，没能在比赛中写完（想错了些情况），成功成为机房唯一一个没上紫的 12345678910111213141516171819202122232425262728293031323334353637ll a[MAX_N];void main()&#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; inv[1]=1;for(int i=2;i&lt;MAX_N;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=facinv[i-1]*inv[i]%MOD; int n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); if(n==1) &#123;puts("1");return;&#125; double ans=0,ans2=0; if(a[1]&lt;=a[2]) ans+=a[1]*(a[2]-a[1]),ans2+=a[1]*(n-a[2]+1); else ans+=(n-a[1]+1)*(a[1]-a[2]),ans2+=a[2]*(n-a[1]+1); if(a[n-1]&lt;=a[n]) ans+=(a[n]-a[n-1])*(n-a[n]+1),ans2+=a[n-1]*(n-a[n]+1); else ans+=a[n]*(a[n-1]-a[n]),ans2+=a[n]*(n-a[n-1]+1); for(int i=2;i&lt;=n-1;i++) &#123; //left &#123; ll x=a[i],y=a[i+1],z=a[i-1];if(x&gt;y) swap(x,y); if(z&lt;x) ans2+=(x-z)*(n-y+1); else if(z&gt;y) ans2+=x*(z-y); &#125; //right &#123; ll x=a[i],y=a[i+1],z=a[i-1];if(x&gt;z) swap(x,z); if(y&lt;x) ans2+=(x-y)*(n-z+1); else if(y&gt;z) ans2+=x*(y-z); &#125; ll x=a[i],y=a[i+1],z=a[i-1];if(y&gt;z) swap(y,z); if(x&lt;=y) ans+=x*(y-x); else if(y&lt;=x and x&lt;=z) ans+=(x-y)*(z-x); else ans+=(x-z)*(n-x+1); &#125; write(round(ans+ans2/2));&#125; 然后问akc他是怎么做的，说完我就懂了，然后在5min内就写完一遍过了woc 就是逐个加入元素，那么有贡献当且仅当区间包含当前元素而且不包含上一个元素 12345678910ll a[MAX_N];void main()&#123; int n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); ll ans=a[1]*(n-a[1]+1); for(int i=2;i&lt;=n;i++) if(a[i-1]&lt;a[i]) ans+=(a[i]-a[i-1])*(n-a[i]+1); else ans+=(a[i-1]-a[i])*a[i]; write(ans);&#125; 更显然的做法其实直接点数-边数就行了，没想到这个有点惭愧啊 bzoj4274 Periodic Sum在做这题之前我根本不知道，原来两边都在变化的那种乘积是有可能矩乘求的 本题的推导没有难点，注意一下细节即可，时间复杂度为 $O(n5^3)$ upd:好像太简略了，大致思想（可能和代码不同）就是 $ans=\sum_{i=0}^{n-1} a_i \sum_{j=0}^{m-1} \frac{10^{i+jn+1}-1}{9}*[(m-j)n-i]$，然后虽然看起来两边都有j，但考虑中途每一步可以有$10^{(j-1)n}*10^n*j$，是可以矩乘的 1234567891011121314151617181920212223242526int n,m,pp1,pp2;char a[MAX_N];int dec[MAX_N],dec2[MAX_N];void main()&#123; scanf("%s%d%d",a,&amp;m,&amp;MOD);n=strlen(a);reverse(a,a+n); dec[0]=1;for(int i=1;i&lt;MAX_N;i++) dec[i]=(ll)dec[i-1]*10%MOD; dec2[0]=1;for(int i=1;i&lt;MAX_N;i++) dec2[i]=(dec2[i-1]+dec[i])%MOD; pp1=dec[n];pp2=dec2[n-1]; Matrix A;A.mm[0][0]=1; A.mm[0][1]=pp1;A.mm[0][2]=-(ll)n*pp1%MOD;A.mm[0][3]=pp2; A.mm[1][1]=pp1;A.mm[1][2]=-(ll)n*pp1%MOD;A.mm[1][3]=pp2; A.mm[2][2]=pp1;A.mm[2][4]=pp2; A.mm[3][3]=1; A.mm[3][4]=-n; A.mm[4][4]=1;A=mpower(A,m-1); int ans=0; for(int i=0;i&lt;n;i++) &#123; Matrix now;now.mm[4][0]=1; now.mm[2][0]=dec2[i];now.mm[3][0]=((ll)n*(m-1)-i)%MOD; now.mm[0][0]=now.mm[1][0]=((ll)n*m-i)%MOD*dec2[i]%MOD; add(ans,ll((A*now).mm[0][0])*(a[i]-'0')%MOD); &#125; write((ans+MOD)%MOD);&#125; 51nod1989 竞赛表格$$f(i)=1+\sum_{j+rev(j)=i} f(j) \\设 j+rev(j)的并集为S\\f(i)=1+\sum_{j+rev(j)=i,j \in S} f(j)+\sum_{j+rev(j)=i,j \notin S} 1\\f(i)=1+\sum_{j+rev(j)=i,j \in S} (f(j)-1)+\sum_{j+rev(j)=i} 1$$ 然后答案其实不会超过ll，剩下自己想即可，时间复杂度的分析的话写完就会了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; int MOD=1e9+7; void add(int &amp;x,int y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; const int MAX_N=1e5+10; vc&lt;pr&gt; gg; ll dec[20]; ll rev(ll num) &#123; int n=log10(num)+1; ll ans=0;for(int i=0;i&lt;n;i++) ans+=dec[n-1-i]*(num/dec[i]%10); return ans; &#125; int calc(int n,int pos) &#123; if(pos==0) return min(n,9)-max(1,n-9)+1; return min(n,9)-max(0,n-9)+1; &#125; int a[20]; void dfs(int pos,int cnt) &#123; if(pos!=0) &#123; ll num2=0;for(int i=0;i&lt;pos;i++) num2+=(ll)a[i]*(dec[i]+dec[2*pos-i-1]); if(num2 and num2&lt;=10000000000ll) gg.PB(MP(num2,cnt)); &#125; if(pos==5) return; for(int i=0;i&lt;=18;i++) &#123; a[pos]=i; if(i%2==0) &#123; ll num2=dec[pos]*i;for(int j=0;j&lt;pos;j++) num2+=(ll)a[j]*(dec[j]+dec[2*pos-j]); if(num2) gg.PB(MP(num2,cnt)); &#125; dfs(pos+1,cnt*calc(i,pos)); a[pos]=0; &#125; &#125; vc&lt;pr&gt; g2;ll ff[4000000]; void main() &#123; dec[0]=1;for(int i=1;i&lt;=18;i++) dec[i]=dec[i-1]*10; dfs(0,1);sort(gg.begin(),gg.end()); for(int t=0;t&lt;(int)gg.size();t++) &#123; if(t==0 or gg[t-1].FR!=gg[t].FR) g2.PB(gg[t]); else g2[g2.size()-1].SE+=gg[t].SE; &#125; for(int t=0;t&lt;(int)g2.size();t++) &#123; ff[t]+=1+g2[t].SE;ll num=g2[t].FR+rev(g2[t].FR); ff[lower_bound(g2.begin(),g2.end(),MP(num,0))-g2.begin()]+=ff[t]-1; &#125; for(int t=1;t&lt;(int)g2.size();t++) ff[t]+=ff[t-1]; int q=qread();ll ans=0; while(q--) &#123; ll l=qread(),r=qread();MOD=qread(); int fl=lower_bound(g2.begin(),g2.end(),MP(l,0))-g2.begin(); int fr=upper_bound(g2.begin(),g2.end(),MP(r,INF))-g2.begin()-1; ans^=(ff[fr]-(fl==0?0:ff[fl-1])+(r-l+1)-(fr-fl+1))%MOD; &#125; write(ans); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; CF889E Mod Mod Mod神仙题……即使有tyb带我依然搞了很久；不知道为什么全世界都是秒懂，直到现在都感觉有些别扭 先扔几个结论，都很好证明：【被更小的数模，只有log次】、【最优方案一定有某个余数为ai-1，否则整体+1即可】$$\begin{aligned}&amp; 首先这个a可以处理为一个递减的，然后为了方便我们设 x_i=X\%a_1\%a_2…\%a_i，ans_i=\sum_{t=1}^i x_t \\&amp; 然后非常关键的一步是， 将ans_i表示为 ix_i+S_i，即把前面的x多出来的部分放在S_i里面 \\&amp; 然后定义一个 g(i,mx)，表示使得 \forall x_i \in[1,mx],S_i \geq g(i,mx)的最大g \\&amp; g(1,a_1-1)=0,ANS=*{max} jn+g(n,j)（注意这里不一定对应，但g是个不递增的函数，所以不会算错） \\&amp; 考虑怎么转移，设 A=a*{i+1}，然后只需改变mx \geq A的部分 \\&amp; g(i,mx)+i(mx-mx\%A) \to g(i+1,mx\%A) （推导可考虑把x_{i+1}补上去然后化一下形式）\\&amp; g(i,mx)+i(\lfloor \frac{mx+1}{A} \rfloor A-A) \to g(i+1,A-1) （找到最大的的?A-1，然后同上推导）\\&amp; 搞个map啥的维护一下，时间复杂度为 O(nlognlogA)\end{aligned}$$ 1234567891011121314151617181920212223ll a[MAX_N];map&lt;ll,ll&gt; g;typedef map&lt;ll,ll&gt;::iterator IT;void main()&#123; int n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread();//实际实现不需要处理 g[a[1]-1]=0; for(int i=1;i&lt;n;i++) &#123; ll lstg=-1,A=a[i+1]; for(IT it=g.lower_bound(A);it!=g.end();it++) &#123; ll mx=it-&gt;FR,gg=it-&gt;SE; g[mx%A]=max(g[mx%A], (mx-mx%A)*i+gg ); g[A-1]=max(g[A-1], ((mx+1-A)/A)*A*i+gg ); if(g.count(lstg)) g.erase(g.find(lstg));lstg=it-&gt;FR; &#125; if(g.count(lstg)) g.erase(g.find(lstg)); &#125; ll ans=0; for(IT it=g.begin();it!=g.end();it++) ans=max(ans, it-&gt;FR*n+it-&gt;SE ); write(ans);&#125; CF1155F Delivery Oligopoly 【Snoi2013】Quare这个模型似乎挺经典的 考虑如何将一个边双分解，首先一个点是边双，然后加入一条两端都连向当前连通块的链后依然是边双 $设f(S)=当前边双集合为S的最小代价,g(S,x,y)表示一条两端为x、y的链的最小代价$ 算法复杂度为 $O(2^nn^3+3^nn^2)$ 常数极小，可通过本题 重边、输出方案啥的处理方法都很简单，就不细说了 HDU6115 Factory考虑根号分治，对于两个都&lt;T的询问用虚树合并+dp计算，否则枚举每个大块计算答案，这个部分换根即可线性，复杂度为 $O(n \sqrt n)$ 下面这份代码在根号内还带个log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; vc&lt;pr&gt; to[MAX_N];int dis[MAX_N],dfn2[MAX_N],dep2[MAX_N];int gogo[MAX_N];//向上的边权 int mp[2*MAX_N][21],pp=0,dfn[MAX_N];int gmin(int x,int y)&#123;return dep2[x]&lt;dep2[y]?x:y;&#125; void dfs(int x,int fa) &#123; dep2[x]=dep2[fa]+1; mp[++pp][0]=x;dfn[x]=pp; for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t].FR,c=to[x][t].SE;if(y==fa) continue; dis[y]=dis[x]+c;dfs(y,x);gogo[y]=c; mp[++pp][0]=x; &#125; dfn2[x]=pp; &#125; int lg[MAX_N*2],bin[100]; int getlca(int x,int y) &#123; x=dfn[x],y=dfn[y];if(x&gt;y) swap(x,y); int t=lg[y-x+1];return gmin(mp[x][t],mp[y-bin[t]+1][t]); &#125; int getdis(int x,int y)&#123;return dis[x]+dis[y]-2*dis[getlca(x,y)];&#125; bool cmp(int a,int b)&#123;return dfn[a]&lt;dfn[b];&#125; bool in(int fa,int x)&#123;return dfn[fa]&lt;=dfn[x] and dfn[x]&lt;=dfn2[fa];&#125; vc&lt;int&gt; on[MAX_N]; vc&lt;int&gt; ss[MAX_N];int id[MAX_N]; int preans[350][MAX_N]; priority_queue&lt; pr,vc&lt;pr&gt;,greater&lt;pr&gt; &gt; q; int dep[MAX_N];bool v[MAX_N]; int solve1(int now) &#123; while(q.size()) q.pop();memset(dep,0x3f,sizeof dep);memset(v,0,sizeof v); for(int t=0;t&lt;(int)ss[now].size();t++) q.push(MP(0,ss[now][t])),dep[ss[now][t]]=0; while(q.size()) &#123; int x=q.top().SE;q.pop(); if(v[x]) continue;v[x]=1; for(int t=0;t&lt;(int)on[x].size();t++) chmin(preans[id[now]][on[x][t]],dep[x]); for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t].FR,c=to[x][t].SE; chmin(dep[y],dep[x]+c);q.push(MP(dep[y],y)); &#125; &#125; return 0; &#125; stack&lt;int&gt; sta; int fa[MAX_N],fm[MAX_N];vc&lt;int&gt; son[MAX_N]; int f[MAX_N]; void dfs1(int x) &#123; f[x]=INF;if(fm[x]==0) f[x]=0; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t],c=gogo[y];dfs1(y); chmin(f[x],f[y]+c); &#125; &#125; void insert(pr &amp;now,int num) &#123; if(num&lt;=now.FR) now.SE=now.FR,now.FR=num; else chmax(now.SE,num); &#125; int getnum(pr now,int num)&#123;return now.FR==num?now.SE:now.FR;&#125; int ans; void dfs2(int x,int tt) &#123; pr tmp=MP(tt,INF);if(fm[x]==0) insert(tmp,0); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t],c=gogo[y]; insert(tmp,f[y]+c); &#125; if(fm[x]==1) chmin(ans, tmp.FR ); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t],c=gogo[y]; dfs2(y,getnum(tmp,f[y]+c)+c); &#125; &#125; vc&lt;int&gt; gg; int solve2(int a,int b) &#123; while(sta.size()) sta.pop(); int n=ss[a].size(),m=ss[b].size(); int p1=0,p2=0;gg.clear(); for(int t=0;t&lt;n+m;t++) &#123; int now; if(p2==m or (p1&lt;n and dfn[ss[a][p1]]&lt;=dfn[ss[b][p2]]) ) now=ss[a][p1++],fm[now]=0; else now=ss[b][p2++],fm[now]=1; if(sta.size() and sta.top()==now) return 0;//重复 int lst=0;while(sta.size() and !in(sta.top(),now)) lst=sta.top(),sta.pop(); if(!lst) ; else &#123; int lca=getlca(lst,now); if(!sta.size()) sta.push(lca),gg.PB(lca),fm[lca]=2,fa[lca]=0,fa[lst]=fa[now]=lca; else if(sta.top()!=lca and now!=lca) fa[lca]=sta.top(),sta.push(lca),gg.PB(lca),fm[lca]=2,fa[lst]=fa[now]=lca; &#125; if(sta.size()) fa[now]=sta.top(); else fa[now]=0;sta.push(now);gg.PB(now); &#125; while(sta.size()&gt;1) sta.pop();int rt=sta.top();fa[rt]=0; for(int t=0;t&lt;(int)gg.size();t++) &#123;int x=gg[t];son[fa[x]].PB(x),gogo[x]=getdis(fa[x],x);&#125; ans=INF;dfs1(rt); dfs2(rt,INF); for(int t=0;t&lt;(int)gg.size();t++) son[fa[gg[t]]].clear(); return ans; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;40;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N*2;i++) lg[i]=lg[i&gt;&gt;1]+1; int T=qread(); while(T--) &#123; for(int i=0;i&lt;MAX_N;i++) to[i].clear(),ss[i].clear(),on[i].clear(); int n=qread(),m=qread(); for(int i=1;i&lt;n;i++)&#123;int x=qread(),y=qread(),c=qread();to[x].PB(MP(y,c));to[y].PB(MP(x,c));&#125; dfs(1,0); for(int t=1;t&lt;=20;t++) for(int i=1;i&lt;=pp-bin[t]+1;i++) mp[i][t]=gmin(mp[i][t-1],mp[i+bin[t-1]][t-1]); int kk=0; for(int i=1;i&lt;=m;i++) &#123; int k=qread(); while(k--) &#123;int x=qread();ss[i].PB(x);on[x].PB(i);&#125; sort(ss[i].begin(),ss[i].end(),cmp);ss[i].resize(unique(ss[i].begin(),ss[i].end())-ss[i].begin()); kk+=ss[i].size(); &#125; memset(preans,0x3f,sizeof preans); int qq=qread(),lstans=0; int T=sqrt(kk*log2(qq)),cnt=0; for(int i=1;i&lt;=m;i++) if((int)ss[i].size()&lt;=T) id[i]=0; else id[i]=++cnt,solve1(i); while(qq--) &#123; int a=qread(),b=qread(); if(a==b) write2(lstans=0); else if(!id[a] and !id[b]) write2(lstans=solve2(a,b)); else &#123; if(!id[a]) swap(a,b); write2(lstans=preans[id[a]][b]); &#125; &#125; &#125; &#125;&#125;;signed main()&#123; //freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125; GDKOI2018D2T4那时候啥都不会的我似乎乱搞这题搞了很久……所以想再做一次，结果又还是不会 首先我们看完后很自然的想法是直接 $ans=\sum_{i=1}^n\frac{S2(L,i) P_n^i}{n-i+1} $ 然后可以得到80分，但似乎是死路一条了…… 考虑题目有什么性质没有利用，即 $\frac{1}{k+1}$ 考虑一个式子： $(1-1)^{k+1}=\sum_{i=0}^{k+1} (-1)^{i+1}C_{k+1}^{i+1}-&gt;\frac{1}{k+1}=\sum_{i=0}^k (-1)^iC_k^i \frac{1}{i+1}$ $ans=\sum_{i=0}^{n-1} (-1)^iC_n^i \frac{1}{i+1} (n-i)^L$ 幂函数是完全积性函数，可以线筛 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=998244353; void add(ll &amp;x,ll y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv2(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=5e6+10; bool mark[MAX_N];int prn=0,pp[MAX_N],nk[MAX_N]; void pre(int nn) &#123; nk[1]=1; for(int i=2;i&lt;MAX_N;i++) &#123; if(!mark[i]) pp[++prn]=i,nk[i]=qpower(i,nn); for(int j=1;j&lt;=prn and (ll)i*pp[j]&lt;MAX_N;j++) &#123; int t=i*pp[j];mark[t]=1; nk[t]=(ll)nk[i]*nk[pp[j]]%MOD; if(i%pp[j]==0) break; &#125; &#125; &#125; ll fac[MAX_N],inv[MAX_N],facinv[MAX_N]; ll C(int n,int m)&#123;return fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;&#125; void main() &#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; inv[1]=1;for(int i=2;i&lt;MAX_N;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=facinv[i-1]*inv[i]%MOD; int n=qread(),L=qread();pre(L); ll ans=0; for(int i=0,t=1;i&lt;=n-1;i++,t=-t) add(ans, (ll)t*C(n,i)*inv[i+1]%MOD*nk[n-i]%MOD ); write((ans+MOD)%MOD); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[atcTenka1-2019]]></title>
    <url>%2Fposts%2F23f2.html</url>
    <content type="text"><![CDATA[atcTenka1-2019好题：F D Three Colors$(a&gt;b&gt;c)合法当且仅当 a&lt;\lceil \frac{sum}{2} \rceil$ ，考虑容斥掉非法情况 先考虑一个 $n^4$ 的做法，$dp(i,a)=选了i个数，和为a的方案数$ 那么 $ans=\sum_{S \geq \lceil \frac{sum}{2} \rceil} \sum_i 3f(i,S)2^{n-i}$ 但当S为偶数，a=b=num/2的情况会被减两次，加回来即可 然后仔细观察一下上面的式子，发现只要一开始存在$2^n$的系数，在增加数的时候/2即可 123456789101112131415int f[MAX_N*MAX_N],g[MAX_N*MAX_N];void main()&#123; int n=qread(),sum=0;f[0]=qpower(2,n);g[0]=1; for(int i=1;i&lt;=n;i++) &#123; int aa=qread(); for(int s=sum;s&gt;=0;s--) add(f[s+aa],(ll)f[s]*inv2%MOD),add(g[s+aa],g[s]); sum+=aa; &#125; int ans=qpower(3,n); for(int a=ceil(sum/2.0);a&lt;=sum;a++) add(ans,-(ll)f[a]%MOD*3%MOD); if(sum%2==0) add(ans,(ll)g[sum/2]*3%MOD); write((ans+MOD)%MOD);&#125; 还有一种做法，也是考虑容斥，容斥掉 $a-b-c \geq 0$ 的部分，然后这个部分很好求，因为a一定是最大值，不会被替代 和上面一样要考虑a=b=num/2的情况 1234567891011121314151617181920212223int f[MAX_N][MAX_N*MAX_N*2],g[MAX_N][MAX_N*MAX_N];#define F(i,j) f[i][MAX_N*MAX_N+j]#define G(i,j) g[i][MAX_N*MAX_N+j]void main()&#123; int n=qread(),sum=0;F(0,0)=1;G(0,0)=1; for(int i=1;i&lt;=n;i++) &#123; int aa=qread(); for(int s=-sum;s&lt;=sum;s++) &#123; add(F(i,s+aa),F(i-1,s)); add(F(i,s-aa),1ll*F(i-1,s)*2%MOD); add(G(i,s+aa),G(i-1,s)); add(G(i,s-aa),G(i-1,s)); &#125; sum+=aa; &#125; int ans=qpower(3,n); for(int s=0;s&lt;=sum;s++) add(ans,-(ll)F(n,s)*3%MOD); if(sum%2==0) add(ans,(ll)G(n,0)*3%MOD); write((ans+MOD)%MOD);&#125; E Polynomial Divisors$\forall f(i)=0(\%p)$ 在 $p|gcd(ai)$ 时显然成立，考虑如何验证一个p 多项式必定含有因式 $\prod_{t=0}^{p-1} (x-t)$ ，使用【威尔逊定理】、【任意模数下存在逆元的数，其逆元互不相同】这两个结论，可化为 $x^p-x$ 【任意模数下存在逆元的数，其逆元互不相同】的证明： $ax=1(\%p)，那么把其一作为未知数，根据裴蜀定理另一个与p互质​$ 实现的时候，化一下式子，发现只需要判断【%下系数剩余系=0】即可；根据上面的推导，只要判断 $p \leq n$ 即可(upd：需要判断a[0]%p=0，我不太清楚为什么) 12345678910111213141516171819202122232425262728293031int n,a[MAX_N];bool check(int p)&#123; for(int t=0;t&lt;p-1;t++) &#123; int sum=0;for(int i=t;i&lt;=n;i+=p-1) sum=(sum+a[i])%p; if(sum) return 0; &#125; return 1;&#125;bool isp(int n)&#123; for(int i=2;i*i&lt;=n;i++) if(n%i==0) return 0; return 1;&#125;int gcd(int x,int y)&#123;return y==0?x:gcd(y,x%y);&#125;vc&lt;int&gt; ans;void main()&#123; n=qread();int d=0;for(int i=n;i&gt;=0;i--) a[i]=qread(),d=gcd(d,abs(a[i])); for(int i=2;(ll)i*i&lt;=d;i++) if(d%i==0)//debug 爆int &#123; ans.PB(i); while(d%i==0) d/=i; &#125; if(d&gt;1) ans.PB(d); for(int i=2;i&lt;=n;i++) if(a[0]%i==0 and isp(i) and check(i)) ans.PB(i); sort(ans.begin(),ans.end()); for(int t=0;t&lt;(int)ans.size();t++) if(t==0 or ans[t-1]!=ans[t]) write2(ans[t]);//debug&#125; F Banned X需要考虑12串的贡献，最后枚举长度塞0即可 $sum&lt;X$ $sum&gt;X，不能产生一个连续区间的和为某个 \geq sum 的偶数$ 如果存在这样的区间，那么不断删除2、删除两边的1就能产生0 那么枚举ln和sum 对于第一种，$C_{ln}^{sum-ln}​$ 对于第二种，$[(sum-X)\&amp;1]$，左右两侧都必须放足够多的2（$\lceil \frac{sum-ln}{2} \rceil$），然后中间就可以随便放了，即 $C_{ln-2\lceil \frac{sum-ln}{2} \rceil}^{2ln-sum}$ $ans=\sum C_n^{ln} f(ln)$ 时间复杂度 $O(n^2)$ 12345678910111213141516171819202122int C[MAX_N][MAX_N];void main()&#123; C[0][0]=1;for(int i=1;i&lt;MAX_N;i++)&#123;C[i][0]=1;for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;&#125; int n=qread(),X=qread();int ans=1; for(int ln=1;ln&lt;=n;ln++) &#123; int now=(X&amp;1 or X&gt;2*ln); for(int sum=ln;sum&lt;=2*ln-1;sum++) &#123; if(sum&lt;X) add(now,C[ln][sum-ln]); else if((sum-X)&amp;1) &#123; int cnt=(sum-X+1)/2;if(cnt*2&gt;=ln) continue; add(now,C[ln-2*cnt][2*ln-sum]); &#125; &#125; add(ans,(ll)now*C[n][ln]%MOD); &#125; write(ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20190423模拟赛]]></title>
    <url>%2Fposts%2F13ef.html</url>
    <content type="text"><![CDATA[侯爷爷的场 A现在给定n个数 ，找一个非空子集，使得这个子集的平均数减去中位数最大， $n \leq 2e5$ 请先思考后再展开 显然枚举中位数，然后显然长度是单峰的，选择方案显然是【中位数左边第一个往左若干，n往左若干】 说些小trick： 如果考虑集合大小为偶数的情况，那么一定左右两边第一个数都会被选；考虑反证，把中位数右边那个往左移，平均数的变化量一定比中位数的变化量小 其实既然想到上面这个，类似地可以发现，只有奇数个是有用的；考虑反证，把中位数右边那个丢掉，同上；而且这两个都让ln的上限增大了（选择更多） 实现直接二分变化量即可，时间复杂度为 $O(nlogn)$ 1234567891011121314151617181920212223ll a[MAX_N],sum[MAX_N];int n;ll getsum(int l,int r)&#123;return sum[r]-sum[l-1];&#125;double getf(int i,int ln)&#123;return 1.0*(getsum(i-ln,i)+getsum(n-ln+1,n))/(2*ln+1);&#125;void main()&#123; n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread();sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i]; double mx=0; for(int i=1;i&lt;=n;i++) &#123; int l=0,r=min(i-1,n-i); while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; double x=getf(i,mid);mx=max(mx,x-a[i]);if(l==r) break; double y=getf(i,mid+1);mx=max(mx,y-a[i]); if(x&lt;=y) l=mid+1; else r=mid-1; &#125; &#125; printf("%.5lf",mx);&#125; B有两个长度为n的数组和2n个数，每个数可以填在第一个数组的ai处，也可以填在第二个数组的bi处，数组上每个位置只能填一个数。求最小代价（两个数组的和的差的绝对值），如果无解（不能填满）输出-1。 $n \leq 3e4,num\leq 15$ 请先思考后再展开 建棵2n个点的基环树，然后假设树边是直接得到的，环上就只有两个方向，考虑对A-B的贡献（不考虑绝对值），就是X和-X，直接背包 背包有两种选择，直接分治fft、根号的背包（套路已更新）；然后第二种常数更小，随机数据飞快，第一种会被卡常 C给出一个 $n \times m$ 的矩形，每个位置可以填上 $[1,c]$ 中的任意一个数，要求填好后任意两行不完全相等，任意两列不完全相等，求方案数 $n,m,c \leq 5e3$ 请先思考后再展开 经典套路题$g(m)表示保证行合法=(c^m)^{\underline n}$f(m)表示都合法，考虑用f表示g设有k组本质不同的列，那么相当于只有k列要求满足行的条件$g(m)=\sum_{k=0}^m S2(m,k)f(k)$反演得$f(m)=\sum\limits_{i=0}^m(-1)^{m-i}\begin{bmatrix}m\i \end{bmatrix}g(i)$ D给定一个n个点m条边的有向图，将这个图复制成e份，任意两份之间没有连边，求复制得到的图的补图的哈密顿路径条数%998244353。$n \leq 14,e \leq 5e4$ 请先思考后再展开 初看感觉极不可做，会觉得哈密顿这种东西只能指数级搞；但细看数据范围发现n很小，那估计就是利用复制这个性质去搞。 问题等价于e种颜色，每种n个球，相邻不同色或同色无边的排列方案数 考虑容斥，通常我们都会希望设一个f为恰好g为至少，然后希望转移系数带有组合数什么的便于反演 $g(n)=\sum_{i=n}^N C_i^n f(i)$ 那么假设某个方案有恰好k段连续的非法边（其实这里思路清奇），那么我们要假装没看到一部分来产生组合的贡献 每个连通块是相同的，直接卷起来，若总共固定了成k段连续的块，方案数为可重集即 $\frac{k!}{\prod k_t!}$，此处时间为 $O(nelog)$ 考虑得到之后如何统计答案，k段则有ne-k条边，系数为 $(-1)^{ne-k}$ 现在考虑同色无边这个限制，n很小直接状压dp求出生成函数的系数即可，此处时间为 $O(2^nn^3)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=998244353; void add(ll &amp;x,ll y)&#123;x+=y;if(x&gt;=MOD)x-=MOD;if(x&lt;=-MOD)x+=MOD; &#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=4e6+10; int bin[50];ll fac[MAX_N]; struct NTT &#123; int R[MAX_N];void preR(int ln)&#123;for(int i=1;i&lt;ln;i++)R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|( (i&amp;1)*bin[(int)log2(ln)-1] ); &#125; ll w[2][MAX_N]; void prew(int ln) &#123; ll now0=qpower(3,(MOD-1)/ln),now1=inv(now0);w[0][0]=w[1][0]=1; for(int i=1;i&lt;ln;i++) w[0][i]=w[0][i-1]*now0%MOD,w[1][i]=w[1][i-1]*now1%MOD; &#125; void DFT(ll A[],int n,int f) &#123; for(int i=1;i&lt;n;i++) if(i&gt;R[i]) swap(A[i],A[R[i]]); for(int ln=1;ln&lt;=n/2;ln*=2) for(int st=0;st&lt;n;st+=2*ln) for(int k=0;k&lt;ln;k++) &#123; ll x=A[st+k],y=w[f][k*(n/ln/2)]*A[st+ln+k]%MOD; A[st+k]=(x+y)%MOD;A[st+ln+k]=(x-y)%MOD; &#125; &#125; &#125;ntt; ll A[MAX_N]; void solve(int e,int n) &#123; for(int k=0;k&lt;=n;k++) A[k]=A[k]*inv(fac[k])%MOD; int ln=1;while(ln&lt;=n) ln*=2;ntt.preR(ln);ntt.prew(ln); ntt.DFT(A,ln,0); for(int i=0;i&lt;ln;i++) A[i]=qpower(A[i],e); ntt.DFT(A,ln,1); ll ans=0; for(int k=0,t=(n&amp;1)?-1:1;k&lt;=n;k++,t=-t) add(ans,A[k]*inv(ln)%MOD*t*fac[k]%MOD); write((ans+MOD)%MOD); &#125; const int MAX_M=15; int mp[MAX_M][MAX_M]; ll f[1&lt;&lt;MAX_M][MAX_M][MAX_M];//f(S,k,lst) void dp(int n) &#123; for(int i=0;i&lt;n;i++) f[bin[i]][1][i]=1; for(int S=0;S&lt;bin[n];S++) for(int k=0;k&lt;=n;k++) for(int lst=0;lst&lt;n;lst++) if(f[S][k][lst]) for(int j=0;j&lt;n;j++) if((S&amp;bin[j])==0) &#123; add(f[S|bin[j]][k+1][j],f[S][k][lst]); if(mp[lst][j]) add(f[S|bin[j]][k][j],f[S][k][lst]); &#125; for(int k=0;k&lt;=n;k++) for(int lst=0;lst&lt;n;lst++) add(A[k],f[bin[n]-1][k][lst]); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; int e=qread(),n=qread(),m=qread(); while(m--)&#123;int x=qread()-1,y=qread()-1;mp[x][y]=1;&#125; dp(n);solve(e,e*n); &#125;&#125;;signed main()&#123; //freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GDOI2019滚粗记]]></title>
    <url>%2Fposts%2F46b6.html</url>
    <content type="text"><![CDATA[GDOI2019滚粗记 day1（队线150，最高400）看完4题没有一道会做的，感觉难度意料之中 t1写了个高维前缀和的20pt，想过容斥但没有意识到很好搞……考虑了一堆没用的东西 t2发现有40，但全程分就没高过就没有打暴力的心思了 t3看完想了点东西就跑路了 t4先想了个50的贪心，然后发现上下界可能能A?就yy+打了1h（似乎没写错），然后我的建图反复思考后蜜汁自信认为是对的，只不过有个负环的问题，然后就感觉后面那个可能要搞点特技消除负环啥的，不太会，就搞这50了；然后过了样例后写拍直接gg，此时时间已经不多了，只能瞎jb再看看前面，然后写贪心；手动对拍（因为造数据可能无解）了2和3似乎都没事，最后5min换成5就GG了，调的中途还以为是dfs写错了又浪费了点时间，最后几秒忽然意识到是哪里写错了真是爽快；出考场后都不想说话了 中午感觉我校一片黑暗外校众人一片光明人均两题，技不如人没什么好说的 看到成绩表的时候真的惊呆了，本来感觉怎么说队线要250吧，然后OZY4题暴力直接rk16 似乎爆分最多的是曾老师，直接300-&gt;10，原因不太清楚 t1：chd给60分的容斥加个mx&lt;0的剪枝就艹过去了是什么操作； 正解是跑完高维前缀和后，考虑求 $max(a_i,b_i)=c_i$ 这东西其实就是集合幂级数的平方，逆前缀和回去，然后后缀和即可解决询问3，询问4同理 t4：正常人的构图都是左边行右边列中间连边跑最小费用上下界可行流；然后后面50就是要把-1的环消除，并没有听懂 day2又是一题不会滚粗，但鉴于昨天的情况+后面一直挂机决定写写暴力，55+0+30+35，几乎没拍没挂分挺意外的 OZY又是四题暴力然后也是挂了一点分，不过即使没挂也似乎没在队内，果然这样真的不可行； 感觉很多人不挂分就有前30了，但想要到队内则是完全不同的难度； 所以这次我校连省队都没有了，唯一能看的就是xgc切了两题]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【51nod1222】最小公倍数计数]]></title>
    <url>%2Fposts%2Fb91b.html</url>
    <content type="text"><![CDATA[Source51nod1222 Solution请先思考后再展开 tjz$O(n^{\frac{2}{3}})$（花了点时间，忘记第二个函数在x=0是没有定义的了） 洲阁筛、杜教筛做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e6+10; ll MOD; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll qpower(ll x,ll e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x)&#123;return qpower(x,MOD-2);&#125; bool mark[MAX_N];int prime[MAX_N/10],pp=0; int mu[MAX_N]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAX_N;i++) &#123; if(!mark[i]) prime[++pp]=i,mu[i]=-1; for(int j=1;j&lt;=pp and (ll)i*prime[j]&lt;MAX_N;j++) &#123; int t=i*prime[j];mark[t]=1; if(i%prime[j]==0) &#123;mu[t]=0;break;&#125; mu[t]=-mu[i]; &#125; &#125; &#125; ll solve(ll n) &#123; ll ans=0; for(ll d=1;d*d&lt;=n;d++) &#123; ll sum=0; for(ll D=1;D*D*D&lt;=n/(d*d);D++) for(ll i=D;i*i&lt;=n/(d*d*D);i++) &#123; ll tmp=n/(d*d*D*i); ll a=tmp-i,b=(tmp&gt;=i); if(D==i) sum+=b+a*3; else sum+=b*3+a*6; &#125; ans=ans+sum*mu[d]; &#125; return ans; &#125; void main() &#123; pre(); ll l=qread(),r=qread(); write((solve(r)-solve(l-1)+r-l+1)/2); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu3768】简单的数学题]]></title>
    <url>%2Fposts%2F8859.html</url>
    <content type="text"><![CDATA[Sourceluogu3768 Hint请先思考后再展开 $\varphi \ast I = id$$\sum i^k$ 是多项式，可高斯消元求通项公式 Solution请先思考后再展开 yyb补充一下复杂度，尽管有根号次询问，但都是n/i的各种取值下不同的i，尽管有整除但应该不会太多，所以记忆化后总复杂度是对的 这题有个类似的题hihocoder1456-zjp就是前面套了个模型转化 code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e7+10; ll MOD; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll qpower(ll x,ll e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x)&#123;return qpower(x,MOD-2);&#125; bool mark[MAX_N];int pp=0,prime[MAX_N/10]; ll f[MAX_N]; void pre() &#123; f[1]=1; for(int i=2;i&lt;MAX_N;i++) &#123; if(!mark[i]) prime[++pp]=i,f[i]=i-1; for(int j=1;j&lt;=pp and (ll)i*prime[j]&lt;MAX_N;j++) &#123; int t=i*prime[j];mark[t]=1; if(i%prime[j]==0)&#123;f[t]=f[i]*prime[j];break;&#125; f[t]=f[i]*(prime[j]-1); &#125; &#125; for(int i=1;i&lt;MAX_N;i++) f[i]=(f[i-1]+f[i]*i%MOD*i%MOD)%MOD; &#125; ll inv4;ll H(ll n)&#123;n%=MOD;return n*n%MOD*(n+1)%MOD*(n+1)%MOD*inv4%MOD;&#125; ll inv6;ll G(ll n)&#123;n%=MOD;return n*(n+1)%MOD*(n*2+1)%MOD*inv6%MOD;&#125; map&lt;int,ll&gt; hash; ll getF(ll n) &#123; if(n&lt;MAX_N) return f[n]; if(hash.count(n)) return hash[n]; ll ans=H(n); for(ll l=2,r;l&lt;=n;l=r+1) r=n/(n/l),ans=(ans-getF(n/l)*(G(r)-G(l-1))%MOD)%MOD; return hash[n]=ans; &#125; void main() &#123; MOD=qread();ll n=qread(); inv4=inv(4);inv6=inv(6);pre();getF(n); ll ans=0;for(ll l=1,r;l&lt;=n;l=r+1) r=n/(n/l),ans+=H(n/l)*(getF(r)-getF(l-1))%MOD; write((ans%MOD+MOD)%MOD); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【THUSC2015】解密运算]]></title>
    <url>%2Fposts%2F3a8.html</url>
    <content type="text"><![CDATA[SourceTHUSC2015bzoj4104 Hint请先思考后再展开 先考虑所有字符不同怎么做，然后考虑一下这道题的字符串的一些特性 Solution请先思考后再展开 首先根据.可以判断出最后一个字符是什么然后我们希望找到这个字符开头那个串的排名如果所有字符都不同，我们可以直接找到排名否则，考虑一下这个字符串的特性，那一定是按照开头这个字符排序，然后按照给出的顺序作为第二关键字]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>趣题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu6389】Go to school]]></title>
    <url>%2Fposts%2F5d54.html</url>
    <content type="text"><![CDATA[SourceHDU的输入可能和代码不同然后被卡精了并没有acHdu6389 Hint请先思考后再展开 $E(x)=\int_{1}^{mx} P(x \leq t) dt$然后对于n个[0,R]的随机变量， $E(min x)=后面那个的积=\frac{R}{n+1}$ 然后直接搞的话会有个min，比较麻烦把所有船按照Li从小到大排序，然后分情况讨论一下 Solution请先思考后再展开 考虑第一个在T之前的船i第一部分， $L_i \leq T$那么前面的就是钦定不出现， $\prod 1-\frac{min(T,L_i)}{m}$然后后面的设有k个在T前出现$P=1-\frac{L_i}{m},C_{n-i}^k P^k (1-P)^{n-i-k} \frac{L_i}{k+2}$ 第二部分， $L_i&gt;T$类似，不细说 第三部分，所有人都在T后面很简单 50pt：1234567891011121314151617181920212223int n=qread(),m=qread(),q=qread(),a=qread(),b=qread();for(int i=1;i&lt;=n;i++) L[i]=qread();sort(L+1,L+n+1);while(q--)&#123; int T=qread(); pre[0]=1;for(int i=1;i&lt;=n;i++) pre[i]=pre[i-1]*(m-min(T,L[i]))/m; double ans=(double)(T+b)*pre[n]; for(int i=1;i&lt;=n;i++) &#123; if(L[i]&lt;=T) &#123; double P=(double)L[i]/m; for(int k=0;k&lt;=n-i;k++) ans+=C[n-i][k]*pow(P,k+1)*pow(1-P,n-i-k)*L[i]/(k+2)*pre[i-1]; &#125; else &#123; double P=(double)T/m; for(int k=0;k&lt;=n-i;k++) ans+=C[n-i][k]*pow(P,k+1)*pow(1-P,n-i-k)*T/(k+2)*pre[i-1]; &#125; &#125; printf("%.5Lf\n",ans+a*(1-pre[n]));&#125; 然后第一部分优化掉k，第二部分优化掉i即可时间复杂度 $O(n^2+qn)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e3+10; const ll MOD=998244353; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int L[MAX_N]; double C[MAX_N][MAX_N],pre[MAX_N],pre2[MAX_N],f[MAX_N]; void main() &#123; C[0][0]=1;for(int i=1;i&lt;MAX_N;i++)&#123;C[i][0]=1;for(int j=1;j&lt;=i;j++) C[i][j]=C[i-1][j-1]+C[i-1][j];&#125; int n=qread(),q=qread(),m=qread(),a=qread(),b=qread(); for(int i=1;i&lt;=n;i++) L[i]=qread();sort(L+1,L+n+1); for(int i=1;i&lt;=n;i++) &#123; double P=(double)L[i]/m; for(int k=0;k&lt;=n-i;k++) f[i]+=C[n-i][k]*pow(P,k+1)*pow(1-P,n-i-k)*L[i]/(k+2); &#125; while(q--) &#123; int T=qread(); pre[0]=1;for(int i=1;i&lt;=n;i++) pre[i]=pre[i-1]*(m-min(T,L[i]))/m; pre2[0]=1;for(int i=1;i&lt;=n;i++) pre2[i]=pre2[i-1]+pre[i]; double ans=(T+b)*pre[n]+a*(1-pre[n]); int pos=0;while(pos+1&lt;=n and L[pos+1]&lt;=T) pos++; for(int i=1;i&lt;=pos;i++) ans+=f[i]*pre[i-1]; double P=(double)T/m; for(int k=1;k&lt;=n-pos;k++) ans+=C[n-pos][k]*pow(P,k)*pow(1-P,n-pos-k)*T/(k+1)*pre[pos]; printf("%.6Lf\n",ans); &#125; &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2015】组合数学]]></title>
    <url>%2Fposts%2Fad32.html</url>
    <content type="text"><![CDATA[SourceTJOI2015bzoj5481 Hint请先思考后再展开 转dag，求最小链覆盖 Solution请先思考后再展开 根据Dilworth定理，最小链覆盖=最小反链然后每个点按权值拆开来，他们一定在同一条反链上然后他一定是形如一个递增序列的那么dp(i,j)表示结尾在(i,j)右上角的最长反链然后就可以直接dp了 1234567891011121314int a[MAX_N][MAX_N];ll f[MAX_N][MAX_N];void main()&#123; int T=qread(); while(T--) &#123; int n=qread(),m=qread();memset(f,0,sizeof f); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a[i][j]=qread(); for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=1;j--) f[i][j]=max( max(f[i-1][j],f[i][j+1]),f[i-1][j+1]+a[i][j] ); write2(f[n][1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>Dilworth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PA2014】Final Zadanie]]></title>
    <url>%2Fposts%2F2519.html</url>
    <content type="text"><![CDATA[SourcePA2014bzoj5481 Hint请先思考后再展开 众所周知这个C可以二次扫描求出来，形式为Ci=xi+yi但现在是已知C求a，上面这东西我不知道怎么求此时不妨换个角度，考虑从x移动到fa，C有怎样的变化，列一些方程 Solution请先思考后再展开 设tot为子树人数和$2tot_x=tot_1+C_{fa}-C_x$此时只有n-1个方程，玩玩样例发现不对，发现忽略了一个基本方程$C_1=\sum (tot_x-\sum tot_{son})dis(x,1)=\sum_{x&gt;1} tot_x$于是可以直接求出 $tot_1$于是其他tot也可以直接求了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;double,double&gt; #define PB push_back #define vc vector void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=3e5+10; const ll MOD=2542; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int ff[MAX_N];vector&lt;int&gt; son[MAX_N]; void dfs(int x,int fa) &#123; ff[x]=fa; for(int t=0;t&lt;(int)son[x].size();t++) if(son[x][t]!=fa) dfs(son[x][t],x); &#125; int C[MAX_N]; ll tot[MAX_N]; void main() &#123; int n=qread(); for(int i=1;i&lt;n;i++)&#123;int x=qread(),y=qread();son[x].PB(y);son[y].PB(x);&#125;dfs(1,0); for(int i=1;i&lt;=n;i++) C[i]=qread(); ll sum=0;for(int x=2;x&lt;=n;x++) sum+=C[ff[x]]-C[x];tot[1]=(2*C[1]-sum)/(n-1); for(int x=2;x&lt;=n;x++) tot[x]=(tot[1]+C[ff[x]]-C[x])/2; for(int x=1;x&lt;=n;x++) &#123; ll now=tot[x]; for(int t=0;t&lt;(int)son[x].size();t++) if(son[x][t]!=ff[x]) now-=tot[son[x][t]]; write1(now); &#125; &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>趣题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu6403】Card]]></title>
    <url>%2Fposts%2Fb524.html</url>
    <content type="text"><![CDATA[Source目前过不去，留坑……Hdu6403 Hint请先思考后再展开 转化为图：数字为点，棋子为边 Solution请先思考后再展开 这道题在模拟赛的时候码了整场……主要是我的写法比较蠢、无脑不过这道题直接搞了我8h，不想再看别人的做法了，自闭了……做法没什么好讲的时间复杂度，手写hash的话是线性的这份代码常数略大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; const ll MOD=998244353; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; struct DSU &#123; int fa[MAX_N],siz[MAX_N];void clear()&#123;for(int i=0;i&lt;MAX_N;i++) fa[i]=i,siz[i]=1;&#125; int findfa(int x)&#123;return fa[x]==x?x:fa[x]=findfa(fa[x]);&#125; void merg(int x,int y) &#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) siz[fx]+=siz[fy],fa[fy]=fx; &#125; &#125;dsu; struct Edge&#123;int x,y,a,b;&#125;; vector&lt;Edge&gt; edge[MAX_N]; int sum;ll all; map&lt;pr,pr&gt; hash; int gg(int x,int y,int k) &#123; if(x&lt;y) return k==0?hash[MP(x,y)].SE:hash[MP(x,y)].FR; return k==0?hash[MP(y,x)].SE:hash[MP(y,x)].FR; &#125; bool zz[MAX_N]; vector&lt;int&gt; son[MAX_N]; int f[MAX_N][2];ll g[MAX_N][2]; void treedp(int x,int fa) &#123; if(zz[x]) f[x][0]=INF,g[x][0]=0,f[x][1]=0,g[x][1]=1; else f[x][0]=f[x][1]=0,g[x][0]=g[x][1]=1; bool hs=0; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; treedp(y,x); if(gg(x,y,0)+gg(x,y,1)==1) &#123; pr tmp[3]; if(hs or zz[x]) tmp[0]=MP(f[x][1]+f[y][0]+gg(x,y,1),g[x][1]*g[y][0]%MOD);if(tmp[0].SE==0) tmp[0].FR=INF; tmp[1]=MP(f[x][0]+f[y][0]+gg(x,y,0),g[x][0]*g[y][0]%MOD);if(tmp[1].SE==0) tmp[1].FR=INF; tmp[2]=MP(f[x][0]+f[y][1]+gg(x,y,0),g[x][0]*g[y][1]%MOD);if(tmp[2].SE==0) tmp[2].FR=INF; sort(tmp,tmp+3);int ta=tmp[0].FR;ll tb=0;for(int i=0;i&lt;3;i++) if(tmp[i].FR==tmp[0].FR) tb+=tmp[i].SE; f[x][1]=ta,g[x][1]=tb%MOD; f[x][0]=f[x][0]+f[y][0]+gg(x,y,1),g[x][0]=g[x][0]*g[y][0]%MOD; &#125; else &#123; int a=gg(x,y,0),b=gg(x,y,1); f[x][1]=f[x][0]+f[y][0]+(a!=b),g[x][1]=g[x][0]*g[y][0]%MOD;if(a!=b) g[x][1]=g[x][1]*2%MOD; f[x][0]=INF,g[x][0]=0; &#125; hs=1; &#125; if(!hs and !zz[x]) g[x][1]=0; if(g[x][0]==0) f[x][0]=INF;if(g[x][1]==0) f[x][1]=INF; &#125; bool solvetree(int rt) &#123; for(int t=0;t&lt;(int)edge[rt].size();t++) if(edge[rt][t].a+edge[rt][t].b&gt;2) &#123;puts("-1 -1");return 0;&#125; treedp(rt,rt); if(f[rt][0]==f[rt][1] and f[rt][0]==0) sum+=f[rt][0],all=all*g[rt][0]%MOD; else if(f[rt][0]==f[rt][1]) sum+=f[rt][0],all=all*(g[rt][0]+g[rt][1])%MOD; else if(f[rt][0]&lt;f[rt][1]) sum+=f[rt][0],all=all*g[rt][0]%MOD; else if(f[rt][0]&gt;f[rt][1]) sum+=f[rt][1],all=all*g[rt][1]%MOD; if(sum&gt;=INF) &#123;puts("-1 -1");return 0;&#125; return 1; &#125; stack&lt;int&gt; sta;bool v[MAX_N];vector&lt;int&gt; hh;bool zzh;bool on[MAX_N]; bool search(int x,int fa) &#123; v[x]=1;sta.push(x); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; if(v[y]) &#123; while(sta.top()!=y) hh.PB(sta.top()),on[sta.top()]=1,sta.pop(); on[y]=1;hh.PB(y);return 1; &#125; else if(search(y,x)) return 1; &#125; sta.pop(); return 0; &#125; int pos[MAX_N],dep[MAX_N]; void dfs(int x,int fa) &#123; dep[x]=dep[fa]+1;if(zz[x]) zzh=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa or on[y]) continue; dfs(y,x); &#125; &#125; bool solvetree2(int rt) &#123; for(int t=0;t&lt;(int)edge[rt].size();t++) if(edge[rt][t].a+edge[rt][t].b&gt;1) &#123;puts("-1 -1");return 0;&#125; while(sta.size()) sta.pop();hh.resize(0);search(rt,rt); for(int t=0;t&lt;(int)hh.size();t++) on[hh[t]]=1,pos[hh[t]]=t; zzh=0; for(int t=0;t&lt;(int)hh.size();t++) dfs(hh[t],0); if(zzh) &#123;puts("-1 -1");return 0;&#125; int tmp=0,cc=0; for(int t=0;t&lt;(int)edge[rt].size();t++) &#123; int x=edge[rt][t].x,y=edge[rt][t].y; if(gg(x,y,1)) swap(x,y); if(on[x] and on[y]) tmp+=(pos[x]+1==pos[y] or (pos[x]==(int)hh.size()-1 and pos[y]==0)); else cc+=(dep[x]&gt;dep[y]); &#125; int ta=tmp,tb=hh.size()-ta; if(ta==tb) sum+=ta+cc,all=all*2; else sum+=min(ta,tb)+cc; return 1; &#125; void solve() &#123; hash.clear();memset(zz,0,sizeof zz);memset(on,0,sizeof on);memset(v,0,sizeof v); dsu.clear();sum=0,all=1;memset(dep,0,sizeof dep); for(int i=0;i&lt;MAX_N;i++) edge[i].resize(0); for(int i=0;i&lt;MAX_N;i++) son[i].resize(0); int n=qread();bool error=0; for(int i=1;i&lt;=n;i++) &#123; int y=qread(),x=qread(); if(x==y)&#123;if(!zz[x]) zz[x]=1; else error=1;&#125; else if(x&lt;y) hash[MP(x,y)].FR++; else hash[MP(y,x)].SE++; &#125; if(error) &#123;puts("-1 -1");return;&#125;//debug for(map&lt;pr,pr&gt;::iterator it=hash.begin();it!=hash.end();it++) &#123; int x=(*it).FR.FR,y=(*it).FR.SE;dsu.merg(x,y); son[x].PB(y);son[y].PB(x); &#125; for(map&lt;pr,pr&gt;::iterator it=hash.begin();it!=hash.end();it++) &#123; int x=(*it).FR.FR,y=(*it).FR.SE; edge[dsu.findfa(x)].PB( (Edge)&#123;x,y,(*it).SE.FR,(*it).SE.SE&#125; ); &#125; for(int i=1;i&lt;=2*n;i++) if(i==dsu.findfa(i)) &#123; int pt=dsu.siz[i],m=edge[i].size();if(pt==1) continue; if(m==pt-1) &#123;if(!solvetree(i)) return;&#125; else if(m==pt) &#123;if(!solvetree2(i)) return;&#125; else &#123;puts("-1 -1");return;&#125; &#125; if(sum==INF) puts("-1 -1"); else printf("%d %lld\n",sum,all); &#125; void main() &#123; int T=qread(); while(T--) solve(); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#549 div1]]></title>
    <url>%2Fposts%2Fa12f.html</url>
    <content type="text"><![CDATA[SourceCF#549div1 A The Beatles请先思考后再展开 阅读理解1234567891011121314151617181920212223ll gcd(ll x,ll y) &#123;return y==0?x:gcd(y,x%y);&#125;ll n,k;ll mi=LLINF,mx=0;void check(ll x,ll y)&#123; if(x&gt;y) y+=n*k; ll tmp=y-x; chmin(mi,n*k/gcd(n*k,tmp)); chmax(mx,n*k/gcd(n*k,tmp));&#125;ll gg(ll x)&#123;return (x+n*k)%(n*k);&#125;void main()&#123; n=qread(),k=qread(); ll a=qread(),b=qread(); for(ll t=0;t&lt;=n*k-1;t+=k) &#123; check(a,gg(t-b));check(k-a,gg(t-b)); check(a,gg(t+b));check(k-a,gg(t+b)); &#125; printf("%lld %lld",mi,mx);&#125; B Lynyrd Skynyrd请先思考后再展开 显然先把排列转化为求递增的序列一直在想怎么处理这个shift，想过复制到后面、从n向左右考虑，然后都搞不动但其实只要直接考虑每个位置作为开头就好了（我以为一般不能这么直接地考虑……）时间复杂度 $O(nlogn)$12345678910111213141516171819202122232425262728293031int a[MAX_N],num[MAX_N];int lst[MAX_N],nxt2[MAX_N];int bin[30],mm[MAX_N][20],nxt[MAX_N][20];int jump(int x,int k)&#123;for(int t=19;t&gt;=0;t--) if(k&amp;bin[t]) x=nxt[x][t];return x;&#125;void main()&#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n=qread(),m=qread(),q=qread(); for(int i=1;i&lt;=n;i++) a[qread()]=i; for(int i=1;i&lt;=m;i++) num[i]=a[qread()]; for(int i=1;i&lt;=n+1;i++) lst[i]=m+1;nxt[m+1][0]=m+1; for(int i=m;i&gt;=1;i--) &#123;lst[num[i]]=i,nxt[i][0]=lst[num[i]+1];if(num[i]==n) nxt2[i]=lst[1];&#125; for(int t=1;t&lt;20;t++) for(int i=1;i&lt;=m+1;i++) nxt[i][t]=nxt[nxt[i][t-1]][t-1]; for(int i=1;i&lt;=m;i++) &#123; int to=jump(i,n-num[i]); if(num[i]==1) mm[i][0]=to; else if(nxt2[to]) mm[i][0]=jump(nxt2[to],num[i]-2); else mm[i][0]=INF; &#125; for(int t=1;t&lt;20;t++) for(int i=1;i&lt;=m-bin[t]+1;i++) mm[i][t]=min(mm[i][t-1],mm[i+bin[t-1]][t-1]); while(q--) &#123; int l=qread(),r=qread(); int t=log2(r-l+1),ans=min(mm[l][t],mm[r-bin[t]+1][t]); write(ans&lt;=r); &#125;&#125; C U2题意补充：如果抛物线重合，只算一条；如果上面恰好有其他点，也合法请先思考后再展开 $y_3&gt;x_3^2+bx_3+c$$y_3-x_3^2&gt;bx_3+c$故把点 $(x,y)-&gt;(x,y-x^2)$然后就是求多少个直线（重叠算一个），上面是没有点的维护上凸壳即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back #define vc vector void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; const ll MOD=1e9+7; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; double slope(pr a,pr b)&#123;return (double)(b.SE-a.SE)/(b.FR-a.FR);&#125; pr p[MAX_N];bool cmp(pr a,pr b)&#123;return a.FR&lt;b.FR or (a.FR==b.FR and a.SE&gt;b.SE);&#125; int sta[MAX_N]; void main() &#123; int n=qread();for(int i=1;i&lt;=n;i++)&#123;ll x=qread(),y=qread();p[i]=MP(x,y-x*x);&#125; sort(p+1,p+n+1,cmp); int top=1;sta[top]=1; for(int i=2;i&lt;=n;i++) if(p[i-1].FR!=p[i].FR) &#123; while(top&gt;1 and slope(p[sta[top-1]],p[sta[top]])&lt;=slope(p[sta[top]],p[i])) top--; sta[++top]=i; &#125; write(top-1); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125; D Foreigner题意：给出一个数字串问多少个子串合法1~9是合法的，now=(10x+y)合法要求x合法且 $y&lt;(rank_x)\%11$请先思考后再展开 注意到我们需要快速计算一个合法数的rank%11记为rk因为明显暗示按位数分层，下一层等价于【前面所有层后面加上一个数+1~9】$考虑rk_x对rk_{now}的贡献$注意到 $1+2+3…+10+0=55,11|55$所以 $rank_x$ 每11个为一组对rk的贡献为0 想通了这点，则 $rk_{now}=(9+rk_x(rk_x-1)/2+y+1) \mod 11$则设f(i,rk)表示从左往右处理到第i位，有多少个为rk的区间注意判断前导0，时间复杂度为 $11n$123456789101112131415161718192021char str[N];int cnt[2][11];void main()&#123; scanf("%s",str+1);int n=strlen(str+1); if(n==1) &#123;puts("1");return;&#125;//debug ll ans=0; for(int i=0,op=0;i&lt;n;i++,op^=1) &#123; memset(cnt[op^1],0,sizeof cnt[op^1]); if(str[i+1]!='0')cnt[op^1][str[i+1]-'0']=1;//debug if(i==0) continue; for(int j=0;j&lt;11;j++) &#123; int to=(j*(j-1)/2+str[i+1]-'0'+10)%11; ans+=cnt[op][j]*( (i==n-1 and str[n]-'0'&lt;j)?2:1 ); if(str[i+1]-'0'&lt;j) cnt[op^1][to]+=cnt[op][j]; &#125; &#125; write(ans+(str[n]!='0'));&#125; E Pink Floydn个点竞赛图中有m条粉色已定向边，可询问最多2n次某条边的方向求哪个点能只通过一种颜色到达所有点请先思考后再展开 先判断使用粉色的情况，则缩点后仅一个dag（并查集），否则粉色边相当于被ban了如果完全没有粉色，则可以任选一个点作为now并维护集合S，每次找一个不在S中的点x，如果x-&gt;now则now放入S中并设x为now，否则x加入S中 正解其实也是类似的，但有个东西不太好想取入度为0的scc中的一点作为now，找另一个入度为0的scc中一点x询问，操作方式和上面类似如果是now-&gt;x则可以把x从那个scc中删除，因为但凡x能去的也就是now应该能去的，总是可以通过其他方式反问道举个例子，有个点y是x能去而now不能去的，这时y会成为now实现可以看远行客]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CF#512 div1]]></title>
    <url>%2Fposts%2Fda7b.html</url>
    <content type="text"><![CDATA[SourceCF#512div1神仙的题解：xyx,dzy好题：C A请先思考后再展开 画一画三角形，发现面积要么是整数，要么是整数/2故约分一下，然后判一下分母，考虑两种情况，注意不要超过坐标限制1234567891011121314151617181920212223242526void main()&#123; ll n=qread(),m=qread(),k=qread(); ll d=gcd(n*m,k);ll b=k/d; if(b==1) &#123; puts("YES"); ll tmp=gcd(n,d); ll x=n/tmp,y=m/(d/tmp); if(x*2&lt;=n) printf("0 0\n%lld %lld\n%lld %lld",x*2,0ll,0ll,y); else printf("0 0\n%lld %lld\n%lld %lld",x,0ll,0ll,y*2); &#125; else if(b==2) &#123; puts("YES"); ll tmp=gcd(n,d); n=n/tmp;m=m/(d/tmp); printf("%lld %lld\n",0ll,0ll); printf("%lld %lld\n",n,0ll); printf("%lld %lld\n",0ll,m); &#125; else &#123; puts("NO"); &#125;&#125; B请先思考后再展开 好难受啊看错数据（$1e18-&gt;2^18$）到最后10min才过……玩一玩样例，再随便举些情况，发现只需要满足以下限制：【ln%2==0】，【2mx&lt;=ln】，【ln&gt;1】证明不太会，也不太会写暴力……实现的话，可以像我现在这样，往前枚举2log值域个，这样是 $O(nlog值域)$更优秀复杂度的做法是分治，考虑跨过mid的区间，然后记录左右两边目前有多少奇偶位， $O(nlogn)$1234567891011121314151617181920212223242526272829303132int t0[MAX_N],t1[MAX_N],a[MAX_N],sum[MAX_N];void main()&#123; int n=qread();t0[0]=1; for(int i=1;i&lt;=n;i++) &#123; ll num=qread(); for(int j=0;j&lt;=62;j++) if(num&amp;(1ll&lt;&lt;j)) a[i]++; sum[i]=sum[i-1]+a[i]; t0[i]=t0[i-1]+( (sum[i]&amp;1)==0 ); t1[i]=t1[i-1]+(sum[i]&amp;1); &#125; ll ans=0; for(int r=2;r&lt;=n;r++) &#123; // if(r==n) // puts(""); int mx=a[r]; for(int l=r-1;l&gt;=r-150 and l&gt;=1;l--) &#123; chmax(mx,a[l]); if(2*mx&lt;=sum[r]-sum[l-1] and (sum[r]-sum[l-1])%2==0) ans++; &#125; if(r-152&gt;=0) &#123; if(sum[r]&amp;1) ans+=t1[r-152]; else ans+=t0[r-152]; &#125; &#125; write(ans);&#125; C请先思考后再展开 能独立做出div1的C让我感到很舒服，虽然清明一个人在家特别颓废……一开始觉得很难做，后来决定把式子写一下，在此过程中曾多次认为无法优化 其实我并没有意识到bi=ai-i这东西能转化为带权中位数……就自己推一推式子，发现要用到，于是就用来化简了……下面给出我的推导过程（具体化简过程略）： 注意$w_i \leq 0,且单调不减$先考虑移动为 $[A_l,A_l+(r-l)]$$$\begin{aligned}l \leq x（题意中的x）,设T=x-l\\ans=\sum_{b_i \geq T} b_iw_i-\sum_{b_i &lt; T} b_iw_i+(\sum_{b_i &lt; T} w_i-\sum_{b_i \geq T} w_i)T\end{aligned}$$ 然后考虑T-&gt;T+1,则变化为$\sum_{b_i \leq T} w_i-\sum_{b_i&gt;T} w_i$注意到右边的增量总是在变大，则二分到最小的那个负数位置T那么现在T已经确定了，统计答案，则总增量为$\sum_{b_i \leq T} (T-2b_i+b_l+1) w_i+\sum_{bi &gt; T} (T-b_l+1)w_i$ 于是树状数组维护 $w_i$和$b_iw_i$ 即可我写的是log方的，树状数组上二分时间复杂度可达 $O(qlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; const ll MOD=1e9+7; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; struct BIT &#123; ll bit[MAX_N];BIT()&#123;memset(bit,0,sizeof bit);&#125; int lowbit(int x) &#123;return x&amp;-x;&#125; void add(int x,int c) &#123;while(x&lt;MAX_N) bit[x]+=c,x+=lowbit(x);&#125; ll sum(int x)&#123;ll ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; ll ask(int l,int r) &#123;return (l&gt;r)?0:sum(r)-sum(l-1);&#125; &#125;bit,bit2;//不取模 ll a[MAX_N],b[MAX_N],w[MAX_N]; void main() &#123; int n=qread(),q=qread(); for(int i=1;i&lt;=n;i++) a[i]=qread(),b[i]=a[i]-i; for(int i=1;i&lt;=n;i++) &#123; w[i]=qread(),bit.add(i,w[i]); bit2.add(i,w[i]*b[i]%MOD); &#125; while(q--) &#123; int x=qread(),y=qread(); if(x&lt;0) &#123; int id=-x,c=y; bit.add(id,-w[id]);bit2.add(id,-w[id]*b[id]%MOD); w[id]=c; bit.add(id,w[id]);bit2.add(id,w[id]*b[id]%MOD); &#125; else &#123; int l=x,r=y; ll now=0;int T0=a[l]-l; int mid=lower_bound(b+l,b+r+1,T0)-b-1; now-=bit2.ask(l,mid)%MOD-bit.ask(l,mid)%MOD*T0%MOD; now+=bit2.ask(mid+1,r)%MOD-bit.ask(mid+1,r)%MOD*T0%MOD; now%=MOD; int fl=b[l],fr=b[r]-1,T=-1; while(fl&lt;=fr) &#123; int mid=(fl+fr)&gt;&gt;1; int tt=upper_bound(b+1,b+n+1,mid)-b-1; if(bit.ask(l,tt)&lt;bit.ask(tt+1,r)) T=mid,fl=mid+1; else fr=mid-1; &#125; if(T&gt;=0)//no move &#123; int tt=upper_bound(b+1,b+n+1,T)-b-1; now+=-bit2.ask(l,tt)*2%MOD+bit.ask(l,tt)%MOD*(T+b[l]+1)%MOD; now-=bit.ask(tt+1,r)%MOD*(T-b[l]+1)%MOD; &#125; write2((now%MOD+MOD)%MOD); &#125; &#125; &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125; D请先思考后再展开 $$\begin{aligned}&amp; 先讨论一下数列 A_{n}=(aA_{n-1}+b)\%p 的循环情况 \\&amp; A_n=a^n (x_0+\frac{b}{a-1})-\frac{b}{a-1} \\&amp; a=0,若b=x_0则T=1否则T=1且进入链长=1 \\&amp; a=1,若b=0则T=1否则T=P \\&amp; a&gt;1,若a=p的原根则T=p-1否则T为p-1的因子\end{aligned}$$证明：$g^n x0+b(g^n-1)/(g-1)=x0 (\% p)$$(g^n-1) x0+b(g^n-1)/(g-1)=0 (\% p)$$(g^n-1)(x0+\frac{b}{g-1})=0 (\% p)$p是质数所以两者必有一个是0而右边与n无关，总有一个b满足非0，而左边的循环节为p-1 综上所述，可以随心所欲选择p、p-1、1且链长=1三种，ans=lcm+max链长不考虑第三种的话按p排序从大到小贪心，因为 $lcm(P-1,p)&lt;=lcm(p-1,P)$ 而lcm是满足结合律的至于第3中，因为max&lt;=1，如果存在一个无贡献的家伙（必须最后重新遍历），改为链长=1即可 时间复杂度 $O(nlogn+P)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=1e9+7; void add(ll &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=2e6+10; bool gg[MAX_N]; int pp=0,prm[MAX_N],mip[MAX_N]; void pre() &#123; for(int i=2;i&lt;MAX_N;i++) &#123; if(!gg[i]) prm[++pp]=i,mip[i]=pp; for(int j=1;j&lt;=pp and (ll)prm[j]*i&lt;MAX_N;j++) &#123; int to=prm[j]*i;gg[to]=1;mip[to]=j; if(i%prm[j]==0) break; &#125; &#125; &#125; int p[MAX_N]; pr cnt[MAX_N]; void insert(int id,int num) &#123; if(num&gt;=cnt[id].FR) cnt[id].SE=cnt[id].FR,cnt[id].FR=num; else if(num&gt;cnt[id].SE) cnt[id].SE=num; &#125; bool fine(int now) &#123; if(now&lt;=0) return 0; while(now&gt;1) &#123; int t=0,id=mip[now]; while(now%prm[id]==0) now/=prm[id],t++; if(cnt[id].FR!=cnt[id].SE and cnt[id].FR==t) return 0; &#125; return 1; &#125; void main() &#123; pre(); int n=qread();for(int i=1;i&lt;=n;i++) p[i]=qread(); sort(p+1,p+n+1); for(int i=n;i&gt;=1;i--) &#123; if(!cnt[ mip[p[i]] ].FR) &#123;cnt[ mip[p[i]] ].FR=1;p[i]=0;continue;&#125; int now=p[i]-1; while(now&gt;1) &#123; int t=0,id=mip[now]; while(now%prm[id]==0) now/=prm[id],t++; insert(id,t); &#125; &#125; bool bk=0;for(int i=1;i&lt;=n;i++) if(fine(p[i]-1)) &#123;bk=1;break;&#125; ll ans=1; for(int i=1;i&lt;=pp;i++) &#123;while(cnt[i].FR--) ans=ans*prm[i]%MOD;&#125; write((ans+bk)%MOD); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); // freopen("jump.in","r",stdin); // freopen("jump.out","w",stdout); srand(time(0)); mine::main();&#125; E请先思考后再展开 构造题要求：将相同的数作为一组，则同组内位置奇偶性相同两个不同的组，不可能交叉思路：i xxx i 可以缩为i 实现有疑问可膜xyx]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【IOI2015】sorting]]></title>
    <url>%2Fposts%2F8565.html</url>
    <content type="text"><![CDATA[SourceIOI2015bzoj4371uoj233 Hint请先思考后再展开 考虑有n个带编号的盘子和n个带编号的苹果，然后A交换盘子，B交换苹果这样就能把两个人拆开来了 Solution请先思考后再展开 首先这东西可以二分，因为如果有序后，B可以每次做A的逆操作然后考虑置换的环数量，显然步数为n-环数然后输出方案的话，考虑值形成的环，按这个去推一下即可时间复杂度 $O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long ll;ll qread()&#123; ll ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans;&#125;#define pr pair&lt;int,int&gt;#define FR first#define SE second#define MP make_pair#define PB push_backconst int MAX_N=6e5+10;int n,m,a[MAX_N],b[MAX_N],fx[MAX_N],fy[MAX_N];int now[MAX_N],to[MAX_N];bool v[MAX_N];bool check(int mid)&#123; memcpy(b,a,sizeof a);for(int i=1;i&lt;=mid;i++) swap(b[fx[i]],b[fy[i]]); for(int i=1;i&lt;=n;i++) now[b[i]]=i; // for(int i=1;i&lt;=n;i++) to[i]=now[i]; memset(v,0,sizeof v);int cnt=0; for(int i=1;i&lt;=n;i++) if(!v[i]) &#123; int x=i;v[x]=1;cnt++; while(now[x]!=i) x=now[x],v[x]=1; &#125; return n-cnt&lt;=mid;&#125;int ans;vector&lt;pr&gt; end;void solve()&#123; int l=0,r=m; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; memcpy(b,a,sizeof a);for(int i=1;i&lt;=ans;i++) swap(b[fx[i]],b[fy[i]]); // for(int i=1;i&lt;=n;i++) to[i]=b[i]; // printf("%d\n",ans); for(int i=1;i&lt;=n;i++) now[a[i]]=i; int tmp=0;memset(v,0,sizeof v); for(int i=1;i&lt;=n;i++) if(!v[i]) &#123; int x=i;v[x]=1; while(b[x]!=i) &#123; tmp++;swap(a[fx[tmp]],a[fy[tmp]]);swap(now[a[fx[tmp]]],now[a[fy[tmp]]]); // printf("%d %d\n",now[x]-1,now[b[x]]-1); end.PB(MP(now[x]-1,now[b[x]]-1)); swap(a[now[x]],a[now[b[x]]]);swap(now[x],now[b[x]]);x=b[x];v[x]=1; &#125; &#125; // while(tmp!=ans) tmp++,puts("0 0"); while(tmp!=ans) tmp++,end.PB(MP(0,0));&#125;int findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[])&#123; n=N;for(int i=1;i&lt;=n;i++) a[i]=S[i-1]+1; m=M;for(int i=1;i&lt;=m;i++) fx[i]=X[i-1]+1,fy[i]=Y[i-1]+1; solve(); for(int t=0;t&lt;(int)end.size();t++) P[t]=end[t].FR,Q[t]=end[t].SE; return ans;&#125;// int main()// &#123;// // freopen("1.in","r",stdin);//// n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread()+1;// m=qread();for(int i=1;i&lt;=m;i++) fx[i]=qread()+1,fy[i]=qread()+1;// solve();// &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj5451】字符串]]></title>
    <url>%2Fposts%2F58a4.html</url>
    <content type="text"><![CDATA[Sourcebzoj5451 Hint请先思考后再展开 把每个串和其逆反串塞到ac自动机里面，就可以跑一个 $O(m2^n|S|)$ 的dp Solution请先思考后再展开 想到这东西后很自闭，不知道怎么处理在中间的情况假设这个串，左边部分为a，右边为b$a&lt;b,那么逆反串长为b的前缀即可$$a&gt;b,那么当前串长为a的前缀即可$于是我们可以给节点子树打上一个d标记，最后统计答案的时候判断 $d_x&amp;S=2^n-1$时间复杂度不变 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=6e2+10; const ll MOD=998244353; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int bin[30],n,m,ans=0; char str[MAX_N];int ln;bool okay[2][MAX_N]; struct ACM &#123; struct Nod&#123;int son[2],fail,d,tg;&#125;p[MAX_N*2];int id; int f[2][MAX_N*2][1&lt;&lt;7]; ACM()&#123;memset(p,0,sizeof p);memset(f,0,sizeof f);id=1;&#125; void insert(int nowid,int op) &#123; int x=1; for(int i=1;i&lt;=ln;i++) &#123; int to=str[i]-'0'; if(!p[x].son[to]) p[x].son[to]=++id; x=p[x].son[to];p[x].d|=bin[nowid-1]*okay[op][i]; &#125; p[x].tg|=bin[nowid-1]; &#125; queue&lt;int&gt; q; void solve() &#123; q.push(1);p[1].fail=0; while(q.size()) &#123; int x=q.front();q.pop(); for(int t=0;t&lt;=1;t++) &#123; int y=p[x].son[t];if(!y) continue;q.push(y); int tmp=p[x].fail;while(tmp and !p[tmp].son[t]) tmp=p[tmp].fail; p[y].fail=p[tmp].son[t];if(p[y].fail==0) p[y].fail=1; if(p[y].fail==y) puts("error"); p[y].tg|=p[p[y].fail].tg;p[y].d|=p[p[y].fail].d; &#125; &#125; f[0][1][0]=1; for(int i=0,now=1;i&lt;m;i++,now^=1) &#123; memset(f[now],0,sizeof f[now]); for(int x=1;x&lt;=id;x++) for(int S=0;S&lt;bin[n];S++) for(int t=0;t&lt;=1;t++) &#123; int tmp=x;while(tmp and !p[tmp].son[t]) tmp=p[tmp].fail;int y=p[tmp].son[t];y=max(y,1); add(f[now][y][S|p[y].tg],f[now^1][x][S]); &#125; &#125; for(int x=1;x&lt;=id;x++) for(int S=0;S&lt;bin[n];S++) if((S|p[x].d)==bin[n]-1) add(ans,f[m&amp;1][x][S]); &#125; &#125;acm; bool check(int l,int r) &#123; for(;l&lt;=r;l++,r--) if(str[l]==str[r]) return 0; return 1; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; n=qread(),m=qread(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1),ln=strlen(str+1); memset(okay,0,sizeof okay);for(int j=1;j&lt;=ln-j;j++) okay[0][ln-j]=check(ln-2*j+1,ln),okay[1][ln-j]=check(1,2*j); acm.insert(i,0);reverse(str+1,str+ln+1);for(int j=1;j&lt;=ln;j++) str[j]=(str[j]=='0'?'1':'0');acm.insert(i,1); &#125; acm.solve();write(ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj5481】矩阵]]></title>
    <url>%2Fposts%2Fa44d.html</url>
    <content type="text"><![CDATA[Sourcebzoj5481 Hint请先思考后再展开 如果两行在同一位置都是1，连一条边 Solution请先思考后再展开 这是若干个环，然后我们考虑图的形状计数，最后把n个列分配到边上$ans=\sum_{n=1}^N n!g_n$然后考虑最后一行所在的行$g_n=\si,*{i=2}^n g*{n-i} \times T_i \times C_{n-1}^{i-1}$这里 $Ti=\frac{i!}{2i}$ 表示一个大小为i的环的形状数然后把组合数化开，发现可以前缀和优化转移，故线性 oj垫底……12345678910111213141516void main()&#123; fac[0]=fac[1]=inv[1]=facinv[0]=facinv[1]=1; int N=qread(),ans=0;g[0]=1;f[0]=f[1]=1; for(int n=2;n&lt;=N;n++) &#123; fac[n]=(ll)fac[n-1]*n%MOD; if(n&gt;1) inv[n]=ll(MOD-MOD/n)*inv[MOD%n]%MOD; facinv[n]=(ll)facinv[n-1]*inv[n]%MOD; g[n]=(ll)f[n-2]*fac[n-1]%MOD*inv[2]%MOD; f[n]=(f[n-1]+(ll)g[n]*facinv[n]%MOD)%MOD; add(ans,(ll)g[n]*fac[n]%MOD); &#125; write(ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExaWizards2019题解]]></title>
    <url>%2Fposts%2F6447.html</url>
    <content type="text"><![CDATA[SourceExaWizards2019 C请先思考后再展开 因为推过去后，后面是生死与共的，考虑dp执行操作的一段后缀i，然后位置j是否活着$f(i,j)=f(i+1,j-1/j+1)$ 然后不难发现其实那一段连续的1每次最多更改1位1234567891011121314151617181920212223242526char type[MAX_N];pr qes[MAX_N];void main()&#123; int n,q;scanf("%d%d%s",&amp;n,&amp;q,type+1); for(int i=1;i&lt;=q;i++) &#123; char str1[10],str2[10];scanf("%s%s",str1,str2); qes[i]=MP(str1[0]-'A',str2[0]=='R'); &#125; int fl=1,fr=n; for(int i=q;i&gt;=1;i--) &#123; if(qes[i].SE) &#123; if(fl&gt;1 and type[fl-1]=='A'+qes[i].FR) fl--; if(type[fr]=='A'+qes[i].FR) fr--; &#125; else &#123; if(fr&lt;n and type[fr+1]=='A'+qes[i].FR) fr++; if(type[fl]=='A'+qes[i].FR) fl++; &#125; if(fl&gt;fr) break; &#125; write(fr-fl+1);&#125; 题解做法是mlogm的，就二分这个区间的端点，模拟这个格子上面的人来check即可 D请先思考后再展开 先从大到小排序f(i,j)表示考虑后缀i，各种方案的和12345678910ll f[MAX_N][MAX_M];int a[MAX_N];void main()&#123; int n=qread(),now=qread();for(int i=1;i&lt;=n;i++) a[i]=qread();sort(a+1,a+n+1);reverse(a+1,a+n+1); for(int i=0;i&lt;MAX_M;i++) f[n][i]=i%a[n]; for(int i=n-1;i&gt;=1;i--) for(int j=0;j&lt;MAX_M;j++) f[i][j]=(f[i+1][j%a[i]]+f[i+1][j]*(n-i)%MOD)%MOD; write(f[1][now]);&#125; E请先思考后再展开 一、 $i \leq min(B,W)$ans=1/2二、设没有白色为fw，没有黑色为fb$fb(i)=\sum_{j=B}^{i-1} C_{j-1}^{W-1} \frac{1}{2^j}$fw类似，然后都有就是 1-fb-fw那么答案为 $\frac{1}{2} (1-fw-fb)+fw$ 1234567891011121314151617void main()&#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; inv[1]=1;for(int i=2;i&lt;MAX_N;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=facinv[i-1]*inv[i]%MOD; bin[0]=1;for(int i=1;i&lt;MAX_N;i++) bin[i]=bin[i-1]*inv[2]%MOD; int B=qread(),W=qread(),fw=0,fb=0; for(int i=1;i&lt;=B+W;i++) &#123; if(W&lt;=i-1) add(fw,C(i-2,W-1)*bin[i-1]%MOD); if(B&lt;=i-1) add(fb,C(i-2,B-1)*bin[i-1]%MOD); if(i&lt;=W and i&lt;=B) write2(inv[2]); else write2( (inv[2]*(MOD*2+1-fw-fb)%MOD+fw)%MOD ); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【cf1012f】Xor MST【uoj176 Goodbye Yiwei C】新年的繁荣]]></title>
    <url>%2Fposts%2Ffd96.html</url>
    <content type="text"><![CDATA[Sourcecf1012fGoodbye Yiwei C 新年的繁荣uoj176 Hint请先思考后再展开 Boruvka算法 Solution请先思考后再展开 A. 先说Xor MST 网上的做法好像都是trie上，考虑每个有分叉的节点，在上面启发式来找到最小点对这里提供一个不同，不过也没有更快的做法，是我在看了看Boruvka后想的就是给每个连通块维护trie，并查集的时候直接trie合并，复杂度和线段树合并是相同的然后我还要开一个总的trie，用于询问这个点向连通块外的节点连边的最小代价，就类似主席树那样搞就行了tire合并的总复杂度为nlogn，然后最小生成树求解过程是 $nlog^2n$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; const ll MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int bin[50]; struct Trie &#123; struct Nod&#123;int son[2],c,fm;&#125;p[MAX_N*32*2];//n+1=all int id;Trie()&#123;memset(p,0,sizeof p);id=MAX_N;&#125; void insert(int x,int num,int fm) &#123; for(int i=30;i&gt;=0;i--) &#123; int wt=(num&amp;bin[i])&gt;0; if(!p[x].son[wt]) p[x].son[wt]=++id; x=p[x].son[wt];p[x].c++;p[x].fm=fm; &#125; &#125; int askmi(int x,int y,int num)//x-y &#123; for(int i=30;i&gt;=0;i--) &#123; int wt=(num&amp;bin[i])&gt;0; if(p[p[x].son[wt]].c-p[p[y].son[wt]].c==0) wt^=1; num^=wt*bin[i];x=p[x].son[wt];y=p[y].son[wt]; &#125; return p[x].fm; &#125; void merg(int x,int &amp;y) &#123; if(!x) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; merg(p[x].son[0],p[y].son[0]); merg(p[x].son[1],p[y].son[1]); &#125; &#125;tr; struct DSU &#123; int fa[MAX_N],siz[MAX_N];DSU()&#123;for(int i=0;i&lt;MAX_N;i++) fa[i]=i,siz[i]=1;&#125; int findfa(int x) &#123;return fa[x]==x?x:fa[x]=findfa(fa[x]);&#125; void merg(int x,int y) &#123; int fx=findfa(x),fy=findfa(y);if(fx==fy) return; fa[fx]=fy;tr.merg(fx,fy);siz[fy]+=fx; &#125; &#125;dsu; int a[MAX_N]; pr ner[MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=40;i++) bin[i]=bin[i-1]&lt;&lt;1; int n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); for(int i=1;i&lt;=n;i++) tr.insert(i,a[i],i),tr.insert(n+1,a[i],i); ll ans=0; while(1) &#123; for(int x=1;x&lt;=n;x++) ner[x]=MP(INF,0); for(int x=1;x&lt;=n;x++) &#123; int fx=dsu.findfa(x),y=tr.askmi(n+1,fx,a[x]),fy=dsu.findfa(y); if(fx!=fy) ner[fx]=min(ner[fx],MP(a[x]^a[y],fy)); &#125; bool bk=0; for(int x=1;x&lt;=n;x++) if(x==dsu.findfa(x) and ner[x].SE) &#123; int fy=dsu.findfa(ner[x].SE);if(x!=fy) ans+=ner[x].FR,dsu.merg(x,fy),bk=1; &#125; if(!bk) break; &#125; write(ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125; B. 新年的繁荣这题其实就是解决and和or的极值生成树，那么和xor不同的在于在某些情况需要遍历两种二进制位以本题为例，就是1-&gt;1,0-&gt;0/1注意到m很小，那么一棵trie填满也只是 $2^m$ ，那么我们建好trie后，从下往上把1的合并到0那边但在上一道题中，我是用了个保存权值的可合并trie，然后求连通块外是用总-当前的，然后我就不知道这种怎么保证复杂度了……只好看了看begay的代码 其实mst整体是log次，每次这个连通块只会被修改一次，询问连通块的时候，询问两端一定在不同连通块，所以合并的时候不用立刻改tire（也没能力改），只要判断编号的异同就行了所以可以每次给所有连通块分别建立trie（其实这样写上一道题会好写一点，我比较蠢就没想到）那么现在每个数所在连通块是确定的，trie上维护子树编号的最大最小就能判断能否访问了 时间复杂度为 $O(m2^mlogn+nlog^2 n)$ 然后对于本题，lzz有个$O(m2^m)$的优秀做法]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度3</tag>
        <tag>trie</tag>
        <tag>Boruvka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cf1012f】Passports]]></title>
    <url>%2Fposts%2F8470.html</url>
    <content type="text"><![CDATA[Sourcecf1012f我的阅读理解好差啊，看错了3次题，无限自闭题意：有pp=1/2个护照，然后要按顺序去n个国家旅游给定时间区间（开始st，长度ln，办签证时间ti），保证区间不相交每个签证必须在非旅游时间开始办理，在经过ti个晚上后送到家中如果去某个国家x用的是A护照，则此时A护照必须在非办理状态，而且上面有x的签证求可行方案，形式为每个签证在哪个护照上、开始办理时间 Hint请先思考后再展开 f[S]表示处理了这个集合的签证的最短时间那么你需要保证，每个签证都在对应国家前得到，而且办签证期间不能使用这个护照旅游 Solution请先思考后再展开 这个dp需要达到 $n2^n$ 的复杂度建议先写个暴力，然后逐步优化例如是具有单调性的：无论是j2&lt;=i还是最小化f，都应该选择最小的合法j2，而且j2的移动在按ti排序后是单调的 先考虑pp=1，办签证的时间和旅游不能重叠，直接判 $f[2^n-1]$然后pp=2，判 $f[a]和f[2^n-1-a]$ 即可 然后我代码有个小小的lower_bound，是可以去掉保证复杂度的，懒得搞了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=24; const ll MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int bin[40],mxb[1&lt;&lt;MAX_N]; struct City &#123; int st,ed,ti,id; friend bool operator &lt; (City a,City b) &#123;return a.st&lt;b.st;&#125; &#125;p[MAX_N];int p2[MAX_N]; bool cmp(int a,int b) &#123;return p[a].ti&lt;p[b].ti;&#125; int n,pp; int f[1&lt;&lt;MAX_N];pr ans[MAX_N]; struct FF&#123;int from,time,nxt;&#125;fm[1&lt;&lt;MAX_N]; bool check(int now,int op) &#123; if(f[now]==f[bin[n]]) return 0; while(now&gt;0) &#123; int from=fm[now].from; if(from==0) return 0; ans[p[from].id]=MP(op,fm[now].time); now^=bin[from-1]; &#125; return 1; &#125; int pre[MAX_N][MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; for(int i=1;i&lt;bin[MAX_N];i++) mxb[i]=max(mxb[i&gt;&gt;1]+1,(i&amp;1)?1:0); for(int l=0;l&lt;MAX_N;l++) for(int r=l;r&lt;MAX_N;r++) pre[l][r]=(bin[r+1]-1)^(bin[l]-1); n=qread(),pp=qread(); for(int i=1;i&lt;=n;i++) p[i].st=qread(),p[i].ed=p[i].st+qread()-1,p[i].ti=qread(),p[i].id=i; sort(p+1,p+n+1);p[n+1].st=INF*2; for(int i=1;i&lt;=n;i++) p2[i]=i;sort(p2+1,p2+n+1,cmp); memset(f,127,sizeof f);f[0]=1; for(int S=0;S&lt;bin[n];S++) &#123; int nxt=upper_bound(p+1,p+n+1,(City)&#123;f[S],0,0,0&#125;)-p; int j=nxt-(f[S]&lt;=p[nxt-1].ed),j2=j; for(int i=1;i&lt;=n;i++) if(!(S&amp;bin[p2[i]-1])) &#123; int S2=S|bin[p2[i]-1]; if(f[S]&gt;p[nxt-1].ed) &#123; int time=f[S]+p[p2[i]].ti,j2=upper_bound(p+1,p+n+1,(City)&#123;time,0,0,0&#125;)-p; bool bk=(j2&lt;=p2[i]);if(nxt&lt;=j2-1) bk&amp;=(S2&amp;pre[max(nxt-1,0)][max(j2-2,0)])==0; if(bk and time&lt;f[S2]) &#123;f[S2]=time,fm[S2]=(FF)&#123;p2[i],f[S]&#125;;continue;&#125; &#125; j=nxt-(f[S]&lt;=p[nxt-1].ed),j2=j; for(;j&lt;n;j++) if(p[j].ed+1!=p[j+1].st)//debug &#123; int time=(p[j].ed+1)+p[p2[i]].ti;while(p[j2].st&lt;=time) j2++; bool bk=1;if(j+1&lt;=j2-1) bk&amp;=(S2&amp;pre[j][max(j2-2,0)])==0; if(bk) &#123; if(time&lt;f[S2] and j2&lt;=p2[i]) f[S2]=time,fm[S2]=(FF)&#123;p2[i],p[j].ed+1&#125;; break; &#125; &#125; &#125; &#125; if(pp==1) &#123; if(!check(bin[n]-1,1)) puts("NO"); else &#123; for(int i=1;i&lt;=n;i++) if(ans[i].FR==0) &#123;puts("NO");return;&#125; puts("YES");for(int i=1;i&lt;=n;i++) printf("%d %d\n",ans[i].FR,ans[i].SE); &#125; &#125; else &#123; for(int a=0;a&lt;bin[n];a++) if(check(a,1) and check((bin[n]-1)^a,2)) &#123; for(int i=1;i&lt;=n;i++) if(ans[i].FR==0) &#123;puts("NO");return;&#125; puts("YES");for(int i=1;i&lt;=n;i++) printf("%d %d\n",ans[i].FR,ans[i].SE);return; &#125; puts("NO"); &#125; &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4699】树上的最短路]]></title>
    <url>%2Fposts%2F271b.html</url>
    <content type="text"><![CDATA[Sourcebzoj4699 Hint请先思考后再展开 请时刻记住这永远是一棵树，坍塌的两端都是树上路径坍塌因为有多个起点，只需要从最短距离的起点出发边权都是正数，可以dij Solution请先思考后再展开 把树边也记为坍塌，建反向边求单源最短路先考虑直接转化为新图，然后发现诸如线段树优化建图什么的都不太行那就考虑在dij的过程中利用边 首先，如何取出经过点x的所有坍塌？这里的取出就是用完之后删除，正如hint中说的，这条坍塌已经没用了情况1：一个在子树内，一个在子树外，则可以配合dfs序在线段树上查询极值取出路径实现的话可以考虑叶子节点开个vec存没有被删除的路径，取出来的时候合并左右信息（管理节点只开结构体存极值）情况2：来自x的不同孩子，这种把路径挂在lca处即可注意每条路径可能被取出常数次，判不判重都行 设点y在路径上，如果y在dij的前面已经出去拓展，而边权又都是正的，则y不再需要出去拓展那么因为这个路径的终点都是相同的代价，则可以把路径也一起塞到堆里面（相当于一个新点）然后因为会更新一条树上路径，先考虑让每个点只被更新一次，好像不太可行但如果我们能让每个点只拓展别人一次，那也是可以保证复杂度的那么我们可以把目标路径拆为(dis,x,lca)和(dis,y,lca)这样向上的路径然后每个点用个并查集维护向上第一个目前依然没有出去拓展的点，从而对目标路径进行更新 复杂度为 $O(mlogn)$ 代码：有空写有空写……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AMPPZ2014】Global Warming]]></title>
    <url>%2Fposts%2F895e.html</url>
    <content type="text"><![CDATA[SourceAMPPZ2014bzoj4149 Hint请先思考后再展开 这种问题我一般都考虑分治：只统计mx在mid左，mi在mid右的情况分治的好处在于，知道一定会经过mid，会好做很多 Solution请先思考后再展开 先用单调栈求出每个位置向左右第一个不能延伸的地方就单调移动左端点，考虑他是mx，然后知道最远的mi在哪里，然后得到left和right时间复杂度为nlogn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e5+10; const ll MOD=1e13; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; #define mid ((l+r)/2) int a[MAX_N]; struct Table &#123; int bg[MAX_N],sm[MAX_N]; Table()&#123;memset(bg,0,sizeof bg);memset(sm,0,sizeof sm);&#125; stack&lt;pr&gt; sta1,sta2; void pre(int n) &#123; sta1.push(MP(a[1],1));sta2.push(MP(a[1],1)); for(int i=2;i&lt;=n;i++) &#123; while(sta1.size() and sta1.top().FR&lt;a[i]) sta1.pop(); if(sta1.size()) bg[i]=sta1.top().SE;sta1.push(MP(a[i],i)); while(sta2.size() and sta2.top().FR&gt;a[i]) sta2.pop(); if(sta2.size()) sm[i]=sta2.top().SE;sta2.push(MP(a[i],i)); &#125; &#125; &#125;tb[2];//0左1右 int mxlen=1,n,leftp=1; void solve(int l,int r,int op) &#123; if(l&gt;=r) return; int lstmx=0,leftmi=mid; int ty=mid,lstmi=mid+1; for(int i=mid;i&gt;=l;i--) &#123; if(a[i]&lt;a[leftmi]) leftmi=i; if(a[i]&gt;a[lstmx]) &#123; lstmx=i; while(ty+1&lt;=r and a[ty+1]&lt;a[i]) &#123; ty++; if(a[ty]&lt;a[lstmi]) lstmi=ty; &#125; if(a[lstmi]&lt;a[lstmx] and a[lstmi]&lt;a[leftmi]) &#123; int left=max(tb[op].bg[lstmx],tb[op].sm[lstmi])+1; int right=min(n-tb[op^1].bg[n-lstmx+1]+1,n-tb[op^1].sm[n-lstmi+1]+1)-1; if(right-left+1&gt;mxlen) mxlen=right-left+1,leftp=(op?n-right+1:left); else if(right-left+1==mxlen) chmin(leftp,(op?n-right+1:left)); &#125; &#125; &#125; solve(l,mid,op);solve(mid+1,r,op); &#125; int b[MAX_N]; void main() &#123; n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); tb[0].pre(n);reverse(a+1,a+n+1);tb[1].pre(n); solve(1,n,1);reverse(a+1,a+n+1);solve(1,n,0); printf("%d %d",mxlen,leftp); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4171】Rhl的游戏]]></title>
    <url>%2Fposts%2F3b9d.html</url>
    <content type="text"><![CDATA[Sourcebzoj4171 Hint请先思考后再展开 高斯消元 Solution请先思考后再展开 首先每个位置按不按是一个bool，然后会有许多异或方程如果n很小可以直接枚举第一行的状态，但这题不行，那就设未知数不难发现f(i,j)可以用若干个第一行的未知数的异或表示，直接bitset递推一下最后就会得到n个未知数，n+k个方程，直接高斯消元复杂度为 $O(Tn^3/32)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=256+10; const ll MOD=1e13; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; typedef bitset&lt;MAX_N&gt; bs; bs f[MAX_N][MAX_N],a[MAX_N*2]; void guass(int n,int m)//n个元，m个方程 &#123; int cnt=0; for(int i=n;i&gt;=1;i--) &#123; int to=-1;for(int j=cnt+1;j&lt;=m;j++) if(a[j][i]) to=j; if(to&lt;0) continue;cnt++; swap(a[to],a[cnt]); for(int j=1;j&lt;=m;j++) if(j!=cnt and a[j][i]) a[j]^=a[cnt]; &#125; for(int i=n+1;i&lt;=m;i++) if(a[i]._Find_first()==n+2) &#123;puts("NO");return;&#125; puts("YES"); &#125; char str[MAX_N][MAX_N]; void main() &#123; int T=qread(); for(int tt=1;tt&lt;=T;tt++) &#123; int n=qread(),m=qread(),ss=qread(); for(int i=1;i&lt;=n;i++) scanf("%s",str[i]+1); for(int j=1;j&lt;=m;j++) f[1][j][j]=1; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; f[i][j]=f[i-1][j]^f[i-1][j-1]^f[i-1][j+1]^f[i-2][j]; f[i][j][m+2]=f[i][j][m+2]^(str[i-1][j]=='B'); &#125; for(int j=1;j&lt;=m;j++) &#123; a[j]=f[n][j]^f[n][j-1]^f[n][j+1]^f[n-1][j]; a[j][m+2]=a[j][m+2]^(str[n][j]=='B'); &#125; for(int i=1;i&lt;=ss;i++) &#123; int x=qread(),y=qread(); a[m+i]=f[x][y]; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[i][j].reset(); printf("Case #%d:\n",tt);guass(m,m+ss); &#125; &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4169】Lmc的游戏]]></title>
    <url>%2Fposts%2Fb9c2.html</url>
    <content type="text"><![CDATA[Sourcebzoj4169 Hint请先思考后再展开 这是一棵树，很多东西都有了正确性的保证，所以可以大胆想首先思考，如果给出了叶子的编号，就是直接模拟然后这种排列的东西有个套路，就是你先考虑我能得到这个子树内，排名为多少的叶子 Solution请先思考后再展开 自底向上贪心显然是正确的没什么好说的，就代入角色去思考决策即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; const ll MOD=1e13; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int ff[MAX_N],siz[MAX_N],f[MAX_N][2],g[MAX_N][2]; vector&lt;int&gt; son[MAX_N]; void dfs(int x) &#123; if(son[x].size()==0) &#123; siz[x]=1;f[x][0]=f[x][1]=g[x][0]=g[x][1]=1; return; &#125; f[x][0]=g[x][1]=INF; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];dfs(y);siz[x]+=siz[y]; chmin(f[x][0],f[y][1]);chmin(g[x][1],g[y][0]); f[x][1]+=f[y][0];g[x][0]+=g[y][1]; &#125; &#125; void main() &#123; int n=qread();for(int i=1;i&lt;n;i++) &#123;int fa=qread(),x=qread();son[fa].PB(x);ff[x]=fa;&#125; for(int rt=1;rt&lt;=n;rt++) if(ff[rt]==0) &#123; dfs(rt);printf("%d %d\n",siz[rt]-f[rt][0]+1,g[rt][0]); break; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4664】Count]]></title>
    <url>%2Fposts%2F8c73.html</url>
    <content type="text"><![CDATA[Sourcebzoj4664 Hint请先思考后再展开 建议先去做bzoj4498魔法的碰撞然后考虑怎样利用L比较小的性质 Solution请先思考后再展开 直接搞的话，因为有加有减，可能中途超过L，会记漏，考虑怎么只有正数$d_i-d_j=(d_i-d_{i-1})+(d_{i-1}-d_{i-2})……$那么每次（特判第一次），设所有括号，旁边已经放了数的一侧的数量为t，则 $w+=t(d_i-d_{i-1})$时间复杂度为 $O(n^2L)$ 12345678910111213141516171819int d[MAX_N],f[2][MAX_N][2][2][1001];void main()&#123; int n=qread(),L=qread();for(int i=1;i&lt;=n;i++) d[i]=qread();sort(d+1,d+n+1); f[1][0][0][0][0]=f[1][0][1][0][0]=f[1][0][0][1][0]=f[1][0][1][1][0]=1; for(int i=2;i&lt;=n;i++) &#123; memset(f[i&amp;1],0,sizeof f[i&amp;1]); for(int j=0;j&lt;=n;j++) for(int a=0;a&lt;=1;a++) for(int b=0;b&lt;=1;b++) for(int w=0;w&lt;=L;w++) &#123; int t2=f[(i-1)&amp;1][j][a][b][w],t1=(ll)t2*j%MOD; int w2=w+(j*2+a+b)*(d[i]-d[i-1]);if(w2&gt;L) break; if(j) add(f[i&amp;1][j-1][a][b][w2],t1),add(f[i&amp;1][j][a][b][w2],t1*2%MOD),add(f[i&amp;1][j+1][a][b][w2],t1); if(a) add(f[i&amp;1][j][0][b][w2],t2),add(f[i&amp;1][j+1][0][b][w2],t2),add(f[i&amp;1][j][1][b][w2],t2),add(f[i&amp;1][j+1][1][b][w2],t2); if(b) add(f[i&amp;1][j][a][0][w2],t2),add(f[i&amp;1][j+1][a][0][w2],t2),add(f[i&amp;1][j][a][1][w2],t2),add(f[i&amp;1][j+1][a][1][w2],t2); &#125; &#125; int ans=0;for(int w=0;w&lt;=L;w++) add(ans,f[n&amp;1][0][0][0][w]);write(ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4498】魔法的碰撞]]></title>
    <url>%2Fposts%2F9743.html</url>
    <content type="text"><![CDATA[Sourcebzoj4498 Hint请先思考后再展开 如果给定一个排列，则其贡献为 $C_{L-\sum max(d_i,d_{i+1})-1}^n$然后你发现只和这个和有关，dp一下方案数 Solution请先思考后再展开 众所周知这个排列能搞成状压dp，n太大，所以考虑插入因为这个是跟max有关，如果从大到小插入，就能消去这个比较假设一开始只有一个括号，考虑以后左右两边是否有人如果都有人，则贡献为2(di-1)，然后会产生两个括号如果只有一边有人，则贡献为di-1，然后产生一个括号如果都没有人，则没贡献没括号于是我们的转移就跟两边具体是什么人没关系了，只需要讨论一下我的决策，他们一定是不同的方案然后注意到我们是不关心括号的位置什么的，只需要记录数量即可 于是不难想到dp的状态，设 $f(i,j,w)$ 表示【考虑前i大，目前有j个空括号，和为w】的方案数 123456789101112131415161718192021void main()&#123; fac[0]=1;for(int i=1;i&lt;MAX_M;i++) fac[i]=fac[i-1]*i%MOD; inv[1]=1;for(int i=2;i&lt;MAX_M;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_M;i++) facinv[i]=facinv[i-1]*inv[i]%MOD; int L=qread(),n=qread();for(int i=1;i&lt;=n;i++) d[i]=qread(); sort(d+1,d+n+1);reverse(d+1,d+n+1); f[0][1][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int w=0;w&lt;MAX_N*MAX_N;w++) &#123; int t=(ll)f[i-1][j][w]*j%MOD;if(t==0) continue; add(f[i][j-1][w],t); add(f[i][j][w+(d[i]-1)],t*2%MOD); add(f[i][j+1][w+2*(d[i]-1)],t); &#125; int ans=0; for(int w=0;w&lt;MAX_N*MAX_N;w++) add(ans,(ll)f[n][0][w]*C(L-w,n)%MOD); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4665】已经没有什么好害怕的了]]></title>
    <url>%2Fposts%2F96b8.html</url>
    <content type="text"><![CDATA[Sourceluogu4859bzoj3622 Hint请先思考后再展开 先解出需要恰好多少个[ai&gt;bi]然后容斥比较套路，求至少的时候需要将数组有序化 Solution请先思考后再展开 $设fi为恰好i个，gi为固定了i个$$g_i=\sum_{j=i}^n C_j^i f_j$二项式反演为 $f_i=\sum_{j=i}^n (-1)^{j-i} C_j^i g_j$然后这个g可以设计一个dp$dp(i,j)表示考虑了前面i个，然后确定了j对[ai&gt;bi]，其他则不确定$$dp(i,j)=dp(i-1,j)+dp(i-1,j-1) \times (sm-j+1)$最后的时候要把剩下没有匹配的，乘个阶乘匹配一下 时间复杂度为 $O(n^2)$ upd：有个东西忘记强调了，就是其他 的东西是放在最后匹配的，所以他的统计次数可以保证是 $C_j^i$ 12345678910111213141516171819202122232425262728int C[MAX_N][MAX_N],fac[MAX_N];int a[MAX_N],b[MAX_N];ll g[MAX_N];void main()&#123; C[0][0]=1; for(int i=1;i&lt;MAX_N;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD; &#125; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=(ll)fac[i-1]*i%MOD; int n=qread(),k=qread(); k=(int)ceil((n+k)/2.0); for(int i=1;i&lt;=n;i++) a[i]=qread();sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) b[i]=qread();sort(b+1,b+n+1); g[0]=1; for(int i=1;i&lt;=n;i++) &#123; int sm=lower_bound(b+1,b+n+1,a[i])-b-1; for(int j=i;j&gt;=1;j--) if(j&lt;=sm) add(g[j],g[j-1]*(sm-j+1)%MOD); else g[j]=0; &#125; for(int i=0;i&lt;=n;i++) g[i]=g[i]*fac[n-i]%MOD; ll ans=0; for(int j=k,t=1;j&lt;=n;j++,t=-t) add(ans,g[j]*C[j][k]*t%MOD); write((ans+MOD)%MOD);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小w的喜糖]]></title>
    <url>%2Fposts%2F838d.html</url>
    <content type="text"><![CDATA[Sourcebzoj4665手动加强：n个杯子，有的杯子品牌相同然后要求重排列后每个人手上的品牌和原本不同n&lt;=1e5 Hint请先思考后再展开 考虑容斥先假定每个杯子都是不同的，但限制是品牌而不是杯子$ans=ANS/(\prod col_i)$ Solution请先思考后再展开 $ANS=\sum_{t=0}^n (-1)^t f(t) (n-t)!$然后这个$f(t)=固定t个人是非法的$，你可以直接dp更优秀的做法是用生成函数，注意到t个人非法可以分解为每种颜色，nowi个人非法那么就是 $\sum now_i=t,\sum \prod P_{col_i}^{now_i} C_{col_i}^{now_i}$所以每个颜色就是个多项式，这就是一个拆系数分治ntt 只有暴力n方的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e3+10; const int MOD=1e9+9; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll fac[MAX_N],inv[MAX_N],facinv[MAX_N]; ll getC(int n,int m) &#123;return fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;&#125; ll getP(int n,int m) &#123;return fac[n]*facinv[n-m]%MOD;&#125; ll C[MAX_N]; void cheng(ll A[],ll B[],int n,int m) &#123; memset(C,0,sizeof C); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) add(C[i+j],A[i]*B[j]%MOD); memcpy(A,C,sizeof C); &#125; int cnt[MAX_N];ll A[MAX_N],B[MAX_N]; void main() &#123; inv[1]=1;for(int i=2;i&lt;MAX_N;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=facinv[i-1]*inv[i]%MOD; int n=qread();for(int i=1;i&lt;=n;i++) cnt[qread()]++; A[0]=1;int all=1; for(int i=1;i&lt;=n;i++) &#123; memset(B,0,sizeof B); for(int j=0;j&lt;=cnt[i];j++) B[j]=getC(cnt[i],j)*getP(cnt[i],j)%MOD; cheng(A,B,all,cnt[i]+1);all+=cnt[i]; &#125; ll ans=0; for(int t=0;t&lt;=n;t++) &#123; ll tmp=A[t]*fac[n-t]%MOD; if(t&amp;1) add(ans,MOD-tmp); else add(ans,tmp); &#125; for(int i=1;i&lt;=n;i++) ans=ans*facinv[cnt[i]]%MOD; write(ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>容斥</tag>
        <tag>fft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ONTAK2010】Peaks]]></title>
    <url>%2Fposts%2F53e7.html</url>
    <content type="text"><![CDATA[SourceONTAK2010luogu4197bzoj3551 Hint请先思考后再展开 建议思考：方法一：可持久化并查集方法二：kruskal重构树 Solution请先思考后再展开 先考虑可持久化并查集，以排序的边作为时间轴因为时间不倒退所以可以不用线段树，开个vector在上面二分即可，降低空间如果只启发式合并，不路径压缩，则最多进行2m次询问，n次合并每个点有log的询问势能，每次在vector上二分，为nlog方然后并查集的空间的话就是n次合并插入1个值，故线性合并的时候并查集插入是O(1)的每个连通块都有个线段树维护权值，而且线段树大小总是vector的log倍此做法瓶颈为时间，理论上无法通过 注意到上面的复杂度不太平衡，考虑路径压缩询问的势能降低为5n，即5nlog，log通常是不满的然后每次合并修改5n个值，所以线段树大小增大为5nlogn此做法瓶颈为空间，理论上无法通过 所以其实这个做法应该是凉凉的那我们只能使用kruskal重构树，这个应用比较经典，不再展开]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>重构树</tag>
        <tag>可持久化并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Baltic2013】pipes]]></title>
    <url>%2Fposts%2F1dfd.html</url>
    <content type="text"><![CDATA[SourceBaltic2013bzoj3135 Hint请先思考后再展开 除了某些极特殊情况，所有方程线性无关 Solution请先思考后再展开 不知道为什么网上非题解都觉得结论显而易见……服了 首先方程的重要特性: 所有系数都是0或1 没有重边 每个变量只会出现在两个方程里面那么我能想出来唯一的特殊情况就是子集包含，如a+b+c=7,a=2,b=2,c=3那么就只有一个是没用的 那么考虑每个连通块（貌似本题数据是连通的，没区别），如果m&gt;n，则一定多解然后m=n-1的树就直接推一下m=n的基环树，如果有偶环一定多解，否则在环上迭代一下即可，都是线性的 然后这个结论官方题解也有证明下面给出简洁的翻译，图还是看题解吧：对于每个连通块，偶环就多解如果两个奇环，最多只有一个公共点，中间的路径无论是奇还是偶，都很容易构造出多解如果两个奇环有至少两个公共点，找出两个公共点，能断开至少3条路径，则一定存在偶环]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>高斯消元</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC002题解]]></title>
    <url>%2Fposts%2F797f.html</url>
    <content type="text"><![CDATA[SourceAGC002好题：E、F B请先思考后再展开 按题意模拟1234567891011121314int siz[MAX_N];bool v[MAX_N];void main()&#123; int n=qread(),m=qread(); v[1]=1;for(int i=1;i&lt;=n;i++) siz[i]=1; while(m--) &#123; int x=qread(),y=qread();siz[x]--;siz[y]++; if(v[x]) v[y]=1; if(siz[x]==0) v[x]=0; &#125; int ans=0;for(int i=1;i&lt;=n;i++) ans+=v[i]; write(ans);&#125; C请先思考后再展开 按题意模拟不过想了一会儿12345678910111213int a[MAX_N];void main()&#123; int n=qread(),L=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); for(int i=1;i&lt;=n-1;i++) if(a[i]+a[i+1]&gt;=L) &#123; puts("Possible"); for(int j=1;j&lt;i;j++) printf("%d\n",j); for(int j=n-1;j&gt;=i+1;j--) printf("%d\n",j); printf("%d",i);return; &#125; puts("Impossible");&#125; D请先思考后再展开 我写了个很显然的整体二分+dsu，时间是nlogn的，唯一缺点是离线网上好像有些人用的是log方的带撤销的并查集，其实没必要，直接从左往右做就行了rose用的是kruskal重构树，时间下界为nlogn，而且是在线的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; struct DSU &#123; int fa[MAX_N],siz[MAX_N]; void clear()&#123;for(int i=1;i&lt;MAX_N;i++) fa[i]=i,siz[i]=1;&#125; int findfa(int x) &#123;return x==fa[x]?x:fa[x]=findfa(fa[x]);&#125; void merg(int x,int y) &#123; int fx=findfa(x),fy=findfa(y); if(fx==fy) return; if(siz[fx]&lt;siz[fy]) swap(fx,fy); siz[fx]+=siz[fy];fa[fy]=fx; &#125; bool check(int x,int y,int z) &#123; x=findfa(x),y=findfa(y); if(x==y) return siz[x]&gt;=z; return siz[x]+siz[y]&gt;=z; &#125; &#125;dsu; int ans[MAX_N]; pr e[MAX_N];struct Qes&#123;int x,y,z,id,nowl,nowr;&#125;q[MAX_N]; int ct[MAX_N],now[MAX_N]; void main() &#123; int n=qread(),m=qread(); for(int i=1;i&lt;=m;i++) e[i].FR=qread(),e[i].SE=qread(); int qq=qread(); for(int i=1;i&lt;=qq;i++) &#123; int x=qread(),y=qread(),z=qread(); q[i]=(Qes)&#123;x,y,z,i,1,m&#125;; &#125; for(int T=20;T&gt;=0;T--) &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=qq;i++) ct[q[i].nowl]++; for(int i=1;i&lt;=m;i++) ct[i]+=ct[i-1]; for(int i=qq;i&gt;=1;i--) now[ct[q[i].nowl]--]=i; dsu.clear(); int fl=1,fr=0; for(int mid=1;mid&lt;=m;mid++) &#123; while(fr+1&lt;=qq and (q[now[fr+1]].nowl+q[now[fr+1]].nowr)/2&lt;=mid) fr++; dsu.merg(e[mid].FR,e[mid].SE); if(fl&lt;=fr) &#123; for(int i=fl;i&lt;=fr;i++) &#123; int t=now[i];if(q[t].nowl&gt;q[t].nowr) continue; if(dsu.check(q[t].x,q[t].y,q[t].z)) ans[q[t].id]=mid,q[t].nowr=mid-1; else q[t].nowl=mid+1; &#125; fl=fr+1; &#125; &#125; &#125; for(int i=1;i&lt;=qq;i++) writeln(ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125; E请先思考后再展开 因为是个平等博弈，sg是可以用的然后不知道怎么表达一个状态，想过排序，但没想下去……就是从大到小排序后，这就是不规则的棋盘，类似这样（图挂不补）：然后用sg函数推一推，很容易证明一条线上的【是否必胜】是相同的那么暴力找即可，复杂度下界为n 12345678910111213141516171819int a[MAX_N];void main()&#123; int n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); sort(a+1,a+n+1);reverse(a+1,a+n+1); for(int x=1;x&lt;=n;x++) if(x+1&gt;a[x+1]) &#123; int up=(a[x]-x),right=0; while(x+right+1&lt;=n and x&lt;=a[x+right+1]) right++; int now; if(up==0 and right==0) now=0; else if(up==0) now=right&amp;1; else if(right==0) now=up&amp;1; else now=(up!=0 and right!=0); puts(now?"First":"Second"); break; &#125;&#125; F Leftmost Ball请先思考后再展开 因为第一个球都是相同颜色，考虑把每个颜色贡献到第二个球上面统计然后每次把一个颜色给统计进来设f(i,j)表示有i个白球，j个其他颜色（显然i&gt;=j） $$f(i,j)=f(i-1,j)+\f(i,j-1) \times (n-j+1) \times C_{n-i+(k-1)*(n-j+1)-1}^{k-2}$$ 12345678910111213141516void main()&#123; inv[1]=1;for(int i=2;i&lt;MAX_M;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; fac[0]=1;for(int i=1;i&lt;MAX_M;i++) fac[i]=(ll)fac[i-1]*i%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_M;i++) facinv[i]=(ll)facinv[i-1]*inv[i]%MOD; int n=qread(),k=qread(); if(k==1) &#123;puts("1");return;&#125; f[0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=i;j++) &#123; if(i&gt;0) add(f[i][j],f[i-1][j]); if(j&gt;0) add(f[i][j],(ll)f[i][j-1]*(n-j+1)%MOD*C(n-i+(k-1)*(n-j+1)-1,k-2)%MOD ); &#125; printf("%d",f[n][n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC001题解]]></title>
    <url>%2Fposts%2F794c.html</url>
    <content type="text"><![CDATA[SourceAGC001好题：B、E A请先思考后再展开 123456789int a[MAX_N];void main()&#123; int n=qread(); for(int i=1;i&lt;=2*n;i++) a[i]=qread(); sort(a+1,a+2*n+1); int ans=0;for(int i=1;i&lt;=2*n;i+=2) ans+=a[i]; write(ans);&#125; B请先思考后再展开 这题点子不错就是每次割一个平行四边形，自己画画很容易想到复杂度和gcd一样，为log1234567891011121314ll ans;void T(ll x,ll y)//x&lt;y&#123; if(x&gt;y) swap(x,y); printf("T(%lld,%lld)\n",x,y); ll a=y/x,b=y%x; if(b==0) ans+=(a*2-1)*x; else ans+=(a*2)*x,T(x,b);&#125;void main()&#123; ll n=qread(),x=qread();ans=n; T(x,n-x);write(ans);&#125; C请先思考后再展开 一开始想了个假的线性，然后改成假的线段树nlogn……好菜啊最早的时候想过dp，感觉不知道搞些什么，然后想完上面的东西之后有了感觉才发现很好dp的f(x,now)=【保证不过x的路径&lt;=K，大小为now】下，子树到x的最大距离 题解做法好麻烦啊，还是这个好想123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector inline void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2100; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int K; vector&lt;int&gt; son[MAX_N]; int dis[MAX_N],siz[MAX_N]; int ans=0; int f[MAX_N][MAX_N];//f(x,now)=【保证不过x的路径&lt;=K，大小为now】下，子树到x的最大距离 void solve(int x,int fa) &#123; f[x][1]=0;siz[x]=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; solve(y,x);siz[x]+=siz[y]; for(int all=siz[x];all&gt;=1;all--) for(int b=1;b&lt;=siz[y] and b&lt;=all;b++) if(f[x][all-b]+f[y][b]+1&lt;=K) chmin(f[x][all],max(f[x][all-b],f[y][b]+1)); &#125; for(int i=siz[x];i&gt;=1;i--) if(f[x][i]&lt;=K) chmax(ans,i); &#125; void main() &#123; int n=qread();K=qread(); for(int i=1;i&lt;n;i++) &#123; int x=qread(),y=qread(); son[x].PB(y);son[y].PB(x); &#125; memset(f,0x3f,sizeof f); solve(1,0);write(n-ans); &#125;&#125;;int main()&#123; srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125; D题意（看了好久）：就是N个点，然后给一个长为m的序列，要求重排列后为a，再构造一个b，每ai个是回文的，要求图连通请先思考后再展开 日常不会做构造…… 因为是连通图，然后每个节点度数不超过2，所以一定是环或者链，那么如果不止两个奇数，则度为1的点过多，无法连通然后对于m=1的情况， ${a}-&gt;{a-1,1}$然后类似地，考虑这样搞： ${a,b,c,d}-&gt;{a-1,b,c,d+1}$但这种偏移在中间有奇数项的时候会gg，但因为奇数最多两个，可以把奇数放到序列头尾12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;ctime&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;set&gt;using namespace std;typedef long long ll;ll qread()&#123; ll ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans;&#125;void write(ll num)&#123; if(num&gt;9) write(num/10); putchar('0'+num%10);&#125;void writeln(ll num) &#123;write(num);puts("");&#125;#define pr pair&lt;int,int&gt;#define FR first#define SE second#define MP make_pair#define PB push_backconst int INF=0x3f3f3f3f;void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125;const int MAX_N=110;int a[MAX_N];int main()&#123; int n=qread(),m=qread(); int cnt=0,x=0,y=0; for(int i=1;i&lt;=m;i++) &#123; a[i]=qread(); if(a[i]&amp;1) &#123;cnt++;if(x==0) x=i; else y=i;&#125; &#125; if(m==1) &#123; if(a[1]==1) printf("1\n1\n1\n",1); else printf("%d\n2\n%d 1",a[1],a[1]-1); return 0; &#125; if(cnt&gt;2) &#123;puts("Impossible");return 0;&#125; if(x&gt;0) swap(a[1],a[x]); if(y&gt;0) swap(a[m],a[y]); for(int i=1;i&lt;=m;i++) printf("%d ",a[i]);puts(""); if(a[1]==1) writeln(m-1); else writeln(m),printf("%d ",a[1]-1); for(int i=2;i&lt;=m;i++) printf("%d ",a[i]+(i==m));&#125; E BBQ Hard请先思考后再展开 这题妙啊众所周知组合数可以转化为网格图，从原点到(n,m)，只能上或右的方案数那现在不能枚举两个的拼接，但值域很小，不妨转化为从(-ai,-bi)走到(aj,bj)的方案数注意要去掉自己到自己，以及无序二元组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector inline void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int inv[MAX_N],fac[MAX_N],facinv[MAX_N]; int C(int n,int m) &#123;return (ll)fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;&#125; int f[5100][5100]; #define F(i,j) (f[(i)+2100][(j)+2100]) int a[MAX_N],b[MAX_N]; void main() &#123; inv[1]=1;for(int i=2;i&lt;MAX_N;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=(ll)fac[i-1]*i%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=(ll)facinv[i-1]*inv[i]%MOD; int n=qread(),ans=0; for(int i=1;i&lt;=n;i++) &#123; a[i]=qread(),b[i]=qread(); add(ans,MOD-C(2*a[i]+2*b[i],2*a[i]) ); F(-a[i],-b[i])++; &#125; for(int i=-2000;i&lt;=2000;i++) for(int j=-2000;j&lt;=2000;j++) add(F(i+1,j),F(i,j)),add(F(i,j+1),F(i,j)); for(int i=1;i&lt;=n;i++) add(ans,F(a[i],b[i])); write((ll)ans*inv[2]%MOD); &#125;&#125;;int main()&#123; srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125; F请先思考后再展开 设A[p[i]]=i即某个值的位置，那么就是每次交换相邻的，差&gt;=K的值注意到如果两个值，$差&lt;K$，则相对位置是不会改变的即对于A中的数字i，数字(i-K,i+K)与i的相对顺序不能改变 那么就是说我能得出一些顺序的限制条件，在满足这些条件的情况下构造一个拓扑序方案，我们已经获得了一个 $n^2$的做法这个做法的主要瓶颈在于边数过多，这些边我能用bitset快速获得，但连边还是没办法优化但这个边多只发生在K比较大的时候，而这种时候其实拓扑排序中没意义的边是很多的，所以思路是尽量减少边数 然后这里我一开始的想法是，对于每个i只考虑i-K部分，原本在前后的限制，然后发现很难做但如果每个i，考虑i-K和i+K，他们原本在前面的限制，就完全不一样了，因为距离限制是对称的 具体而言，左边大小为K的部分，只需要向比i早而最晚出现的那个连边，因为其他已经出现的，都一定被这个覆盖；右边同理这样边数是2n级别的，用线段树维护即可时间复杂度为 nlogn 最后讲讲这个字典序的问题不知道为什么很多题解都说，p最小就是让A最小，然而这应该是错的，但本题极难卡这种让拓扑序的逆最小的模型，应该是建反向边，然后开大根堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e5+10; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; struct SegmentTree &#123; #define lc 2*x #define rc 2*x+1 #define mid ((l+r)&gt;&gt;1) pr mx[MAX_N*4]; void change(int x,int l,int r,int p,int c) &#123; mx[x]=max(mx[x],MP(c,p)); if(l==r) return; if(p&lt;=mid) change(lc,l,mid,p,c); else change(rc,mid+1,r,p,c); &#125; pr ask(int x,int l,int r,int fl,int fr) &#123; if(fl&gt;fr) return MP(0,0); if(l==fl and r==fr) return mx[x]; if(fr&lt;=mid) return ask(lc,l,mid,fl,fr); if(fl&gt;mid) return ask(rc,mid+1,r,fl,fr); return max(ask(lc,l,mid,fl,mid),ask(rc,mid+1,r,mid+1,fr)); &#125; &#125;sgt; int a[MAX_N],ans[MAX_N]; int ru[MAX_N];vector&lt;int&gt; to[MAX_N]; void ins(int x,int y) &#123;ru[y]++;to[x].PB(y);&#125; priority_queue&lt;int&gt; q; void main() &#123; int n=qread(),K=qread(); for(int i=1;i&lt;=n;i++) a[qread()]=i; for(int i=1;i&lt;=n;i++) &#123; int num=a[i];sgt.change(1,1,n,num,i); pr a=sgt.ask(1,1,n,max(1,num-K+1),num-1);if(a.FR&gt;0) ins(num,a.SE); pr b=sgt.ask(1,1,n,num+1,min(num+K-1,n));if(b.FR&gt;0) ins(num,b.SE); &#125; for(int i=1;i&lt;=n;i++) if(ru[i]==0) q.push(i); for(int now=n;now&gt;=1;now--) &#123; int x=q.top();q.pop();ans[x]=now; for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t];ru[y]--; if(ru[y]==0) q.push(y); &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛42]]></title>
    <url>%2Fposts%2F145e.html</url>
    <content type="text"><![CDATA[Source牛客练习赛42 A请先思考后再展开 其实最长的一段子串一定是最优答案12345678910111213const int MAX_N=2e5+10;char a[MAX_N],b[MAX_N];void main()&#123; scanf("%s%s",a+1,b+1);int n=strlen(a+1); ll ans=0; for(int i=1,j=0;i&lt;=n;i++) &#123; if(a[i]==b[i]) j++; else j=0; chmax(ans,ll(j+2)*j); &#125; printf("%lld",ans);&#125; B请先思考后再展开 显然所有数都选123456789101112const int MOD=1e8+7;void main()&#123; int n=qread(); ll a=0,b=0; for(int i=1;i&lt;=n;i++) &#123; int x=qread(); a^=x;b+=x; &#125; write((a+b)%MOD);&#125; C请先思考后再展开 这道题思路显然，就是把一个序列中相同值贡献到第一个上面不过需要卡常，我的写法是，f表示前面存在这个值的行的对应乘积，然后g表示出现在了多少个行时间复杂度为 $O(n^2)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;#define int intusing namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; const int MAX_N=4e6+10; const int mod=20030122; struct Hash &#123; int f[mod],g[mod];Hash()&#123;memset(f,-1,sizeof f);&#125; int ask(int num,int &amp;id) &#123; int pos=num%mod;while(f[pos]&gt;=0 and f[pos]!=num) pos=(pos+1==mod?0:pos+1); if(f[pos]==num) return g[pos]; f[pos]=num;g[pos]=++id;return 0; &#125; &#125;hash; int b[MAX_N],old[MAX_N],f[MAX_N],g[MAX_N]; int ti[MAX_N],ti2[MAX_N],cnt[MAX_N],nn[MAX_N]; void main() &#123; int n=qread(),m=qread(); int id=0; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) &#123; int now=qread(),t=hash.ask(now,id);f[id]=1; b[n*(i-1)+j]=(t==0?id:t);old[b[n*(i-1)+j]]=now; &#125; nn[0]=1;for(int i=1;i&lt;=m;i++) nn[i]=(ll)nn[i-1]*n%MOD; int ans=0; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; int now=b[n*(i-1)+j]; add(ans,(ll)f[now]*nn[i-1-g[now]+m-i]%MOD*old[now]%MOD); if(ti2[now]&lt;i) ti2[now]=i,cnt[now]=1; else cnt[now]++; &#125; for(int j=1;j&lt;=n;j++) &#123; int now=b[n*(i-1)+j]; if(ti[now]&lt;i) ti[now]=i,f[now]=(ll)f[now]*(n-cnt[now])%MOD,g[now]++; &#125; &#125; write(ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; D请先思考后再展开 这是一道花了我2h的模拟题，主要是我去大力推式子了，而且还看错题目的输出方式又重新推了一遍（不太熟练也是问题）就先是递减序列，然后k为需要多少个顺序对，那么二分到第一个需要修改的位置，然后后面的部分一定是个递增的序列然后你可以像我这样sb地推差比数列的式子，也可以直接矩乘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;#define int intusing namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; ll T(ll n) &#123;return n*(n-1)/2;&#125;//debug 不能取模 ll A; ll g(ll n) &#123;return (qpower(A,n+1)+MOD-1)*inv(A-1)%MOD;&#125;//等比数列 ll f(ll n) &#123;return (qpower(A,n+1)*n%MOD+MOD-g(n)+1)*inv(A-1)%MOD;&#125;//差比数列，递减 void main() &#123; ll n=qread(),k=T(n)-qread();A=n+1; int l=1,r=n,pos=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(k&lt;=T(mid)) pos=mid,r=mid-1; else l=mid+1; &#125; int ned=k-T(pos-1); ll ans=ll(pos-ned)*qpower(A,n-pos+1)%MOD; if(pos+1&lt;=n) add(ans, ((g(n-pos)-1)*(n+1)%MOD+MOD-f(n-pos))%MOD ); int a=pos-ned-1,b=pos; if(1&lt;=a) add(ans, f(a)*qpower(A,n-pos+1)%MOD ); if(a+2&lt;=b) add(ans, (f(b)+MOD-f(a+1))*qpower(A,n-pos)%MOD ); write(ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; E请先思考后再展开 显然先离散化我们需要统计的是【子树内至少一个关键点】的节点-虚树根节点深度+1 询问离线到右端点上，按从小到大的顺序access右端点，涂上这次的颜色则每个点的颜色即子树最大值，而我目前能出现的也只有r以内的，所以只要mx&gt;=l即可这个可以树状数组统计，比较套路，时间复杂度为 $O(nlog^2n+qlogn)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector inline void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; struct BIT &#123; int bit[MAX_N];BIT()&#123;memset(bit,0,sizeof bit);&#125; int lowbit(int x) &#123;return x&amp;-x;&#125; void add(int x,int c) &#123;while(0&lt;x and x&lt;MAX_N) bit[x]+=c,x+=lowbit(x);&#125; int sum(int x) &#123;int ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; &#125;bit; struct LCT &#123; struct Nod&#123;int son[2],fa,col,siz;bool tg;&#125;p[MAX_N]; LCT()&#123;memset(p,0,sizeof p);for(int i=1;i&lt;MAX_N;i++) p[i].siz=1;&#125; #define lc p[x].son[0] #define rc p[x].son[1] void pushup(int x) &#123;p[x].siz=1+p[lc].siz+p[rc].siz;&#125; void pushdown(int x) &#123;if(p[x].tg) p[x].tg=0,p[lc].col=p[rc].col=p[x].col,p[lc].tg=p[rc].tg=1;&#125; #define son(x) (p[p[x].fa].son[1]==x) bool isrt(int x) &#123;return p[p[x].fa].son[son(x)]!=x;&#125; void rotate(int x) &#123; int f=p[x].fa,ff=p[f].fa;if(!isrt(f)) p[ff].son[son(f)]=x; int w=son(x),ts=p[x].son[w^1];p[x].son[w^1]=f;p[f].son[w]=ts; p[x].fa=ff;p[f].fa=x;if(ts) p[ts].fa=f;pushup(f);pushup(x); &#125; int tmp[MAX_N]; void splay(int x) &#123; int tot=0,t=x;while(!isrt(t)) tmp[++tot]=t,t=p[t].fa; pushdown(t);for(int i=tot;i&gt;=1;i--) pushdown(tmp[i]); for(int fa=p[x].fa;!isrt(x);rotate(x),fa=p[x].fa) if(!isrt(fa)) son(x)^son(fa)?rotate(x):rotate(fa); &#125; void access(int x,int col) &#123; int lst=0,tmp=x; while(x&gt;0) &#123; splay(x); bit.add(p[x].col,-p[lc].siz-1); p[x].son[1]=lst;if(lst) p[lst].fa=x;pushup(x); lst=x;x=p[x].fa; &#125; splay(tmp);p[tmp].tg=1;p[tmp].col=col; bit.add(col,p[tmp].siz); &#125; &#125;lct; vector&lt;int&gt; son[MAX_N]; int dep[MAX_N],mm[MAX_N*2][21],dfn[MAX_N],id=0; void dfs(int x,int fa) &#123; dep[x]=dep[fa]+1;lct.p[x].fa=fa;dfn[x]=++id;mm[id][0]=x; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; dfs(y,x);mm[++id][0]=x; &#125; &#125; int gmin(int x,int y) &#123;return dep[x]&lt;dep[y]?x:y;&#125; int getlca(int x,int y) &#123; x=dfn[x],y=dfn[y];if(x&gt;y) swap(x,y); int t=lg[y-x+1];return gmin(mm[x][t],mm[y-bin[t]+1][t]); &#125; int gg[MAX_N][21]; int gettop(int l,int r) &#123; int t=lg[r-l+1];return getlca(gg[l][t],gg[r-bin[t]+1][t]); &#125; int tmp[MAX_N],a[MAX_N],rk[MAX_N];//映射 bool cmp(int x,int y) &#123;return a[x]&lt;a[y];&#125; vector&lt;pr&gt; qes[MAX_N];int ans[MAX_N*5]; void main() &#123; int n=qread(),q=qread(); for(int i=1;i&lt;=n;i++) a[tmp[i]=i]=qread(); sort(tmp+1,tmp+n+1,cmp);sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) rk[tmp[i]]=i; for(int i=2;i&lt;=n;i++) &#123;int x=rk[qread()],y=rk[qread()];son[x].PB(y),son[y].PB(x);&#125; dfs(1,0); for(int i=1;i&lt;=20;i++) for(int j=1;j&lt;=id-bin[i]+1;j++) mm[j][i]=gmin(mm[j][i-1],mm[j+bin[i-1]][i-1]); for(int i=1;i&lt;=n;i++) gg[i][0]=i; for(int i=1;i&lt;=20;i++) for(int j=1;j&lt;=n-bin[i]+1;j++) gg[j][i]=getlca(gg[j][i-1],gg[j+bin[i-1]][i-1]); for(int i=1;i&lt;=q;i++) &#123; int l=lower_bound(a+1,a+n+1,qread())-a; int r=upper_bound(a+1,a+n+1,qread())-a-1; qes[r].PB(MP(l,i)); &#125; for(int r=1;r&lt;=n;r++) &#123; lct.access(r,r); for(int t=0;t&lt;(int)qes[r].size();t++) &#123; int l=qes[r][t].FR,id=qes[r][t].SE; if(l&lt;=r) ans[id]=bit.sum(r)-bit.sum(l-1)-(dep[gettop(l,r)]-1); &#125; &#125; for(int i=1;i&lt;=q;i++) writeln(ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125; F请先思考后再展开 如果不强制在线，可以把询问和原树的点放在一起，建虚树，然后换根dp，复杂度下界为n（笛卡尔树什么的……）现在强制在线的话，就是需要在线地找到离原树某个点最近的点，这个在套路集锦-树-6里面有时间复杂度为nlogn，空间为n或者暴力树剖+二分找，时间为log方 然后你也可以动态点分治，每个点开个map记录去子树内这个颜色，最小距离，时间为log方，空间为nlogn时间换空间的手写hash，每个节点的模数根据子树大小设定，以10倍为例,时间nlogn，空间10nlogn此做法好写好调，虽然不优秀但本题不卡（upd：个屁……卡了好久）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector inline void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=4e5+10; struct Hash &#123; vector&lt;pr&gt; mp;int mod; void getmod(int mm) &#123;mod=mm;mp.resize(mm);for(int t=0;t&lt;mm;t++) mp[t]=MP(-1,-1);&#125; int ask(int num,int val) &#123; int pos=num%mod; while(mp[pos].FR!=-1 and mp[pos].FR!=num) pos=(pos==mod-1?0:pos+1); if(mp[pos].FR==num) &#123;chmin(mp[pos].SE,val);return mp[pos].SE;&#125; if(val!=INF) mp[pos]=MP(num,val);return -1; &#125; &#125;hash[MAX_N]; // unordered_map&lt;int,int&gt; hash[MAX_N]; vector&lt;int&gt; son[MAX_N]; int dep[MAX_N],dfn[MAX_N],id=0; int mm[MAX_N*2][21];int gmin(int x,int y) &#123;return dep[x]&lt;dep[y]?x:y;&#125; void dfs(int x,int fa) &#123; dep[x]=dep[fa]+1;dfn[x]=++id;mm[id][0]=x; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; dfs(y,x);mm[++id][0]=x; &#125; &#125; int getlca(int x,int y) &#123; x=dfn[x],y=dfn[y];if(x&gt;y) swap(x,y); int t=lg[y-x+1];return gmin(mm[x][t],mm[y-bin[t]+1][t]); &#125; int getdis(int x,int y) &#123;return dep[x]+dep[y]-2*dep[getlca(x,y)];&#125; int G,gg[MAX_N],ff[MAX_N],all; bool v[MAX_N];int siz[MAX_N],siz2[MAX_N]; vector&lt;int&gt; cc[MAX_N]; void insert(int x,int fa,int dis,int top) &#123; for(int t=0;t&lt;(int)cc[x].size();t++) &#123; int col=cc[x][t]; hash[top].ask(col,dis); // if(hash[top].count(col)) hash[top][col]=min(hash[top][col],dis); // else hash[top][col]=dis; &#125; siz[x]=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa or v[y]) continue; insert(y,x,dis+1,top);siz[x]+=siz[y]; &#125; &#125; void getrt(int x,int fa) &#123; siz[x]=1;gg[x]=0;siz2[x]=cc[x].size(); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa or v[y]) continue; getrt(y,x);siz[x]+=siz[y];chmax(gg[x],siz[y]);siz2[x]+=siz2[y]; &#125; chmax(gg[x],all-siz[x]); if(gg[x]&lt;gg[G]) G=x; &#125; void solve(int x) &#123; v[x]=1; getrt(x,0); hash[x].getmod(siz2[x]*10+1); insert(x,0,0,x); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y]) continue; G=0;all=siz[y];getrt(y,x);ff[G]=x;solve(G); &#125; &#125; void main() &#123; int n=qread(),m=qread(),q=qread(); for(int i=1;i&lt;=n-1;i++) &#123;int x=qread(),y=qread();son[x].PB(y);son[y].PB(x);&#125; dfs(1,0); for(int i=1;i&lt;=20;i++) for(int j=1;j&lt;=2*n-bin[i]+1;j++) mm[j][i]=gmin(mm[j][i-1],mm[j+bin[i-1]][i-1]); for(int col=1;col&lt;=m;col++) &#123; int siz=qread();//这里一步步跳上去会tle，O(1)lca居然比压栈还慢…… while(siz--) cc[qread()].PB(col); &#125; G=0;gg[0]=INF;all=n;getrt(1,0);solve(G); int lst=0; while(q--) &#123; int x=(qread()+lst)%n+1,col=(qread()+lst)%m+1; int ans=n,y=x; while(y!=0) &#123; // if(hash[y].count(col)) chmin(ans,hash[y][col]+getdis(x,y)); int t=hash[y].ask(col,INF);if(t&gt;=0) chmin(ans,t+getdis(x,y)); y=ff[y]; &#125; writeln(lst=ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客挑战赛32]]></title>
    <url>%2Fposts%2F145e.html</url>
    <content type="text"><![CDATA[Source牛客挑战赛32 代码见我（zory）的提交 A AKB 114514此题需要int128 C 斐波那契数列卷积此题的正解应该是考虑组合意义，我是直接oeis的 D 放物品请先思考后再展开 感觉百度之星复赛的故事再一次重演了，被有区分的讨论题搞了2h，后面1h是因为mod太多没看到多写了一个2，然后到外面思考人生了我的做法需要你能扎实地理解错排D的递推式怎么推，具体见oi之路错排本质上是n人n个不重叠限制，然后下面还要用到n-1个和n-2个限制，分别设为f和g，然后我一开始的做法要所有f和g，所以就推了一波递推式，结果多写了个2（有点像烧情侣的一道题，也在错排那里）；因为限制不满，会有人和位置空闲$f_n=D_{n-1}+f_{n-1}*(n-1)$，即考虑空出来的人是否在空出来的位置上 $g_n=P_{n-2}^2*g_{n-2}+2*f_{n-1}+4*D_{n-1}$，也就是考虑空出来两个位置都空、都不空、恰一个空，这里恰一个空的话剩下n-1个人和n-1个限制（新限制是另一个空人不能在另一个空位置上） 那么求答案的话考虑数对i和j，$j&gt;i,pos_j&lt;pos_i$的贡献，然后你把暴力写了优化一下即可，具体见代码 1234567891011121314151617181920212223242526272829303132333435ll p[N],D[N],F[N],G[N],pre[N],pre2[N];void main()&#123; D[0]=1,D[1]=0;for(int i=2;i&lt;N;i++) D[i]=ll(i-1)*(D[i-1]+D[i-2])%MOD; F[0]=1,F[1]=1;for(int i=2;i&lt;N;i++) F[i]=( D[i-1]+F[i-1]*(i-1) )%MOD; G[0]=1,G[1]=1;for(int i=2;i&lt;N;i++) G[i]=( G[i-2]*(i-2)%MOD*(i-3)%MOD+4*D[i-1]%MOD+MOD+2*D[i-2]%MOD )%MOD; pre[0]=0;for(int i=1;i&lt;N;i++) pre[i]=mm(pre[i-1]+i); int T=qread(); while(T--) &#123; int n=qread();for(int i=1;i&lt;=n;i++) p[i]=qread(); if(n&lt;=1)&#123;puts("0");continue;&#125; for(int ln=1;ln&lt;=n;ln++) pre2[ln]=(pre2[ln-1]+1ll*ln*(n-ln))%MOD; ll ans=0; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) &#123; ll cnt=pre2[n-1]; if(p[j]&lt;p[i]) add(cnt, MOD-(p[i]-p[j]) ); add(cnt, 1ll*MOD-mm( pre[n-p[j]]+MOD-(p[j]&lt;p[i]?p[i]-p[j]:0) ) ); add(cnt, 1ll*MOD-mm( pre[p[i]-1]+MOD-(p[j]&lt;p[i]?p[i]-p[j]:0) ) ); if(p[i]&lt;p[j]) add(cnt, MOD-(p[j]-p[i]) ); add(cnt, 1ll*MOD-mm( pre[n-p[i]]+MOD-(p[i]&lt;p[j]?p[j]-p[i]:0) ) ); add(cnt, 1ll*MOD-mm( pre[p[j]-1]+MOD-(p[i]&lt;p[j]?p[j]-p[i]:0) ) ); ll sum=0; add(sum, cnt*G[n-2]%MOD );if(p[i]&lt;p[j]) add(sum, (p[j]-p[i])*D[n-2]%MOD ); add(sum, ( pre[n-p[i]]+MOD-(p[i]&lt;p[j]?p[j]-p[i]:0) )*F[n-2]%MOD ); add(sum, ( pre[p[j]-1]+MOD-(p[i]&lt;p[j]?p[j]-p[i]:0) )*F[n-2]%MOD ); add(ans, sum*(j-i)%MOD ); &#125;write2((ans%MOD+MOD)%MOD); &#125;&#125;//(ans+MOD)%MOD E 树上逆序对请先思考后再展开 其实我写复杂了，我考虑的是如果一个点选了，那么增量就是 【到根更小】-【子树更小】，然后这样有正有负不好搞，注意到k很小，那用sum（初始逆序对数），把它转正即可，于是就是个二选一的01背包，bitset优化即可 其实更加有脑子的方法是看原本我的贡献是【子树更小】，新贡献是【到根更小】，所以不需要上述思考；另外我脑残还写了个dfs序，其实如果对dfs灵活一点的话，搞个东西记录前面访问的所有，减去遍历子树后新产生的，这样一个dfs即可，短不少 12345678910111213141516171819202122232425262728293031323334struct BIT&#123; int bit[N];int lowbit(int x)&#123;return x&amp;-x;&#125; void add(int x,int c)&#123;while(x&lt;N)bit[x]+=c,x+=lowbit(x);&#125; int ask(int x)&#123;int ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125;&#125;up,down;vc&lt;pr&gt; b;int a[N];vc&lt;int&gt; to[N];int dfn[N],dfnid=0,siz[N];void pre(int x,int fa)&#123; dfn[x]=++dfnid;siz[x]=1; for(int t=0;t&lt;sz(to[x]);t++) if(to[x][t]!=fa) pre(to[x][t],x),siz[x]+=siz[to[x][t]];&#125;bitset&lt;M&gt; bs;ll sum=0;int sm[N];void dfs(int x,int fa)&#123; int num=lower_bound(all(b),MP(a[x],0))-b.begin()+1; up.add(num,1);for(int t=0;t&lt;sz(to[x]);t++) if(to[x][t]!=fa) dfs(to[x][t],x),siz[x]+=siz[to[x][t]];up.add(num,-1); int add=up.ask(num-1)-sm[x],add2=0;if(add&lt;0) &#123;add2-=add;sum+=add;add=0;&#125;GG(sum&lt;0); bs=(bs&lt;&lt;add)|(bs&lt;&lt;add2);&#125;void main()&#123; int n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(),b.PB(MP(a[i],i));sort(all(b)); for(int i=1;i&lt;n;i++)&#123;int x=qread(),y=qread();to[x].PB(y);to[y].PB(x);&#125;pre(1,0); for(int t=0;t&lt;sz(b);t++) &#123; int x=b[t].SE; sm[x]=down.ask(dfn[x]+siz[x]-1)-down.ask(dfn[x]-1); down.add(dfn[x],1);sum+=sm[x]; &#125; bs[0]=1;dfs(1,0);GG(sum&lt;0);bs&lt;&lt;=sum; int q=qread();while(q--)&#123;int k=qread();puts(bs[k]?"Orz":"QAQ");&#125;&#125;//(ans+MOD)%MOD]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AGC032题解]]></title>
    <url>%2Fposts%2F6c3f.html</url>
    <content type="text"><![CDATA[SourceAGC032 A请先思考后再展开 首先显然，一个序列必须满足 $num_{ \leq i} \geq i$然后我们考虑倒推，那么就变成每次值域总是在i以内，i不断减小当前最后一次操作一定满足 $A_k=k$ ，如果有多个，只能选择最后一个否则这个球的位置一定会$&lt;k$，再也无法拿走 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e5+10; int a[MAX_N],ct[MAX_N]; vector&lt;int&gt; ans; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),ct[a[i]]++; for(int i=1;i&lt;=n;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) &#123; for(int j=i;j&gt;=1;j--) if(ct[j]&lt;j) &#123;puts("-1");return;&#125; bool ok=0; for(int j=i;j&gt;=1;j--) if(j==a[j]) &#123; ans.PB(j);for(int t=j;t&lt;=i;t++) ct[t]--; for(int t=j;t&lt;=i-1;t++) swap(a[t],a[t+1]); ok=1;break; &#125; if(ok==0) &#123;puts("-1");return;&#125; &#125; reverse(ans.begin(),ans.end()); for(int t=0;t&lt;(int)ans.size();t++) printf("%d\n",ans[t]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; B请先思考后再展开 考虑一个图，如果强制i-&gt;i，然后不允许连向所有点生成的图能满足编号和的限制，那么其补图一定是个连通图，而且也满足编号和限制于是就很好构造了偶数数：{1,n-1},{2,n-2}……奇数：{1,n},{2,n-1}……{n/2+1}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e3+10; bool v[MAX_N][MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); if(n&amp;1) for(int i=1;i&lt;=n/2;i++) v[i][n-i]=1; else for(int i=1;i&lt;=n/2;i++) v[i][n+1-i]=1; printf("%d\n",n*(n-1)/2-(n/2) ); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(!v[i][j]) printf("%d %d\n",i,j); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; C请先思考后再展开 首先这个图必须是欧拉回路，否则没有合法解首先两个环如果有公共交点是可以合并为1个的，所以只要我们能找到至少3个环即可 结论1：如果有公共交点，那么那个公共交点的度数必然&gt;=6，如果有则合法证明：将这个点的欧拉路径分3段即可，必定经过这里6次以上 结论2：【度数=4】的点如果&gt;=3个，则合法证明：我们只需考虑每个点度数=2或4的情况，设某3个【度数=4】的点为A，B，C情况一，A出去的两个环，其中一个环B出现了两次，那么把B回到B的路径拉为第3个环即可情况二，在这两个环中B和C都在每个中出现一次，那么总能拆开来，画画图就知道了 结论3：【度数=4】的点如果=2个（显然1个的话无解）为什么不一定合法呢？可以看看官方题解的图即A和B之间恰好有两条路径（显然不会有除A、B外的交点）然后一个比较巧妙的判断方法是把A去掉后，连通块数&gt;=3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; int dg[MAX_N];pr e[MAX_N]; int fa[MAX_N];int findfa(int x) &#123;return x==fa[x]?x:fa[x]=findfa(fa[x]);&#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int tmp=0; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); dg[x]++;dg[y]++;e[i]=MP(x,y); &#125; for(int i=1;i&lt;=n;i++) if(dg[i]&amp;1) &#123;puts("No");return;&#125; for(int i=1;i&lt;=n;i++) if(dg[i]&gt;=6) &#123;puts("Yes");return;&#125; int cnt=0,A;for(int i=1;i&lt;=n;i++) if(dg[i]==4) cnt++,A=i; if(cnt&gt;=3) &#123;puts("Yes");return;&#125; if(cnt==1) &#123;puts("No");return;&#125; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) if(e[i].FR!=A and e[i].SE!=A) fa[findfa(e[i].FR)]=findfa(e[i].SE); int tot=0;for(int i=1;i&lt;=n;i++) tot+=(findfa(i)==i); if(tot&gt;=3) puts("Yes"); else puts("No"); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; D请先思考后再展开 先转化一下题意：把问题放到实数数轴上，那么显然每个数最多被操作一次$ans=\sum A(ai&lt;bi)+B(ai&gt;bi)$那么不难设计一个dp，自己想一下就好了 123456789101112131415161718ll f[MAX_N];//前缀和int a[MAX_N];void main()&#123; int n=qread(),A=qread(),B=qread(); for(int i=1;i&lt;=n;i++) a[qread()]=i; for(int i=1;i&lt;=n;i++) &#123; for(int j=n;j&gt;=0;j--) &#123; f[j]=f[j]+A*(a[i]&lt;=j)+B*(a[i]&gt;j); if(j==a[i]) chmin(f[j],f[j-1]); else if(j) chmin(f[j],f[j-1]+A*(a[i]&lt;j)+B*(a[i]&gt;j)); &#125; for(int j=1;j&lt;=n;j++) chmin(f[j],f[j-1]); &#125; ll ans=LLINF;for(int j=0;j&lt;=n;j++) chmin(ans,f[j]);write(ans);&#125; E请先思考后再展开 先有序化结论：一定存在一个合法方案形如证明的话，最好别像题解这样瞎jb画画图就没了，可以设未知数，列些不等式我在证颜色交叉那种情况的时候漏了几条不等式被mldD飞了 然后考虑那个分界点,满足左边是1~A,右边是B~n，如果 $B&lt;A$ 则取B，求A和B可以二分另外，个人认为官方题解有个小细节没证明，就是B&lt;=A不过也挺好证明的，反证一下，如果B&gt;A，即右边弹簧拉到最左，左边部分依然&gt;M，则直接全部红色会更优，即弹簧没有到最左12345678910111213141516171819202122232425262728293031323334int a[MAX_N];void main()&#123; int n=qread(),M=qread();for(int i=1;i&lt;=n*2;i++) a[i]=qread();sort(a+1,a+n+n+1); int l,r,A,B; l=1,r=n,A=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1;bool bk=0; for(int tl=1,tr=2*mid;tl&lt;=tr;tl++,tr--) if(a[tl]+a[tr]&gt;=M) &#123;bk=1;break;&#125; if(!bk) A=mid,l=mid+1; else r=mid-1; &#125; l=0,r=n-1,B=n; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1;bool bk=0; for(int tl=mid*2+1,tr=2*n;tl&lt;=tr;tl++,tr--) if(a[tl]+a[tr]&lt;M) &#123;bk=1;break;&#125; // printf("l=%d r=%d mid=%d bk=%d\n",l,r,mid,bk); if(!bk) B=mid,r=mid-1; else l=mid+1; &#125; if(B&gt;A) &#123; printf("error A=%d B=%d\n",A,B); &#125; else &#123; int mx=0; for(int tl=1,tr=2*B;tl&lt;=tr;tl++,tr--) chmax(mx,a[tl]+a[tr]); for(int tl=2*B+1,tr=2*n;tl&lt;=tr;tl++,tr--) chmax(mx,a[tl]+a[tr]-M); write(mx); &#125;&#125; F请先思考后再展开 0上有一个点，设[0,120)A类，[120,240)B类，[240,360)C类注意到不包含任意一个特殊点的区间一定不会是最优解（即&lt;1/3且其中一个为0的区间）于是把问题放到数轴[0,1/3]上且0为A类1/3为B类，相当于随机撒n-1个点随机定颜色答案为最小的异色点距离，显然是中间不会跨过其他点 然后接下来你有2种殊途同归的思考方式：A根据 这里的推导其中第k小没看懂的话还是有救的，请看方法B可知答案为 $\sum_{i=1}^n \frac{1}{3^{i-1}} \times \frac{1}{3} \times \frac{1}{in(n-i+1)}$B设 f(i,0/1/2)表示结尾颜色下i个异色块（两段的点颜色不同的块）的方案数（可有可无）观察一下转移和所求可以简化为 $f(i)=2f(i-2)+f(i-1)$$ans=\sum_{i=1}^n \frac{f(i) \times C_n^i}{3^{n-1}} \times g(i)$$g(i)为期望最小段长度=\frac{1}{i^2} \times \frac{i}{3n}=\frac{1}{3in}$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2510】弱题]]></title>
    <url>%2Fposts%2F41d4.html</url>
    <content type="text"><![CDATA[Sourcebzoj2510 Solution请先思考后再展开 长见识好题 不难想到一个朴素的3次方矩乘，然后你手玩一下会发现：第i行总是第i-1行右移一位，第i列总是第i-1列下移一位，然后第1列是第1行绕(1,1)逆时针90度得到的注意上面说的这些需要自行循环]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩乘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF700E】Cool Slogans]]></title>
    <url>%2Fposts%2Ff4a.html</url>
    <content type="text"><![CDATA[Sourceluogu翻译CF700E Solution请先思考后再展开 先给出一个n方的做法，f(l,r)表示这里所有子区间的mx那么除了f(l,r-1)和f(l+1,r)外，需要考虑的只是从所有border转移，然后因为我们包含了子区间，那么就只要从最大的border转移，可以枚举左端点用kmp求border12345678910111213141516171819202122char str[MAX_N];int nxt[MAX_N][MAX_N],f[MAX_N][MAX_N];void main()&#123; int n;scanf("%d%s",&amp;n,str+1); for(int l=1;l&lt;=n;l++) &#123; nxt[l][l]=l-1; for(int r=l+1;r&lt;=n;r++) &#123; int j=nxt[l][r-1];while(j&gt;l-1 and str[j+1]!=str[r]) j=nxt[l][j]; nxt[l][r]=j+(str[j+1]==str[r]); &#125; &#125; for(int ln=2;ln&lt;=n;ln++) for(int l=1;l&lt;=n;l++) &#123; int r=l+ln-1;f[l][r]=max(f[l+1][r],f[l][r-1]); if(nxt[l][r]&gt;l-1) chmax(f[l][r],f[l][nxt[l][r]]+1); &#125; printf("%d",f[1][n]+1);&#125; 方法一：sa看不懂，跑路了…… 方法二：sam首先对于某个合法序列，我们可以通过一些调整使得每一个都是前一个的后缀，而长度不变于是我们试图考虑sam的parent树 我们自然希望每个节点的值只有一个，然后全世界都说只需要考虑mx然后我一开始很懵逼，因为以为会有这种情况：!()[../images/题解图片/Cool_Slogans.png]神仙tkj反手就反证掉了这种情况：既然当前节点的mx没有去覆盖它，那么一定存在某个其他位置，mx左边的部分和紫色不同，则当前的fail和当前fail去除多出的部分一定不是相同节点，设为fail2则fail2是fail的fail，所以fail的mi一定至少在当前串外面 然后树上可持久化线段树合并求right集合然后递推，记录链上最大值的位置、值，只从那里转移，因为从其他地方转移最多和最大值相同，而长度更长时间复杂度为 $O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=4e5+10; const ll MOD=1e13; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int n;char str[MAX_N]; struct SegmentTree &#123; struct Nod&#123;int lc,rc,c;&#125;p[MAX_N*20*2]; int id;SegmentTree()&#123;id=0;memset(p,0,sizeof p);&#125; #define mid ((l+r)&gt;&gt;1) void insert(int &amp;x,int l,int r,int pos) &#123; if(!x) x=++id; p[x].c++;if(l==r) return; if(pos&lt;=mid) insert(p[x].lc,l,mid,pos); else insert(p[x].rc,mid+1,r,pos); &#125; void merg(int x,int &amp;y,int l,int r) &#123; if(!x) return; if(!y) &#123;y=x;return;&#125; int tmp=++id;p[tmp]=(Nod)&#123;p[y].lc,p[y].rc,p[y].c+p[x].c&#125;;y=tmp; if(l==r) return; merg(p[x].lc,p[y].lc,l,mid); merg(p[x].rc,p[y].rc,mid+1,r); &#125; bool find(int x,int l,int r,int fl,int fr) &#123; if(p[x].c==0 or fl&gt;fr) return 0; if(l==fl and r==fr) return 1; if(fr&lt;=mid) return find(p[x].lc,l,mid,fl,fr); if(fl&gt;mid) return find(p[x].rc,mid+1,r,fl,fr); return find(p[x].rc,mid+1,r,mid+1,fr) or find(p[x].lc,l,mid,fl,mid); &#125; &#125;sgt; int rt[MAX_N]; struct SAM &#123; struct Nod&#123;int son[26],fail,mx,rpos;&#125;p[MAX_N]; int id,lst;SAM()&#123;memset(p,0,sizeof p);id=lst=1;&#125; void insert(int pos,int c) &#123; int now=++id;p[now].mx=p[lst].mx+1;sgt.insert(rt[now],1,n,pos);p[now].rpos=pos; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; int b=p[a].son[c]; if(!b) p[now].fail=1; else &#123; if(p[b].mx==p[a].mx+1) p[now].fail=b; else &#123; int tmp=++id;p[tmp]=p[b];p[tmp].mx=p[a].mx+1;p[tmp].rpos=0; p[b].fail=p[now].fail=tmp; while(a and p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; &#125; lst=now; &#125; int ct[MAX_N],tmp[MAX_N];pr f[MAX_N]; void solve() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=id;i++) ct[p[i].mx]++; for(int i=1;i&lt;=n;i++) ct[i]+=ct[i-1]; for(int i=id;i&gt;=1;i--) tmp[ct[ p[i].mx ]--]=i; for(int i=id;i&gt;=2;i--) &#123; int x=tmp[i],fa=p[x].fail; sgt.merg(rt[x],rt[fa],1,n); chmax(p[fa].rpos,p[x].rpos); &#125; f[1]=MP(1,0);int ans=1; for(int i=2;i&lt;=id;i++) &#123; int x=tmp[i],to=f[p[x].fail].FR; int endpos=p[x].rpos; if(sgt.find(rt[to],1,n,max(endpos-p[x].mx+p[to].mx,1),endpos-1)) f[x]=MP(x,f[to].SE+1); else f[x]=f[p[x].fail]; chmax(ans,f[x].SE); &#125; write(ans); &#125; &#125;sam; void main() &#123; scanf("%d%s",&amp;n,str+1); for(int i=1;i&lt;=n;i++) sam.insert(i,str[i]-'a'); sam.solve(); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51nod1600】Simple KMP]]></title>
    <url>%2Fposts%2Fbe44.html</url>
    <content type="text"><![CDATA[Source51nod1600 Solution请先思考后再展开 将kmp深度转border可知$f(n)=f(n-1)+(f(n-1)-f(n-2))+\sum_{后缀} 出现次数$然后就lct在线维护parent树上信息即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; const int MAX_N=2e5+10; struct LCT &#123; struct Nod &#123; int son[2],fa; int siz,right,add,sum; int sum2; bool fz; &#125;p[MAX_N]; int id;LCT()&#123;id=0;memset(p,0,sizeof p);&#125; #define lc p[x].son[0] #define rc p[x].son[1] bool son(int x) &#123;return p[p[x].fa].son[1]==x;&#125; void rr(int x) &#123; if(p[x].fz) &#123; if(lc) p[lc].fz^=1,swap(p[lc].son[0],p[lc].son[1]); if(rc) p[rc].fz^=1,swap(p[rc].son[0],p[rc].son[1]); p[x].fz=0; &#125; &#125; void pushup(int x) &#123; p[x].sum2=p[x].siz; if(lc&gt;0) add(p[x].sum2,p[lc].sum2); if(rc&gt;0) add(p[x].sum2,p[rc].sum2); p[x].sum=(ll)p[x].siz*p[x].right%MOD; if(lc&gt;0) add(p[x].sum,p[lc].sum); if(rc&gt;0) add(p[x].sum,p[rc].sum); add(p[x].sum,(ll)(p[x].sum2-p[x].siz)*p[x].add%MOD); &#125; void pushdown(int x) &#123; if(p[x].add==0) return; if(lc) p[lc].right+=p[x].add,p[lc].add+=p[x].add,pushup(lc); if(rc) p[rc].right+=p[x].add,p[rc].add+=p[x].add,pushup(rc); p[x].add=0;pushup(x); &#125; void rotate(int x) &#123; int f=p[x].fa,ff=p[f].fa;if(p[ff].son[son(f)]==f) p[ff].son[son(f)]=x; int w=son(x),tt=p[x].son[1-w];p[x].son[1-w]=f;p[f].son[w]=tt; p[tt].fa=f;p[f].fa=x;p[x].fa=ff;pushup(f);pushup(x); &#125; bool isrt(int x) &#123;return p[x].fa==0 or p[p[x].fa].son[son(x)]!=x;&#125; int tmp[MAX_N]; void splay(int x) &#123; int tot=0,now=x;while(!isrt(now)) tmp[++tot]=now,now=p[now].fa; tmp[++tot]=now;for(int i=tot;i&gt;=1;i--) rr(tmp[i]),pushdown(tmp[i]); for(int f=p[x].fa;!isrt(x);rotate(x),f=p[x].fa) if(!isrt(f)) son(x)^son(f)?rotate(x):rotate(f); &#125; void access(int x) &#123; int lst=0; while(x) &#123; splay(x); p[x].son[1]=lst;p[lst].fa=x;pushup(x); lst=x;x=p[x].fa; &#125; &#125; void link(int x,int y) &#123; access(y);p[y].fa=x; &#125; int root; void makeroot(int x) &#123; root=x; access(x);splay(x); p[x].fz^=1;//swap(lc,rc); swap(p[x].son[0],p[x].son[1]); &#125; void cut(int x,int y) &#123; makeroot(x);access(y);splay(y); if(p[y].son[0]!=x) puts("error"); p[y].son[0]=p[x].fa=0;pushup(y); &#125; &#125;lct; int t[MAX_N]; int ans=0,kkk=0; struct SAM &#123; struct Nod&#123;int fail,mx,son[26];&#125;p[MAX_N]; int id,lst; void insert(int c) &#123; int now=++id;p[now].mx=p[lst].mx+1; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; if(a==0) p[now].fail=1; else &#123; int b=p[a].son[c]; if(p[b].mx==p[a].mx+1) &#123; p[now].fail=b; lct.makeroot(1);lct.access(b);lct.splay(b);add(kkk,lct.p[b].sum); &#125; else &#123; int tmp=++id;p[tmp]=p[b];p[tmp].mx=p[a].mx+1; lct.cut(b,p[b].fail);lct.splay(b);lct.p[b].siz=p[b].mx-p[tmp].mx;lct.pushup(b);//一个连通块 lct.p[tmp].siz=p[tmp].mx-p[p[tmp].fail].mx;lct.p[tmp].right=lct.p[b].right;lct.pushup(tmp); lct.link(p[tmp].fail,tmp);lct.link(tmp,b); lct.makeroot(1);lct.access(tmp);lct.splay(tmp);add(kkk,lct.p[tmp].sum); p[b].fail=p[now].fail=tmp; while(a and p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; &#125; int fa=p[now].fail; lct.makeroot(1);lct.access(fa);lct.splay(fa);lct.p[fa].add++;lct.p[fa].right++;add(lct.p[fa].sum,lct.p[fa].siz);lct.pushup(fa); lct.p[now].right=1;lct.p[now].siz=p[now].mx-p[fa].mx;lct.pushup(now);lct.link(fa,now); lst=now;add(ans,kkk); &#125; SAM()&#123;id=lst=1;memset(p,0,sizeof p);&#125; &#125;sam; char str[MAX_N]; void main() &#123; int n;scanf("%d%s",&amp;n,str+1); for(int i=1;i&lt;=n;i++) &#123; sam.insert(str[i]-'a'); printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度2</tag>
        <tag>lct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51nod1647】小Z的trie]]></title>
    <url>%2Fposts%2F4085.html</url>
    <content type="text"><![CDATA[Source51nod1647 Solution请先思考后再展开 这题做法其实挺sb的就建个广义sam，然后倍增找到具体状态，答案为其right集合大小 写博客的理由：这sb题卡了我3h的空间主要是我用了map来达到trie和sam的线性空间后，并没有意识到如果开数组，倍增和trie是可以共用的，可以省下一大笔空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+2,MAX_M=1e6+2,MAX_T=1800010; int f[MAX_T][26]; struct SAM &#123; struct Nod&#123;int fail,mx,siz,son[26];&#125;p[MAX_T]; int id; int insert(int lst,int c) &#123; int now=++id;p[now].mx=p[lst].mx+1;p[now].siz++; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; if(a==0) p[now].fail=1; else &#123; int b=p[a].son[c]; if(p[b].mx==p[a].mx+1) p[now].fail=b; else &#123; int tmp=++id;p[tmp]=p[b];p[tmp].mx=p[a].mx+1;p[tmp].siz=0; p[b].fail=p[now].fail=tmp; while(a and p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; &#125; return now; &#125; vector&lt;int&gt; son[MAX_T]; void dfs(int x,int fa) &#123; f[x][0]=fa;for(int i=1;i&lt;=22;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];dfs(y,x); p[x].siz+=p[y].siz; &#125; &#125; void pre() &#123; for(int i=1;i&lt;=id;i++) son[p[i].fail].PB(i); memset(f,0,sizeof f); dfs(1,0); &#125; int solve(int x,int ln) &#123; if(p[x].mx&lt;=ln) return p[x].siz;//debug for(int i=22;i&gt;=0;i--) if(p[f[x][i]].mx&gt;=ln) x=f[x][i]; return p[x].siz; &#125; SAM()&#123;id=1;memset(p,0,sizeof p);&#125; &#125;sam; char str[MAX_M];int ln; vector&lt;int&gt; pp[MAX_N];int pos[MAX_M]; struct Trie &#123; int id;Trie()&#123;id=1;&#125; void insert(int now) &#123; pp[now].PB(0); for(int x=1,i=1;i&lt;=ln;i++) &#123; int c=str[i]-'a'; if(!f[x][c]) f[x][c]=++id; x=f[x][c];pp[now].PB(x); &#125; &#125; queue&lt;int&gt; q; void bfs() &#123; q.push(1);pos[1]=1; while(q.size()) &#123; int x=q.front();q.pop(); for(int i=0;i&lt;26;i++) if(f[x][i]&gt;0) pos[f[x][i]]=sam.insert(pos[x],i),q.push(f[x][i]); &#125; &#125; &#125;tr; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",str+1),ln=strlen(str+1),tr.insert(i); tr.bfs();sam.pre(); int m;scanf("%d",&amp;m); while(m--) &#123; int now=qread(),x=qread(),y=qread(); writeln(sam.solve(pos[pp[now][y]],y-x+1)); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WC2016】论战捆竹竿]]></title>
    <url>%2Fposts%2F7e8f.html</url>
    <content type="text"><![CDATA[SourceWC2016uoj172 Solution请先思考后再展开 官方题解 先讲讲部分分热热身，显然是个border相关的无限背包因为长度n可以随便加，那么这就是一个循环图（模数为n）的可达性统计考虑求到达这个余数需要的最小长度（和这题的思想类似），暴力dij是带log的，可能被卡因为边的种类最多n个，考虑每种边L的贡献（border为n-L）注意到从每个点出发，回到这里需要走lcm(L,n)，即lcm(L,n)/L步因为每个点只会在一个环里面，故环个数为gcd(L,n)（其实你不算这个也没什么啦）从每个环最小的位置开始更新，这样就能少一个log【这里的模型挺经典的】然后还有20分，是w较小的，众所周知存在性无限背包可以用bitset优化，时间复杂度为 O(Twn/32)算出来相同复杂度的分治+fft据说会被卡常 接下来的部分需要一些前置知识因为这个border的等差数列只有log个，考虑利用等差数列的性质设当前等差数列首项a和公差d，长ln，很自然的想法是考虑利用公差不妨把n个点按%d的余数分组，那么点i会更新(i+a)%n开始的一段连续区间，考虑线段树优化建图那么log组，每组O(n)点，O(nlog(n/d))条边，跑dij，不知为何题解上说是双log的，个人感觉d可能=1 我们需要更优秀的做法，观察上面的做法，瓶颈依旧是转移边过多（尽管已经尽力优化为一个log了）再考虑利用首项a。我们之所以只建了n个点，是因为得到最小代价后，后面是可以任意用的类似的，当前首项a也是可以任意用的，考虑把n个点改为a个点会发生什么：假设我们已经处理完了前面的等差数列，而且经过处理现在恰好a个点，而且更新完毕，现在考虑将新的等差数列加入背包因为转移边中a已经被模去了，考虑d，和前面类似的分为gcd(a,d)个环，每个环相邻差为d（模意义下）然后和上面类似取出每个环，从环最小的值所在位置开始更新，这次一次转移ln-1种$f(i)=min:f(i),f(j)+d \times (i-j)+a,j&lt;i,j \geq i-(ln-1) \times d$这个显然可以单调队列优化 剩下的唯一问题就是如何把当前的答案A贡献到下次的答案B中？$B[A_i\%b] \gets A_i,B[(i+a)\%b] \gets B[i]+a$ ，注意这里只有一个a，因为其他a已经被统计了第一步直接扔过去，第二步又是个无限背包，那我们再次分为gcd(a,b)个环去更新（和暴力一样） 时间复杂度为 O(nlogn)uoj要卡常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; #define sum(x,mm) ((x)&gt;=(mm)?(x)-(mm):(x)) const int MAX_N=5e5+10; struct Data&#123;int a,d,ln;&#125;; ll f[MAX_N],g[MAX_N];bool v[MAX_N];int mi; void getcc(int st,int kk,int aa) &#123; v[st]=1;mi=st;int tt=sum(st+kk,aa); while(tt!=st) &#123; if(f[tt]&lt;f[mi]) mi=tt; v[tt]=1;tt=sum(tt+kk,aa); &#125; &#125; pr q[MAX_N]; void calc(Data now,int lst) &#123; for(int i=0;i&lt;now.a;i++) g[i]=LLINF; for(int i=0;i&lt;lst;i++) chmin(g[f[i]%now.a],f[i]); for(int i=0;i&lt;now.a;i++) v[i]=0,f[i]=g[i]; for(int i=0;i&lt;now.a;i++) if(!v[i]) &#123; int m=lst%now.a;getcc(i,m,now.a); int tt=mi; while(1) &#123; chmin(f[sum(tt+m,now.a)],f[tt]+lst); tt=sum(tt+m,now.a);if(tt==mi) break; &#125; &#125; for(int i=0;i&lt;now.a;i++) v[i]=0; for(int i=0;i&lt;now.a;i++) if(!v[i]) &#123; int m=now.d%now.a;getcc(i,m,now.a); int tou=1,wei=1;q[1]=MP(mi,0); for(int tt=sum(mi+m,now.a),tmp=1;tt!=mi;tt=sum(tt+m,now.a),tmp++) &#123; while(tou&lt;=wei and q[tou].SE+(now.ln-1)&lt;tmp) tou++; if(tou&lt;=wei) chmin(f[tt],f[q[tou].FR]+ll(tmp-q[tou].SE)*now.d+now.a); while(tou&lt;=wei and f[q[wei].FR]-f[tt]&gt;=ll(q[wei].SE-tmp)*now.d) wei--; q[++wei]=MP(tt,tmp); &#125; &#125; &#125; Data s[30];int cnt=0; char str[MAX_N];int nxt[MAX_N]; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;ll w;scanf("%d%lld",&amp;n,&amp;w);gets(str+1);gets(str+1); nxt[1]=0; for(int i=2;i&lt;=n;i++) &#123; int j=nxt[i-1];while(j and str[j+1]!=str[i]) j=nxt[j]; nxt[i]=j+(str[j+1]==str[i]); &#125; cnt=0; for(int k=nxt[n];1;k=nxt[k]) &#123; int tt=n-k; if(cnt&gt;0 and s[cnt].ln==1) s[cnt].ln++,s[cnt].d=(tt-s[cnt].a); else if(cnt&gt;0 and tt==s[cnt].a+s[cnt].ln*s[cnt].d) s[cnt].ln++; else s[++cnt]=(Data)&#123;tt,0,1&#125;; if(k==0) break; &#125; int lst=n;memset(f,0x3f,sizeof f);f[0]=n; for(int i=1;i&lt;=cnt;i++) calc(s[i],lst),lst=s[i].a; ll ans=0;for(int i=0;i&lt;lst;i++) if(f[i]&lt;=w) ans+=(w-f[i])/lst+1; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ctsc2012】Cheat]]></title>
    <url>%2Fposts%2F6eac.html</url>
    <content type="text"><![CDATA[SourceCtsc2012bzoj2806 Solution请先思考后再展开 考虑如何快速地判断一个区间是否合法sa，二分一下左右第一个hei比len小的位置，得到区间，询问区间是否有模式串，这个可以前缀和sam，无法快速地从空串跳到对应位置，但不代表不能用sam注意sam在询问状态的时候，可以同时用dag在后面加/减字符，也可以用parent树在前面加/减字符 首先，对于每个询问，L是满足二分性的，因为划分方法不变，划分的合法部分不减，考虑如何check(L&gt;=len)对于每个询问串，f(i)表示以位置i为划分结尾的所有划分方案中，合法长度最长为多少，g(i)为其前缀max考虑用尺取法获得每个位置，左端点必须&gt;rp，这个用广义sam是线性的，用sa是log的$f(i)=^{max}_{rp&lt;pos \leq i-L+1} { g(pos-1)+(i-pos+1) },g(i-1)$这就是一个维护单调队列，给内部整体加的模型，是线性的 总复杂度为 $O(n+nlogn)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2012】喵星球上的点名]]></title>
    <url>%2Fposts%2F3351.html</url>
    <content type="text"><![CDATA[SourceSCOI2012luogu2336 Solution请先思考后再展开 两个问：求每次叫了多少人、求被叫了多少次 方法一：广义sam建广义sam，这里姓名这个东西其实没有区别的，此处复杂度为nlogn （大字符集）对于第一问，把每个询问挂在对应的状态上，最后扫一遍parent树，就是要求dfs序区间不同颜色数，可以离线+树状数组，复杂度nlogn（用线段树合并nlogn，用dsu则是log方）对于第二问，就是有多少个询问，其子树内有我这个串的点，那这个可以预处理好树上前缀和表示多少个询问然后给这个串建一个虚树，注意要特判根，这部分的复杂度为线性 方法二：sa先做第一问我母串就是和我lcp=我的长度的人的后缀，可以线性求左右两边第一个比我小的，然后就是区间有多少个颜色，这个和上面一样是log的第二问就是每个颜色被多少个区间覆盖，那么枚举每个位置，用个树状数组存储现在覆盖这段区间的那些左端点，那么新覆盖这个颜色的区间就是询问一个后缀和就是把区间贡献到同颜色的第一个里面 这两个做法的时空复杂度、代码复杂度相当，个人认为第一个比较粗暴无脑好想]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cf708d】Incorrect Flow]]></title>
    <url>%2Fposts%2F4331.html</url>
    <content type="text"><![CDATA[Sourcecf708d Hint请先思考后再展开 个人感觉和有源汇上下界可行流的思想有点类似建议先去看看，或许会有启发，反正我是这样的…… Solution请先思考后再展开 建图的正确性比较显然，就只讲讲怎么建以及思路 首先我们先不考虑容量的限制则为了流量守恒，ins(n-&gt;1,INF)后，对每个点入流出流差分类为正负，分别连接st和ed然后对于每条有向边，ins(x,y,INF,1),ins(y,x,c,1)，最大流一定能满流 然后考虑容量其实也没什么区别，就是要分段讨论一个费用$$1)c&lt;mx,ins(x,y,mx-c,1),ins(x,y,INF,2),ins(y,x,c,1)\\2)c \geq mx,ans+=c-mx,ins(x,y,INF,2),ins(y,x,c-mx,0),ins(y,x,mx,1)$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=110,MAX_M=1e5; int hou[MAX_N],cur[MAX_N]; struct Edge&#123;int y,g,c,w;&#125;e[MAX_M*2]; int ln=0;int oth(int x)&#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c,int w) &#123; if(c==0) return; e[++ln]=(Edge)&#123;y,hou[x],c,w&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0,-w&#125;;hou[y]=ln; &#125; int st,ed;queue&lt;int&gt; q;bool v[MAX_N]; int dis[MAX_N],fm[MAX_N],mic[MAX_N]; int ans=0; bool solve() &#123; memset(dis,0x3f,sizeof dis); memset(v,0,sizeof v);v[st]=1; q.push(st);dis[st]=0;mic[st]=INF; while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&gt;dis[x]+e[k].w and e[k].c) &#123; dis[y]=dis[x]+e[k].w; mic[y]=min(mic[x],e[k].c);fm[y]=k; if(!v[y]) v[y]=1,q.push(y); &#125; &#125; v[x]=0; &#125; if(mic[ed]==0 or dis[ed]==INF) return 0; ans+=dis[ed]*mic[ed]; for(int x=ed;x!=st;x=e[oth(fm[x])].y) e[fm[x]].c-=mic[ed],e[oth(fm[x])].c+=mic[ed]; return 1; &#125; int sum[MAX_N]; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m);st=0,ed=n+1;ins(n,1,INF,0);//假装流掉的真实流大小 for(int i=1;i&lt;=m;i++) &#123; int x,y,c,mx;scanf("%d%d%d%d",&amp;x,&amp;y,&amp;mx,&amp;c); if(c&lt;mx) ins(x,y,mx-c,1),ins(y,x,c,1),ins(x,y,INF,2); else ans+=c-mx,ins(x,y,INF,2),ins(y,x,c-mx,0),ins(y,x,mx,1); sum[x]-=c;sum[y]+=c; &#125; for(int i=1;i&lt;=n;i++) if(sum[i]&gt;0) ins(st,i,sum[i],0); else ins(i,ed,-sum[i],0); while(solve()) ; printf("%d",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Zjoi2015】诸神眷顾的幻想乡]]></title>
    <url>%2Fposts%2Fadb7.html</url>
    <content type="text"><![CDATA[SourceZjoi2015bzoj3926 Hint请先思考后再展开 考虑怎样让一段路径变为连续的一段 Solution请先思考后再展开 对于某个路径，任意选一个点子树内的叶子节点作为根，这个路径就是连续一段了那么枚举每个叶子节点，插入到广义sam里面就好了时间复杂度为 $200n$ upd：这里代码是错误的，在线建广义sam不是这么建的，应该用bfs不过我懒得改了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10;ll ans=0; struct SAM &#123; struct Nod&#123;int son[11],fail,mx;&#125;p[2*MAX_N*20]; int id; int insert(int lst,int c) &#123; int now=++id;p[now].mx=p[lst].mx+1; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; int b=p[a].son[c]; if(!b) p[now].fail=1; else &#123; if(p[b].mx==p[a].mx+1) p[now].fail=b; else &#123; int tmp=++id;p[tmp]=p[b];p[tmp].mx=p[a].mx+1; p[b].fail=p[now].fail=tmp; while(a and p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; &#125; return now; &#125; SAM()&#123;id=1;memset(p,0,sizeof p);&#125; &#125;sam; int col[MAX_N],ru[MAX_N]; vector&lt;int&gt; son[MAX_N]; void dfs(int lst,int x,int fa) &#123; int now=sam.insert(lst,col[x]); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; dfs(now,y,x); &#125; &#125; void main() &#123; int n,cc;scanf("%d%d",&amp;n,&amp;cc); for(int i=1;i&lt;=n;i++) col[i]=qread(); for(int i=1;i&lt;n;i++) &#123; int x=qread(),y=qread(); son[x].PB(y);son[y].PB(x); ru[x]++;ru[y]++; &#125; for(int i=1;i&lt;=n;i++) if(ru[i]==1) dfs(1,i,0); for(int i=2;i&lt;=sam.id;i++) ans+=(sam.p[i].mx-sam.p[sam.p[i].fail].mx); printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC031题解]]></title>
    <url>%2Fposts%2F6c0c.html</url>
    <content type="text"><![CDATA[SourceAGC031 参考zsysjq A请先思考后再展开 每种颜色大小+1的乘积-112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; const int MAX_N=1e5+10; char s[MAX_N]; int f[30]; void main() &#123; int n;scanf("%d",&amp;n); scanf("%s",s+1);for(int i=1;i&lt;=n;i++) f[s[i]-'a']++; ll ans=1;for(int i=0;i&lt;26;i++) ans=ans*(f[i]+1)%MOD; printf("%lld",(ans+MOD-1)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; B请先思考后再展开 凭直觉想到的……就是我们希望找到多少种不同的操作序列，然后注意到真正有意义的操作是互不重叠的然后如果一个操作能被多个操作等效替代，或者不操作也行，那么是没有意义的所以我们只需要考虑互不重叠的、中间没有这个颜色的、长度&gt;2的操作即可设f(i)表示考虑了前i位，而且最后一次操作的右端点在i这个dp用前缀和优化一下就是线性的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; int c[MAX_N],lst[MAX_N],pos[MAX_N]; const int MOD=1e9+7; ll f[MAX_N],g[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; c[i]=qread(); lst[i]=pos[c[i]]; pos[c[i]]=i; &#125; f[0]=g[0]=1; for(int i=1;i&lt;=n;i++) &#123; int j=lst[i]; if(j&lt;i-1 and j!=0) f[i]=g[j]; g[i]=(g[i-1]+f[i])%MOD; &#125; printf("%lld",g[n]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; C请先思考后再展开 $2^n个数，变化2^n-1次，为奇数，故A和B的popcount奇偶性不同$考虑以构造的方式证明，当A和B满足上述条件时，至少有一组方案归纳法，n=1显然成立，然后假设n=k成立，现在尝试做n=k+1去掉A和B的某个不同位置后，A和B的popcount奇偶性相同，然后我们令C为与当前A差一位的数那么我们到n=k下，得出A-&gt;C和C-&gt;B，然后左边插入A少的那一位，右边插入B少的那一位然后这样就能满足奇偶性的那个性质了代码实现也是类似这样归纳，时间复杂度为 $O(n2^n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; int bin[30],ct[1&lt;&lt;21]; vector&lt;int&gt; ans[30]; int lowbit(int x) &#123;return x&amp;-x;&#125; void solve(int mask,int a,int b) &#123; int len=ct[mask]; ans[len].resize(0); if(len==1)&#123;ans[len].PB(a&amp;mask);ans[len].PB(b&amp;mask);return;&#125; int k=lowbit((a^b)&amp;mask),c=a^lowbit(mask^k); solve(mask^k,a,c);for(int t=0;t&lt;(int)ans[len-1].size();t++) ans[len].PB(ans[len-1][t]^(a&amp;k)); solve(mask^k,c,b);for(int t=0;t&lt;(int)ans[len-1].size();t++) ans[len].PB(ans[len-1][t]^(b&amp;k)); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; for(int i=1;i&lt;=bin[20];i++) ct[i]=ct[i&gt;&gt;1]+(i&amp;1); int n,a,b;scanf("%d%d%d",&amp;n,&amp;a,&amp;b); if((ct[a]&amp;1)==(ct[b]&amp;1)) &#123;puts("NO");return;&#125; puts("YES");solve(bin[n]-1,a,b); for(int t=0;t&lt;(int)ans[n].size();t++) printf("%d ",ans[n][t]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; D请先思考后再展开 看到这题后，就想着应该要用公式化的语言，找到一些规律什么的……但不知道怎么表达这个操作随便手画了一个n=3发现循环节是6但没敢画下去了，嫌麻烦…… 我们定义排列的乘法： $pq=A,A[i]=p_{q_i}$那么我们自然希望 $A \times 1=A$ 故1应为递增的序列注意这个东西是不满足交换律的，所以做除法的时候顺序要倒过来那么逆元也是可求的 $[f(p,q)]_p_i=q_i,f(p,q)p=q,f(p,q)=qp^{-1}$然后把前面若干项列出来$$a_1=p\a_2=q\a_3=qp^{-1}\a_4=qp^{-1}q^{-1}\a_5=qp^{-1}q^{-1}pq^{-1}\a_6=qp^{-1}q^{-1}ppq^{-1}\a_7=qp^{-1}q^{-1}pqpq^{-1}\a_8=qp^{-1}q^{-1}pqp^{-1}qpq^{-1}$$然后你会发现 $A=qp^{-1}q^{-1}p,a_n=Aa_{n-6}A^{-1}$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; struct PP &#123; int m[MAX_N];PP()&#123;memset(m,0,sizeof m);&#125; int&amp; operator [] (int i) &#123;return m[i];&#125; PP inv() &#123; PP b;for(int i=1;i&lt;MAX_N;i++) b[m[i]]=i; return b; &#125; friend PP operator * (PP a,PP b) &#123; PP c;for(int i=1;i&lt;MAX_N;i++) c[i]=a[b[i]]; return c; &#125; friend PP operator / (PP a,PP b) &#123; return a*b.inv(); &#125; &#125;; PP qpower(PP x,int e) &#123; PP ans;for(int i=1;i&lt;MAX_N;i++) ans[i]=i; while(e) &#123; if(e&amp;1) ans=ans*x; x=x*x;e&gt;&gt;=1; &#125; return ans; &#125; PP a[10],A,ans; void main() &#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) a[1][i]=qread(); for(int i=1;i&lt;=n;i++) a[2][i]=qread(); a[0]=a[2].inv()*a[1];for(int i=3;i&lt;=5;i++) a[i]=a[i-1]/a[i-2]; A=a[2]/a[1]/a[2]*a[1];ans=qpower(A,k/6)*a[k%6]/qpower(A,k/6); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; E请先思考后再展开 枚举最后选了T个 先考虑只有一维的情况$$\begin{aligned}&amp;L:[x \leq a_i] \leq b_i \to A[b_i+1]&gt;a_i\\&amp;R:[x \geq a_i] \leq b_i \to A[T-b_i] \leq a_i-1\\&amp;注意这里不能死板地认为二分图中L_i选择的就是第i个珠子\\&amp;那么你会发现推一下标记即可得到连边的不重叠区间，如果重叠就不能这么做了\end{aligned}$$ 二维的话，左右都有限制，类似于每个点在两侧占用配额权值拆点即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1100,MAX_M=1e5; int hou[MAX_N]; struct Edge&#123;int y,g,c;ll w;&#125;e[MAX_M*2]; int ln=0;int oth(int x)&#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c,ll w) &#123; if(c==0) return; e[++ln]=(Edge)&#123;y,hou[x],c,w&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0,-w&#125;;hou[y]=ln; &#125; int st,ed;queue&lt;int&gt; qq;bool v[MAX_N]; ll dis[MAX_N];int fm[MAX_N],mic[MAX_N]; ll ans;int flow; bool solve() &#123; memset(dis,-0x3f,sizeof dis); memset(v,0,sizeof v);v[st]=1; qq.push(st);mic[st]=INF;dis[st]=0; while(qq.size()) &#123; int x=qq.front();qq.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&lt;dis[x]+e[k].w and e[k].c) &#123; dis[y]=dis[x]+e[k].w; mic[y]=min(mic[x],e[k].c);fm[y]=k; if(!v[y]) v[y]=1,qq.push(y); &#125; &#125; v[x]=0; &#125; if(mic[ed]==0 or dis[ed]&lt;0) return 0; ans+=dis[ed]*mic[ed];flow+=mic[ed]; for(int x=ed;x!=st;x=e[oth(fm[x])].y) e[fm[x]].c-=mic[ed],e[oth(fm[x])].c+=mic[ed]; return 1; &#125; int n,m;ll val[MAX_N]; pr pt[MAX_N];struct Qes&#123;int a,b;char op[10];&#125;q[MAX_N]; int fl[2][MAX_N],fr[2][MAX_N]; ll getans(int T) &#123; ln=0;memset(hou,0,sizeof hou);st=0,ed=n*4+1; for(int i=1;i&lt;=n;i++) ins(i,n+i,1,val[i]); memset(fl,0,sizeof fl);memset(fr,0x3f,sizeof fr);fl[0][1]=1;fr[0][T]=100;fl[1][1]=1;fr[1][T]=100; for(int i=1;i&lt;=m;i++) if(q[i].b&lt;T) &#123; if(q[i].op[0]=='L') chmax(fl[0][q[i].b+1],q[i].a+1); if(q[i].op[0]=='R') chmin(fr[0][T-q[i].b],q[i].a-1); if(q[i].op[0]=='D') chmax(fl[1][q[i].b+1],q[i].a+1); if(q[i].op[0]=='U') chmin(fr[1][T-q[i].b],q[i].a-1); &#125; for(int i=1;i&lt;T;i++) chmax(fl[0][i+1],fl[0][i]);for(int i=T;i&gt;=2;i--) chmin(fr[0][i-1],fr[0][i]); for(int i=1;i&lt;=T;i++) &#123; ins(st,n*2+i,1,0); for(int j=1;j&lt;=n;j++) if(fl[0][i]&lt;=pt[j].FR and pt[j].FR&lt;=fr[0][i]) ins(n*2+i,j,1,0); &#125; for(int i=1;i&lt;T;i++) chmax(fl[1][i+1],fl[1][i]);for(int i=T;i&gt;=2;i--) chmin(fr[1][i-1],fr[1][i]); for(int i=1;i&lt;=T;i++) &#123; ins(n*3+i,ed,1,0); for(int j=1;j&lt;=n;j++) if(fl[1][i]&lt;=pt[j].SE and pt[j].SE&lt;=fr[1][i]) ins(n+j,n*3+i,1,0); &#125; ans=0;flow=0;while(solve()) ; return ans*(flow==T); &#125; void main() &#123; n=qread();for(int i=1;i&lt;=n;i++) scanf("%d%d%lld",&amp;pt[i].FR,&amp;pt[i].SE,&amp;val[i]); m=qread();for(int i=1;i&lt;=m;i++) scanf("%s%d%d",q[i].op,&amp;q[i].a,&amp;q[i].b); ll ans=0;for(int T=1;T&lt;=n;T++) ans=max(ans,getans(T)); printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; F请先思考后再展开 有个比较巧妙的转化：因为代价是个多项式的形式，可以联想到秦九韶正着走，那么代价会和点、第几条边、当前和有关，但倒着走则只和当前点、当前和有关(a-&gt;2a+c)那么相当于有n乘mod个点，要求判断可达性 考虑这个模型的特殊性质： 边是双向的，如果不停经过同一条边， $2^{MOD-1}=1,MOD-1为偶数，且c前面的常数总是a系数-1，则回到a是一个偶环，所以会恰好回到(x,a)$ 考虑同一个点旁边的两条边，(x,4a+3n)与(x,4n+3m)等价，即可以任意加上3(n-m)那么这个就是在模M意义下，存在某个跨度T的经典模型考虑到回到原地需要lcm(M,T)/T步，即存在gcd(M,T)个环，且由裴蜀定理知与x同个环的序列上下个元素，与x的差为gcd(M,T)故可以把0~gcd(M,T)-1作为每个环的起点，即可以 $M \gets gcd(M,T)$又因为图是连通的，那么每两条边都能影响整个图的所有点，$(x,a)与(x,a+3g)等价,g=所有边的差与MOD的gcd$$g|a-b且g|a-c \to g|b-c$ ，所以这个g可以通过所有边和第一条边的差与MOD的gcd得到（注意这里我可以直接说a与a+gcd(边差,MOD)，但为了后面方便用a+gcd(3gcd(边差,MOD),MOD)显然没影响） 于是M=g或3g，此时边权%g相同=z，考虑所有边权-=z，然后状态+=z不难证明这样是等价的，只不过我们需要询问的是(st,z)-&gt;(ed,r+z)此时所有边都是g的倍数，边的部分的影响就是 $bg(0 \leq b \leq 2)$除此之外我们关心的就是z，z-&gt;2z+c-&gt;4z+3c，故可表示为 $az(1 \leq a \leq 2)$ ，这里1z表示系数为2的奇数次幂于是现在图上面只有6n个状态了…… 需要预处理一下z前2的次幂可达状态 忘记翻转ed和st，调了很久……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e5+10; struct DSU &#123; int fa[MAX_N];DSU()&#123;for(int i=0;i&lt;MAX_N;i++) fa[i]=i;&#125; int findfa(int x) &#123;return x==fa[x]?x:fa[x]=findfa(fa[x]);&#125; bool okay(int x,int y) &#123;return findfa(x)==findfa(y);&#125; void merg(int x,int y) &#123;fa[findfa(x)]=findfa(y);&#125; &#125;dsu; int gcd(int x,int y) &#123;return y==0?x:gcd(y,x%y);&#125; struct Edge&#123;int x,y,c;&#125;e[MAX_N]; int calc(int x,int a,int b)&#123;return 6*(x-1)+3*a+b;&#125; bool tmp[2][1100000]; void main() &#123; int n,m,q,M;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;M);int g=M; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].c),g=gcd(g,abs(e[i].c-e[1].c)); M=gcd(M,3*g);int z=e[1].c%g; for(int i=1;i&lt;=m;i++) &#123; int x=e[i].x,y=e[i].y,c=(e[i].c-z)/g; for(int a=0;a&lt;=1;a++) for(int b=0;b&lt;=2;b++) &#123; dsu.merg(calc(x,a,b),calc(y,a^1,(b*2+c)%3)); dsu.merg(calc(y,a,b),calc(x,a^1,(b*2+c)%3)); &#125; &#125; for(int i=0,j=z;i&lt;M;i++,j=j*2%M) tmp[i&amp;1][j]=1; while(q--) &#123; int x,y,r;scanf("%d%d%d",&amp;x,&amp;y,&amp;r); bool bk=0; for(int a=0;a&lt;=1;a++) for(int b=0;b&lt;=2;b++) if(dsu.okay(calc(y,0,0),calc(x,a,b)) and tmp[a][ (r+z+(3-b)*g)%M ]) bk=1; puts(bk?"YES":"NO"); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3441】乌鸦喝水]]></title>
    <url>%2Fposts%2Fa456.html</url>
    <content type="text"><![CDATA[Sourcebzoj3441 Hint请先思考后再展开 按被删除的顺序考虑每个点，然后按照题意模拟 Solution请先思考后再展开 被删除的顺序一定是按照【能被操作的次数】为第一关键字，位置作为第二关键字然后你维护当前轮数和当前走到什么位置（我存了具体位置，其实应该存排名更好写……）用个树状数组资瓷排名和位置之间的转化即可时间复杂度为 $O(nlogn)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; int bin[30]; struct BIT &#123; int bit[MAX_N];BIT()&#123;memset(bit,0,sizeof bit);&#125; int lowbit(int x) &#123;return x&amp;-x;&#125; void add(int x,int c) &#123;while(x&lt;MAX_N) bit[x]+=c,x+=lowbit(x);&#125; int ask(int x) &#123;int ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; int findk(int k) &#123; int ans=0; for(int i=20;i&gt;=0;i--) if(ans+bin[i]&lt;MAX_N and k&gt;=bit[ans+bin[i]]) k-=bit[ans+bin[i]],ans+=bin[i]; return ans; &#125; &#125;bit; pr a[MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m,all;scanf("%d%d%d",&amp;n,&amp;m,&amp;all); for(int i=1;i&lt;=n;i++) a[i].FR=all-qread()+1; for(int i=1;i&lt;=n;i++) a[i].FR=ceil((double)a[i].FR/qread()),a[i].SE=i,bit.add(i,1); sort(a+1,a+n+1); ll ans=0,dec=0;int turn=1,pos=1;//pos=应从哪里开始 for(int i=1;i&lt;=n and turn&lt;=m;i++) &#123; int rk=bit.ask(pos); ll tmp=a[i].FR-dec;int me=bit.ask(a[i].SE); if(tmp&gt;0) &#123; int rk2=(tmp+rk-1)%(n-i+1),t2=(tmp+rk-1)/(n-i+1); if(rk2==0) rk2=n-i+1,t2--; if(turn+t2&gt;m) &#123;ans+=ll(m-turn)*(n-i+1)+(n-i+1-rk+1);break;&#125; turn+=t2;dec+=tmp;ans+=tmp; if((me==n-i+1 and rk2==n-i) or rk2==n-i+1) rk2=1,turn++; else if(rk2&lt;me) rk2++; bit.add(a[i].SE,-1); pos=bit.findk(rk2); &#125; else &#123; if(rk&gt;me) rk--; if(rk==n-i+1) rk=1,turn++; bit.add(a[i].SE,-1); pos=bit.findk(rk); &#125; &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ahoi2014&Jsoi2014】骑士游戏]]></title>
    <url>%2Fposts%2F4c92.html</url>
    <content type="text"><![CDATA[SourceAhoi2014&amp;Jsoi2014bzoj3875 Hint请先思考后再展开 很多思路最终都不可避免地到环的问题本题的特点在于是对y求和，不妨先求和y的魔法值，然后在此基础上考虑更新 Solution请先思考后再展开 这个求和不太常见，但这种类似更新的东西，应该是类似于记忆化搜索、最短路这种东西的 我们需要保存f和g表示当前代价、上次向外更新的代价$f_y=min(f_y,f_y-g_x+f_x)$我们尽可能使用复杂度稳定的方法，如dij，考虑如何让每个点只出去更新一次注意到上面的转移中暗含了一个限制，我还真没看出来……$f_y \geq g_x$那么我们只要按照f从小到大更新，没更新我的，f不会比当前小，则无法构成更新 时间复杂度为 $O(nlogn)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WF2011】To Add or to Multiply]]></title>
    <url>%2Fposts%2Ffa84.html</url>
    <content type="text"><![CDATA[Source更好的题面bzoj3957 Hint请先思考后再展开 因为没有模，先考虑不缩长度的 $num \times x^a+by$ 注意a是log级别的，直接枚举然后贪心利用多项式缩小长度 Solution请先思考后再展开 尽管很快会做，这题细节非常多，写了1个多h，把我完全写自闭了时间复杂度是log方的具体怎么做很难解释，建议看代码（我感觉我的代码有意义部分算短的了）我的特判略多，可以稍微少一点的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; void main() &#123; int T=0; while(1) &#123; ll x,y,a,b,c,d;scanf("%lld%lld%lld%lld%lld%lld",&amp;x,&amp;y,&amp;a,&amp;b,&amp;c,&amp;d); if(x==0) break; printf("Case %d:",++T); if(c&lt;=a and b&lt;=d) &#123;puts(" empty");continue;&#125; int t=0;ll ty=1; vector&lt;pr&gt; ans;int now=INF; while(ty&lt;=INF) &#123; if( (b-a)*ty&gt;(d-c) ) break; int cnt=0; vector&lt;pr&gt; tt; ll nowa=a*ty,nowb=b*ty; for(int i=ty;i&gt;=1;i/=y) &#123; if(nowa&lt;c and nowb+i*x&lt;=d) &#123; int tmp2=ceil(double(c-nowa)/i/x); if(nowb+tmp2*i*x&lt;=d) &#123; nowa+=tmp2*i*x;nowb+=tmp2*i*x; tt.PB(MP(0,tmp2));cnt+=tmp2; &#125; else &#123; int tmp=floor(double(d-nowb)/i/x); nowa+=tmp*i*x;nowb+=tmp*i*x; tt.PB(MP(0,tmp));cnt+=tmp; &#125; &#125; if(i!=1) &#123; if(tt.size()&gt;0 and tt[(int)tt.size()-1].FR==1) tt[(int)tt.size()-1].SE++; else tt.PB(MP(1,1)); cnt++; &#125; if(y==1) break; &#125; if(cnt&lt;now and nowa&gt;=c and nowb&lt;=d) now=cnt,ans=tt; if(c&lt;a*ty) break; if(y==1) break;t++,ty=ty*y; &#125; if(now==INF) puts(" impossible"); else &#123; for(int t=0;t&lt;(int)ans.size();t++) if(ans[t].FR==0) printf(" %dA",ans[t].SE); else printf(" %dM",ans[t].SE); puts(""); &#125; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190314模拟]]></title>
    <url>%2Fposts%2F457a.html</url>
    <content type="text"><![CDATA[3月模拟赛1质量不错 T1给定一棵树，Alan和Bob轮流操作，Alan先手。Alan可以把一个白点染灰，Bob可以选择一个白点，把被选点和周围相邻的点都染黑。Bob有K次作弊机会，可以在任意时刻使用，每次作弊可以断开一条树边。当所有点都被染黑，Bob获胜，否则，Alan获胜。求最优策略下的输赢局面。复杂度线性请先思考后再展开 如果存在连通块大小=1，A获胜如果存在连通块大小=奇，A在某个叶子节点的父亲放，B只能取那个叶子节点，可归纳到大小为1，A获胜接下来只剩下偶数的情况如果存在大小=2，B获胜如果存在不是2的链，A在端点放，B在旁边放，剩下的大小=奇，A获胜如果存在某个节点x的孩子全部是叶子节点且不止一个，A在x放，显然获胜而如果有非叶子节点在严格子树内，考虑深度最大那个非叶子节点的孩子处放，B必须在其父亲放，然后因为没有其他孩子，这样就减少了3个节点，剩下的大小为奇数 综上所述，B获胜，当且仅当把树完美匹配为相邻的大小为2的连通块，并且至少有 (n/2-1) 次删边机会1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e3+10; vector&lt;int&gt; to[MAX_N]; bool ok=1,v[MAX_N]; void dfs(int x,int fa) &#123; v[x]=1; for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t];if(y==fa) continue; dfs(y,x); &#125; if(v[x]==1) &#123; if(v[fa]) v[fa]=0; else ok=0; &#125; &#125; void main() &#123; int n,K;scanf("%d%d",&amp;n,&amp;K); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); to[x].PB(y);to[y].PB(x); &#125; dfs(1,0); if(ok and K&gt;=(n/2)-1) puts("Bob"); else puts("Alan"); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; T2给定n个三元组(ai,bi,ci)求有多少合法的(a0,b0,c0)满足$∀i:[a0&gt;ai]+[b0&gt;bi]+[c0&gt;ci]≥2$n,a,b,c≤5e5请先思考后再展开 因为一开始看错题，想的是其他人要比我小，就懒得换了，翻转一下即可 考虑二维平面上(a,b)能选取的c的数量，首先左上角不能有节点，然后左下角和右上角贡献c+1的上界注意到平面上能限制我的c的上界的，本质只是有n个节点，分别为x和y的两次，看上去有n方个不同的矩形但仔细考虑，发现只有2n个权值完全不同的矩形，就是两维坐标分别排序，然后维护两个指针的移动这个过程每次增加的面积，类似于一个矩形横坐标或纵坐标增加的过程不过因为有左上角不能有节点的限制，这个是类似于一个左上的阶梯形状，可以预处理那么每次的面积就是和阶梯的交，这个其实只有两段，可以二分得出，复杂度为 $O(nlogn)$ 因为横纵坐标都很小，排序可以线性，二分可以转为两个指针，复杂度为 $O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e5+10; int a[MAX_N],b[MAX_N],c[MAX_N]; int bin[30],lg[MAX_N]; ll f1[MAX_N],f2[MAX_N]; pr g1[MAX_N],g2[MAX_N]; ll t1[MAX_N],t2[MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; int n,A,B,C;scanf("%d%d%d%d",&amp;n,&amp;A,&amp;B,&amp;C); for(int i=1;i&lt;=A;i++) f1[i]=B; for(int i=1;i&lt;=B;i++) f2[i]=A; memset(t1,0x3f,sizeof t1);memset(t2,0x3f,sizeof t2); for(int i=1;i&lt;=n;i++) &#123; a[i]=A-qread()+1,b[i]=B-qread()+1,c[i]=C-qread()+1; chmin(f1[a[i]],b[i]-1);chmin(f2[b[i]],a[i]-1); chmin(t1[a[i]],c[i]);chmin(t2[b[i]],c[i]); &#125; for(int i=1;i&lt;=A;i++) chmin(f1[i+1],f1[i]); for(int i=1;i&lt;=B;i++) chmin(f2[i+1],f2[i]); for(int i=1;i&lt;=A;i++) f1[i]+=f1[i-1]; for(int i=1;i&lt;=B;i++) f2[i]+=f2[i-1]; g1[0]=MP(INF,0);g2[0]=MP(INF,0);int gg1=0,gg2=0; for(int i=1;i&lt;=A;i++) if(t1[i]&lt;g1[gg1].FR) g1[++gg1]=MP(t1[i],i); for(int i=1;i&lt;=B;i++) if(t2[i]&lt;g2[gg2].FR) g2[++gg2]=MP(t2[i],i); g1[++gg1]=MP(1,A+1);g2[++gg2]=MP(1,B+1); ll ans=(g1[1].SE-1)*(g2[1].SE-1)*C;int i=0,j=0; while(1) &#123; if(i==gg1-1 and j==gg2-1) break; if(j==gg2-1 or g1[i+1].FR&gt;g2[j+1].FR) &#123; i++; //贴着左边,g1[i].SE-&gt;g1[i+1].SE-1,&lt;=g2[j+1].SE-1 int l=g1[i].SE,r=g1[i+1].SE-1,pos=g1[i+1].SE; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(f1[mid]-f1[mid-1]&lt;g2[j+1].SE-1) pos=mid,r=mid-1; else l=mid+1; &#125; ll area=f1[g1[i+1].SE-1]-f1[pos-1]+(pos-1-g1[i].SE+1)*(g2[j+1].SE-1); ans+=area*(g1[i].FR-1); &#125; else &#123; j++; //贴着上面,g2[j].SE-&gt;g2[j+1].SE-1,&lt;=g1[i+1].SE-1 int l=g2[j].SE,r=g2[j+1].SE-1,pos=g2[j+1].SE; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(f2[mid]-f2[mid-1]&lt;g1[i+1].SE-1) pos=mid,r=mid-1; else l=mid+1; &#125; ll area=f2[g2[j+1].SE-1]-f2[pos-1]+(pos-1-g2[j].SE+1)*(g1[i+1].SE-1); ans+=area*(g2[j].FR-1); &#125; &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; T3$pi在[1,K]中随机，记ai表示i出现的次数，求 a_1^F a_2^F a_3^F … a_L^F 的期望 mod \ 2003$$n≤10^9,L \times F≤5e4,F≤1e3$请先思考后再展开 %DZY补充：总期望=各个单项式期望的和，每个单项式的长度为FL每个合法单项式的期望，就是本质不同位置的概率乘积，即 $\frac{1}{K^{种类t}}$枚举种类数量t，变成一个计数问题，在大小为FL的矩阵里填n以内的数字，某个数字不能跨行出现，且种类为t 因为行独立，则 $dp(i)=划分为t个给定数字的方案数=第二类斯特林数卷自己L次[t] \times t!$$ans=\sum dp(t) C_n^t t! \frac{1}{K^t}$因为有阶乘，计算dp的时候算到MOD即可 时间复杂度为 $O(F^2+MOD^2logL)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MOD=2003; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; const int MAX_N=3e3; int c[MAX_N]; void cheng(int a[],int b[],int len) &#123; memset(c,0,sizeof c); for(int i=0;i&lt;len;i++) for(int j=0;j&lt;len;j++) if(i+j&lt;len) add(c[i+j],a[i]*b[j]%MOD); memcpy(a,c,sizeof c); &#125; int C[MAX_N][MAX_N],S2[MAX_N][MAX_N],inv[MAX_N],fac[MAX_N]; int getC(int n,int m) &#123; if(n&lt;m) return 0; if(n&gt;=MOD or m&gt;=MOD) return getC(n%MOD,m%MOD)*getC(n/MOD,m/MOD)%MOD; return C[n][m]; &#125; int dp[MAX_N],f[MAX_N]; void main() &#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; C[0][0]=1;S2[0][0]=1; for(int i=1;i&lt;MAX_N;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=i;j++) &#123; C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD; S2[i][j]=(S2[i-1][j-1]+S2[i-1][j]*j)%MOD; &#125; &#125; inv[1]=1;for(int i=2;i&lt;MOD;i++) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD; int n,K,L,F;scanf("%d%d%d%d",&amp;n,&amp;K,&amp;L,&amp;F);K%=MOD; if(K==0) &#123;puts("0");return;&#125; for(int i=0;i&lt;=F;i++) f[i]=S2[F][i]; int e=L;dp[0]=1; while(e) &#123; if(e&amp;1) cheng(dp,f,MOD); cheng(f,f,MOD);e&gt;&gt;=1; &#125; int ans=0; for(int t=1,tk=inv[K];t&lt;=MOD-1;t++,tk=tk*inv[K]%MOD) add(ans, dp[t]*getC(n,t)%MOD*fac[t]%MOD*tk%MOD ); printf("%d",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3879】SvT]]></title>
    <url>%2Fposts%2F2003.html</url>
    <content type="text"><![CDATA[Sourcebzoj3879 Hint请先思考后再展开 sa的话考虑利用上次信息后缀树的话就是lca Solution请先思考后再展开 方法一：sa，考虑每个串，利用上次信息，单调栈修改前面的人的贡献123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e5+10; int n;char str[MAX_N]; struct SA &#123; int sa[MAX_N],rk[MAX_N],tmp[MAX_N],wr[MAX_N*2],ct[MAX_N]; void getsa() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[rk[i]=str[i]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;n) &#123; int tot=0;for(int i=1;i&lt;=n;i++) if(sa[i]+ln&gt;n) tmp[++tot]=sa[i]; for(int i=1;i&lt;=n;i++) if(sa[i]-ln&gt;=1) tmp[++tot]=sa[i]-ln; memset(ct,0,sizeof ct);memset(wr,0,sizeof wr); for(int i=1;i&lt;=n;i++) ct[ wr[tmp[i]]=rk[tmp[i]] ]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[wr[tmp[i]]]--]=tmp[i]; int cnt=1;rk[sa[1]]=1; for(int i=2;i&lt;=n;i++) &#123; if(wr[sa[i]]!=wr[sa[i-1]] or wr[sa[i]+ln]!=wr[sa[i-1]+ln]) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; int hei[MAX_N]; void gethei() &#123; int lst=0; for(int i=1;i&lt;=n;i++) &#123; if(rk[i]==1) continue; int j=sa[rk[i]-1];if(lst) lst--; while(max(i,j)+lst&lt;=n and str[i+lst]==str[j+lst]) lst++; hei[rk[i]]=lst; &#125; &#125; int bin[30],lg[MAX_N],mm[MAX_N][20]; int gmin(int x,int y) &#123;return hei[x]&lt;hei[y]?x:y;&#125; void pre() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=2;i&lt;=n;i++) mm[i][0]=i; for(int i=1;i&lt;20;i++) for(int j=2;j&lt;=n-bin[i]+1;j++) mm[j][i]=gmin(mm[j][i-1],mm[j+bin[i-1]][i-1]); &#125; int ask(int l,int r) &#123; int t=lg[r-l+1]; return gmin(mm[l][t],mm[r-bin[t]+1][t]); &#125; &#125;sa; vector&lt;int&gt; now; stack&lt;pr&gt; q; ll ans=0,tmp=0; void insert(int pos,int op) &#123; int cnt=0; while(q.size()) &#123; pr t=q.top();if(sa.hei[t.FR]&lt;sa.hei[pos]) break; cnt+=t.SE;tmp-=(ll)sa.hei[t.FR]*t.SE;q.pop(); &#125; q.push(MP(pos,cnt+op));tmp+=(ll)(cnt+op)*sa.hei[pos]; &#125; void main() &#123; int m;scanf("%d%d%s",&amp;n,&amp;m,str+1); sa.getsa();sa.gethei();sa.pre(); while(m--) &#123; now.resize(0);while(q.size()) q.pop();ans=tmp=0; int m=qread();while(m--) now.PB(sa.rk[qread()]); sort(now.begin(),now.end());now.resize(unique(now.begin(),now.end())-now.begin()); for(int t=0;t&lt;(int)now.size();t++) &#123; int me=now[t]; if(q.size() and q.top().FR&lt;me) insert(sa.ask(q.top().FR+1,me),0); ans+=tmp;insert(me+1,1); &#125; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 方法二：lcp转后缀，后缀树的lca这个虚树搞一搞即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度2</tag>
        <tag>单调栈</tag>
        <tag>后缀树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4310】跳蚤【HDU5030】Rabbit's String]]></title>
    <url>%2Fposts%2F6af4.html</url>
    <content type="text"><![CDATA[Sourcebzoj4310HDU5030 Hint请先思考后再展开 二分子串（先后缀再前缀） Solution请先思考后再展开 这题是我sb了就是打个标记，表示这里后面第一个分段结尾最晚在哪里用sa求lcp，时间复杂度为 $O(nlogn)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; int n;char str[MAX_N]; struct SA &#123; int sa[MAX_N],rk[MAX_N],tmp[MAX_N],ct[MAX_N],wr[MAX_N*2]; void getsa() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[rk[i]=str[i]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;n) &#123; int tot=0;for(int i=1;i&lt;=n;i++) if(sa[i]+ln&gt;n) tmp[++tot]=sa[i]; for(int i=1;i&lt;=n;i++) if(sa[i]-ln&gt;=1) tmp[++tot]=sa[i]-ln; memset(ct,0,sizeof ct);memset(wr,0,sizeof wr); for(int i=1;i&lt;=n;i++) ct[ wr[tmp[i]]=rk[tmp[i]] ]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[ wr[tmp[i]] ]--]=tmp[i]; int cnt=1;rk[sa[1]]=1; for(int i=2;i&lt;=n;i++) &#123; if(wr[sa[i]]!=wr[sa[i-1]] or wr[sa[i]+ln]!=wr[sa[i-1]+ln]) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; int hei[MAX_N]; void gethei() &#123; int lst=0; for(int i=1;i&lt;=n;i++) &#123; if(rk[i]==1) continue; int j=sa[rk[i]-1];if(lst) lst--; while(max(i,j)+lst&lt;=n and str[i+lst]==str[j+lst]) lst++; hei[rk[i]]=lst; &#125; &#125; &#125;sa; struct STB &#123; int bin[30],lg[MAX_N],mm[MAX_N][20]; void pre() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;20;i++) for(int j=2;j&lt;=n-bin[i]+1;j++) mm[j][i]=min(mm[j][i-1],mm[j+bin[i-1]][i-1]); &#125; int ask(int x,int y) &#123; int t=lg[y-x+1]; return min(mm[x][t],mm[y-bin[t]+1][t]); &#125; &#125;stb; int K;int mk[MAX_N];//出现一个结尾的下界 bool check(int pos,int len) &#123; memset(mk,63,sizeof mk);mk[pos]=pos+len-1;mk[n]=n; for(int i=1;i&lt;=n;i++) if(sa.rk[i]&gt;sa.rk[pos]) &#123; int lcp=stb.ask(sa.rk[pos]+1,sa.rk[i]);chmin(lcp,len); if(lcp==0) return 0; mk[i]=i+lcp-1; &#125; int mi=n+1,cnt=0; for(int i=1;i&lt;=n;i++) &#123; chmin(mi,mk[i]); if(mi==i) cnt++,mi=n+1; &#125; return cnt&lt;=K; &#125; void main() &#123; while(1) &#123; scanf("%d",&amp;K);if(K==0) break; scanf("%s",str+1);n=strlen(str+1); sa.getsa();sa.gethei(); for(int i=2;i&lt;=n;i++) stb.mm[i][0]=sa.hei[i]; stb.pre(); int l=1,r=n,pos; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(sa.sa[mid],n-sa.sa[mid]+1)) pos=sa.sa[mid],r=mid-1; else l=mid+1; &#125; l=1,r=n-pos+1;int len; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(pos,mid)) len=mid,r=mid-1; else l=mid+1; &#125; for(int i=1;i&lt;=len;i++) putchar(str[pos+i-1]); puts(""); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>sa</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#545题解]]></title>
    <url>%2Fposts%2F9fc9.html</url>
    <content type="text"><![CDATA[SourceCF#545好题：C、D、F 参考了神仙们的博客yybmyh B请先思考后再展开 kmp+贪心即可1234567891011121314151617181920212223const int MAX_N=5e5+10;int nxt[MAX_N],ct[2];char a[MAX_N],b[MAX_N];void main()&#123; scanf("%s%s",a+1,b+1); int n=strlen(a+1),m=strlen(b+1);for(int i=1;i&lt;=n;i++) ct[a[i]=='1']++; nxt[1]=0; for(int i=2;i&lt;=m;i++) &#123; int j=nxt[i-1];while(j&gt;0 and b[j+1]!=b[i]) j=nxt[j]; nxt[i]=j+(b[j+1]==b[i]); &#125; int now=0; for(int i=1;i&lt;=n;i++) &#123; int t=(b[now+1]-'0'); if(ct[t]&gt;0) now++,ct[t]--,putchar('0'+t); else now=nxt[now],putchar('0'+(t^1)),ct[t^1]--; if(now==m) now=nxt[now]; &#125;&#125; C请先思考后再展开 按余数拆点，tarjan一下转化为求dag上某点出发，能经过多少个不同而且开着的博物馆然后有个性质，就是如果某条路径上来自某个点的造成了多个贡献，也就是有个能贡献i-&gt;j的环，那么一定也能回到i，所以他们不会同时在一条路径上而且还不在同一个强连通里面于是可以跑以点为贡献的最长路，50n D请先思考后再展开 有个叫floyd判环法，就是两个人一个走一步一个走两步$2(T+x)=T+x+kC$ （而且x&lt;=C，没想清楚这里） ，那么他们同时再走T步就会到终点复杂度为3T+2C，实现的话分两队即可 E请先思考后再展开 显然每次加入多个，只有第一个是有意义的把整体的操作暗处理，那么加点就是常规的变换考虑询问（kk和bb为当前和）： $ai+(kk \times i+bb)-&gt;ai-(-kk \times i-bb)$那么每次塞一个-kk的直线进去询问，这个斜率是递减的，所以维护好斜率递增的凸壳，就是线性的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,ll&gt; #define PB push_back inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=310000; pr q[MAX_N];int top=0; void insert(pr now) &#123; while(top&gt;1 and (double)(q[top].SE-q[top-1].SE)*(now.FR-q[top].FR)&gt;=(double)(now.SE-q[top].SE)*(q[top].FR-q[top-1].FR) ) top--; q[++top]=now; &#125; pr ask(ll k) &#123; while(top&gt;1 and (q[top].SE-q[top-1].SE)&gt;=k*(q[top].FR-q[top-1].FR) ) top--; return q[top]; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int cnt=n;ll kk=0,bb=0;top=1;q[1]=MP(1,0); while(m--) &#123; int op=qread(); if(op==1) kk=bb=0,top=1,q[1]=MP(1,0),cnt+=qread(); else if(op==2) insert(MP(cnt+1,-kk*(cnt+1)-bb)),cnt+=qread(); else &#123;ll b=qread(),k=qread();b-=k;kk+=k;bb+=b;&#125; pr ans=ask(-kk);printf("%d %lld\n",ans.FR,ans.SE+kk*ans.FR+bb); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; F请先思考后再展开 这是一棵无根树，但我们可以把当前最大值作为根，这样就是有根树考虑x早于y，当且仅当 子树mx(x)&lt;=mx(y)且x不是y的祖先然后我们从大到小枚举每个位置access一下（理解为染色），这样形成的链就是和它的子树mx相同的链如果没有修改，我们的答案就是 比当前颜色小的+当前颜色的孩子+1修改的话就是一个makeroot，每个颜色用树状数组维护前缀大小复杂度为 $O(nlog^2n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,ll&gt; #define PB push_back inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; struct BIT &#123; int bit[MAX_N*2]; BIT()&#123;memset(bit,0,sizeof bit);&#125; int lowbit(int x) &#123;return x&amp;-x;&#125; void add(int x,int c) &#123;while(x&lt;MAX_N*2) bit[x]+=c,x+=lowbit(x);&#125; int sum(int x) &#123;int ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; &#125;bit; struct LCT &#123; struct Nod&#123;int son[2],fa,col,siz;bool fz,lz;&#125;p[MAX_N]; LCT()&#123;memset(p,0,sizeof p);&#125; void pushdown(int x) &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(p[x].lz) &#123; p[x].lz=0; p[lc].lz=1;p[lc].col=p[x].col; p[rc].lz=1;p[rc].col=p[x].col; &#125; if(p[x].fz) &#123; p[lc].fz^=1;swap(p[lc].son[0],p[lc].son[1]); p[rc].fz^=1;swap(p[rc].son[0],p[rc].son[1]); p[x].fz=0; &#125; &#125; void pushup(int x) &#123; p[x].siz=1; if(p[x].son[0]) p[x].siz+=p[p[x].son[0]].siz; if(p[x].son[1]) p[x].siz+=p[p[x].son[1]].siz; &#125; bool son(int x) &#123;return p[p[x].fa].son[1]==x;&#125; void rotate(int x) &#123; int f=p[x].fa,ff=p[f].fa;if(p[ff].son[son(f)]==f) p[ff].son[son(f)]=x; int w=son(x),t=p[x].son[w^1];p[f].son[w]=t;p[x].son[w^1]=f; p[x].fa=ff;p[t].fa=f;p[f].fa=x; pushup(f);pushup(x); &#125; bool isrt(int x) &#123;return p[x].fa==0 or (p[p[x].fa].son[0]!=x and p[p[x].fa].son[1]!=x);&#125; int tmp[MAX_N]; void splay(int x) &#123; int tot=0,now=x;while(!isrt(now)) tmp[++tot]=now,now=p[now].fa; pushdown(now);for(int i=tot;i&gt;=1;i--) pushdown(tmp[i]); for(int f=p[x].fa;!isrt(x);rotate(x),f=p[x].fa) if(!isrt(f)) son(x)^son(f)?rotate(x):rotate(f); &#125; void access(int x,int id) &#123; int lst=0,cnt=0; while(x&gt;0) &#123; splay(x); int now=p[p[x].son[0]].siz+1;cnt+=now;if(p[x].col) bit.add(p[x].col,-now); p[x].son[1]=lst;p[lst].fa=x;pushup(x); lst=x;x=p[x].fa; &#125; if(id) bit.add(id,cnt); p[lst].col=id;p[lst].lz=1; &#125; void makeroot(int x,int id) &#123; access(x,id);splay(x); p[x].fz=1;swap(p[x].son[0],p[x].son[1]); &#125; void link(int x,int y) &#123; makeroot(x,0);p[x].fa=y; &#125; int getc(int x) &#123; splay(x);p[0].siz=0; //printf("col=%d\n",p[x].col); return bit.sum(p[x].col-1)+p[p[x].son[1]].siz+1; &#125; &#125;lct; void main() &#123; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); lct.link(x,y); &#125; lct.makeroot(n,n);for(int i=1;i&lt;=n;i++) lct.access(i,i); int cnt=n; while(q--) &#123; char s[10];scanf("%s",s); if(s[0]=='u') lct.makeroot(qread(),++cnt); else if(s[0]=='w') printf("%d\n",lct.getc( qread() )); else &#123; int x=qread(),y=qread(); printf("%d\n",lct.getc(x)&lt;lct.getc(y)?x:y); &#125; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2008】奥运物流]]></title>
    <url>%2Fposts%2Ffdba.html</url>
    <content type="text"><![CDATA[SourceNOI2008loj2868 Hint请先思考后再展开 两维状态显然不够f(x,tot,dis)表示x子树内有tot个选择改变，且x距离1为dis的代价 Solution请先思考后再展开 这是一棵基环内向树，显然要改就将后继改为1化一下环上的式子，发现就是最小化 $\frac{\sum C_i k^{dis}}{1-k^{环长}}$枚举环长，那么那一条边前面的环上的边就不能动了我们只要树形dp即可建议是否更改由父亲决定 时间复杂度为 $O(n^4)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(double &amp;x,double y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(double &amp;x,double y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=70; double kk[MAX_N]; int hh[MAX_N];bool on[MAX_N];int pos[MAX_N]; int one;vector&lt;int&gt; son[MAX_N];double cc[MAX_N];int siz[MAX_N]; double f[MAX_N][MAX_N][MAX_N]; void update(int x,int y,int dis) &#123; for(int ab=siz[x]+siz[y];ab&gt;=0;ab--) for(int b=0;b&lt;=siz[y] and b&lt;=ab;b++) &#123; chmax(f[x][ab][dis],f[x][ab-b][dis]+f[y][b][dis+1]); if((!on[y] or pos[y]&gt;=pos[one]) and ab-b-1&gt;=0) chmax(f[x][ab][dis],f[x][ab-b-1][dis]+f[y][b][1]); &#125; &#125; void dp(int x) &#123; for(int dis=0;dis&lt;MAX_N-1;dis++) &#123; f[x][0][dis]=cc[x]*kk[dis];siz[x]=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==1 or y==one) continue; if(dis==0) dp(y); update(x,y,dis);siz[x]+=siz[y]; &#125; &#125; if(x==1) dp(one),update(1,one,0); &#125; int to[MAX_N]; void main() &#123; int n,m;double K;scanf("%d%d%Lf",&amp;n,&amp;m,&amp;K); kk[0]=1;for(int i=1;i&lt;MAX_N;i++) kk[i]=kk[i-1]*K; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;to[i]),son[to[i]].PB(i); for(int i=1;i&lt;=n;i++) scanf("%Lf",&amp;cc[i]); int now=to[1],tot=0;hh[++tot]=1;on[1]=1;pos[1]=1; while(now!=1) pos[now]=pos[hh[tot]]+1,hh[++tot]=now,on[now]=1,now=to[now]; double ans=0; for(int i=(m==0?tot:2);i&lt;=tot;i++) &#123; one=hh[i];for(int x=1;x&lt;=n;x++) for(int t=0;t&lt;=n;t++) for(int dis=0;dis&lt;=n;dis++) f[x][t][dis]=0; dp(1);double mx=0;for(int t=(i!=tot);t&lt;=m;t++) chmax(mx,f[1][t-(i!=tot)][0]); chmax(ans, mx/(1-kk[i]) ); &#125; printf("%.2Lf",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3681】Arietta【uoj77】A+B Problem]]></title>
    <url>%2Fposts%2F8d01.html</url>
    <content type="text"><![CDATA[Sourcebzoj3681uoj77 Hint请先思考后再展开 网络流+数据结构优化建图 Solution请先思考后再展开 【uoj77】A+B Problem朴素的最小割建图：每个点向st连b,向ed连w，然后拆一个辅助点，同点间p，符合条件点连辅助点流量INF然后因为是给前缀中值域区间建边，考虑保留中间状态的权值线段树合并优化网络流建图【bzoj3681】Arietta类似，只不过改为树上线段树合并优化二分图匹配]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>最小割</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HEOI2016】字符串]]></title>
    <url>%2Fposts%2Fc709.html</url>
    <content type="text"><![CDATA[SourceHEOI2016loj2868 Hint请先思考后再展开 二分答案 Solution请先思考后再展开 二分答案，height+主席树，化化式子发现很好check，时间复杂度为 $O(nlog^2n)$ 还有一个sam的做法，先翻转变为求后缀，然后网上的线段树合并需要新建节点，这里给出一个和普通线段树合并没区别的做法（主要是我比较菜，以为线段树合并必须在线）：在外层枚举这是第几次二分，然后把目前依然没有得出答案的人倍增挂到parent树上，然后线段树合并求right集合，时间复杂度为 $O(n log^2 n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const ll LINF=0x3f3f3f3f3f3f3f3fLL; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(ll num)&#123;write(num);puts("");&#125; inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; inline void chmaxll(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chminll(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; #define PB push_back #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; const int MAX_N=110000; struct CMT &#123; struct Nod&#123;int c,lc,rc;&#125;p[MAX_N*30]; int id;CMT()&#123;id=0;memset(p,0,sizeof p);&#125; void add(int &amp;x,int l,int r,int pos) &#123; if(x==0) x=++id; p[x].c++; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos); else add(p[x].rc,mid+1,r,pos); &#125; void merg(int x,int &amp;y,int l,int r) &#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; if(l==r) return; int mid=(l+r)&gt;&gt;1; merg(p[x].lc,p[y].lc,l,mid); merg(p[x].rc,p[y].rc,mid+1,r); &#125; int ask(int x,int y,int l,int r,int tt) &#123; if(tt&lt;l or tt&gt;r or y==0) return 0; if(l==r) return p[y].c-p[x].c; int mid=(l+r)&gt;&gt;1; if(tt&gt;mid) return (p[p[y].lc].c-p[p[x].lc].c)+ask(p[x].rc,p[y].rc,mid+1,r,tt); return ask(p[x].lc,p[y].lc,l,mid,tt); &#125; &#125;cmt; int rt[MAX_N]; int n; struct STB &#123; int mm[MAX_N][20],bin[30],lg[MAX_N]; void pre() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;20;i++) for(int j=2;j&lt;=n-bin[i]+1;j++) mm[j][i]=min(mm[j][i-1],mm[j+bin[i-1]][i-1]); &#125; int ask(int l,int r) &#123; int t=lg[r-l+1]; return min(mm[l][t],mm[r-bin[t]+1][t]); &#125; &#125;stb; char s[MAX_N]; struct SA &#123; int sa[MAX_N],rk[MAX_N],wr[MAX_N*2],tmp[MAX_N],ct[MAX_N]; void getsa() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[rk[i]=s[i]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;n) &#123; int tot=0;for(int i=1;i&lt;=n;i++) if(sa[i]+ln&gt;n) tmp[++tot]=sa[i]; for(int i=1;i&lt;=n;i++) if(sa[i]-ln&gt;=1) tmp[++tot]=sa[i]-ln; memset(ct,0,sizeof ct);memcpy(wr,rk,sizeof rk); for(int i=1;i&lt;=n;i++) ct[ wr[tmp[i]] ]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[ wr[tmp[i]] ]--]=tmp[i]; int tt=1;rk[sa[1]]=1; for(int i=2;i&lt;=n;i++) &#123; if(wr[sa[i-1]+ln]!=wr[sa[i]+ln] or wr[sa[i-1]]!=wr[sa[i]]) tt++; rk[sa[i]]=tt; &#125; ln*=2; &#125; &#125; int hei[MAX_N]; void gethei() &#123; int lst=0; for(int i=1;i&lt;=n;i++) &#123; if(rk[i]==1) &#123;hei[1]=0;continue;&#125; int j=sa[rk[i]-1];if(lst) lst--; while(max(i,j)+lst&lt;=n and s[i+lst]==s[j+lst]) lst++; hei[rk[i]]=lst; &#125; &#125; &#125;sa; bool check(int i,int a,int b,int L) &#123; if(i&gt;1) &#123; int tl=1,tr=i-1,mx=-1; while(tl&lt;=tr) &#123; int mid=(tl+tr)/2; if(stb.ask(mid+1,i)&gt;=L) mx=mid,tr=mid-1; else tl=mid+1; &#125; if(mx&gt;0 and cmt.ask(rt[mx-1],rt[i-1],1,n,b-L+1)-cmt.ask(rt[mx-1],rt[i-1],1,n,a-1)&gt;0) return 1; &#125; if(i&lt;n) &#123; int tl=i+1,tr=n,mi=n+1; while(tl&lt;=tr) &#123; int mid=(tl+tr)/2; if(stb.ask(i+1,mid)&gt;=L) mi=mid,tl=mid+1; else tr=mid-1; &#125; if(mi&lt;=n and cmt.ask(rt[i],rt[mi],1,n,b-L+1)-cmt.ask(rt[i],rt[mi],1,n,a-1)&gt;0) return 1; &#125; return 0; &#125; void main() &#123; int q;scanf("%d%d%s",&amp;n,&amp;q,s+1); sa.getsa();sa.gethei(); for(int i=2;i&lt;=n;i++) stb.mm[i][0]=sa.hei[i]; stb.pre(); for(int i=1;i&lt;=n;i++) cmt.add(rt[i],1,n,sa.sa[i]),cmt.merg(rt[i-1],rt[i],1,n); for(int i=1;i&lt;=q;i++) &#123; int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); int l=1,r=d-c+1,gg=0; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(sa.rk[c],a,b,mid)) gg=mid,l=mid+1; else r=mid-1; &#125; int ans=gg;if(a&lt;=c and c&lt;=b) chmax(ans,min(d-c+1,b-c+1)); printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>主席树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IOI2018】会议]]></title>
    <url>%2Fposts%2Fc53a.html</url>
    <content type="text"><![CDATA[SourceIOI2018loj2868 Hint请先思考后再展开 对于询问[l,r]，找到mx表示最大位置，那么$ans(l,r)=min:ans(l,mx-1)+a_{mx} \times (r-mx+1),ans(mx+1,r)+a_{mx} \times (mx-l+1)​$ 这样的好处就是知道有一个极大值贴着区间的某侧，然后这样通常都会产生一些不错的性质，类似的例子 Solution请先思考后再展开 只要建出笛卡尔树，把询问挂在点上，考虑从下往上，对每个点（覆盖范围为[l,r]）求出所有贴着l或者r的区间S，就能回答询问了，那么以贴着l为例，考虑怎么由lc和rc合并为当前$S_{rt}​$：lc是直接全部保留的，然后对于rc， $ans(l,k \geq rt)=min:ans(l,rt-1)+a_{rt} \times (k-rt+1),ans(rt+1,k)+a_{rt} \times (rt-l+1)​$ 仔细观察一下上式，随着k的增大，左边一定增加 $a_{rt}​$ ，右边则会增加比 $a_{rt}​$ 小的一个量（$a_{rt}​$是最大的），那么只要线段树上二分到一个分界点，那么就是给区间改成与pos相关的一次函数或者区间加法，还有单点询问 $ans(k \leq rt,r)=min:ans(rt+1,r)+a_{rt} \times (rt-k+1),ans(k,rt-1)+a_{rt} \times (r-rt+1)​$ 同理考虑如何实现，你会发现看似区间很多，但对于每个r，其实当前这一层对应的l是固定的，$seg[r]=ans(l,r)$ ，然后在非叶子节点的地方，定义为保存$a_{mid}$的值。时间复杂度为 $O(nlogn)$ （uoj被卡常了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const ll LINF=0x3f3f3f3f3f3f3f3fLL; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(ll num)&#123;write(num);puts("");&#125; inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; inline void chmaxll(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chminll(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; #define PB push_back #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; const int MAX_N=2e6+10; struct SegmentTree &#123; #define lc 2*x #define rc 2*x+1 pr now[MAX_N*4];bool lz2[MAX_N*4];ll lz[MAX_N*4]; SegmentTree()&#123;memset(now,0,sizeof now);memset(lz,0,sizeof lz);memset(lz2,0,sizeof lz2);&#125; void ch(int x,pr c) &#123;now[x]=c;lz2[x]=1;lz[x]=0;&#125; void ad(int x,ll c) &#123;if(lz2[x] and 2*x&lt;=MAX_N*4) ch(lc,now[x]),ch(rc,now[x]),lz2[x]=0;now[x].SE+=c;lz[x]+=c;&#125;//debug void update(int x) &#123; if(lz2[x]) ch(lc,now[x]),ch(rc,now[x]),lz2[x]=0; if(lz[x]&gt;0) ad(lc,lz[x]),ad(rc,lz[x]),lz[x]=0; &#125; void add(int x,int l,int r,int fl,int fr,ll c) &#123; update(x); if(l==fl and r==fr) &#123;ad(x,c);return;&#125; int mid=(l+r)&gt;&gt;1; if(fr&lt;=mid) add(lc,l,mid,fl,fr,c); else if(fl&gt;mid) add(rc,mid+1,r,fl,fr,c); else add(lc,l,mid,fl,mid,c),add(rc,mid+1,r,mid+1,fr,c); if(fl&lt;=mid and fr&gt;=mid) now[x].SE+=c; &#125; pr ask(int x,int l,int r,int pos) &#123; update(x); if(l==r) return now[x]; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return ask(lc,l,mid,pos); return ask(rc,mid+1,r,pos); &#125; void solve(int x,int l,int r,int fl,int fr,pr c,bool op) &#123; update(x); if(fl&gt;fr) return; int mid=(l+r)&gt;&gt;1;ll a=now[x].FR*mid+now[x].SE,b=c.FR*mid+c.SE; if(fl&lt;=mid and mid&lt;=fr and b&lt;a) now[x]=c; if(l==fl and r==fr) &#123; if(l==r) return; if(op) &#123; if(b&lt;=a) solve(lc,l,mid,l,mid,c,op),ch(rc,c); else solve(rc,mid+1,r,mid+1,r,c,op); &#125; else &#123; if(b&lt;=a) ch(lc,c),solve(rc,mid+1,r,mid+1,r,c,op); else solve(lc,l,mid,l,mid,c,op); &#125; &#125; else &#123; if(fr&lt;=mid) solve(lc,l,mid,fl,fr,c,op); else if(fl&gt;mid) solve(rc,mid+1,r,fl,fr,c,op); else solve(lc,l,mid,fl,mid,c,op),solve(rc,mid+1,r,mid+1,fr,c,op); &#125; &#125; #undef lc #undef rc &#125;sgt1,sgt2; int n,h[MAX_N]; struct Qes&#123;int l,r,id;&#125;;vector&lt;Qes&gt; qes[MAX_N]; int bin[20],f[MAX_N][20],root=1; struct Nod&#123;int dep,lc,rc,fl,fr;&#125;p[MAX_N]; void build() &#123; for(int i=2;i&lt;=n;i++) &#123; int now=i-1; while(f[now][0]&gt;0 and h[i]&gt;h[now]) now=f[now][0]; if(h[i]&lt;=h[now]) &#123; if(p[now].rc&gt;0) f[p[now].rc][0]=i;//debug p[i].lc=p[now].rc,p[now].rc=i,f[i][0]=now; &#125; else f[now][0]=i,p[i].lc=now,root=i; &#125; &#125; void dfs(int x) &#123; p[x].dep=p[f[x][0]].dep+1;for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; p[x].fl=p[x].fr=x; if(p[x].lc) dfs(p[x].lc),chmin(p[x].fl,p[p[x].lc].fl),chmax(p[x].fr,p[p[x].lc].fr); if(p[x].rc) dfs(p[x].rc),chmin(p[x].fl,p[p[x].rc].fl),chmax(p[x].fr,p[p[x].rc].fr); &#125; int lca(int x,int y) &#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=19;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; ll ans[MAX_N]; void solve(int x) &#123; if(p[x].lc) solve(p[x].lc); if(p[x].rc) solve(p[x].rc); for(int t=0;t&lt;(int)qes[x].size();t++) &#123; Qes now=qes[x][t];ans[now.id]=ll(now.r-now.l+1)*h[x]; pr k=p[x].lc&gt;0?sgt2.ask(1,1,n,now.l):MP(0ll,0ll); chminll(ans[now.id], (k.FR*now.l+k.SE)+ll(now.r-x+1)*h[x] ); k=p[x].rc&gt;0?sgt1.ask(1,1,n,now.r):MP(0ll,0ll); chminll(ans[now.id], (k.FR*now.r+k.SE)+ll(x-now.l+1)*h[x] ); &#125; int l=p[x].fl,r=p[x].fr; if(l==r) sgt1.add(1,1,n,x,x,h[x]); sgt1.add(1,1,n,x,r,(ll)h[x]*(x-l+1) );pr t=p[x].lc&gt;0?sgt1.ask(1,1,n,x-1):MP(0ll,0ll); sgt1.solve(1,1,n,x,r,MP(h[x],(t.FR*(x-1)+t.SE)+ll(1-x)*h[x]),0); sgt2.add(1,1,n,l,x,(ll)h[x]*(r-x+1) );t=p[x].rc&gt;0?sgt2.ask(1,1,n,x+1):MP(0ll,0ll); sgt2.solve(1,1,n,l,x,MP(-h[x],(t.FR*(x+1)+t.SE)+ll(1+x)*h[x]),1); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) h[i]=qread(); build();dfs(root); for(int i=1;i&lt;=q;i++) &#123; int l=qread()+1,r=qread()+1; qes[lca(l,r)].PB( (Qes)&#123;l,r,i&#125; ); &#125; memset(ans,0x3f,sizeof ans);solve(root); for(int i=1;i&lt;=q;i++) writeln(ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF715E】Complete the Permutations【bzoj5406】Gift]]></title>
    <url>%2Fposts%2Fa5e5.html</url>
    <content type="text"><![CDATA[Sourcebzoj5406CF715E Hint请先思考后再展开 看到排列的置换问题，套路地转化为图上连下，并把非0的相同数字合并那么就会形成一些环和链，如果没有0，代价就是n-环数 Solution请先思考后再展开 对于每条链，我们只关心两端是什么类型的（1表示非0），例如没有成环的11就是无用的01、10与00合并，意味着决定把那个数字填上去，于是剩下的就是那两个0，也就是00所以01和10不会直接组合，但可能01与00合并为00后与10组合 那么分开考虑01和10，以10为例：$$f_i=\sum_{j=i}^n C_n^j S_1(j,i) (n-j+k)^{\underline{n-j}},k条00，n条10，至少i个环$$意思就是选j条边先强制生成i个环，然后剩下的边选择后继，如果选择自己意味着单独作为自环$$设g_i为恰好i个环,f_i=\sum_{j=i}^n C_j^i g_j（考虑计算了多少个），二项式反演得 g_i=\sum_{j=i}^n (-1)^{j-i} C_j^i f_j$$然后考虑剩下的00，依然有k个，在排列中可以交换顺序，方案为 $T_i=S_1(k,i) \times k!​$ 然后把3种类型卷积在一起即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2100; bool vis[MAX_N*2];int n,cnt=0,s0=0,s1=0,s2=0; int a[MAX_N],b[MAX_N],nxt[MAX_N*2],ru[MAX_N*2]; void dfs(int x,int tp) &#123; vis[x]=1; if(nxt[x]&gt;0) &#123; if(vis[nxt[x]]) cnt++; else dfs(nxt[x],tp); &#125; else &#123; if(tp&gt;n and x&lt;=n) s1++; if(tp&lt;=n and x&gt;n) s2++; if(tp&gt;n and x&gt;n) s0++; &#125; &#125; const int MOD=998244353; void add(ll &amp;x,ll y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; ll sum(ll x,ll y)&#123;add(x,y);return x;&#125; ll g[MAX_N],c[MAX_N][MAX_N],S1[MAX_N][MAX_N],D[MAX_N][MAX_N]; void pre() &#123; c[0][0]=1;S1[0][0]=1;D[0][0]=1; for(int i=1;i&lt;MAX_N;i++) &#123; c[i][0]=1;S1[i][0]=0;D[i][0]=1; for(int j=1;j&lt;=i;j++) &#123; c[i][j]=sum(c[i-1][j-1],c[i-1][j]); S1[i][j]=sum(S1[i-1][j-1],S1[i-1][j]*(i-1)%MOD); D[i][j]=D[i][j-1]*(i-j+1)%MOD; &#125; &#125; &#125; void getA(ll f[],int n,int k) &#123; memset(g,0,sizeof g); for(int i=0;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) add(g[i],c[n][j]*S1[j][i]%MOD*D[n-j+k][n-j]%MOD); for(int i=0;i&lt;=n;i++) for(int j=i,t=1;j&lt;=n;j++,t=-t) add(f[i],c[j][i]*t*g[j]%MOD); &#125; void cheng(ll a[],ll b[],int n) &#123; memset(g,0,sizeof g); for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) if(i+j&lt;=n) add(g[i+j],a[i]*b[j]%MOD); memcpy(a,g,sizeof g); &#125; ll A[MAX_N],B[MAX_N],C[MAX_N]; void main() &#123; pre(); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n*2;i++) vis[i]=1; for(int i=1;i&lt;=n;i++) if(a[i]+b[i]==0) s0++; else &#123; if(!a[i]) a[i]=i+n;if(!b[i]) b[i]=i+n; vis[a[i]]=vis[b[i]]=0; nxt[a[i]]=b[i];ru[b[i]]++; &#125; for(int i=1;i&lt;=2*n;i++) if(ru[i]==0 and !vis[i]) dfs(i,i);//先找链 for(int i=1;i&lt;=2*n;i++) if(!vis[i]) dfs(i,i); getA(A,s1,s0);getA(B,s2,s0);for(int k=0;k&lt;=s0;k++) C[k]=S1[s0][k]*D[s0][s0]%MOD; cheng(A,B,n);cheng(A,C,n); for(int i=0;i&lt;=n-1;i++) printf("%lld ",(n-i&gt;=cnt?(A[n-i-cnt]+MOD)%MOD:0) ); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二项式反演</tag>
        <tag>难度3</tag>
        <tag>复习</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2016】序列【HNOI2017】影魔]]></title>
    <url>%2Fposts%2Ffe94.html</url>
    <content type="text"><![CDATA[SourceHNOI2016、HNOI2017loj2051 Solution请先思考后再展开 先说序列 先求出每个位置左右第一个比他小的lmi和rmi，可以用单调栈解决然后显然整体思路是把每个区间贡献到最小值上面 先考虑莫队，只要能解决右边增加一个的操作，那么其他操作都是类似的先求出[l,r+1]的最小的位置p（st表），然后一定有个位置lmi=p注意到lmi是个森林，然后你可以把代价贡献到边权上那么代价就是树上路径+p的那条不完整的边$O(n \sqrt n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=110000; int n,a[MAX_N]; int bin[30],lg[MAX_N],mm[MAX_N][30]; int gmin(int x,int y)&#123;return a[x]&lt;a[y]?x:y;&#125; void pre() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;=20;i++) for(int j=0;j&lt;n-bin[i]+1;j++) mm[j][i]=gmin(mm[j][i-1],mm[j+bin[i-1]][i-1]); &#125; int ask(int l,int r) &#123; int t=lg[r-l+1]; return gmin(mm[l][t],mm[r-bin[t]+1][t]); &#125; int fa[2][MAX_N];ll dis[2][MAX_N];//森林 stack&lt;pr&gt; sta; void pre2() &#123; sta.push(MP(a[0],0));fa[0][0]=-1;dis[0][0]=a[0]; for(int i=1;i&lt;n;i++) &#123; while(sta.size() and sta.top().FR&gt;=a[i]) sta.pop(); fa[0][i]=sta.size()&gt;0?sta.top().SE:-1; if(fa[0][i]&gt;=0) dis[0][i]=dis[0][fa[0][i]]+ll(i-fa[0][i])*a[i]; else dis[0][i]=(ll)a[i]*(i+1); sta.push(MP(a[i],i)); &#125; while(sta.size()) sta.pop(); sta.push(MP(a[n-1],n-1));fa[1][n-1]=-1;dis[1][n-1]=a[n-1]; for(int i=n-2;i&gt;=0;i--) &#123; while(sta.size() and sta.top().FR&gt;=a[i]) sta.pop(); fa[1][i]=sta.size()&gt;0?sta.top().SE:-1; if(fa[1][i]&gt;=0) dis[1][i]=dis[1][fa[1][i]]+ll(fa[1][i]-i)*a[i]; else dis[1][i]=(ll)a[i]*(n-i); sta.push(MP(a[i],i)); &#125; &#125; struct Qes&#123;int l,r,id;ll ans;&#125;q[MAX_N]; int T; bool cmp(Qes a,Qes b) &#123;return a.l/T&lt;b.l/T or (a.l/T==b.l/T and a.r&lt;b.r);&#125; bool cmp2(Qes a,Qes b) &#123;return a.id&lt;b.id;&#125; ll now=0;int fl,fr; void movel(int f) &#123; int k=ask(fl,fr); now+=(dis[1][fl]-dis[1][k]+ll(fr-k+1)*a[k])*f; &#125; void mover(int f) &#123; int k=ask(fl,fr); now+=(dis[0][fr]-dis[0][k]+ll(k-fl+1)*a[k])*f; &#125; void main() &#123; n=qread();T=sqrt(n);int m=qread(); for(int i=0;i&lt;n;i++) a[i]=qread(),mm[i][0]=i; pre();pre2(); for(int i=1;i&lt;=m;i++) q[i].l=qread()-1,q[i].r=qread()-1,q[i].id=i; sort(q+1,q+m+1,cmp); fl=q[1].l,fr=q[1].l-1; for(int i=1;i&lt;=m;i++) &#123; while(fl&gt;q[i].l) fl--,movel(1); while(fr&lt;q[i].r) fr++,mover(1); while(fl&lt;q[i].l) movel(-1),fl++; while(fr&gt;q[i].r) mover(-1),fr--; q[i].ans=now; &#125; sort(q+1,q+m+1,cmp2);for(int i=1;i&lt;=m;i++) printf("%lld\n",q[i].ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 然后考虑在线，你观察一下莫队的做法，其实你需要的就是一个前缀、后缀和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=110000; int n,a[MAX_N]; int bin[30],lg[MAX_N],mm[MAX_N][30]; int gmin(int x,int y)&#123;return a[x]&lt;a[y]?x:y;&#125; void pre() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;=20;i++) for(int j=0;j&lt;n-bin[i]+1;j++) mm[j][i]=gmin(mm[j][i-1],mm[j+bin[i-1]][i-1]); &#125; int ask(int l,int r) &#123; int t=lg[r-l+1]; return gmin(mm[l][t],mm[r-bin[t]+1][t]); &#125; int fa[2][MAX_N];ll dis[2][MAX_N];//森林 ll g[2][MAX_N]; stack&lt;pr&gt; sta; void pre2() &#123; sta.push(MP(a[0],0));fa[0][0]=-1;g[0][0]=dis[0][0]=a[0]; for(int i=1;i&lt;n;i++) &#123; while(sta.size() and sta.top().FR&gt;=a[i]) sta.pop(); fa[0][i]=sta.size()&gt;0?sta.top().SE:-1; if(fa[0][i]&gt;=0) dis[0][i]=dis[0][fa[0][i]]+ll(i-fa[0][i])*a[i]; else dis[0][i]=(ll)a[i]*(i+1); sta.push(MP(a[i],i)); g[0][i]=g[0][i-1]+dis[0][i]; &#125; while(sta.size()) sta.pop(); sta.push(MP(a[n-1],n-1));fa[1][n-1]=-1;g[1][n-1]=dis[1][n-1]=a[n-1]; for(int i=n-2;i&gt;=0;i--) &#123; while(sta.size() and sta.top().FR&gt;=a[i]) sta.pop(); fa[1][i]=sta.size()&gt;0?sta.top().SE:-1; if(fa[1][i]&gt;=0) dis[1][i]=dis[1][fa[1][i]]+ll(fa[1][i]-i)*a[i]; else dis[1][i]=(ll)a[i]*(n-i); sta.push(MP(a[i],i)); g[1][i]=g[1][i+1]+dis[1][i]; &#125; &#125; void main() &#123; n=qread();int m=qread(); for(int i=0;i&lt;n;i++) a[i]=qread(),mm[i][0]=i; pre();pre2(); for(int i=1;i&lt;=m;i++) &#123; int l=qread()-1,r=qread()-1; int k=ask(l,r); ll ans=(ll)a[k]*(k-l+1)*(r-k+1); ans+=g[0][r]-g[0][k]-dis[0][k]*(r-k); ans+=g[1][l]-g[1][k]-dis[1][k]*(k-l); printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 然后你会发现影魔是挺类似的，不过是排列对于第一问，套路地选取最大点p，然后在l和r内的点对是不能跨过p的第一问的点对，就是每个点向左向右第一个更大的，贡献为1，预处理左端点和右端点的前缀和$A=(ls[p]-ls[l-1])+(rs[r]-rs[p])$对于第二问，感觉不太好求，但考虑两个问的关系，可以设置第三问，就是中间比两点max小那么B=C-A，然后这个C也是求左右两边第一个更大的，但贡献为中间长度-1那么离线一下，从左往右扫右端点，就变成一个区间加，区间求和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=210000; int n,a[MAX_N]; struct SegmentTree &#123; #define lc 2*x #define rc 2*x+1 ll lz[MAX_N*4],sum[MAX_N*4];int tl[MAX_N*4],tr[MAX_N*4]; void clear()&#123;memset(lz,0,sizeof lz);memset(sum,0,sizeof sum);&#125; void build(int x,int l,int r) &#123; tl[x]=l;tr[x]=r;if(l==r) return; int mid=(l+r)&gt;&gt;1; build(lc,l,mid);build(rc,mid+1,r); &#125; void pd(int x) &#123; sum[lc]+=lz[x]*(tr[lc]-tl[lc]+1);lz[lc]+=lz[x]; sum[rc]+=lz[x]*(tr[rc]-tl[rc]+1);lz[rc]+=lz[x]; lz[x]=0; &#125; void add(int x,int fl,int fr) &#123; if(fl&gt;fr) return; sum[x]+=(fr-fl+1); if(tl[x]==fl and tr[x]==fr)&#123;lz[x]++;return;&#125; int mid=(tl[x]+tr[x])&gt;&gt;1; if(fr&lt;=mid) add(lc,fl,fr); else if(fl&gt;mid) add(rc,fl,fr); else add(lc,fl,mid),add(rc,mid+1,fr); &#125; ll ask(int x,int fl,int fr) &#123; if(fl&gt;fr) return 0; if(tl[x]==fl and tr[x]==fr) return sum[x]; pd(x);int mid=(tl[x]+tr[x])&gt;&gt;1; if(fr&lt;=mid) return ask(lc,fl,fr); if(fl&gt;mid) return ask(rc,fl,fr); return ask(lc,fl,mid)+ask(rc,mid+1,fr); &#125; &#125;sgt; struct Stb &#123; int mm[MAX_N][20],bin[20],lg[MAX_N]; int gmin(int x,int y) &#123;return a[x]&gt;a[y]?x:y;&#125; void pre() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;20;i++) for(int j=1;j&lt;=n-bin[i]+1;j++) mm[j][i]=gmin(mm[j][i-1],mm[j+bin[i-1]][i-1]); &#125; int ask(int x,int y) &#123; int t=lg[y-x+1]; return gmin(mm[x][t],mm[y-bin[t]+1][t]); &#125; &#125;stb; int p1[MAX_N],p2[MAX_N];stack&lt;pr&gt; sta; void pre() &#123; p1[1]=0;sta.push(MP(1,a[1])); for(int i=2;i&lt;=n;i++) &#123; while(sta.size() and sta.top().SE&lt;=a[i]) sta.pop(); p1[i]=sta.size()&gt;0?sta.top().FR:0;sta.push(MP(i,a[i])); &#125; while(sta.size()) sta.pop(); p2[n]=n+1;sta.push(MP(n,a[n])); for(int i=n-1;i&gt;=1;i--) &#123; while(sta.size() and sta.top().SE&lt;=a[i]) sta.pop(); p2[i]=sta.size()&gt;0?sta.top().FR:n+1;sta.push(MP(i,a[i])); &#125; &#125; vector&lt;pr&gt; fl[MAX_N],fr[MAX_N]; ll ct1[MAX_N],ct2[MAX_N]; int ls[MAX_N],rs[MAX_N]; void work() &#123; for(int i=1;i&lt;=n;i++) &#123; if(p2[i]&lt;=n) ls[i]++,rs[p2[i]]++; if(p1[i]&gt;=1) ls[p1[i]]++,rs[i]++; &#125; for(int i=2;i&lt;=n;i++) ls[i]+=ls[i-1],rs[i]+=rs[i-1]; sgt.clear();sgt.build(1,1,n); for(int r=1;r&lt;=n;r++) &#123; sgt.add(1,p1[r]+1,r-1); for(int t=0;t&lt;(int)fr[r].size();t++) &#123; pr now=fr[r][t]; ct2[now.SE]+=sgt.ask(1,now.FR,n); int p=stb.ask(now.FR,r); ct1[now.SE]+=(ls[p-1]-ls[now.FR-1])+(rs[r]-rs[p]); &#125; &#125; sgt.clear(); for(int l=n;l&gt;=1;l--) &#123; sgt.add(1,l+1,p2[l]-1); for(int t=0;t&lt;(int)fl[l].size();t++) &#123; pr now=fl[l][t]; ct2[now.SE]+=sgt.ask(1,1,now.FR); &#125; &#125; &#125; void main() &#123; int m,c1,c2;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;c1,&amp;c2); for(int i=1;i&lt;=n;i++) a[i]=qread(),stb.mm[i][0]=i; stb.pre();pre(); for(int i=1;i&lt;=m;i++) &#123; int l=qread(),r=qread(); fl[l].push_back(MP(r,i)); fr[r].push_back(MP(l,i)); &#125; work(); for(int i=1;i&lt;=m;i++) printf("%lld\n",ct1[i]*c1+(ct2[i]-ct1[i])*c2); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDWC2018】Set]]></title>
    <url>%2Fposts%2F6bea.html</url>
    <content type="text"><![CDATA[Source and JudgeSDWC2018loj6060 Analysis请先思考后再展开 考虑xor+S^xor作不进位加法，考虑二进制每一位如果S=0，则xor应=1；否则无所谓，即S=0的位置优先级更高在满足上述的情况下，通过最大化xor来最小化另一个即可，故位置的第二关键字是位置高低考虑线性基的本质，每个数挂在第一个1是因为通常情况下越前优先级越高，所以我们现在自定义优先级是没有问题的，而且线性基相对最小化更擅长最大化code upd：这题和一次abc撞了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jsoi2014】回文串]]></title>
    <url>%2Fposts%2F3d6b.html</url>
    <content type="text"><![CDATA[SourceJsoi2014bzoj5036 Hint请先思考后再展开 将贡献的条件化开来作为系数 Solution请先思考后再展开 从对称中心考虑贡献，然后每个位置是3个取min，分两半就可以化为两个条件了（就是把区间分开确保限制侧）然后 $p-d[p] \leq l-1 则d[p] 否则p-l+1$把贡献放到系数里面，用个数据结构（如树状数组）维护 还有一种比较好想的双log做法：manacher+二分答案+主席树]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jsoi2017】原力]]></title>
    <url>%2Fposts%2F249c.html</url>
    <content type="text"><![CDATA[SourceJsoi2017bzoj5206 Hint请先思考后再展开 用hash求两点间边权度数的数据分治 Solution请先思考后再展开 设阈值T若度数&lt;=T,选边，考虑每条边只会被枚举T次，所以是mT若度数&gt;T,选点， $(m/T)^3$取 $T=m^{1/2}$ 得到最低复杂度 $O(m^{3/2})$ T取 $2\sqrt m$ 会比较恰当 upd：其实用这里的方法会很好写]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>复习</tag>
        <tag>数据分治</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2563】阿狸和桃子的游戏]]></title>
    <url>%2Fposts%2Fdcc7.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2563 Analysis请先思考后再展开 那么对于点，选+w，不选-w对于边，选2个点+c，选一个点+0，选0个点-c那么把边权分摊到点权上，然后轮流取即可 然后如果要求具体值的话，就通过选的点判断即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=11000; double a[MAX_N];priority_queue&lt;double&gt; q; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;a[i]); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); a[x]+=c/2.0;a[y]+=c/2.0; &#125; for(int i=1;i&lt;=n;i++) q.push(a[i]); double ans=0; while(q.size()) &#123; ans+=q.top();q.pop(); ans-=q.top();q.pop(); &#125; printf("%.0lf",ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>复习</tag>
        <tag>题意转化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2017】抛硬币]]></title>
    <url>%2Fposts%2Fa109.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2017loj2023 Analysis请先思考后再展开 先观察数据范围，注意到a和b的差很特殊还有就是要尽量减少表达式的项数，比较巧妙的做法是考虑二进制的翻转、对称性 先考虑a=b注意到二进制翻转能完全把正负调换，那么考虑用(总情况-平局)/2$ans=\frac{2^{a+b}-C_{2n}^n}{2}$ 不同的时候， $[a1 \leq b1,a&gt;b]-&gt;[a-a1&gt;b-b1]$ ，所以依然能把A负或平局翻转为胜利但部分A胜的情况翻转后依然胜利，这种情况是没有配对的，要补上$[a1&gt;b1,a-a1&gt;b-b1]-&gt;[0&lt;a1-b1&lt;a-b]$ $$\begin{aligned}=&amp;\sum_{b1=0}^b C_b^{b1} \sum_{t=0}^{a-b-1} C_a^{b1+t}\\=&amp;\sum_{t=1}^{a-b-1} \sum_{b1=0}^b C_b^{b-b1} C_a^{b1+t}\\=&amp;\sum_{k=b+1}^{a-1} C_{a+b}^{b}\\ans=&amp;\frac{ 2^{a+b}+\sum_{k=b+1}^{a-1} C_{a+b}^{b} }{2}\end{aligned}$$ 求组合数要用拓展lucas，教程不过这次稍有不同，已知质因子是2和5$fac(n)=fac(\frac{n}{p^k}) \times p^t \times fac(p^k-1)^{\frac{n}{p^k}} \times fac(n\%p^k)$$p^k$ 以内的阶乘可以预处理出来 最后提一提这个除以2，如果a-b+1是偶数，直接算一半（对称性）如果是奇数，那么就是要加上 $\frac{1}{2} C_{a+b}^{(a+b)/2}$因为只有一次，可以分解质因数暴力做]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>拓展卢卡斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WC2007】剪刀石头布]]></title>
    <url>%2Fposts%2F72cc.html</url>
    <content type="text"><![CDATA[Source and JudgeWC2007bzoj2957 Analysis请先思考后再展开 这道题感觉最难的就是，给你一个图你怎么计数首先肯定是贡献到点上面，如果直接对三元环考虑，对于x考虑i和j，那么会跟i和j之间的边有关，很麻烦但补集转化，非三元环的话，一定是从某个点出发，第三条边随意，这样就很好处理了，而且只会被统计一次所以就是 $\sum C(deg_i,2)$那么费用流，增量法建图即可，这个和【CQOI2014】学习小组挺像的 我写得常数很大…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=110; int hou[MAX_N*MAX_N*3]; struct Edge&#123;int y,c,w,g;&#125;e[MAX_N*MAX_N*4*2*2]; int ln=0;int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c,int w) &#123; e[++ln]=(Edge)&#123;y,c,w,hou[x]&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,0,-w,hou[y]&#125;;hou[y]=ln; &#125; int st,ed; int dis[MAX_N*MAX_N*3],fm[MAX_N*MAX_N*3],mif[MAX_N*MAX_N*3];bool v[MAX_N*MAX_N*3]; int cost=0; queue&lt;int&gt; q; bool solve() &#123; memset(dis,0x3f,sizeof dis); q.push(st);dis[st]=0;mif[st]=INF;v[st]=1; while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&gt;dis[x]+e[k].w and e[k].c) &#123; dis[y]=dis[x]+e[k].w; fm[y]=k;mif[y]=min(mif[x],e[k].c); if(!v[y]) v[y]=1,q.push(y); &#125; v[x]=0; &#125; &#125; if(dis[ed]==INF) return 0; cost+=dis[ed]*mif[ed]; for(int x=ed;x!=st;x=e[oth(fm[x])].y) e[fm[x]].c-=mif[ed],e[oth(fm[x])].c+=mif[ed]; return 1; &#125; int n;pr out[MAX_N*MAX_N*2]; inline int calc(int x,int y) &#123;return min(x,y)*(n+1)+max(x,y);&#125; int ans[MAX_N][MAX_N]; void main() &#123; scanf("%d",&amp;n);int m=n*n*2;st=0,ed=m+n+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) out[calc(i,j)]=MP(i,j); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) ins(m+i,ed,1,j-1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int t=qread(); if(i&lt;j) &#123; if(t==2) ins(st,calc(i,j),1,0),ins(calc(i,j),m+i,1,0),ins(calc(i,j),m+j,1,0); else ins(st,m+(t==1?j:i),1,0); &#125; ans[i][j]=t; &#125; while(solve()) ; printf("%d\n",n*(n-1)/2*(n-2)/3-cost); for(int k=hou[st];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y&gt;m) continue; for(int k2=hou[y];k2&gt;0;k2=e[k2].g) if(e[k2].c==0 and e[k2].y!=st) &#123; int a=e[k2].y-m,b=(a==out[y].FR?out[y].SE:out[y].FR); ans[b][a]=1;ans[a][b]=0; &#125; &#125; for(int i=1;i&lt;=n;i++,puts("")) for(int j=1;j&lt;=n;j++) printf("%d ",ans[i][j]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51nod1462】树据结构]]></title>
    <url>%2Fposts%2Fd8f8.html</url>
    <content type="text"><![CDATA[Source and Judge51nod1462 Analysis请先思考后再展开 dffxtz师兄出的题 做法一：暴力树剖+分块，时间复杂度为 $O(nlogn\sqrt n)$ 做法二：利用矩阵乘法的优秀性质，树剖时间复杂度为 $O(8nlog^2 n)$ 做法三：考虑时间倒流，考虑每次操作1的增量的总系数，就是后面有多少次操作2不太好整体做，不妨考虑树上启发式合并，树状数组边插边弄时间复杂度为 $O(nlog^2 n)$ 做法四：把树上启发式改为线段树合并，开两棵以时间为下标的动态开点线段树统计答案就是类似cdq的过程，而复杂度则和合并是一样的时间复杂度为 $O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=110000; vector&lt;int&gt; son[MAX_N]; int id=0; void insert(ll s[],int lc[],int rc[],int &amp;x,int l,int r,int p,ll c) &#123; if(x==0) x=++id; s[x]+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(s,lc,rc,lc[x],l,mid,p,c); else insert(s,lc,rc,rc[x],mid+1,r,p,c); &#125; void merg(ll s[],int lc[],int rc[],int x,int &amp;y,int l,int r) &#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; s[y]+=s[x]; if(l==r) return; int mid=(l+r)&gt;&gt;1; merg(s,lc,rc,lc[x],lc[y],l,mid); merg(s,lc,rc,rc[x],rc[y],mid+1,r); &#125; ll s[2][MAX_N*20]; int rt[2][MAX_N],lc[2][MAX_N*20],rc[2][MAX_N*20]; ll ans[MAX_N]; void calc(ll &amp;sum,int x,int y,int l,int r) &#123; if(x==0 or y==0) return; sum+=s[0][lc[0][x]]*s[1][rc[1][y]]; if(l==r) return; int mid=(l+r)&gt;&gt;1; calc(sum,lc[0][x],lc[1][y],l,mid); calc(sum,rc[0][x],rc[1][y],mid+1,r); &#125; int q; void solve(int x) &#123; calc(ans[x],rt[0][x],rt[1][x],1,q); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t]; solve(y); ans[x]+=ans[y]; calc(ans[x],rt[0][x],rt[1][y],1,q); calc(ans[x],rt[0][y],rt[1][x],1,q); merg(s[0],lc[0],rc[0],rt[0][y],rt[0][x],1,q); merg(s[1],lc[1],rc[1],rt[1][y],rt[1][x],1,q); &#125; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=2;i&lt;=n;i++) son[qread()].push_back(i); scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++) &#123; int op=qread(),x=qread();ll d=qread(); if(op==1) insert(s[0],lc[0],rc[0],rt[0][x],1,q,i,d); else insert(s[1],lc[1],rc[1],rt[1][x],1,q,i,d); &#125; memset(ans,0,sizeof ans); solve(1); for(int i=1;i&lt;=n;i++) printf("%lld\n",ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>树上启发式</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2011】向量]]></title>
    <url>%2Fposts%2Fa027.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2011bzoj2299 Analysis请先思考后再展开 裴蜀定理的应用最难的一步是转化为，+-2a，+-2b，(+a,+b),(+b,+a)然后后面两个只会进行最多一次，暴力枚举判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; ll gcd(ll x,ll y) &#123;return y==0?x:gcd(y,x%y);&#125; ll a,b;bool solve(ll x,ll y) &#123;return x%gcd(2*a,2*b)==0 and y%gcd(2*a,2*b)==0;&#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; ll x,y;a=qread();b=qread();x=qread();y=qread(); if(solve(x+a,y+b) or solve(x+b,y+a) or solve(x,y) or solve(x+a+b,y+a+b)) puts("Y"); else puts("N"); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>裴蜀定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CC-LECOINS】Little Elephant and Colored Coins]]></title>
    <url>%2Fposts%2F3003.html</url>
    <content type="text"><![CDATA[Source and JudgeCC-LECOINS题意：n种无限个硬币，有价值v和颜色c，然后q次询问能否恰好凑出价值S，无解就-1，否则最大化不同颜色数量1 ≤ N ≤ 301 ≤ Vi ≤ 2000001 ≤ Ci ≤ 1e91 ≤ Q ≤ 2000001 ≤ S ≤ 1e18 Analysis请先思考后再展开 这道题其实难度不大，但因为网上题解少+这sb题卡常，花了我一天时间，相当蛋疼就是那种意识逐渐模糊，到最后都只知道卡stl、对拍什么的，题意都不太记得了…… 建议先做bzoj2118墨墨的等式，也就是不考虑这个颜色那现在这个颜色，显然不能状压，但可以按顺序处理每种颜色，然后考虑一个dp$f(0/1,cnt,num)$ 表示上一个使用的硬币和当前颜色是否相同，以及颜色总数、当前值(%v1)这是一个转移取模的无限背包，咋一看无法转移，但其实只有多个环，每个环就非常好dp了 然后接下来就就是无限长的卡常时间了$O(n^2V+qn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=31,MAX_M=2e5+10; int n,m,mn;ll f[2][MAX_N][MAX_M]; bool v[MAX_M];int q[MAX_M]; void insert(int num)//多个环无限背包 &#123; for(int t=0;t&lt;m;t++) for(int now=0;now&lt;mn;now++) chmin(f[0][t+1][(now+num)%mn],f[1][t][now]+num); memset(v,0,sizeof v); for(int st=0;st&lt;mn;st++) if(!v[st]) &#123; int tot=1;q[1]=st;v[st]=1; for(int now=(st+num)%mn;now!=st;now=(now+num)%mn) q[++tot]=now,v[now]=1; for(int t=0;t&lt;=m;t++) &#123; ll mi=f[0][t][st]-num; for(int i=2;i&lt;=tot;i++) chmin(f[0][t][q[i]],(ll)num*i+mi),chmin(mi,-(ll)num*i+f[0][t][q[i]]); for(int i=1;i&lt;=tot;i++) chmin(f[0][t][q[i]],(ll)num*(tot+i)+mi); &#125; &#125; &#125; pr c[MAX_N];map&lt;int,int&gt; tmp;vector&lt;int&gt; coin[MAX_N]; void main() &#123; n=qread(),m=0,mn=INF; for(int i=1;i&lt;=n;i++) &#123; c[i].SE=qread();mn=min(mn,c[i].SE); int col=qread();if(!tmp.count(col)) tmp[col]=++m; c[i].FR=tmp[col]; &#125; sort(c+1,c+n+1);for(int i=1;i&lt;=n;i++) coin[c[i].FR].push_back(c[i].SE); bool bk=1;//强行放最后 for(int i=1;i&lt;=m;i++) for(int t=0;t&lt;(int)coin[i].size();t++) if(bk and coin[i][t]==mn) &#123;swap(coin[i],coin[m+1]);bk=0;break;&#125; memset(f,0x3f,sizeof f);f[1][0][0]=0; for(int i=1;i&lt;=m+1;i++) &#123; for(int j=0;j&lt;i;j++) for(int t=0;t&lt;mn;t++) chmin(f[1][j][t],f[0][j][t]); for(int t=0;t&lt;(int)coin[i].size();t++) insert(coin[i][t]); &#125; int q=qread(); while(q--) &#123; ll wt=qread(); int ans=-1; for(int lst=0;lst&lt;=1;lst++) for(int t=1;t&lt;=m;t++) &#123; ll tmp=f[lst][t][wt%mn];if(tmp&gt;wt) continue; ans=max(ans,t+(tmp+mn&lt;=wt?lst:0)); &#125; writeln(ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨墨的等式]]></title>
    <url>%2Fposts%2Fcf0b.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2118 Analysis请先思考后再展开 其实就是求能凑出多少个区间内的数如果对于某个对a1的余数b最小凑出的是k，则统计k+xa1在区间内的答案即可注意到a都很小，求k的话相当于在a1个点的图上跑最短路（直接dp应该也行）时间复杂度 $O(nalog)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; #define pr pair&lt;ll,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=5e5+10; int hou[MAX_N];ll dis[MAX_N]; struct Edge&#123;int y,c,g;&#125;e[MAX_N*20]; int ln=0;void ins(int x,int y,int c)&#123;e[++ln]=(Edge)&#123;y,c,hou[x]&#125;;hou[x]=ln;&#125; priority_queue&lt; pr,vector&lt;pr&gt;,greater&lt;pr&gt; &gt; q; void dij() &#123; memset(dis,63,sizeof dis); q.push(MP(0,0));dis[0]=0; while(q.size()) &#123; pr now=q.top();q.pop();int x=now.SE; if(now.FR!=dis[x]) continue; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&gt;dis[x]+e[k].c) &#123; dis[y]=dis[x]+e[k].c; q.push(MP(dis[y],y)); &#125; &#125; &#125; &#125; int a[20]; void main() &#123; int n;ll l,r;scanf("%d%lld%lld",&amp;n,&amp;l,&amp;r); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); for(int i=0;i&lt;a[1];i++) for(int j=2;j&lt;=n;j++) ins(i,(i+a[j])%a[1],a[j]); dij(); ll ans=0; for(int b=0;b&lt;a[1];b++) &#123; ll mi=dis[b];if(mi&gt;r) continue; if(mi&lt;l) mi+=(ll)a[1]*(int)ceil(double(l-mi)/a[1]); ans+=(r-mi)/a[1]+1; &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2016】优秀的拆分]]></title>
    <url>%2Fposts%2Ff7b4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2016uoj219 Analysis请先思考后再展开 本题的套路和bzoj2119 股市的预测是一样的，就是建立关键点那么对于本题，如果能求出lf和rf表示某个位置作为端点的AA数量对于AA，枚举长度，然后发现只要有向两边的lcp，就会对【左右端点都是区间】产生贡献，用差分求和得到lf和rf时间复杂度为调和级数的log123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=31000; int bin[30],lg[MAX_N]; int n; struct Sa &#123; char ss[MAX_N]; int rk[MAX_N],sa[MAX_N],ct[MAX_N]; int wr[MAX_N*2],tmp[MAX_N]; void getsa() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[rk[i]=ss[i]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;n) &#123; int tot=0;for(int i=1;i&lt;=n;i++) if(sa[i]+ln&gt;n) tmp[++tot]=sa[i]; for(int i=1;i&lt;=n;i++) if(sa[i]-ln&gt;=1) tmp[++tot]=sa[i]-ln; memset(wr,0,sizeof wr);//debug memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[wr[tmp[i]]=rk[tmp[i]]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[wr[tmp[i]]]--]=tmp[i]; int cnt=1;rk[sa[1]]=1; for(int i=2;i&lt;=n;i++) &#123; if(wr[sa[i-1]]!=wr[sa[i]] or wr[sa[i-1]+ln]!=wr[sa[i]+ln]) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; int hei[MAX_N]; void gethei() &#123; int lst=0; for(int i=1;i&lt;=n;i++) &#123; if(rk[i]==1) &#123;hei[rk[i]]=0;continue;&#125; int j=sa[rk[i]-1];if(lst) lst--; while(max(i,j)+lst&lt;=n and ss[i+lst]==ss[j+lst]) lst++; hei[rk[i]]=lst; &#125; &#125; int mi[MAX_N][20]; void pre() &#123; getsa();gethei(); for(int i=2;i&lt;=n;i++) mi[i][0]=hei[i]; for(int i=1;i&lt;20;i++) for(int j=2;j&lt;=n-bin[i]+1;j++) mi[j][i]=min(mi[j][i-1],mi[j+bin[i-1]][i-1]); &#125; int ask(int l,int r) &#123; if(l&lt;=0 or r&lt;=0 or l&gt;n or r&gt;n) return 0; if(l==r) return n-l+1;//debug l=rk[l];r=rk[r];if(l&gt;r) swap(l,r); l++;int lgg=lg[r-l+1]; return min(mi[l][lgg],mi[r-bin[lgg]+1][lgg]); &#125; &#125;sa1,sa2;//1是原串 ll lf[MAX_N],rf[MAX_N]; char s[MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N;i++) lg[i]=lg[i&gt;&gt;1]+1; int T;scanf("%d",&amp;T); while(T--) &#123; memset(lf,0,sizeof lf);memset(rf,0,sizeof rf); memset(s,0,sizeof s); scanf("%s",s+1);n=strlen(s+1); memcpy(sa1.ss,s,sizeof s);memcpy(sa2.ss,s,sizeof s);reverse(sa2.ss+1,sa2.ss+n+1); sa2.pre();sa1.pre(); for(int ln=1;ln&lt;=n/2;ln++) for(int i=1;i+ln&lt;=n;i+=ln) &#123; int j=i+ln; int minr=sa1.ask(i,j),minl=sa2.ask(n-i+2,n-j+2); minl=min(minl,ln-1);minr=min(minr,ln); if(ln&lt;=minl+minr) &#123; lf[i-minl]++;lf[i+minr-ln+1]--;//差分 rf[i-minl+ln*2-1]++;rf[i+minr+ln]--; &#125; &#125; for(int i=1;i&lt;=n;i++) lf[i]+=lf[i-1],rf[i]+=rf[i-1]; ll ans=0;for(int i=2;i&lt;=n;i++) ans+=rf[i-1]*lf[i]; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市的预测]]></title>
    <url>%2Fposts%2Fa10e.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2119 Analysis请先思考后再展开 先差分一下，就是求形如ABA这样的串，$|B|=m,lcp(后缀j,后缀i) \geq i-j-M$如果考虑通常的sa+倒着加入hei，那么就是一个动态开点权值线段树维护次数+启发式合并的事了，复杂度log方 正解：考虑长度为L的A的贡献，然后每个L分一个段，每个段的第一个是这一段的关键点考虑到每个长度为L的串只会经过一个关键点，那么对于每个关键点，考虑这上面的串去唯一计数具体而言，枚举第i个关键点（格子(i-1)L+1）和格子(i-1)L+L+M，考虑分别左边（不包含）和右边（包含）的lcp那么总共有 $minl+minr-ln+1$复杂度为调和级数的一个log]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2011】兔兔与蛋蛋游戏]]></title>
    <url>%2Fposts%2F9d0c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2011luogu1971 Analysis请先思考后再展开 仔细分析题意，发现就是移动空格。棋盘问题先染色一下（强制空格为黑色），然后只有那些【棋子和格子颜色相同】的位置能去，而且一旦出去就被删除了。那么其实就是一个二分图，多次加点并询问现在某个点是必胜还是必败然后有个结论 接下来就很简单了，倒着加点判是否是关键点，应该匈牙利和网络流都行吧……时间复杂度为 O(能过)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=41; char mp[MAX_N][MAX_N]; int n,m; inline bool okay(int x,int y) &#123;return 0&lt;=x and x&lt;n and 0&lt;=y and y&lt;m;&#125; inline int calc(int x,int y)&#123;return x*m+y;&#125; int col[MAX_N*MAX_N];//1-&gt;black const int dx[4]=&#123;0,0,-1,1&#125;; const int dy[4]=&#123;-1,1,0,0&#125;; int stx,sty;queue&lt;pr&gt; q; bool vis[MAX_N][MAX_N]; void bfs() &#123; q.push(MP(calc(stx,sty),1));vis[stx][sty]=1; while(q.size()) &#123; pr x=q.front();q.pop(); col[calc(x.FR/m,x.FR%m)]=x.SE; for(int i=0;i&lt;4;i++) &#123; int tx=x.FR/m+dx[i],ty=x.FR%m+dy[i]; if(!okay(tx,ty) or vis[tx][ty]) continue; q.push(MP(calc(tx,ty),x.SE^1));vis[tx][ty]=1; &#125; &#125; &#125; int ti=0,ask[MAX_N*MAX_N]; bool can[MAX_N*MAX_N]; int match[MAX_N*MAX_N]; bool findm(int x) &#123; for(int i=0;i&lt;4;i++) &#123; int tx=x/m+dx[i],ty=x%m+dy[i],y=calc(tx,ty); if(!okay(tx,ty) or !can[y] or ask[y]==ti) continue; ask[y]=ti; if(match[y]&lt;0 or findm(match[y])) &#123; match[x]=y; match[y]=x; return 1; &#125; &#125; return 0; &#125; vector&lt;int&gt; tmp;int f[2100]; vector&lt;int&gt; ans; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) &#123; scanf("%s",mp[i]); for(int j=0;j&lt;m;j++) if(mp[i][j]=='.') stx=i,sty=j; &#125; bfs(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) can[calc(i,j)]=( col[calc(i,j)]==(mp[i][j]!='O') ); int q;scanf("%d",&amp;q);pr now=MP(stx,sty); for(int i=1;i&lt;=q*2;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y);x--;y--; tmp.push_back(calc(now.FR,now.SE)),can[calc(now.FR,now.SE)]=0; now=MP(x,y); &#125; memset(match,-1,sizeof match); int tt=0;for(int i=0;i&lt;n*m;i++) if(can[i] and col[i] and match[i]&lt;0) &#123;ti++;tt+=findm(i);&#125; for(int t=(int)tmp.size()-1;t&gt;=0;t--) &#123; int tot=0;can[tmp[t]]=1; for(int i=0;i&lt;n*m;i++) if(can[i] and col[i] and match[i]&lt;0) &#123;ti++;tot+=findm(i);&#125; f[t]=tot; &#125; for(int i=0;i&lt;=q*2-2;i+=2) if(f[i]==1 and f[i+1]==1) ans.push_back(i/2); printf("%d\n",ans.size());for(int t=0;t&lt;(int)ans.size();t++) printf("%d\n",ans[t]+1); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CQOI2014】学习小组]]></title>
    <url>%2Fposts%2F4e7e.html</url>
    <content type="text"><![CDATA[Source and JudgeCQOI2014bzoj3442 Record1h Analysis请先思考后再展开 第一想法显然是网络流，主要有两点不会处理： 每个小组参加人数的平方 不要求总人数最多 第一个可能是套路，但我忘记了，就是流量为1，费用为平方的差分乘ci第二个问题，也挺妙的……这个技巧必须掌握，就是你从每个人再建去ed一个流量k-1费用0的边]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CQOI2014】危桥]]></title>
    <url>%2Fposts%2F3001.html</url>
    <content type="text"><![CDATA[Source and JudgeCQOI2014loj2239 Record1h Analysis请先思考后再展开 https://www.luogu.org/blog/39887/solution-p3163]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【COCI2013】hiperprostor]]></title>
    <url>%2Fposts%2F2fdd.html</url>
    <content type="text"><![CDATA[Source and JudgeCOCI2013bzoj3482 Record2h Analysis请先思考后再展开 对于每个st，用最短路求出f(k,ed)表示经过了k条x到达ed的最短路那么每个的贡献就是y=kx+f(k,ed)，这m条直线放到坐标系上，维护最底下的部分和往常不同的是，这些是直线而不是点，然后我就搞了个求交点稍微分类讨论一下（利用本题斜率的特点）然后无论x取什么，k超过n就不会有贡献了，所以其实直线只有n条那么复杂度为 $O(q*(n^2log+n))$ 拍了很久各种情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair ll INF; const int MAX_N=510,MAX_M=11000; int hou[MAX_N]; struct Edge&#123;int y,c,g;&#125;e[MAX_M]; int ln=0;void ins(int x,int y,int c)&#123;e[++ln]=(Edge)&#123;y,c,hou[x]&#125;;hou[x]=ln;&#125; ll dis[MAX_N][MAX_N]; int n,m; struct Data &#123; int k,x;ll d; friend bool operator &lt;(Data a,Data b) &#123;return a.d&gt;b.d;&#125; &#125;; priority_queue&lt;Data&gt; q; void pre(int st) &#123; memset(dis,63,sizeof dis);INF=dis[0][0]; dis[0][st]=0;q.push((Data)&#123;0,st,0&#125;); while(q.size()) &#123; Data now=q.top();q.pop(); if(now.k&gt;n or now.d!=dis[now.k][now.x]) continue; for(int k=hou[now.x];k&gt;0;k=e[k].g) &#123; int y=e[k].y,k2=now.k+(e[k].c&lt;0);ll c2=now.d+(e[k].c&lt;0?0:e[k].c); if(dis[k2][y]&gt;c2) dis[k2][y]=c2,q.push((Data)&#123;k2,y,c2&#125;); &#125; &#125; &#125; double ptx[MAX_N]; pr line[MAX_N]; double getpt(pr a,pr b) &#123; return double(b.SE-a.SE)/(a.FR-b.FR); &#125; char s[20]; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d%s",&amp;x,&amp;y,s); if(s[0]=='x') ins(x,y,-1); else &#123; int ln=strlen(s),num=0; for(int i=0;i&lt;ln;i++) num=num*10+s[i]-'0'; ins(x,y,num); &#125; &#125; int q;scanf("%d",&amp;q); while(q--) &#123; int st,ed;scanf("%d%d",&amp;st,&amp;ed); if(st==ed)&#123;puts("1 0");continue;&#125; pre(st); bool bk=1;for(int i=0;i&lt;=n;i++) if(dis[i][ed]!=INF) bk=0; if(bk) &#123;puts("0 0");continue;&#125; if(dis[0][ed]==INF) &#123;puts("inf");continue;&#125; int tot=0; for(int k=n;k&gt;=0;k--) &#123; if(dis[k][ed]==INF) continue; pr now=MP(k,dis[k][ed]); while(tot&gt;0 and getpt(line[tot],now)&lt;=ptx[tot]) tot--; tot++;line[tot]=now; ptx[tot]=(tot==1)?0:getpt(line[tot-1],now); &#125; ll cnt=0,sum=0; for(int i=1;i&lt;=tot-1;i++) &#123; ll x1=ceil(ptx[i]),x2=floor(ptx[i+1]); if(i==1 or x1-ptx[i]&lt;=1e-4) x1++; if(x1&gt;x2) continue; cnt+=(x2-x1+1);sum+=((x1+x2)*line[i].FR+2*line[i].SE)*(x2-x1+1)/2; &#125; if(ceil(ptx[tot])-ptx[tot]&gt;1e-4 or tot==1) cnt++,sum+=line[tot].SE; printf("%lld %lld\n",cnt,sum); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2957】楼房重建]]></title>
    <url>%2Fposts%2F44d84051.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2957 Record1h Analysis请先思考后再展开 一开始的想法：求一个最顶上，斜率递增的面然后分块维护，询问的时候，加入第i个块的时候前面不会被修改，后面就二分一下接在上面，复杂度为 $O(n\sqrt{n log})$显然不能过…… 正解：vali=yi/xi，则求上升序列，这样就好做多了，我连这个都没转化qwq注意到修改只会修改一个位置，我们要尽量利用已有的信息去剪枝考虑分治，设计一个函数solve(l,r,left)表示只考虑这段区间时候的答案，然后左边被left挡住分类讨论一下，如果left挡住左区间的mx，则solve(mid+1,r,left)否则，solve(l,mid,left)+solve(mid+1,r,lmx)注意到右边那个，通过线段树是可以保存的（线段树区间个数为2n）设cnt为只考虑本区间的答案，cnt2是上面说的那个保存的东东（只用于右区间） 考虑复杂度，修改的时候搞cnt和cnt2需要log次solve，每个solve是log； 询问的时候，分裂成log个区间，每次都要solve，时间复杂度为 $O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=110000; struct SegmentTree &#123; double mx[MAX_N*4];int cnt[MAX_N*4],cnt2[MAX_N*4]; #define lc 2*x #define rc 2*x+1 void build(int x,int l,int r) &#123; mx[x]=0;cnt[x]=1;cnt2[x]=1; if(l==r) return; int mid=(l+r)/2; build(lc,l,mid);build(rc,mid+1,r); &#125; int calc(int x,int l,int r,double left) &#123; if(left&gt;=mx[x]) return 0; if(l==r) return mx[x]&gt;left; int mid=(l+r)&gt;&gt;1; if(left&gt;=mx[lc]) return calc(rc,mid+1,r,left); return calc(lc,l,mid,left)+cnt2[rc]; &#125; void change(int x,int l,int r,int pos,double val) &#123; if(l==r) &#123;mx[x]=val;return;&#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) change(lc,l,mid,pos,val); else change(rc,mid+1,r,pos,val); mx[x]=max(mx[lc],mx[rc]); cnt2[rc]=calc(rc,mid+1,r,mx[lc]); cnt[x]=cnt[lc]+cnt2[rc]; &#125; &#125;sgt; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); sgt.build(1,1,n); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); sgt.change(1,1,n,x,(double)y/x); printf("%d\n",sgt.calc(1,1,n,0)); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2012】滑雪与时间胶囊]]></title>
    <url>%2Fposts%2Fb8b9.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2012bzoj2753 Record1h Analysis请先思考后再展开 显然先处理出1能到的节点，这样保证根是1能穿越回去过的点，每条边长只考虑一次，要求去过所有能去的点看起来很像MST，考虑到是有向边，类似于求最小树形图显然不能朱刘算法，但注意到边的方向是由高度决定的 考虑为什么普通的MST不能用，因为加入某条边的时候，你并不知道是把点加了进去还是把点作为祖先……联想dag的树形图————贪心地选择边权最小的入边还有就是，同一高度的点，内部是无向边，谁找谁都没问题那么我们不妨按照高度从大到小枚举每个点（等价于按拓扑序），然后仿照kruskal那样从小到大枚举入边，尝试加入mst 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=1100000; int h[MAX_N];bool v[MAX_N]; vector&lt;int&gt; to[MAX_N]; int tot=0; void dfs(int x) &#123; v[x]=1;tot++; for(int t=0;t&lt;(int)to[x].size();t++) if(!v[to[x][t]]) dfs(to[x][t]); &#125; int fa[MAX_N];int findfa(int x) &#123;return fa[x]=(fa[x]==x?x:findfa(fa[x]));&#125; struct Edge&#123;int x,y,c;&#125;; bool cmp(Edge a,Edge b) &#123;return h[a.y]&gt;h[b.y] or (h[a.y]==h[b.y] and a.c&lt;b.c);&#125; vector&lt;Edge&gt; e; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]),fa[i]=i; for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(h[x]&lt;h[y]) swap(x,y); to[x].push_back(y);if(h[x]==h[y]) to[y].push_back(x); e.push_back((Edge)&#123;x,y,c&#125;); &#125; sort(e.begin(),e.end(),cmp); dfs(1); ll ans=0; for(int t=0;t&lt;(int)e.size();t++) &#123; Edge a=e[t];if(!v[a.x] or !v[a.y]) continue; int fx=findfa(a.x),fy=findfa(a.y); if(fx!=fy) fa[fx]=fy,ans+=a.c; &#125; printf("%d %lld",tot,ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>复习</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3450】OSU]]></title>
    <url>%2Fposts%2F18cd.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3450bzoj4318 Record30min Analysis请先思考后再展开 期望入门好题……………………设当前成功的概率为P，考虑一个递推以bzoj3450为例，设g为前面连续长度的期望$f(i)=\sum (1-np) \times p \times 权值和+\sum np \times p \times (权值和+2 \times 连续长度+1)$$f(i)=\sum p \times 权值和+\sum np \times p \times (2*连续长度+1)$$f(i)=\sum f(i-1)+np \times (2 \times g(i-1)+1)$ 然后bzoj4318同理$f(i)=\sum (1-np) \times p \times 权值和+\sum np \times p \times (权值和+3连续长度平方+3连续长度+1)$$f(i)=\sum p \times 权值和+\sum np \times p(3连续长度平方+3连续长度+1)$$f(i)=\sum f(i-1)+np \times (3g1(i-1)+3g2(i-1)+1)$分g1和g2是因为，概率是不平方的，也就是说$连续长度的期望^2 \neq 连续长度平方的期望$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair void main() &#123; int n;scanf("%d",&amp;n); // double f=0,g=0; // for(int i=1;i&lt;=n;i++) // &#123; // double p;scanf("%lf",&amp;p); // double g2=p*(g+1); // double f2=f+p*(2*g+1); // f=f2;g=g2; // &#125; // printf("%.4lf",f); double a=0,b=0,c=0; for(int i=1;i&lt;=n;i++) &#123; double p;scanf("%lf",&amp;p); double a2=p*(a+1),b2=p*(b+2*a+1); double c2=c+p*(3*b+3*a+1); a=a2,b=b2,c=c2; &#125; printf("%.1lf",c); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BJWC2018】餐巾计划问题]]></title>
    <url>%2Fposts%2F509.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu4480 Record1h Analysis请先思考后再展开 考虑枚举新毛巾的购买数量那么贪心地计算代价即可 打个表出来不难发现新毛巾的选取满足单峰性不过我不会证明，网上目前的两篇题解都在乱说……$O(nlog_{1.5}n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=210000; int n,m1,m2,c1,c2,cost,ned[MAX_N],left[MAX_N]; stack&lt;int&gt; a,b; int check(int st) &#123; while(a.size()) a.pop(); while(b.size()) b.pop(); memcpy(left,ned,sizeof ned); int ans=st*cost; for(int i=1;i&lt;=n;i++) &#123; int now=ned[i]; if(st&gt;0) &#123; if(now&lt;=st) st-=now,now=0; else now-=st,st=0; &#125; if(i-m1&gt;=1) a.push(i-m1); if(i-m2&gt;=1) b.push(i-m2); while(now and a.size()) &#123; int t=a.top(); if(now&lt;=left[t]) ans+=now*c1,left[t]-=now,now=0; else ans+=left[t]*c1,now-=left[t],left[t]=0; if(left[t]==0) a.pop(); &#125; while(now and b.size()) &#123; int t=b.top(); if(now&lt;=left[t]) ans+=now*c2,left[t]-=now,now=0; else ans+=left[t]*c2,now-=left[t],left[t]=0; if(left[t]==0) b.pop(); &#125; if(now) return -1; &#125; return ans; &#125; void main() &#123; scanf("%d%d%d%d%d%d",&amp;n,&amp;m1,&amp;m2,&amp;c1,&amp;c2,&amp;cost); int l=1,r=0;for(int i=1;i&lt;=n;i++) scanf("%d",&amp;ned[i]),r+=ned[i]; if(c1&gt;c2) swap(m1,m2),swap(c1,c2); while(l&lt;r) &#123; int mid1=l+(r-l+1)/3,mid2=r-(r-l+1)/3; ll t1=check(mid1),t2=check(mid2); if(l+1==r) &#123; if(t1&lt;0) l=r=mid2; else l=r=(t1&lt;t2?mid1:mid2); &#125; else &#123; if(t1&lt;0) l=mid1; else if(t1&gt;t2) l=mid1; else r=mid2; &#125; &#125; printf("%d",check(l)); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WC2014】时空穿梭]]></title>
    <url>%2Fposts%2F6b1.html</url>
    <content type="text"><![CDATA[ProblemWC2014uoj54 Analysis请先思考后再展开 完整数据范围请前往uoj如果对像本sb一样对高维空间难以理解，可以看看bzoj3518帮助理解 因为在一条直线上，考虑枚举线段两端的节点那么我们不妨枚举跨度向量a，那么在中间的点的数量就是 $gcd(a_i)-1$ ，这个挺好想的吧，因为右上角的节点会被所有【除以gcd的位置】覆盖考虑每种向量实际有多少个，那么不难得出式子（如果选不到c-2个，组合数为0）$$\begin{aligned}ans&amp;=\sum_{a_t}^{M_t} \sum \sum C_{gcd(a_t)-1}^{c-2} (\prod M_t-a_t)\\&amp;=\sum_{g=1}^{minM} C_{g-1}^{c-2} \times ( \sum_{m_t=1}^{M_t/g} \sum \sum (\prod M_t-m_t \times g) \times [gcd(m)=1] )\\&amp;然后套路地莫反一下（目的是取消之间的依赖性，利用乘法分配律降低复杂度）\\&amp;=\sum_{g=1}^{minM} C_{g-1}^{c-2} \times ( \sum_{m_t=1}^{M_t/g} \sum \sum (\prod M_t-m_t \times g) \times (\sum_{d|gcd(m_i)} \mu(d)) )\\&amp;=\sum_{g=1}^{minM} C_{g-1}^{c-2} \times ( \sum_{d=1}^{minM/g} \mu(d) \times \prod (\sum_{i=1}^{\frac{M_t}{dg}} M_t-i \times dg) )\\&amp;看到这个形式，做题多的不难发现枚举dg会方便很多\\&amp;=\sum_{D=1}^{minM} (\prod ( \sum_{i=0}^{\frac{M_t}{D}} M_t-i \times D )) \times (\sum_{g|D} C_{g-1}^{c-2} \mu(D/g))\\&amp;=\sum_{D=1}^{minM} (\prod ( (M_t/D) \times M_t-D \times (M_t/D)*(M_t/D+1)/2 )) \times (\sum_{g|D} C_{g-1}^{c-2} \mu(D/g))\\\end{aligned}$$后面那个 cmlogm 预处理为f(c,D)，则每组数据的复杂度为nmlogm到此为止都比较常规，然而还是无法处理多组数据，主要在于致命的枚举D此时很多人肯定会观察到式子中的整除，公所周知现在不同的 $\frac{M_t}{D}$ 只有 $n \sqrt m$ 个但是看到式子中还有一个D，非常麻烦，但也仅仅只有这个东西是麻烦的，于是我们不妨把D当做未知数！所以我们依然可以用数论分块得出当前D的区间dl和dr，这段区间内中间的东西是个关于D的多项式，可以 $n^2$ 计算出 $D^i$ 的系数a$ans=\sum_{i=0}^n a_i \times ( \sum_{dl}^{dr} f(D) \times D^i )$后面那个可以cnM计算前缀和 组合数用递推式算f(i,c,D)枚举倍数暴力预处理总复杂度为 $O(cmlogm+cnm+Tn^3\sqrt m)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MOD=10007; void add(int &amp;x,int y) &#123; x+=y;if(x&gt;=MOD) x-=MOD; if(x&lt;=-MOD) x+=MOD; &#125; int sum(int x,int y) &#123;add(x,y);return x;&#125; const int MAX_N=12,MAX_M=100001; bool no[MAX_M];int pr=0,prime[MAX_M],mu[MAX_M]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAX_M;i++) &#123; if(!no[i]) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_M;j++) &#123; int t=i*prime[j];no[t]=1; if(i%prime[j]==0) &#123;mu[t]=0;break;&#125; mu[t]=-mu[i]; &#125; &#125; &#125; int aa[MAX_N]; int C[MAX_M][30],f[30][MAX_M],ff[MAX_N][30][MAX_M]; int m[MAX_N]; void main() &#123; pre(); C[0][0]=1; for(int i=1;i&lt;MAX_M;i++) &#123; C[i][0]=1; for(int j=1;j&lt;30 and j&lt;=i;j++) C[i][j]=sum(C[i-1][j-1],C[i-1][j]); &#125; for(int D=1;D&lt;MAX_M;D++) for(int c=2;c&lt;=20;c++) for(int j=D;j&lt;MAX_M;j+=D) add(f[c][j], C[D-1][c-2]*mu[j/D] ); for(int i=0;i&lt;MAX_N;i++) for(int D=1;D&lt;MAX_M;D++) &#123; int Di=1;for(int j=1;j&lt;=i;j++) Di=Di*D%MOD; for(int c=2;c&lt;=20;c++) ff[i][c][D]=f[c][D]*Di%MOD,add(ff[i][c][D],ff[i][c][D-1]); &#125; int T;scanf("%d",&amp;T); while(T--) &#123; int n,c;scanf("%d%d",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;m[i]); sort(m+1,m+n+1); int ans=0; for(int D=1;D&lt;=m[1]-1;) &#123; int lst=m[1];for(int i=1;i&lt;=n;i++) lst=min(lst,m[i]/(m[i]/D)); memset(aa,0,sizeof aa);aa[0]=1; for(int i=1;i&lt;=n;i++) &#123; int t=(m[i]/D)%MOD;int a=t*m[i]%MOD,b=(-t*(t+1)/2)%MOD; for(int j=n;j&gt;=1;j--) aa[j]=sum(aa[j]*a%MOD,aa[j-1]*b%MOD); aa[0]=aa[0]*a%MOD; &#125; for(int i=0;i&lt;=n;i++) add(ans, aa[i]*(ff[i][c][lst]-ff[i][c][D-1])%MOD ); D=lst+1; &#125; printf("%d\n",(ans+MOD)%MOD); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>莫反</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2015】线性代数]]></title>
    <url>%2Fposts%2F1b03.html</url>
    <content type="text"><![CDATA[ProblemTJOI2015bzoj3996HDU4307 Analysis请先思考后再展开 把题意转化为点有点权，边有边权，求权值和最大的点导出子图然后想了想普通的网络流，感觉无法解决，然后就不会了其实是个最小割……好久没用了就完全没想到其实有经验的话，这种决策类的东西，不能贪心基本都是网络流了吧 最大化答案，即最大化总边权+点权-被舍去的部分如果一条边的两个点都没有被舍去，那么边权就必须舍去基于这个思路构图就好了具体而言就是给每条边建点，然后连st，原点连ed 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;vector&gt;using namespace std;namespace mine&#123; #define double long double typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector #define mid (l+r)/2 #define lc 2*x #define rc 2*x+1 void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; const int INF=0x3f3f3f3f; const int MOD=998244353; void add(int &amp;a,ll b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;if(a&lt;=-MOD)a+=MOD;&#125; ll qpower(ll x,ll e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll invm(ll x)&#123;return qpower(x,MOD-2);&#125; const int N=2e6+10; int hou[N]; struct Edge&#123;int y,g;ll c;&#125;e[N]; int ln=0;int oth(int x)&#123;return (x&amp;1)?x+1:x-1;&#125; void ins(int x,int y,ll c) &#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0&#125;;hou[y]=ln; &#125; int st,ed;int h[N];queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,4*(ed+10)); h[st]=1;q.push(st); while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(!h[y] and e[k].c) h[y]=h[x]+1,q.push(y); &#125; &#125; return h[ed]&gt;0; &#125; ll dfs(int x,ll flow) &#123; if(x==ed)return flow; ll now=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c and now&lt;flow) &#123; ll out=dfs(y,min(flow-now,e[k].c)); e[k].c-=out;e[oth(k)].c+=out;now+=out; &#125; if(now==flow)break; &#125;if(now==0)h[x]=0; return now; &#125; void main() &#123; int n=qread();st=0,ed=(n+1)*n+1;ll ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int b=qread(),id=n+(i-1)*n+j;ins(id,ed,b);ans+=b; ins(i,id,(ll)INF*INF/N);ins(j,id,(ll)INF*INF/N); &#125; for(int i=1;i&lt;=n;i++) ins(st,i,qread()); while(bfs()) ans-=dfs(st,(ll)INF*INF);write(ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>最小割</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph]]></title>
    <url>%2Fposts%2F405b.html</url>
    <content type="text"><![CDATA[ProblemBernard有n个结点，编号1至n，一开始没有边。现在Bernard要新建m条边，构成一个图。每一条新建的边都是无向边。但是要满足如下的条件：1、选择两个不同编号的结点X和Y，在X和Y之间建立一条边，前提是两个结点的编号的差不超过给定的参数k，即0&lt;|y-x|≤k。注意：允许在A和B之间建立多条边（即两个结点之间可以有重边）。2、当最终建完m条边之后，对于任意的一个结点i，与结点i相连的边共有偶数条。注意：0也被认为是偶数。问：总共可以构造出多少种不同的图？答案对1000000007取模。注意构出来的图可以是不连通的图。 1≤n≤30，0≤m≤30，1≤k≤8 Analysis请先思考后再展开 wo shi sb 一直不知道怎么处理重边但其实如果现在满足度数的奇偶性，那么每条边的重复次数是可以%2的所以最后用隔板法统计一下插入的边即可 f[i][j][S]表示考虑完点i有j条边，包括i在内的k个点的度数奇偶性枚举第i个点相关的边就能通过本题了更优秀的做法是考虑往前的每条边，这样就是 $O(nmk2^k)$ 不过并没有写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MOD=1000000007; void add(int &amp;x,int y) &#123; x+=y;if(x&gt;=MOD) x-=MOD; &#125; int f[32][42][1&lt;&lt;10],bin[30],siz[1&lt;&lt;10]; int c[1100][1100]; void main() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; siz[1]=1;for(int i=2;i&lt;bin[10];i++) siz[i]=siz[i&gt;&gt;1]+siz[i&amp;1]; c[0][0]=1; for(int i=1;i&lt;1100;i++) &#123; c[i][0]=1; for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD; &#125; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); f[1][0][0]=1; for(int i=1;i&lt;n;i++) for(int j=0;j&lt;=m;j++) for(int s=0;s&lt;bin[k];s++) if(f[i][j][s]) &#123; int left=min(i,k); for(int s2=0;s2&lt;bin[left];s2++) &#123; if(left==k and ((s^s2)&amp;bin[left-1]) ) continue; add(f[i+1][j+siz[s2]][ ((s^s2)&lt;&lt;1)+(siz[s2]&amp;1) ],f[i][j][s]); &#125; &#125; int tot=0;for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n and j&lt;=i+k;j++) tot++; int ans=0; for(int j=0;j&lt;=m;j++) &#123; int left=m-j;if(left&amp;1) continue; add(ans,(ll)f[n][j][0]*c[left/2+tot-1][tot-1]%MOD); &#125; printf("%d",ans); &#125;&#125;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小奇挖矿]]></title>
    <url>%2Fposts%2F1596.html</url>
    <content type="text"><![CDATA[ProblemNOIP模拟赛 Analysis请先思考后再展开 wo shi sb 考虑每个a的系数，这样就能直接做了123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=1e5+10; int op[MAX_N],x[MAX_N]; double f[MAX_N]; void main() &#123; int n,k,c,w;scanf("%d%d%d%d",&amp;n,&amp;k,&amp;c,&amp;w); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;op[i],&amp;x[i]); f[n+1]=0; for(int i=n;i&gt;=1;i--) &#123; if(op[i]==1) f[i]=max(f[i+1],f[i+1]*(1-0.01*k)+x[i]); else f[i]=max(f[i+1],f[i+1]*(1+0.01*c)-x[i]); &#125; printf("%.2lf",f[1]*w); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3560】DZY Loves Math V]]></title>
    <url>%2Fposts%2Fb3c.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3560 Record1h Analysis请先思考后再展开 这道题的第一步挺妙的就是显然你要把phi拆开来，然后一个很自然的想法就是利用其积性函数的性质那么我应该要考虑每个p的贡献，然后我就不会了…… $ans=\prod solve(p)$可以用一个乘法原理理解它，仔细想想就会发现是正确的（很多大佬直接跳过这步让我一开始觉得好懵逼）$$\begin{aligned}\sum \sum \sum_{c_i=0-&gt;b_i} \varphi( p^{\sum ci} )\\但需要考虑特殊的\varphi(1)=1\\1+\frac{p-1}{p} ((\sum \sum \sum_{c_i=0-&gt;b_i} p^{\sum c_i})-1) \\1+\frac{p-1}{p} (( \prod( \sum_{k=0}^{b_i} p^k ) )-1) \\\end{aligned}$$ 那么线性筛一下就是O(nlogn)的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MOD=1e9+7; const int MAX_NUM=10000001; bool no[MAX_NUM]; int pr=0,prime[MAX_NUM],mip[MAX_NUM]; void pre() &#123; for(int i=2;i&lt;MAX_NUM;i++) &#123; if(!no[i]) prime[++pr]=i,mip[i]=i; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; int t=i*prime[j];no[t]=1; mip[t]=min(mip[i],prime[j]); if(i%prime[j]==0) break; &#125; &#125; &#125; int tot[MAX_NUM],inv[MAX_NUM]; void main() &#123; for(int i=0;i&lt;MAX_NUM;i++) tot[i]=1; inv[1]=1;for(int i=2;i&lt;MAX_NUM;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; pre(); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int num;scanf("%d",&amp;num); while(num&gt;1) &#123; int p=mip[num]; int tmp=1;ll sum=1; while(num%p==0) num/=p,tmp*=p,(sum+=tmp)%=MOD; tot[p]=(ll)tot[p]*sum%MOD; &#125; &#125; int ans=1;for(int p=2;p&lt;MAX_NUM;p++) if(tot[p]&gt;1) ans=(ll)ans*(ll(p-1)*inv[p]%MOD*(tot[p]-1)%MOD+1)%MOD; printf("%d",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【中山市选2011】完全平方数]]></title>
    <url>%2Fposts%2Fd03f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2440 Record30min Analysis请先思考后再展开 市选时代的题目，挺妙的就是你先考虑这种数怎么贡献到单一约数上然而即使你去除那些因子数&gt;1的约数，你发现并不只一个，然而这是可以容斥的然后你发现mu既能去除平方因子，又能帮你容斥然后你需要枚举的地方只有根号级别，mu可以用线性筛处理出来所以最后套个二分就好了，这个倒比较显然]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>容斥</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cf407e】外星千足虫]]></title>
    <url>%2Fposts%2F27f0.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj1923 Record30min Analysis请先思考后再展开 为什么一大堆人都是直接用高斯消元做？我只会二分的……复杂度显然不优秀考虑动态插入，那么像线性基那样做就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=1100; typedef bitset&lt;MAX_N&gt; bit; int n,cnt=0,val[MAX_N]; bit bs[MAX_N]; void insert(bit now,int num) &#123; for(int i=n-1;i&gt;=0;i--) if(now[i]) &#123; if(bs[i][i]) now^=bs[i],num^=val[i]; else &#123; for(int j=i-1;j&gt;=0;j--) if(now[j] and bs[j][j]) now^=bs[j],num^=val[j]; cnt++;bs[i]=now;val[i]=num; for(int j=n-1;j&gt;i;j--) if(bs[j][i]) bs[j]^=now,val[j]^=num; break; &#125; &#125; &#125; void main() &#123; int m;scanf("%d%d",&amp;n,&amp;m); bool ok=0; for(int i=1;i&lt;=m;i++) &#123; char s[MAX_N];int num;scanf("%s%d",s,&amp;num); bit now;for(int j=0;j&lt;n;j++) now[j]=(s[j]-'0'); insert(now,num); if(cnt==n) &#123;ok=1;printf("%d\n",i);break;&#125;; &#125; if(ok==0) puts("Cannot Determine"); else for(int i=0;i&lt;n;i++) puts(val[i]?"?y7M#":"Earth"); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cf407e】kd-sequence]]></title>
    <url>%2Fposts%2Fd7fc.html</url>
    <content type="text"><![CDATA[Source and Judgecf407ebzoj4527 Record1h Analysis请先思考后再展开 这个序列必须原本就满足所有数的差都是d的倍数（特判0）只需要一个数就能确定该序列对d的余数，所以可以将原序列分为一个个区间然后在值域上考虑插入k个数，即 (max-min)/d+1-(i-j+1)&lt;=k那么我们可以从左往右枚举r，用线段树维护上述式子，在线段树上二分找答案指针的移动的话，可以用一个单调栈去准确更新，不难发现复杂度是nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模拟赛】旅游【CC】Chef and Bike]]></title>
    <url>%2Fposts%2F17d8.html</url>
    <content type="text"><![CDATA[Problem【模拟赛】旅游：有一个点数为 n 边数为 m 的带边权有向图，可能有重边和自环，求从 1 号点到 n 号点，恰好经过 t 条边，边权和是 k 的倍数，这样的路径数，对 232792561 取模。 【CC】Chef and Bikehttps://www.codechef.com/problems/BIKE毕克出的题目输入 n(n ≤ 22) 个点，m(m ≤ 8000) 个边。每个边连接着点 (si, ei)，有两个长度 fi, ri。问对于每个点 k，有多少条路径（不一定是简单路径）由 t (t ≤ 10^9) 条边组成，从 k 开始，并且以 k 结束；并且路径上所有边 f 的和 mod n 为 x；并且路径上所有边 r 的和 mod (n − 1) 为 y。对于每一个 (x, y) 都要计算。方案数 mod 1163962801 输出。 Record2h Analysis请先思考后再展开 首先，这两题的模数都满足边权和模数任意，都能有对应的单位原根模数的原根分别是71和46 方法一：适用于【旅游】因为只需要求余数为0，可以利用一个式子： $\frac{1}{k} \sum_{i=0}^{k-1} g_k^{ni}=[n\%k=0]$这个式子知道DFT原理的一定知道，不知道也不难看出来是正确的（单位复数根和单位原根都适用）因为边权是求和的，那么作为次幂就是g的乘积然后矩阵乘法，维护所有方案的 $\sum( \prod w )$ ，这个东西根据乘法原理直接乘即可时间复杂度 $O(n^3 k log_t)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MOD=232792561,G=71; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; void add(ll &amp;x,ll y) &#123; x+=y;if(x&gt;=MOD) x-=MOD; &#125; const int MAX_N=60,MAX_K=21; struct Matrix &#123; ll m[MAX_N][MAX_N]; Matrix()&#123;memset(m,0,sizeof m);&#125; friend Matrix operator *(Matrix a,Matrix b) &#123; Matrix c; for(int i=1;i&lt;MAX_N;i++) for(int j=1;j&lt;MAX_N;j++) for(int k=1;k&lt;MAX_N;k++) add(c.m[i][j],a.m[i][k]*b.m[k][j]%MOD); return c; &#125; &#125;; Matrix mpower(Matrix x,int e) &#123; Matrix ans;for(int i=1;i&lt;MAX_N;i++) ans.m[i][i]=1; while(e) &#123; if(e&amp;1) ans=ans*x; x=x*x;e&gt;&gt;=1; &#125; return ans; &#125; ll gk[MAX_K*MAX_K]; Matrix A[MAX_K]; void main() &#123; int n,m,e,k;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;e,&amp;k); gk[0]=1;gk[1]=qpower(G,(MOD-1)/k);for(int i=2;i&lt;MAX_K*MAX_K;i++) gk[i]=gk[i-1]*gk[1]%MOD; while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); for(int t=1;t&lt;=k;t++) add(A[t].m[x][y],gk[c%k*t]); &#125; ll ans=0;for(int t=1;t&lt;=k;t++) add(ans,mpower(A[t],e).m[1][n]); printf("%lld",ans*qpower(k,MOD-2)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 方法二：适用于【旅游】考虑矩阵里存多项式（千万别像我这样去想多项式里存矩阵，会自闭的），表示对k余数的生成函数那么这是一个对k的循环卷积，暴力DFT（可参考毛爷爷论文）即可复杂度为 $O(n^2k^2+n^3klog_t)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MOD=232792561,G=71; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; void add(ll &amp;x,ll y) &#123; x+=y;if(x&gt;=MOD) x-=MOD; &#125; const int MAX_N=60,MAX_K=23; ll gk[MAX_K*MAX_K],gv[MAX_K*MAX_K]; struct T &#123; ll a[MAX_K]; T()&#123;memset(a,0,sizeof a);&#125; friend T operator +(T a,T b) &#123; for(int i=0;i&lt;MAX_K;i++) add(a.a[i],b.a[i]); return a; &#125; friend T operator *(T a,T b) &#123; for(int i=0;i&lt;MAX_K;i++) a.a[i]=a.a[i]*b.a[i]%MOD; return a; &#125; void DFT(int n) &#123; ll ta[MAX_K];memset(ta,0,sizeof ta); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) add(ta[i],a[j]*gk[i*j]%MOD); memcpy(a,ta,sizeof a); &#125; void IDFT(int n) &#123; ll ta[MAX_K];memset(ta,0,sizeof ta); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) add(ta[i],a[j]*gv[i*j]%MOD); for(int i=0;i&lt;n;i++) a[i]=ta[i]*qpower(n,MOD-2)%MOD; &#125; &#125;; struct Matrix &#123; T m[MAX_N][MAX_N]; Matrix()&#123;memset(m,0,sizeof m);&#125; friend Matrix operator *(Matrix a,Matrix b) &#123; Matrix c; for(int i=1;i&lt;MAX_N;i++) for(int j=1;j&lt;MAX_N;j++) for(int k=1;k&lt;MAX_N;k++) c.m[i][j]=c.m[i][j]+a.m[i][k]*b.m[k][j]; return c; &#125; &#125;; Matrix mpower(Matrix x,int e) &#123; Matrix ans;for(int i=1;i&lt;MAX_N;i++) ans.m[i][i].a[0]=1,ans.m[i][i].DFT(MAX_K); while(e) &#123; if(e&amp;1) ans=ans*x; x=x*x;e&gt;&gt;=1; &#125; return ans; &#125; Matrix A; void main() &#123; int n,m,e,k;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;e,&amp;k); gk[0]=1;gk[1]=qpower(G,(MOD-1)/k);for(int i=2;i&lt;MAX_K*MAX_K;i++) gk[i]=gk[i-1]*gk[1]%MOD; gv[0]=1;gv[1]=qpower(gk[1],MOD-2);for(int i=2;i&lt;MAX_K*MAX_K;i++) gv[i]=gv[i-1]*gv[1]%MOD; while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); A.m[x][y].a[c%k]++; &#125; for(int x=1;x&lt;=n;x++) for(int y=1;y&lt;=n;y++) A.m[x][y].DFT(k); A=mpower(A,e); for(int x=1;x&lt;=n;x++) for(int y=1;y&lt;=n;y++) A.m[x][y].IDFT(k); printf("%lld",A.m[1][n].a[0]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 方法三：适用于【BIKE】这题就必须老老实实对k求余数了矩阵里面存矩阵，然后是一个二维的卷积，自己仿照一维的推一下即可$O(n^2k^4+n^3k^2log_t)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MOD=1163962801,G=46; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; void add(ll &amp;x,ll y) &#123; x+=y;if(x&gt;=MOD) x-=MOD; &#125; const int MAX_N=23,MAX_K=23; ll gk[2][MAX_K*MAX_K],gv[2][MAX_K*MAX_K]; struct T &#123; ll a[MAX_K][MAX_K]; T()&#123;memset(a,0,sizeof a);&#125; friend T operator +(T a,T b) &#123; for(int i=0;i&lt;MAX_K;i++) for(int j=0;j&lt;MAX_K;j++) add(a.a[i][j],b.a[i][j]); return a; &#125; friend T operator *(T a,T b) &#123; for(int i=0;i&lt;MAX_K;i++) for(int j=0;j&lt;MAX_K;j++) a.a[i][j]=a.a[i][j]*b.a[i][j]%MOD; return a; &#125; void DFT(int n,int m) &#123; ll ta[MAX_K][MAX_K];memset(ta,0,sizeof ta); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) for(int x=0;x&lt;n;x++) for(int y=0;y&lt;m;y++) add(ta[i][j],a[x][y]*gk[0][i*x]%MOD*gk[1][j*y]%MOD); memcpy(a,ta,sizeof a); &#125; void IDFT(int n,int m) &#123; ll ta[MAX_K][MAX_K];memset(ta,0,sizeof ta); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) for(int x=0;x&lt;n;x++) for(int y=0;y&lt;m;y++) add(ta[i][j],a[x][y]*gv[0][i*x]%MOD*gv[1][j*y]%MOD); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) a[i][j]=ta[i][j]*qpower(n*m,MOD-2)%MOD; &#125; &#125;; struct Matrix &#123; T m[MAX_N][MAX_N]; Matrix()&#123;memset(m,0,sizeof m);&#125; friend Matrix operator *(Matrix a,Matrix b) &#123; Matrix c; for(int i=1;i&lt;MAX_N;i++) for(int j=1;j&lt;MAX_N;j++) for(int k=1;k&lt;MAX_N;k++) c.m[i][j]=c.m[i][j]+a.m[i][k]*b.m[k][j]; return c; &#125; &#125;; Matrix mpower(Matrix x,int e) &#123; Matrix ans;for(int i=1;i&lt;MAX_N;i++) ans.m[i][i].a[0][0]=1,ans.m[i][i].DFT(MAX_K,MAX_K); while(e) &#123; if(e&amp;1) ans=ans*x; x=x*x;e&gt;&gt;=1; &#125; return ans; &#125; Matrix A; void main() &#123; int n,m,e;scanf("%d%d%d",&amp;n,&amp;m,&amp;e); gk[0][0]=1;gk[0][1]=qpower(G,(MOD-1)/n);for(int i=2;i&lt;MAX_K*MAX_K;i++) gk[0][i]=gk[0][i-1]*gk[0][1]%MOD; gv[0][0]=1;gv[0][1]=qpower(gk[0][1],MOD-2);for(int i=2;i&lt;MAX_K*MAX_K;i++) gv[0][i]=gv[0][i-1]*gv[0][1]%MOD; gk[1][0]=1;gk[1][1]=qpower(G,(MOD-1)/(n-1));for(int i=2;i&lt;MAX_K*MAX_K;i++) gk[1][i]=gk[1][i-1]*gk[1][1]%MOD; gv[1][0]=1;gv[1][1]=qpower(gk[1][1],MOD-2);for(int i=2;i&lt;MAX_K*MAX_K;i++) gv[1][i]=gv[1][i-1]*gv[1][1]%MOD; while(m--) &#123; int x,y,c,d;scanf("%d%d%d%d",&amp;x,&amp;y,&amp;c,&amp;d); A.m[x][y].a[c%n][d%(n-1)]++; &#125; for(int x=1;x&lt;=n;x++) for(int y=1;y&lt;=n;y++) A.m[x][y].DFT(n,n-1); A=mpower(A,e); for(int x=1;x&lt;=n;x++) for(int y=1;y&lt;=n;y++) A.m[x][y].IDFT(n,n-1); for(int now=1;now&lt;=n;now++) for(int x=0;x&lt;n;x++) &#123; for(int y=0;y&lt;n-1;y++) printf("%lld ",A.m[now][now].a[x][y]); puts(""); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
        <tag>dft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ahoi2005】航线规划【bzoj4229】选择]]></title>
    <url>%2Fposts%2Fa4df.html</url>
    <content type="text"><![CDATA[Source and JudgeAhoi2005bzoj4229bzoj1969 Record1h Analysis请先思考后再展开 仔细想想，发现就是求两点路径上割边数量这个删除很难处理，考虑时间倒流，动态加边一般图比较麻烦，考虑求一个生成树，因为其他边不可能是割边然后用其他边和加的边，更新路径即可，可以用树剖实现]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>思维</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj5040】未来研究]]></title>
    <url>%2Fposts%2Ff5d.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj5040 Record1h Analysis请先思考后再展开 本题题面仿照bzoj4241历史研究（带权众数），建议先去看看那道题，虽然不难注意到范围卡根号，注意到有个性质是区间只会分开或包含那么离线一下，询问呈树状，而且叶子节点的总长度在n以内 如果只是想求子树的信息，那么显然可以线段树合并，但因为是带权的，无法避免再扫一次所以我们希望一个个加入，这样答案就很好维护，所以考虑树上启发式，做法oi之路有 建树的话，可以单调栈 O(n) 建]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树上启发式</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小G的线段树]]></title>
    <url>%2Fposts%2F807.html</url>
    <content type="text"><![CDATA[Problem小G是一名OIer，他最近学习了一种高级数据结构——线段树，做题时，他遇到了如下的问题：维护一个序列，要求支持三种操作：1.区间加上一个数x2.区间赋值为一个数x3.求一个区间的和小G是一个爱思考的同学。他在做出来了这题之后，又提出了一个新的问题：如果把所有的操作随机打乱，那么每个询问的期望输出是多少呢？注意，随机打乱既所有m!种操作排列的出现概率均等。为了方便，我们假设询问在最后且不参与随机打乱。【输入格式】第一行两个整数n m q，分别表示序列长度、修改数和询问数接下来一行n个整数ai，表示序列的初始值接下来m行，每行4个整数c,l,r,x若c=1，则表示把区间[l,r]的元素加上x若c=2，则表示把区间[l,r]的元素全赋为x接下来q行，每行2个整数l,r，代表每次询问的左右端点。【输出格式】q行，每行一个实数，按照输入顺序分别为q个询问的期望答案答案保留3位小数【样例】5 4 82 3 3 3 31 1 3 21 3 5 12 2 4 12 1 3 41 12 23 34 45 51 32 51 5 5.0003.1673.5001.5004.00011.66712.16717.167 Analysis请先思考后再展开 考虑每个格子的期望值，并且把修改和添加分开设修改次数为a，修改权值和为val，添加权值和为add则格子的期望为 $\frac{val}{a}+\frac{add}{a+1}$12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX_N=1e5+10;typedef long long ll;double num[MAX_N];ll a[MAX_N],val[MAX_N],add[MAX_N];int main()&#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;num[i]); while(m--) &#123; int op,l,r,t;scanf("%d%d%d%d",&amp;op,&amp;l,&amp;r,&amp;t); if(op==1) add[l]+=t,add[r+1]-=t; else a[l]++,a[r+1]--,val[l]+=t,val[r+1]-=t; &#125; for(int i=1;i&lt;=n;i++) &#123; add[i]+=add[i-1],val[i]+=val[i-1],a[i]+=a[i-1]; if(a[i]==0) num[i]+=add[i]; else num[i]=(double)val[i]/a[i]+(double)add[i]/(a[i]+1); num[i]+=num[i-1]; &#125; while(q--) &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); printf("%.3lf\n",num[r]-num[l-1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2007】捉迷藏 【SPOJ】QTREE4]]></title>
    <url>%2Fposts%2Fc89a.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2007bzoj3136QTREE4 Record3h Analysis请先思考后再展开 首先因为修改，显然需要一个可删堆来维护信息 记录子树内前两条链，复杂度为平方，显然考虑点分治点分树上，点对的LCA一定也在原树两点路径上基于这点，对于分治节点x，每个孩子贡献一条链，然后拼接最长的两条放到答案里面f(x)存节点x的子树内孩子到x父亲的距离，g(x)存节点x的每个直接孩子的f(x)的堆顶用A存全局答案，也就是g(x)的前两个之和 复杂度显然log方但这道题非常容易写错细节……要留足够时间对拍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=110000; int bin[30],lg[MAX_N*2]; int hou[MAX_N],dfn[MAX_N],dep[MAX_N],dis[MAX_N]; struct Edge&#123;int y,c,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,c,hou[x]&#125;;hou[x]=ln;&#125; int mm[MAX_N*2][30],id=0; int tmin(int x,int y) &#123;return dep[x]&lt;dep[y]?x:y;&#125; void dfs(int x,int fa) &#123; dfn[x]=++id;mm[id][0]=x; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dep[y]=dep[x]+1;dis[y]=dis[x]+e[k].c; dfs(y,x);mm[++id][0]=x; &#125; &#125; void pre() &#123; for(int t=1;t&lt;=20;t++) for(int i=1;i&lt;=id-bin[t]+1;i++) mm[i][t]=tmin(mm[i][t-1],mm[i+bin[t-1]][t-1]); &#125; int lca(int x,int y) &#123; x=dfn[x];y=dfn[y]; if(x&gt;y) swap(x,y); int t=lg[y-x+1]; return tmin(mm[x][t],mm[y-bin[t]+1][t]); &#125; int Dis(int x,int y) &#123; return dis[x]+dis[y]-2*dis[lca(x,y)]; &#125; struct Heap &#123; priority_queue&lt;int&gt; a,b; int top() &#123; while(b.size() and a.top()==b.top()) a.pop(),b.pop(); return a.top(); &#125; void push(int x) &#123;a.push(x);&#125; void pop() &#123; while(b.size() and a.top()==b.top()) a.pop(),b.pop(); a.pop(); &#125; void erase(int x) &#123;b.push(x);&#125; int size() &#123;return a.size()-b.size();&#125; int top2() &#123; int x=top();pop(); int y=top();push(x); return x+y; &#125; &#125;A,f[MAX_N],g[MAX_N]; int siz[MAX_N],G,all,mx[MAX_N];bool v[MAX_N]; void getrt(int x,int fa) &#123; mx[x]=0;siz[x]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or v[y]) continue; getrt(y,x);mx[x]=max(mx[x],siz[y]); siz[x]+=siz[y]; &#125; mx[x]=max(mx[x],all-siz[x]); if(mx[x]&lt;mx[G]) G=x; &#125; vector&lt;int&gt; pt; void getpt(int x,int fa) &#123; pt.push_back(x);siz[x]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or v[y]) continue; getpt(y,x);siz[x]+=siz[y]; &#125; &#125; int Fa[MAX_N]; void solve(int x,int fa) &#123; v[x]=1;Fa[x]=fa; pt.clear();getpt(x,fa); if(fa&gt;0) for(int t=0;t&lt;(int)pt.size();t++) f[x].push(Dis(pt[t],fa)); g[x].push(0); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or v[y]) continue; all=siz[y];G=0;getrt(y,x);y=G;//debug 要备份 solve(G,x);g[x].push(f[y].top()); &#125; if(g[x].size()&gt;=2) A.push(g[x].top2()); &#125; int col[MAX_N]; void change(int now,int x) &#123; int fa=Fa[now];if(fa==0) return; if(g[fa].size()&gt;=2) A.erase(g[fa].top2()); if(f[now].size()) g[fa].erase(f[now].top()); if(col[x]) f[now].push(Dis(x,fa)); else f[now].erase(Dis(x,fa)); if(f[now].size()) g[fa].push(f[now].top()); if(g[fa].size()&gt;=2) A.push(g[fa].top2()); change(fa,x); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAX_N*2;i++) lg[i]=lg[i&gt;&gt;1]+1; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c; // scanf("%d%d",&amp;x,&amp;y);c=1; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; dfs(1,0);pre(); mx[0]=n+1;G=0;all=n;getrt(1,0);solve(G,0); int q;scanf("%d",&amp;q);int tot=n; while(q--) &#123; char op[5];scanf("%s",op); if(op[0]=='C') &#123; int x;scanf("%d",&amp;x); if(g[x].size()&gt;=2) A.erase(g[x].top2()); if(col[x]==0) tot--,g[x].erase(0); else tot++,g[x].push(0); if(g[x].size()&gt;=2) A.push(g[x].top2()); change(x,x);col[x]^=1; &#125; else &#123; if(tot&gt;1) printf("%d\n",max(A.top(),0)); else if(tot==1) puts("0"); // else puts("-1"); else puts("They have disappeared."); &#125; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3136】brunhilda]]></title>
    <url>%2Fposts%2Fb76f.html</url>
    <content type="text"><![CDATA[Source and JudgeBaltic2013bzoj3136 Record2h Analysis请先思考后再展开 首先有个结论，就是每个数搞完的次数是不递减的因为首先每个操作相当于按p分组，然后每组变为第一个，那么一个数只要小，以后都是小的，相对关系不会变$f(i)=f(j)+1$显然j是某个p的倍数 那么每个j，要向后最多，则找j的约数中在P里出现，最大的那个，以影响最大的范围这个可以线性筛出minp来实现递推 方法一，枚举每个j，用单调队列维护影响范围方法二，枚举每个i，观察j+vj&lt;=i的i是递增的，则决策点递增，可以维护指针扫过去]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1110E】Magic Stones]]></title>
    <url>%2Fposts%2F8e88.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1110E Record2h Analysis请先思考后再展开 看到这道题，就感觉应该是需要某些巧妙的转化，挺吃题量的，就放了赛后看题解，果然如此……不过转化方式比想象中简洁就是差分一下，然后不难发现就是交换相邻两个1234567891011121314151617181920212223242526272829303132333435363738394041424344//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=1e5+10; int c[2][MAX_N],d[2][MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[0][i]),d[0][i]=c[0][i]-c[0][i-1]; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[1][i]),d[1][i]=c[1][i]-c[1][i-1]; bool bk=(c[0][1]!=c[1][1] or c[0][n]!=c[1][n]); sort(d[0]+2,d[0]+n+1);sort(d[1]+2,d[1]+n+1); for(int i=2;i&lt;=n;i++) if(d[0][i]!=d[1][i]) bk=1; if(bk) puts("No"); else puts("Yes"); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Noi2013】快餐店]]></title>
    <url>%2Fposts%2Fe514.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2013bzoj3242 Record2h Analysis请先思考后再展开 第一次写基环树（以前总觉得好麻烦啊不想写什么的……）这次写是没事干练练码力 如果是一棵树，那么一定是找直径的中点但在基环树上，直径的许多性质被破坏了，不能直接求图的直径考虑把基环树转化为树，首先断掉一条边不会使答案更优，而且一定有一条边去掉不会有影响（考虑对最优点到各个点的路径一定是树） 把环拉成序列，然后答案的下界是max 各个树内直径/2，而且断边不会影响这个，先处理好，最后更新ans然后设我们枚举的断边，右边的节点编号为k=1~cnt-1（从0开始）然后分情况讨论直径经过环上边的情况，是在断边左边a、右边c或者从右边开始去往左边b$$\begin{aligned}val是挂在这上面的树的最大深度，d是前缀环上距离\\A1(i)=&amp;前缀max的val-d\\B1(i)=&amp;后缀max的val-d\\B2(i)=&amp;后缀max的val+d\\0&lt;i&lt;k,a=&amp;A1(i-1)+d_i+val_i\\0 \leq i&lt;k,b=&amp;B1(k)+d_i+d_{cnt-1}+d_{cnt-1到0}+val_i\\k \leq i&lt;cnt,c=&amp;B2(i+1)-d_i+val_i\\ans=&amp;min(ans,max(a,b,c))\end{aligned}$$ 那么显然可以 O(n) 做了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll INF=1ll&lt;&lt;60; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=1e5+10; int hou[MAX_N];bool v[MAX_N]; struct Edge&#123;int y,c,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,c,hou[x]&#125;;hou[x]=ln;&#125; stack&lt;int&gt; sta;bool in[MAX_N]; vector&lt;int&gt; id; bool dfs(int x,int fa) &#123; if(in[x]) &#123; while(1) &#123; int now=sta.top();sta.pop(); id.push_back(now);v[now]=1; if(now==x) break; &#125; return 1; &#125; in[x]=1,sta.push(x); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; if(dfs(y,x)) return 1; &#125; in[x]=0;sta.pop(); return 0; &#125; ll f[MAX_N],zjmx=0; void getzj(int x,int fa) &#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or v[y]) continue; getzj(y,x);zjmx=max(zjmx,f[x]+f[y]+e[k].c); f[x]=max(f[x],f[y]+e[k].c); &#125; &#125; ll d[MAX_N],val[MAX_N]; ll A1[MAX_N],B1[MAX_N],B2[MAX_N]; struct Nod&#123;ll d;int p;&#125;tmp[MAX_N];bool cmp(Nod a,Nod b)&#123;return a.d&gt;b.d;&#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(a,b,c);ins(b,a,c); &#125; dfs(1,0);int cnt=id.size(); for(int i=0;i&lt;cnt;i++) &#123; if(i!=0) for(int k=hou[id[i]];k&gt;0;k=e[k].g) if(e[k].y==id[i-1]) d[i]=e[k].c; d[i]+=d[i==0?0:i-1];getzj(id[i],0);val[i]=f[id[i]]; &#125; for(int k=hou[id[0]];k&gt;0;k=e[k].g) if(e[k].y==id[cnt-1]) d[cnt]=e[k].c; A1[0]=val[0]-d[0];for(int i=1;i&lt;cnt;i++) A1[i]=max(A1[i-1],val[i]-d[i]); B1[cnt]=B2[cnt]=-INF; for(int i=cnt-1;i&gt;=0;i--) B1[i]=max(B1[i+1],val[i]-d[i]),B2[i]=max(B2[i+1],val[i]+d[i]); for(int i=0;i&lt;=cnt-2;i++) tmp[i]=(Nod)&#123;B2[i+1]-d[i]+val[i],i&#125;; sort(tmp,tmp+cnt-1,cmp); ll ans=INF,A=-INF,B=d[0]+val[0]; for(int k=1,now=0;k&lt;cnt;k++) &#123; ll a=A,b=B1[k]+d[cnt-1]+d[cnt]+B; while(now!=cnt-1 and tmp[now].p&lt;k) now++; ll c=(now==cnt-1?-INF:tmp[now].d); ans=min(ans,max(a,max(b,c))); A=max(A,A1[k-1]+d[k]+val[k]); B=max(B,d[k]+val[k]); &#125; ans=min(ans,A);//断0-&gt;cnt-1 printf("%.1lf",max(zjmx,ans)/2.0); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU6212】Zuma]]></title>
    <url>%2Fposts%2F4279.html</url>
    <content type="text"><![CDATA[Source and JudgeHDU6212 Record1h Analysis请先思考后再展开 好神仙啊，虽然正解看上去很简单 考试的时候一直往lrj之前一道经典区间dp方面想然而这是一道分类讨论转移的dp题（当然依然要合并同颜色的块） 直接分两半 通过消除中间的，合并两边，两边代价是补上去的 消除两块，使3个合并起来，那么中间一定只能是1个 还有一种情况，但似乎不会是最优解？就是四个球，然后先分别消除两边，然后把2和2合并。但不知道怎么排除这种情况另外，本题应该有非常多种写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=210; char s[MAX_N]; int a[MAX_N],sz[MAX_N]; int f[MAX_N][MAX_N]; void chmin(int &amp;x,int y)&#123;x=x&gt;y?y:x;&#125; void main() &#123; int T;scanf("%d",&amp;T);s[0]='h'; for(int t=1;t&lt;=T;t++) &#123; scanf("%s",s+1);int m=strlen(s+1),n=0; for(int i=1;i&lt;=m;i++) if(s[i-1]!=s[i]) a[++n]=s[i]-'0',sz[n]=1; else sz[n]++; memset(f,63,sizeof f); for(int i=1;i&lt;=n;i++) f[i][i]=3-sz[i]; for(int ln=2;ln&lt;=n;ln++) for(int l=1,r=l+ln-1;r&lt;=n;l++,r++) &#123; for(int k=l;k&lt;r;k++) chmin(f[l][r],f[l][k]+f[k+1][r]); int tot=sz[l]+sz[r]; if(a[l]==a[r]) chmin(f[l][r],f[l+1][r-1]+(tot&gt;=3?0:3-tot)); if(a[l]==a[r] and tot&lt;=3) for(int k=l+1;k&lt;=r-1;k++) if(sz[k]==1 and a[l]==a[k]) chmin(f[l][r],f[l+1][k-1]+f[k+1][r-1]); &#125; printf("Case #%d: %d\n",t,f[1][n]); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1110D】Jongmah]]></title>
    <url>%2Fposts%2F5fd7.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1110D Record1h Analysis请先思考后再展开 一开始有些东西没想清楚就写，太菜了我写的是dp，然后比较无脑地记录了3个位置，然后当时觉得可以贪心到6以内3以上然后一直wa，只能过样例，但自己又举不出反例……当时曾经有缩小贪心范围的想法，但又觉得肯定没用就没有尝试……赛后看看别人的代码感觉差不多，就是上界不一样 那么认真想想，就是x，x+1，x+2最多2次，那么每个位置我们至少需要保留6所以只要不减少到6及以内，就贪心具体dp的话状态可以设两维的，但cf比较快就无脑3维了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair int f[2][10][10][10]; int now[1100000]; void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int a;scanf("%d",&amp;a); now[a]++; if(now[a]&gt;=9) now[a]-=3,ans++; &#125; if(m&gt;=3) &#123; int tmp=0; memset(f,-63,sizeof f); f[0][0][now[1]][now[2]]=0; for(int i=3;i&lt;=m;i++) &#123; memset(f[i&amp;1],-63,sizeof f[i&amp;1]); for(int a=8;a&gt;=0;a--) for(int b=8;b&gt;=0;b--) for(int c=8;c&gt;=0;c--) &#123; if(c==now[i]) &#123; for(int t=0;t&lt;=8;t++) chmax(f[i&amp;1][a][b][c],f[(i-1)&amp;1][t][a][b]); &#125; if(f[i&amp;1][a][b][c]&lt;0) continue; if(a&gt;=1 and b&gt;=1 and c&gt;=1) chmax(f[i&amp;1][a-1][b-1][c-1],f[i&amp;1][a][b][c]+1); if(a&gt;=3) chmax(f[i&amp;1][a-3][b][c],f[i&amp;1][a][b][c]+1); if(b&gt;=3) chmax(f[i&amp;1][a][b-3][c],f[i&amp;1][a][b][c]+1); if(c&gt;=3) chmax(f[i&amp;1][a][b][c-3],f[i&amp;1][a][b][c]+1); // printf("f[%d][%d][%d][%d]=%d\n",i,a,b,c,f[i&amp;1][a][b][c]); chmax(tmp,f[i&amp;1][a][b][c]); &#125; &#125; ans+=tmp; &#125; else &#123; while(now[1]&gt;=3) now[1]-=3,ans++; while(now[2]&gt;=3) now[2]-=3,ans++; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Noi2011】Noi嘉年华]]></title>
    <url>%2Fposts%2F1d84.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2011bzoj2436 Record2h Analysis请先思考后再展开 题意：n个值域为2n的区间分为A、B、C，要求A交B为空求固定第i个区间或不固定时的最大【A和B中小的集合大小】 那么我们希望求出F[l][r]表示这段值域区间A必选的答案那么我们考虑枚举前后A选择了多少然后我们需要f[i][t]表示前缀值前i个A选了t个区间，B最多选多少个后缀意义下自然也求一个g[i][t]，求的话就是枚举两人选的最后一段区间$f(i,t)=max{f(j,t)+num[j+1][i],f(j,t-num[j+1][i])}$这样就能求出第一问了，第二问目前是 $O(n^4)$$cal(l,r,a,b)=min{ f(l-1,a)+f(r+1,b),a+b+num[l][r] }$$F[l][r]=max{ cal(fl \leq l,r \leq fr,a,b) }$然后对于每个a，b应该是个二次函数，而且a增b减，用个指针即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; const int MAX_N=410; struct Data&#123;int d,p;&#125;d[MAX_N]; bool cmp(Data a,Data b) &#123;return a.d&lt;b.d;&#125; int val[MAX_N]; int num[MAX_N][MAX_N],f[MAX_N][MAX_N],g[MAX_N][MAX_N]; int F[MAX_N][MAX_N]; int cal(int l,int r,int a,int b) &#123;return min(f[l-1][a]+g[r+1][b],a+b+num[l][r]);&#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int st,ed;scanf("%d%d",&amp;st,&amp;ed);ed+=st-1; d[2*i-1]=(Data)&#123;st,2*i-1&#125;;d[2*i]=(Data)&#123;ed,2*i&#125;; &#125; sort(d+1,d+2*n+1,cmp); int rx=1;val[d[1].p]=rx; for(int i=2;i&lt;=n*2;i++) &#123; if(d[i-1].d!=d[i].d) rx++; val[d[i].p]=rx; &#125; for(int l=1;l&lt;=rx;l++) for(int r=l;r&lt;=rx;r++) for(int i=1;i&lt;=n;i++) num[l][r]+=(l&lt;=val[2*i-1] and val[2*i]&lt;=r); for(int i=1;i&lt;=rx;i++) for(int t=0;t&lt;=n;t++) for(int j=0;j&lt;i;j++) &#123; if(num[1][j]&gt;=t) chmax(f[i][t],f[j][t]+num[j+1][i]); if(t&gt;=num[j+1][i]) chmax(f[i][t],f[j][t-num[j+1][i]]); &#125; for(int i=rx;i&gt;=1;i--) for(int t=0;t&lt;=n;t++) for(int j=rx+1;j&gt;i;j--) &#123; if(num[j][rx]&gt;=t) chmax(g[i][t],g[j][t]+num[i][j-1]); if(t&gt;=num[i][j-1]) chmax(g[i][t],g[j][t-num[i][j-1]]); &#125; int ans=0;for(int i=0;i&lt;=n;i++) chmax(ans,min(f[rx][i],i)); printf("%d\n",ans); for(int ln=rx;ln&gt;=1;ln--) for(int l=1;l&lt;=rx-ln+1;l++) &#123; int r=l+ln-1,b=num[r+1][rx]; F[l][r]=max(F[l-1][r],F[l][r+1]); for(int a=0;a&lt;=num[1][l-1];a++) &#123; while(b-1&gt;=0 and cal(l,r,a,b-1)&gt;=cal(l,r,a,b)) b--; chmax(F[l][r],cal(l,r,a,b)); &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%d\n",F[ val[2*i-1] ][ val[2*i] ]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Coci2009】podjela]]></title>
    <url>%2Fposts%2F8a58.html</url>
    <content type="text"><![CDATA[Source and JudgeCoci2009bzoj3090 Record1h Analysis请先思考后再展开 因为不用求方案，不用考虑次序什么的，允许负数显然次数不会比点数多，因为每条边单向值很大而次数少，所以应该对次数背包而不是对值$$\begin{aligned}&amp; 设f(x,now)=maxup\\&amp; 1. f(y,b)&lt;ned\\&amp; f_1(x,a+b+1)=f_0(x,a)-(ned-f(y,b))\\&amp; 2. f(y,b) \geq ned\\&amp; f_1(x,a+b)=f_0(x,a)\\&amp; f_1(x,a+b+1)=f_0(x,a)+f(y,b)-ned\end{aligned}$$复杂度显然 $O(n^2)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=2100; int hou[MAX_N],siz[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int f[2][MAX_N][MAX_N],ned[MAX_N]; void chmax(int &amp;x,int y) &#123;x=max(x,y);&#125; void dp(int x,int fa) &#123; int now=0;siz[x]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dp(y,x); for(int a=0;a&lt;=siz[x];a++) for(int b=0;b&lt;=siz[y];b++) &#123; int up=f[0][y][b];if(up==f[0][0][0]) continue; chmax(f[now^1][x][a+b+1],f[now][x][a]+up-ned[y]); if(up&gt;=ned[y]) chmax(f[now^1][x][a+b],f[now][x][a]); &#125; siz[x]+=siz[y]; memset(f[now][x],-63,sizeof f[now][x]);now^=1; &#125; memcpy(f[0][x],f[now][x],sizeof f[0][x]); &#125; void main() &#123; memset(f,-63,sizeof f); int n,st;scanf("%d%d",&amp;n,&amp;st); for(int i=1;i&lt;=n;i++) f[0][i][0]=st,scanf("%d",&amp;ned[i]); for(int i=1;i&lt;n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dp(1,0); int ans=-1;for(int i=n;i&gt;=0;i--) if(f[0][1][i]&gt;=ned[1]) ans=i; printf("%d",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【cqoi2013】二进制a+b]]></title>
    <url>%2Fposts%2Fd59f.html</url>
    <content type="text"><![CDATA[Source and Judgecqoi2013bzoj3107 Record30min Analysis请先思考后再展开 dp做法比较显然然后这题可以O(1)，当构造来做]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2011】细胞]]></title>
    <url>%2Fposts%2F6e7f.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2011bzoj2323 Record2h Analysis请先思考后再展开 这题的两部分显然是分开的然后我就一直在想构造一个方案被重复计数的情况，然后发现构造不出来，但总觉得一定是存在的……样例太水所以没体现，恩一定是这样的想半天膜题解看到第一句话就自闭了，怎么你们都有这么好的直觉woc 总之我们只需要考虑分割方案带来的长度就好了，不需要考虑质量知道长度就好办了，不难发现是个fib$\sum fib[(\sum b_i)-1]=\frac{fib[1]}{A^2} \sum( \prod A^{b_i} )$$F_i=\sum F_j \times A^{num(j+1,i)}$然后注意一下矩阵的交换律即可$ans=F_n \times \frac{fib[1]}{A^2}$右边那个考虑一下A的实际意义，手推一下即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MOD=1e9+7; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;&#125; struct Matrix &#123; ll a[2][2]; Matrix()&#123;memset(a,0,sizeof a);&#125; friend Matrix operator +(Matrix x,Matrix y) &#123; for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) add(x.a[i][j],y.a[i][j]); return x; &#125; friend Matrix operator *(Matrix x,Matrix y) &#123; Matrix t; for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) for(int k=0;k&lt;=1;k++) add(t.a[i][j],x.a[i][k]*y.a[k][j]%MOD); return t; &#125; &#125;; const int MAX_N=1100; char s[MAX_N]; Matrix pre[MAX_N][MAX_N],f[MAX_N],A; Matrix pre2[MAX_N][20]; void main() &#123; A.a[0][1]=A.a[1][0]=A.a[1][1]=1; pre2[0][1]=A;for(int j=2;j&lt;=10;j++) pre2[0][j]=pre2[0][j-1]*pre2[0][1]; for(int i=1;i&lt;MAX_N;i++) &#123; pre2[i][1]=pre2[i-1][10]; for(int j=2;j&lt;=10;j++) pre2[i][j]=pre2[i][j-1]*pre2[i][1]; &#125; int n;scanf("%d%s",&amp;n,s+1); for(int r=1;r&lt;=n;r++) &#123; pre[r][r]=pre2[0][s[r]-'0']; for(int l=r-1;l&gt;=1;l--) pre[l][r]=pre[l+1][r]*pre2[r-l][s[l]-'0']; &#125; f[0].a[0][0]=f[0].a[1][1]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) f[i]=f[i]+pre[j+1][i]*f[j]; Matrix tmp;tmp.a[0][0]=-1;tmp.a[1][0]=1; printf("%lld",((f[n]*tmp).a[1][0]+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Baltic2004】sequence]]></title>
    <url>%2Fposts%2Fa3ae.html</url>
    <content type="text"><![CDATA[Source and JudgeBaltic2004bzoj1367 Record3h Analysis请先思考后再展开 首先让ai递增等价于让bi=ai-i不递减前置知识： 对于一个序列，如果变成相同的数，那么变成中位数的绝对值代价最小 两段序列合并的中位数，显然在两边中位数的值域区间内然后我们现在要寻找最小代价，肯定要在多个最优解中尽量找一个最容易算的形式，同理，我们说的中位数是指第 $\lceil \frac{n}{2} \rceil$ 小的数然后我们的思路主要是，对于一个不递增的序列，变成不递减的最小代价方案中一定有变成中位数 那么做法非常容易，每次加入一个数，作为一个区间和上一个区间比较，如果比上个区间的中位数小或相等，则合并两段区间，并用新的中位数作为这段区间的目标值，并不断往前这样做然后实现的话，用可并堆（如左偏树）是nlogn，否则是log方，堆顶就是中位数那样维护，两边都是奇数长度时缩1即可 但是这个做法的正确性呢？hyh的论文有一段没看懂，DraZxlNDdt的博客也有一段没看懂，捣鼓了几天（其实主要是过年巨颓废）才想出来（神仙写的东西依旧没看懂；哦说不定还是伪证？） 第一点，两段区间的中位数不递增的话（不仅是内部递减的情况），合并为新序列的中位数设前一段的中位数为u，后一段的中位数为v设中间的编号为t，设某个最优方案为b，显然只考虑 $b_t,v \leq b_{t+1},u$ 否则没必要说下去了（例如左边如果比u大，改为全部u不会更差，递增性也保证了）所以可以改为 $b_t,b_t,…,b_{t+1},b_{t+1}$此时已经非常棒了，然而还是不好求，考虑进一步转化，这里就比较容易了因为两边分别的代价是越接近中位数越小，显然两边不同是亏的，数学证明的话也很好推，分类讨论一下即可所以两边相同，然后显然取为中位数 第二点，新序列的中位数在保存的数中这个你会经历多个过程，首先你想着维护中位数可以log方，然后你可能会想把中位数放在堆顶，感觉很对，然后又想想万一中位数不在两个堆中呢？再仔细想想又可以证明不会出现这种情况（我觉得这个很难啊……）这需要我们仔细思考现在做法的细节我们现在担心的是，新的中位数出现在右边，而且比右边中位数大合并的时候一定是 $L_{mid} \leq R_{mid},L_{mid} \leq R_{mid_old}$然后因为只有一个数，显然 $mid_old+1=mid$然后因为新的中位数在它们之间，所以如果比右边中位数大的话，不会出现在右边，只会在左边画画图就能理解了，关键是这个细节是否能在证明的时候想到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125; const int MAX_N=1e6+10; int a[MAX_N]; struct Nod&#123;int ls,rs,dis,key;Nod()&#123;ls=rs=0;dis=-1;key=-INF;&#125;&#125;p[MAX_N]; int merg(int a,int b) &#123; if(a==0 or b==0) return a+b; if(p[a].key&lt;p[b].key) swap(a,b); p[a].rs=merg(p[a].rs,b); if(p[p[a].ls].dis&lt;p[p[a].rs].dis) swap(p[a].ls,p[a].rs); p[a].dis=p[p[a].rs].dis+1; return a; &#125; int cnt=0,rt[MAX_N],right[MAX_N],siz[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),a[i]-=i; for(int i=1;i&lt;=n;i++) &#123; siz[++cnt]=1;rt[cnt]=right[cnt]=i;p[i].key=a[i];p[i].dis=0; while(p[rt[cnt-1]].key&gt;=p[rt[cnt]].key) &#123; cnt--;right[cnt]=right[cnt+1]; rt[cnt]=merg(rt[cnt],rt[cnt+1]);siz[cnt]+=siz[cnt+1]; while(siz[cnt]*2&gt;right[cnt]-right[cnt-1]+1)//delete rt[cnt]=merg(p[rt[cnt]].ls,p[rt[cnt]].rs),siz[cnt]--; &#125; &#125; ll ans=0; for(int i=1;i&lt;=cnt;i++) for(int j=right[i-1]+1;j&lt;=right[i];j++) ans+=myabs(a[j]-p[rt[i]].key); printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
        <tag>难度3</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2006】数字序列]]></title>
    <url>%2Fposts%2Fe4c.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2006luogu2501 Record2h Analysis请先思考后再展开 目前本题一大堆人都是抄个n3方的代码完事（似乎难以证明复杂度），在此给出满n方的做法 使a递增等价于让bi=ai-i不递减第一问就是让不改变的最少，直接总长-最长不递减子序列然后第二问要求在第一问的前提下计算代价 结论：一定存在一种最优的区间调整方案，使得存在一个k，k左边和bj一样，右边和bi一样证明：首先对于能转移的j到i，之间的数要么比i大，要么比j小想象一下最后连续的值为一个横线，那么每个x坐标相当于有个橡皮筋在拉着横线往bi方向走那么如果最后的情况不是只有两段，那么总有木板往想去的方向，然后路上某个瞬间和【能任意上下的木板】合并这样最后总是只有两段的 那么先设中间所有人变成bi的代价为old，然后考虑一个分界点k，额外的代价= $(big_{left}-small_{left})*(b_i-b_j)$那么对于每个i，先预处理出$(big_{left}-small_{left})$的前缀和，然后倒序枚举j统计old即可 如果你仅仅是想ac本题，随便加点优化应该就行了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SHOI2008】汉诺塔]]></title>
    <url>%2Fposts%2F8125.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu4285 Record1h Analysis请先思考后再展开 这题是真的骚，以后复习一下吧反正我是被这个【看起来很noip的题目】搞自闭了方法一，dp方法二，递推]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>复习</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2009】变换序列]]></title>
    <url>%2Fposts%2Feed2.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu1963 Record1h Analysis请先思考后再展开 不难转化为求二分图完备匹配中的字典序最小对应方案匈牙利算法能很好地解决这个问题，从下往上枚举左边（越后优先级越高，类似基数排序），右边则从上往下复杂度为n方，不会太满（当时网络流不普及，这个正解合情合理）这时候就会有人想，为什么不dinic+一些建边顺序的调整呢，n根号呢然而dinic是bfs一次后多路同时dfs，缺乏匈牙利算法那种不断推开别人的过程一个显然的反例就是第一次就完备匹配 upd：rose爷爷给出了一个 O(n) 的做法因为每个点只连出去两条边，把点化为两个选择之间的边，那么如果不是基环树（或基环森林）就无解然后每个环的方向一定是相同的，环上挂的边一定是向外的，每个环独立地贪心即可因为可以计数排序，所以线性]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串游戏]]></title>
    <url>%2Fposts%2Ff9d8.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2121 Record2h Analysis请先思考后再展开 因为删除的都是序列，比较难思考，不妨想成删除一段区间中没被删除的部分，那么区间是个dag设 f(l,r,a,b)表示原串l到r，最后匹配第a个字符串（即l和r都是a的）的第b个字符然后为了方便转移，设v(l,r)表示能否删除转移显然，时间复杂度为 $O(L^3ab)$ 理论上是跑不满的，所以注意一些显然的优化即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JSOI2009】火星藏宝图]]></title>
    <url>%2Fposts%2Fae6f.html</url>
    <content type="text"><![CDATA[Source and JudgeJSOI2009luogu4056 Record2h Analysis请先思考后再展开 首先权值都都是正数，那么显然如果在一列路径上多一个点一定更优，所以每一列只会从最底下的那个转移然后这样就能nm做了，卡卡常可以过但这个式子显然是可以斜率优化的$f(i)=f(j)-(x-pos_j)^2-(i-j)^2+w_i$$f(j)-pos_j^2-2xpos-j^2=i(-2j)+(f(i)-w_i+i^2+x^2)$最小化截距，然后i还是单调的，那么每行维护一个斜率单降凸壳即可，复杂度m方]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UNR1】合唱队形]]></title>
    <url>%2Fposts%2Fd84e.html</url>
    <content type="text"><![CDATA[Source and JudgeUNR1uoj214 Record2h Analysis请先思考后再展开 不妨先考虑，n=m的时候如何简便地求出期望设总课程为A，需要的课程为B， $E=\sum_{i=0}^{B-1} \frac{A}{B-i}$那么预处理一下g1(B) 然后现在碰到第一个合法的序列就停止，但很难求，不难联想到min-max容斥然后max也非常好求，用二进制表示起点，直接套用上面的式子即可，时间复杂度为 $2^{n-m}(n-m)m$ 考虑m比较小的时候怎么做因为g1只和B有关，明显可以设一个dp统计每种B的系数设 $dp(i,S,tot)$ 表示前面的B=tot，然后现在在考虑第i位，然后用一个S表示前面的起点选择情况，用来辅助判断这次如果选，新产生的课程数量然后这个可以预处理一个g2(i,S)表示第i位选，i-m+1~i-1的选择情况下，新产生的课程数量然后对于每个二进制，在最后一个1出现的时候统计答案即可复杂度为 $O(26n^22^m+nm^2 2^m)$ （大概吧……） 那么对数据分治一下即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>min-max容斥</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给自己的话]]></title>
    <url>%2Fposts%2F770.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2013】游走]]></title>
    <url>%2Fposts%2F47af.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2013loj2383 Record1h Analysis请先思考后再展开 我真是菜炸了$ans=\sum e_{边经过次数} w_i$那么只要能求出边经过次数的期望，贪心分配即可求边很麻烦，考虑求点$$Ept_1=1+\sum \frac{Ept_y}{dg_y} \\Ept_n=0 （不出去） \\Ept_i=\sum \frac{Ept_y}{dg_y} \\Eedge_i=\frac{Ept_x}{dg_x}+\frac{Ept_y}{dg_y}$$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JLOI2012】时间流逝]]></title>
    <url>%2Fposts%2Fada4.html</url>
    <content type="text"><![CDATA[Source and JudgeJLOI2012luogu3251 Record1h Analysis请先思考后再展开 这题感觉挺妙的，当然也可能很套路？注意到题目有个很显眼的性质，就是只能获得更小的值这就像个字典树什么的，总之就是一棵树$f(x)=1+pp \cdot f(fa)+\frac{1-pp}{tot} \sum f(son)$然后在树上，高斯消元可以做到线性，抓住唯一父亲这个特征，手动迭代具体而言就是把每个f(x)表示为 $k \cdot f(fa)+b$ ，这个显然是可以实现的记 $A=\frac{1-pp}{tot}$$f(x)=\frac{pp}{1-A \cdot \sum kson} f(fa)+\frac{1+A \cdot \sum bson}{1-A \cdot \sum kson}$每个状态用mi和sum表示，然后每个节点只存储k和b，答案为根节点的b（注意在根时pp=0） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; #define pr pair&lt;double,double&gt; #define FR first #define SE second #define MP make_pair pr operator + (pr a,pr b) &#123;return MP(a.FR+b.FR,a.SE+b.SE);&#125; double pp;int T; int a[100]; pr dfs(int mi,int sum) &#123; if(sum&gt;T) return MP(0,0); pr now=MP(0,0); for(int i=1;i&lt;=mi;i++) now=now+dfs(i,sum+a[i]); if(sum==0) pp=0; double A=(1.0-pp)/mi; return MP(pp/(1-A*now.FR),(1+A*now.SE)/(1-A*now.FR)); &#125; void main() &#123; while(1) &#123; int n;if(scanf("%lf%d%d",&amp;pp,&amp;T,&amp;n)==EOF) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); pr ans=dfs(n,0); printf("%.3lf\n",ans.SE); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4707 重返现世]]></title>
    <url>%2Fposts%2Fee60.html</url>
    <content type="text"><![CDATA[Source and Judgeluogu4707 Record2h Analysis请先思考后再展开 首先你需要熟悉kth-minmax容斥，我写了教程，自行搜索 主要难点应该是考虑S的增大，用组合数 $C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$ ，所以状态多个n-k就好了 剩下的难点主要是初始化……但这个我好像没啥好说的 时间复杂度为 $O(nm(n-k))$ 123456789101112131415void add(int &amp;x,int y)&#123;x=(1ll*x+y)%MOD;&#125;int f[11][10010],a[N];void main()&#123; int n=qread(),k=qread(),m=qread();for(int i=1;i&lt;=n;i++) a[i]=qread(); for(int i=0;i&lt;=n-k;i++) f[i][0]=-1; for(int i=1,t=1;i&lt;=n;i++,t^=1) for(int ss=10000-a[i];ss&gt;=0;ss--) &#123; add(f[0][ss+a[i]],-f[0][ss]); for(int nk=1;nk&lt;=10;nk++) add(f[nk][ss+a[i]],f[nk-1][ss]-f[nk][ss]); &#125; ll ans=0;for(int ss=1;ss&lt;=10000;ss++) ans+=(ll)f[n-k][ss]*m%MOD*invm(ss),ans%=MOD; write((ans+MOD)%MOD);&#125;//x+MOD]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>min-max容斥</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PKUWC2019 游记与题解]]></title>
    <url>%2Fposts%2F2a15.html</url>
    <content type="text"><![CDATA[PKUWC2019菜鸡博主去不了ccf WC目前暂时没有题解，等loj有题面先吧…… 其他人的游记：bztMinamotoxzz day1自闭了，被广大附中的hz大爷d飞了，才人家的一半…… t1：n个节点m条边，求边集的子集下每个图的合法拓扑序之和，n小于20题解：考虑统计贡献相同的排列出现次数设$f(S,tot)$表示当前用了S这些点，然后已知有tot条给出的边已知被满足，那么贡献次数就是$2^{tot}$然后直接dp就是$2^n n^3$的先考虑优化空间，按照1的数量滚动数组即可优化时间，灵光一闪发现可以只处理到选n/2个1，大概210000个，dp就很快乐然后关键是合并，一开始没有算复杂度就写写写，到这里以为要枚举tot1和tot2，心态就崩了，以为这个做法凉凉了，又忘记算一算后来因为有点不甘心又想了想，发现可以分别求和然后乘法原理起来然后卡卡常就过了，可能不是最优秀的做法，花了2.5h，同时间大把人已经切了两道题了upd：不难发现我sb了，状态的第二维是没有必要的，因为2的次幂不像阶乘那样不能分解 t2：n个点的树，每个节点有颜色，定义点集的虚树为内部路径的并求多少个颜色的集合，满足这些颜色的虚树的并非空n小于1e5题解：虚树的并还是树，然后贡献到树的深度最浅的节点上然后就不会了……大概是set启发式合并+生成函数+fft什么的 upd：口胡 注意到树的并也是树，既然是树的计数考虑 点-边，以点为例 考虑求出每个点被多少棵虚树包含（$col_x$），这个可以差分，用些小技巧让虚树上每个点的系数=1 那么 $ans_i=\sum_x C_{col_x}^i=\frac{1}{i!}\sum_{j=i}^n \frac{tot_j j!}{(j-i)!}$ 这个翻转一下ntt优化即可 t3：地主斗，给定至少包含的牌，然后判多少种方案平手【无法在某次询问中一个能出牌另一个不行】，规则很繁琐题解：不会 day2上午是数学，啥都不会 下午继续上机t1：给出3个长度为100值域在ll内的数组a,l,r，求严格递增序列b，满足bi在[li,ri]内，而且是ai的超集经历：开场就写了个22的暴力，然后就不会了……题解： t2：对于有向图G求无向图G’，用简单环对应点，然后有公共边就连接，求其连通块数，n在2e5内经历：没时间写暴力了，爆0题解： t3：给出2e5个点，然后2e5次给定询问点，然后以原本的点为圆心，过询问点作圆，求最多去掉多少个圆后总面积不变经历：杠了一场，发现有趣的东西，理论上70分但过不去，调了很久搞不出来，把凸包去掉就拿了47题解： 我校两位神仙又让分了……]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>赛事</tag>
        <tag>PKUWC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PKUWC2018题解]]></title>
    <url>%2Fposts%2Fbe4c.html</url>
    <content type="text"><![CDATA[当时太菜了没有去，（除斗地主外）题解合集感觉这套题的idea不错 Minimax请先思考后再展开 考虑$f[i][j]$表示节点i取值j的概率，注意到最多两个儿子，而且有效取值是做并，考虑线段树合并$$P_i+=left_i*(p_x*\sum_{j&lt;i} right_j+(1-p_x)*\sum_{j&gt;i} right_j) \\P_j+=right_i*(p_x*\sum_{i&lt;j} left_j+(1-p_x)*\sum_{i&lt;j} left_j) \\$$当两边都有的时候暴力合并，合并的时候带上参数分别表示left、right的左侧、右侧和 当只有某边有节点的时候，相当于给里面的东西打上一个乘法标记，$O(nlogn)$ code Slay the Spire请先思考后再展开 首先，保证了单组数据在3000内，所以是可以n方的其次，因为翻倍牌都大于1，所以如果可以，出k-1张翻倍牌一定是最优的，否则当然是所有翻倍牌然后剩下的就非常容易了，应该也是签到题，不过我在一些细节的地方想错、写错了好多次 设fa(n,k)表示翻倍牌，考虑前n个用了k张的 $\sum 积$ ，然后根据美妙的乘法原理直接转移，但当k超过k-1的时候积的长度只能是k-1设fb(n,k)表示攻击牌，考虑前n个而且用了第n个的 $\sum 和$ ，然后为了转移需要再记录一个tb表示sum的数量设fr(a,b)表示攻击牌，选a个但求和b个的 $\sum 和$设fc(n)表示攻击牌，选m个然后 $\sum 第一个$ ，这个很好做然后我们枚举a和b=m-a表示两边分别选多少牌$a \leq k-1,ans+=fa(n,a) \times fr(b,k-a)$$a&gt;k-1,ans+=fa(n,a) \times fc(m-a)$那么不难注意到，有用的fr状态，a和b的差都是m-k，所以fr也能dp出来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; //#define pr pair&lt;double,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=3100; const int MOD=998244353; ll qpower(ll x,int e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; int inv(int x) &#123;return qpower(x,MOD-2);&#125; void add(int &amp;x,int y) &#123; x+=y; if(x&gt;=MOD) x-=MOD; if(x&lt;=-MOD) x+=MOD; &#125; int fac[MAX_N],facinv[MAX_N]; int C(int n,int m) &#123; if(n&lt;m) return 0;//debug return (ll)fac[n]*facinv[m]%MOD*facinv[n-m]%MOD; &#125; int A[MAX_N],B[MAX_N]; int fa[MAX_N][MAX_N],fc[MAX_N]; int fb[MAX_N][MAX_N],tb[MAX_N][MAX_N],fr[MAX_N];//fb,tb为i降k不降的前缀和 void main() &#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=(ll)fac[i-1]*i%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=inv(fac[i]); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;B[i]); sort(A+1,A+n+1);reverse(A+1,A+n+1); sort(B+1,B+n+1);reverse(B+1,B+n+1);//debug…… for(int i=0;i&lt;n;i++) &#123; fa[i][0]=1; for(int j=0;j&lt;=i;j++) if(fa[i][j]&gt;0) &#123; if(j+1&lt;=k-1) add(fa[i+1][j+1],(ll)fa[i][j]*A[i+1]%MOD); else add(fa[i+1][j+1],fa[i][j]); add(fa[i+1][j],fa[i][j]); fa[i][j]=0; &#125; &#125; for(int ln=1;ln&lt;=n;ln++) for(int i=1;i&lt;=n;i++) add(fc[ln],(ll)B[i]*C(n-i,ln-1)%MOD); for(int i=0;i&lt;=n;i++) fb[i][0]=0,tb[i][0]=1; for(int k=1;k&lt;=n;k++) &#123; for(int i=k;i&lt;=n;i++) &#123; int now1=fb[i-1][k-1]+(ll)tb[i-1][k-1]*B[i]%MOD;now1%=MOD; fb[i][k]=(fb[i-1][k]+now1)%MOD;tb[i][k]=(tb[i-1][k]+tb[i-1][k-1])%MOD; &#125; &#125; for(int a=m-k;a&lt;=n;a++) &#123; int b=a-(m-k); fr[a]=0;for(int i=b;i&lt;=n;i++) add(fr[a], ll(fb[i][b]-fb[i-1][b])*C(n-i,a-b)%MOD ); &#125; int ans=0; for(int a=0;a&lt;=n and a&lt;=m;a++) &#123; int b=m-a;if(b&gt;n or b==0) continue; if(a&lt;=k-1) add(ans,(ll)fa[n][a]*fr[b]%MOD); else add(ans,(ll)fa[n][a]*fc[b]%MOD); &#125; printf("%d\n",(ans+MOD)%MOD); for(int i=0;i&lt;=n;i++) fa[n][i]=fc[i]=fr[i]=0; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) fb[i][j]=tb[i][j]=0; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 随机算法请先思考后再展开 方法一：$O(n^2 2^n)$设f(i,S)表示填了排列的前i个，当前独立集为S的方案数然后为了避免那些无法被独立集记录但在排列中的点被重复计算，尽管他们的边集情况不同，但对当前状态的影响都是相同的，那就是不能加入独立集，所以乘以【n-i-能加入S的点】就能不重不漏的计数了这种做法理论上的分数为50，但在loj上可ac 方法二：$O(n 2^n)$这时候我们不能再记录多一维了尝试直接dp概率而非计数，有的时候这样好做很多注意到对于一个点集，独立集=去掉独立集中的某个点以及其相邻的点后的独立集+被去掉的独立集中的点直接dp当排列的集合为S时的概率，枚举最后一个被加入独立集的点，转移就像上面说的那样然后【你感受一下】，觉得他们到这里的概率应该是相同的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; //#define pr pair&lt;double,int&gt; #define FR first #define SE second #define MP make_pair const int MOD=998244353; void add(int &amp;x,int y) &#123; x+=y; if(x&gt;=MOD) x-=MOD; &#125; const int MAX_N=23; int bin[MAX_N],inv[MAX_N]; int mp[MAX_N]; int f[1&lt;&lt;MAX_N],mx[1&lt;&lt;MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;MAX_N;i++) bin[i]=bin[i-1]&lt;&lt;1; inv[1]=1;for(int i=2;i&lt;MAX_N;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); mp[x-1]|=bin[y-1];mp[y-1]|=bin[x-1]; &#125; f[0]=1;mx[0]=0; for(int s=1;s&lt;bin[n];s++) &#123; int tot=0; for(int i=0;i&lt;n;i++) if(s&amp;bin[i]) &#123; tot++; int s2=s^(mp[i]&amp;s)^bin[i]; if(mx[s2]+1==mx[s]) add(f[s],f[s2]); else if(mx[s2]+1&gt;mx[s]) f[s]=f[s2],mx[s]=mx[s2]+1; &#125; f[s]=(ll)f[s]*inv[tot]%MOD; &#125; printf("%d",f[bin[n]-1]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 方法三：$O(n 2^n)$这是我目前认为最靠谱的做法了就是你顺便记录每个集合，最大的独立集大小然后你只需要转移那些siz=mxsiz[S]的状态，也就是状态就少一维了然后这个和上面的思想也是吻合的 猎人杀有n堆石子，第i堆有wi个，每次随机选一颗石子，然后把整堆拿走，问第一堆最后拿走的概率请先思考后再展开 update：经典面试题，要求将$[1,A]的随机数生成器修改为[1,B]$这个的做法是如果不在B以内，则重新生成，这个你等比数列求和发现是对的 30分：按题意模拟 题意转化是本题的唯一难点1号最后被杀有点烦，容斥一下，固定后面还有多少个活着然后因为每次概率的分母变来变去很麻烦，考虑等效的转化：如果杀了一个已经死了的人，就重新杀一轮令A为权值和，S为被固定的和那么 $P=\sum_{i=0}^{\infty} (1-\frac{S+w_1}{A})^i \frac{w_1}{A}=\frac{w_1}{S+w_1}$$ans=\sum_{k=0}^{n-1} (-1)^k ( \sum_{S=0}^A times(S) \frac{w1}{S+w_1} )$$ans=\sum_{S=0}^A ( \sum_{k=0}^{n-1} (-1)^k times(S) ) \frac{w1}{S+w_1}$显然中间那个，构造一下生成函数即可$\prod (1-x^{w_i})$然后显然用分治ntt求每一层一定比AlogA小，共logn层，故复杂度为 $O(Alog^2A)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MOD=998244353; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; ll add(ll x,ll y) &#123; x+=y; if(x&gt;=MOD) x-=MOD; if(x&lt;=-MOD) x+=MOD; return x; &#125; const int MAX_N=4*110000; struct NTT &#123; int R[MAX_N]; void preR(int n) &#123; R[0]=0;for(int i=1;i&lt;=n;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;((int)log2(n)-1)); &#125; ll w[2][MAX_N]; void prew(int n) &#123; ll now0=qpower(3,(MOD-1)/n),now1=inv(now0); w[0][0]=w[1][0]=1;for(int i=1;i&lt;=n;i++) w[0][i]=w[0][i-1]*now0%MOD,w[1][i]=w[1][i-1]*now1%MOD; &#125; void solve(ll A[],int n,int f) &#123; for(int i=0;i&lt;n;i++) if(i&lt;R[i]) swap(A[i],A[R[i]]); for(int ln=1;ln&lt;=n/2;ln*=2) for(int st=0;st&lt;n;st+=ln*2) for(int k=0;k&lt;ln;k++) &#123; ll a=A[st+k],b=w[f][(n/ln/2)*k]*A[st+ln+k]%MOD; A[st+k]=add(a,b);A[st+ln+k]=add(a,-b); &#125; &#125; &#125;ntt; ll C[MAX_N]; void cheng(ll A[],ll B[],int ln) &#123; int n=1;while(n&lt;=ln) n*=2; for(int i=0;i&lt;n;i++) C[i]=B[i]; ntt.preR(n);ntt.prew(n); ntt.solve(A,n,0);ntt.solve(C,n,0); for(int i=0;i&lt;n;i++) A[i]=A[i]*C[i]%MOD; ntt.solve(A,n,1); for(int i=0;i&lt;n;i++) A[i]=A[i]*inv(n)%MOD; &#125; int w[MAX_N]; ll pp[30][MAX_N]; void solve(int l,int r,int dep) &#123; if(l==r) &#123; pp[dep][0]=1;pp[dep][w[l]-w[l-1]]=-1; return; &#125; int mid=(l+r)/2; solve(l,mid,dep+1);int a=w[mid]-w[l-1]; for(int i=0;i&lt;=a;i++) pp[dep][i]=pp[dep+1][i],pp[dep+1][i]=0; solve(mid+1,r,dep+1);int b=w[r]-w[mid]; cheng(pp[dep],pp[dep+1],a+b+1); for(int i=0;i&lt;=b;i++) pp[dep+1][i]=0; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]),w[i]+=w[i-1]; if(2&lt;=n) solve(2,n,0); ll ans=0;for(int s=0;s&lt;=w[n]-w[1];s++) ans=add(ans,pp[0][s]*w[1]%MOD*inv(s+w[1])%MOD); printf("%lld",(ans+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 随机游走请先思考后再展开 前置知识（套路）：min-max容斥、树上高斯消元、fwt（非必要）特性：有根树的根是固定的（不然就很麻烦了）问题转化为，对于每个点集S，求从根出发的期望步数$f(x)=\frac{1}{tot-\sum kson} f(fa)+\frac{tot+\sum bson}{tot-\sum kson}$最后统计答案时最好用fwt，复杂度为 $O(30n 2^n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair const int MOD=998244353; void add(int &amp;x,int y) &#123; x+=y; if(x&gt;=MOD) x-=MOD; if(x&lt;=-MOD) x+=MOD; &#125; pr operator + (pr a,pr b) &#123;add(a.FR,b.FR);add(a.SE,b.SE);return a;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; const int MAX_N=20; int hou[MAX_N],dg[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int bin[MAX_N],nows; pr dfs(int x,int fa) &#123; if(bin[x]&amp;nows) return MP(0,0); pr tmp=MP(0,0); for(int k=hou[x];k&gt;0;k=e[k].g) if(e[k].y!=fa) tmp=tmp+dfs(e[k].y,x); return MP( inv(dg[x]-tmp.FR),ll(dg[x]+tmp.SE)*inv(dg[x]-tmp.FR)%MOD ); &#125; int a[1&lt;&lt;MAX_N]; void fwt(int n) &#123; for(int i=0;i&lt;n;i++) for(int j=bin[n]-1;j&gt;=0;j--) if(j&amp;bin[i]) add(a[j],a[j^bin[i]]); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;MAX_N;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,q,st;scanf("%d%d%d",&amp;n,&amp;q,&amp;st);st--; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y);x--;y--; ins(x,y);ins(y,x);dg[x]++;dg[y]++; &#125; for(nows=1;nows&lt;bin[n];nows++) &#123; pr ans=dfs(st,-1); for(int i=0;i&lt;n;i++) if(nows&amp;bin[i]) ans.SE*=-1; a[nows]=-ans.SE; &#125; fwt(n); while(q--) &#123; int k;scanf("%d",&amp;k); int wt=0; for(int i=1;i&lt;=k;i++) &#123; int now;scanf("%d",&amp;now); wt|=bin[now-1]; &#125; printf("%d\n",(a[wt]+MOD)%MOD); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>min-max容斥</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GXOI/GZOI2019]]></title>
    <url>%2Fposts%2F50cd.html</url>
    <content type="text"><![CDATA[GXOI/GZOI2019 D2T2 旅行者请先思考后再展开 rose做法：st连向关键点，然后对于每个点求出前两个本质不同的dis，因为每个点只会出去更新两次，所以复杂度是对的 官方题解做法：因为x!=y，将点按每个二进制位分为两个集合，复杂度为 $O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; pr f[MAX_N]; vc&lt;pr&gt; to[MAX_N]; int fmbak[MAX_N]; struct Data &#123; ll dis;int x,fm; friend bool operator &lt; (Data a,Data b)&#123;return a.dis&gt;b.dis;&#125; &#125;; priority_queue&lt; Data &gt; q; void solve() &#123; memset(f,0,sizeof f);q.push((Data)&#123;0,0,0&#125;); while(q.size()) &#123; Data now=q.top();q.pop();int x=now.x,fm=now.fm;ll dd=now.dis; if(f[x].SE) continue; if(f[x].FR and fm==fmbak[x]) continue; if(f[x].FR) f[x].SE=dd; else f[x].FR=dd,fmbak[x]=fm; for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t].SE;ll c=to[x][t].FR; q.push((Data)&#123;dd+c,y, x==0?y:fm &#125;); &#125; &#125; &#125; void main() &#123; int T=qread(); while(T--) &#123; int n=qread(),m=qread(),cnt=qread(); for(int i=0;i&lt;=n;i++) to[i].clear(); while(m--) &#123; int x=qread(),y=qread(),z=qread(); if(x==0)continue;//debug 数据貌似有锅 to[x].PB(MP(1ll*z,y)); &#125; for(int i=1;i&lt;=cnt;i++) to[0].PB( MP(0ll,qread()) ); solve(); ll ans=LLINF; for(int t=0;t&lt;(int)to[0].size();t++) &#123; int x=to[0][t].SE; if(fmbak[x]==x) &#123; if(f[x].SE==0) continue; ans=min(ans,f[x].SE); &#125; else &#123; if(f[x].FR==0) continue; ans=min(ans,f[x].FR); &#125; &#125; if(ans==LLINF) puts("-1"); else write2(ans); &#125; &#125;&#125;;signed main()&#123; freopen("z.txt","r",stdin); srand(time(0)); mine::main();&#125; D2T3 旧词请先思考后再展开 先考虑k=1，离线操作后按x递增加点，每次给x到根的链+1，然后询问链和，即弱化版bzoj3626[LNOI2014]LCA、CF860E Arkady and a Nobody-men，存在线性做法 考虑这个做法的本质，就是+权值的差分，推广一下就是 $dep_x^k-dep_{fa}^k$ ，树剖+线段树维护 因为每次k是相同的（一开始看错了……），每次覆盖的是整个区间，dep连续，可以直接计算新的sum 时间复杂度为 $O(nlog^2n)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF960G】Bandit Blue【FJOI2016】建筑师]]></title>
    <url>%2Fposts%2F62ca.html</url>
    <content type="text"><![CDATA[Source and JudgeCF960G loj2173 Analysis请先思考后再展开 新写的题解： FJOI2016出原题是什么鬼……还削弱了，不知道是好是坏 只考虑a+b-1个关键点的话显然是个山 如果枚举n的位置：$ans=\sum_{i=1}^n C_{n-1}^{i-1}S_1(i-1,a-1)S_1(n-i,b)$ 考虑怎么避免枚举n的位置，考虑上面式子的组合意义，你发现完全可以写成： ${a+b-2 \choose a-1} S_1(n-1,a+b-2)$，那么求斯特林数就好啦 FJOI2016直接用递推式就好了，CF的话快速求法见这里，之前雅礼集训出这道题要nlogn才能过 老题解： 考虑一些性质，发现最高点一定是n，然后左边关键点上升右边下降考虑n个位置，有k个是特殊点的方案数，考虑从大到小放入，考虑最小值的位置可得递推式$dp(n,k)=dp(n-1,k-1)+(n-1)dp(n-1,k)$发现这就是第一类斯特林数那么答案就是 $\sum_{i=1}^n {n-1 \choose i-1} S(i-1,a-1) S(n-i,b)$发现这样太慢了，主要原因是两个方向，考虑优化这个东西只从一个方向看，然后把b-1个翻转过去即可${a+b-2 \choose a-1} S(n-1,a+b-2)$一个log求斯特林数详见这里]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>ntt</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2015】序列统计]]></title>
    <url>%2Fposts%2F7068.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2015luogu3321 Record1h Analysis请先思考后再展开 对M求原根g，对每个s以及x求g下的离散对数，化乘法为加法然后相当于对生成函数求循环卷积（循环长度为phi(M)，需要手动），ntt即可注意si可能为0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; //#define pr pair&lt;double,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_NUM=1e4; bool no[MAX_NUM]; int pr=0,prime[MAX_NUM],phi[MAX_NUM]; void pre() &#123; for(int i=2;i&lt;MAX_NUM;i++) &#123; if(!no[i]) prime[++pr]=i,phi[i]=i-1; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; int t=i*prime[j]; no[t]=1; if(i%prime[j]==0) &#123;phi[t]=phi[i]*prime[j];break;&#125; phi[t]=phi[i]*(prime[j]-1); &#125; &#125; &#125; int MOD=1004535809,M; ll qpower(ll x,ll e,ll MOD) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x,ll MOD) &#123;return qpower(x,MOD-2,MOD);&#125; ll add(ll x,ll y) &#123; x+=y; if(x&gt;=MOD) x-=MOD; if(x&lt;=-MOD) x+=MOD; return x; &#125; bool check(int g,int num) &#123; int tmp=phi[num]; for(int i=1;i&lt;=pr and (ll)prime[i]*prime[i]&lt;=tmp;i++) if(tmp%prime[i]==0) &#123; if(qpower(g,phi[num]/prime[i],num)==1) return 0; while(tmp%prime[i]==0) tmp/=prime[i]; &#125; return qpower(g,tmp,num)!=1; &#125; int getyg(int num) &#123; for(int g=2;g&lt;num;g++) if(check(g,num)) return g; return -1; &#125; const int MAX_N=MAX_NUM*4; struct Ntt &#123; int R[MAX_N]; void preR(int n) &#123; R[0]=0;for(int i=1;i&lt;n;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;((int)log2(n)-1)); &#125; ll w[2][MAX_N]; void prew(int n) &#123; ll g=qpower(3,(MOD-1)/n,MOD),g2=inv(g,MOD); w[0][0]=w[1][0]=1; for(int i=1;i&lt;n;i++) w[0][i]=w[0][i-1]*g%MOD,w[1][i]=w[1][i-1]*g2%MOD; &#125; void solve(ll A[],int n,int f) &#123; for(int i=0;i&lt;n;i++) if(i&lt;R[i]) swap(A[i],A[R[i]]); for(int ln=1;ln&lt;=n/2;ln&lt;&lt;=1) for(int st=0;st&lt;n;st+=ln*2) for(int k=0;k&lt;ln;k++) &#123; ll a=A[st+k],b=w[f][k*(n/(ln*2))]*A[st+ln+k]%MOD; A[st+k]=add(a,b);A[st+ln+k]=add(a,-b); &#125; &#125; &#125;ntt; ll ans[MAX_N],A[MAX_N],C[MAX_N]; void cheng(int ln,int n,ll X[],ll Y[]) &#123; memcpy(C,Y,sizeof C); ntt.solve(X,ln,0);ntt.solve(C,ln,0); for(int i=0;i&lt;ln;i++) X[i]=X[i]*C[i]%MOD; ntt.solve(X,ln,1); for(int i=0;i&lt;n;i++) X[i]=(X[i]+X[n+i])*inv(ln,MOD)%MOD,X[n+i]=0; &#125; void power(int n,int e) &#123; int ln=1;while(ln&lt;4*n) ln&lt;&lt;=1; ntt.preR(ln);ntt.prew(ln); ans[0]=1; while(e) &#123; if(e&amp;1) cheng(ln,n,ans,A); e&gt;&gt;=1;cheng(ln,n,A,A); &#125; &#125; bool app[MAX_N]; void main() &#123; pre(); int k,wt,n;scanf("%d%d%d%d",&amp;k,&amp;M,&amp;wt,&amp;n); for(int i=1;i&lt;=n;i++) &#123;int t;scanf("%d",&amp;t);app[t]=1;&#125; int g=getyg(M); bool bk=1;//debug for(int now=1,t=0;t&lt;=M-2;t++,now=now*g%M) &#123; if(app[now]) A[t]=1; if(bk==1 and now==wt) wt=t,bk=0; &#125; power(M-1,k); printf("%lld",(ans[wt]+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>ntt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2015】按位或]]></title>
    <url>%2Fposts%2F1e94.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2015luogu3175 Record1h Analysis请先思考后再展开 前置知识：min-max容斥那么我们现在希望求出【或出S的任意一位】的期望步数补集转化一下，发现只要求出补集的子集概率和，1除以概率和就是期望然后FWT一下，套式子即可 不过我并不知道为什么不开long double会出现负数……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; #define double long double //#define pr pair&lt;double,int&gt; #define FR first #define SE second #define MP make_pair int n; int bin[30]; double p[1&lt;&lt;23]; void fwt() &#123; for(int i=0;i&lt;n;i++) for(int j=bin[n]-1;j&gt;=0;j--) if(j&amp;bin[i]) p[j]+=p[j-bin[i]]; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; scanf("%d",&amp;n);for(int i=0;i&lt;bin[n];i++) scanf("%Lf",&amp;p[i]); fwt(); double ans=0; for(int s=1;s&lt;bin[n];s++) &#123; double minE=1.0/(1-p[(bin[n]-1)^s]); for(int i=0;i&lt;n;i++) if(s&amp;bin[i]) minE*=-1; ans+=minE*(-1); &#125; if(ans==0) puts("INF"); else printf("%.10Lf\n",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>min-max容斥</tag>
        <tag>难度2</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅礼冬令营集训2019]]></title>
    <url>%2Fposts%2Fcaf.html</url>
    <content type="text"><![CDATA[雅礼冬令营集训2019远行客的blog chd的blog 还有些坑没有填来着…… D1雅礼2019冬令营day1.pdf t1请先思考后再展开 hotel原题，之前写过题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=51000; vector&lt;int&gt; son[MAX_N]; int mxdep[MAX_N],gson[MAX_N]; ll ans; ll *f1[MAX_N],*f2[MAX_N]; ll real[MAX_N*31],*tot; void dfs(int x,int fa) &#123; mxdep[x]=0;gson[x]=0; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; dfs(y,x);chmax(mxdep[x],mxdep[y]+1); if(mxdep[y]&gt;=mxdep[gson[x]]) gson[x]=y; &#125; &#125; void dp(int x,int fa) &#123; if(gson[x]) &#123; f1[gson[x]]=f1[x]+1; f2[gson[x]]=f2[x]-1; dp(gson[x],x); if(mxdep[gson[x]]&gt;=1) ans+=f2[gson[x]][1]; &#125; f1[x][0]++; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa or y==gson[x]) continue; f1[y]=tot;tot+=2*mxdep[y]+10; f2[y]=tot;tot+=2*mxdep[y]+10; dp(y,x); for(int d=mxdep[y];d&gt;=1;d--) ans+=f1[x][d-1]*f2[y][d]; for(int d=0;d&lt;=mxdep[y];d++) &#123; if(d+1&lt;=mxdep[x]) ans+=f2[x][d+1]*f1[y][d]; if(d) f2[x][d-1]+=f2[y][d]; if(d+1&lt;=mxdep[x]) f2[x][d+1]+=f1[x][d+1]*f1[y][d]; if(d+1&lt;=mxdep[x]) f1[x][d+1]+=f1[y][d]; &#125; &#125; &#125; void main() &#123; while(1) &#123; int n;scanf("%d",&amp;n); if(n==0) break; for(int i=1;i&lt;=n;i++) son[i].clear(); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); son[x].PB(y);son[y].PB(x); &#125; dfs(1,0); ans=0; tot=real+mxdep[1]*2+10;f1[1]=tot; tot+=mxdep[1]*2+10;f2[1]=tot;tot+=mxdep[1]*2+10; dp(1,0); printf("%lld\n",ans); for(int i=0;i&lt;=n;i++) gson[i]=mxdep[i]=0,f1[i]=f2[i]=0; for(int x=0;x&lt;=n*30;x++) real[x]=0; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; t2请先思考后再展开 神仙题题解1题解2 t3请先思考后再展开 $sin(kx)=2cos(x)sin((k-1)x)-sin((k-2)x)$神仙数学题 D2雅礼2019冬令营day2.pdf t1请先思考后再展开 苦死无果后，为了避免正解可能会利用图形的性质，就发现二维取点的询问一定是贴着左或右的然后我觉得没什么用……结果一看题解，我去，利用贴边的性质，把边排个序，线段树每个节点开个有序的deque，每次就是删除两边每条边会被删除log次，时间为 $O(nlogn)$ t2请先思考后再展开 看到树上路径先点分治，然后如果能求出一个多项式，就能卷积起来 $ans(a+b)+=\sum A[段数a][sy] \times B[段数b][-sy]$ 注意A和B不重叠，而且点分治套路容斥一下 然后就是考虑怎么求这个多项式，以及复杂度怎么证明了（其实是同一个问题……考场上因为假设第一个能求发现不会第二个，就自闭了） 求的话，考虑一个前缀合法的序列的特性（1和-1），就是后面那一段是后缀和最大的一段（向上），如果是后缀合法（向下）则为最小，然后把段数清空。 然后我们直接枚举剩余系sy，然后直接卷起来，复杂度为 $\sum_{sy} mx_{段数}$ ，考虑到新进入一个剩余系的时候段数会被清空，而且一个点最多让其+1，所有复杂度为 $O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; #define double long double const double PI=acos(-1); typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=51000; struct Cp &#123; double a,b;Cp(double x=0,double y=0) &#123;a=x,b=y;&#125; friend Cp operator +(Cp x,Cp y)&#123;return Cp(x.a+y.a,x.b+y.b);&#125; friend Cp operator -(Cp x,Cp y)&#123;return Cp(x.a-y.a,x.b-y.b);&#125; friend Cp operator *(Cp x,Cp y)&#123;return Cp(x.a*y.a-x.b*y.b,x.a*y.b+x.b*y.a);&#125; &#125;; struct FFT &#123; int R[MAX_N];void preR(int n)&#123;R[0]=0;for(int i=1;i&lt;n;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|( (i&amp;1)&lt;&lt;( (int)log2(n)-1 ) );&#125; Cp w[2][MAX_N]; void prew(int n) &#123; for(int i=0;i&lt;n;i++) w[0][i]=Cp( cos(PI*i*2/n),sin(PI*i*2/n) ); for(int i=0;i&lt;n;i++) w[1][i]=Cp( cos(-PI*i*2/n),sin(-PI*i*2/n) ); &#125; void solve(Cp a[],int n,int f) &#123; for(int i=0;i&lt;n;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int ln=1;ln&lt;=n/2;ln*=2) for(int st=0;st&lt;n;st+=ln*2) for(int k=0;k&lt;ln;k++) &#123; Cp x=a[st+k],y=w[f][k*(n/ln/2)]*a[st+k+ln]; a[st+k]=x+y;a[st+k+ln]=x-y; &#125; &#125; &#125;fft; int n; vector&lt;int&gt; son[MAX_N];bool v[MAX_N]; int val[MAX_N],G,all,siz[MAX_N]; void getrt(int x,int fa) &#123; val[x]=0;siz[x]=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa or v[y]) continue; getrt(y,x);siz[x]+=siz[y];chmax(val[x],siz[y]); &#125; chmax(val[x],all-siz[x]); if(val[x]&lt;val[G]) G=x; &#125; char str[MAX_N][10];int mxsy; void dfs(int x,int fa,vector&lt;int&gt; A[],int sy,int cnt,int now,bool op)//剩余系、段数、当前前缀和 &#123; now+=(str[x][0]=='('?1:-1); if(!op) &#123;if(now&gt;0) sy+=now,now=0,cnt=-1;&#125; else &#123;if(now&lt;0) sy+=now,now=0,cnt=-1;&#125; int ac=op?-sy:sy;chmax(mxsy,ac); if(now==0) &#123; cnt++; while((int)A[ac].size()&lt;=cnt) A[ac].PB(0); A[ac][cnt]++; &#125; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y] or y==fa) continue; dfs(y,x,A,sy,cnt,now,op); &#125; &#125; int ans[MAX_N];vector&lt;int&gt; A[MAX_N],B[MAX_N]; Cp aa[MAX_N],bb[MAX_N]; void calc(int tt) &#123; for(int sy=0;sy&lt;=mxsy;sy++) &#123; int ln1=A[sy].size(),ln2=B[sy].size()+(sy&gt;0);if(ln1==0 or ln2-(sy&gt;0)==0) continue; int ln=1;while(ln&lt;ln1+ln2-1) ln*=2;fft.preR(ln);fft.prew(ln); for(int i=0;i&lt;(int)A[sy].size();i++) aa[i]=Cp(A[sy][i]);fft.solve(aa,ln,0); for(int i=0;i&lt;(int)B[sy].size();i++) bb[i+(sy&gt;0)]=Cp(B[sy][i]);fft.solve(bb,ln,0); for(int i=0;i&lt;ln;i++) aa[i]=aa[i]*bb[i];fft.solve(aa,ln,1); for(int i=0;i&lt;ln;i++) ans[i]+=round(aa[i].a/ln)*tt; for(int i=0;i&lt;ln;i++) aa[i]=Cp(),bb[i]=Cp(); &#125; for(int sy=0;sy&lt;=mxsy;sy++) A[sy].resize(0),B[sy].resize(0); &#125; void solve(int x,int sum) &#123; if(sum==1) return; v[x]=1;B[0].PB(1); mxsy=0;dfs(x,0,A,0,0,0,0);for(int t=0;t&lt;(int)son[x].size();t++) if(!v[son[x][t]]) dfs(son[x][t],0,B,0,0,0,1); calc(1); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y]) continue; mxsy=0;dfs(y,0,A,(str[x][0]=='('?1:0),0,(str[x][0]=='('?0:-1),0);dfs(y,0,B,0,0,0,1); calc(-1); &#125; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y]) continue; G=0;all=siz[y];getrt(y,x);solve(G,siz[y]); &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); son[x].PB(y);son[y].PB(x); &#125; for(int i=1;i&lt;=n;i++) scanf("%s",str[i]); val[0]=INF;G=0;all=n;getrt(1,0);solve(G,n); int q;scanf("%d",&amp;q); while(q--) &#123; int t=qread();if(t==0) puts("error"); printf("%d\n",ans[t]); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; t3请先思考后再展开 bzoj3308 最优方案的两个神仙性质： 每个数，最多两个不同质因子 若两个，一个在根号内，一个在根号外 那么这是一个二分图，显然可以最大费用流，可得80分考虑如何优化，先将只有一个质因子的数放入答案，然后费用流的边权改为f(x,y)-f(x)-f(y)，显然去掉了负权边，而且让图更简单了实测极限数据从几秒变秒出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; bool isp(int x) &#123; if(x&lt;=1) return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1; &#125; const int MAX_N=210000; int hou[MAX_N]; struct Edge&#123;int y,c,w,g;&#125;e[500000]; int ln=0;int oth(int x) &#123;return (x&amp;1)?x+1:x-1;&#125; void ins(int x,int y,int c,int w) &#123; e[++ln]=(Edge)&#123;y,c,w,hou[x]&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,0,-w,hou[y]&#125;;hou[y]=ln; &#125; int st,ed; ll dis[MAX_N],ans=0;bool v[MAX_N]; int fm[MAX_N]; queue&lt;int&gt; q; bool solve() &#123; memset(dis,-0x3f,sizeof dis);dis[st]=0; q.push(st);v[st]=1; while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&lt;dis[x]+e[k].w and e[k].c&gt;0) &#123; dis[y]=dis[x]+e[k].w;fm[y]=k; if(!v[y]) v[y]=1,q.push(y); &#125; &#125; v[x]=0; &#125; if(dis[ed]&lt;0) return 0; ans+=dis[ed]; for(int x=ed;x!=st;x=e[oth(fm[x])].y) e[fm[x]].c--,e[oth(fm[x])].c++; return 1; &#125; int num1[MAX_N],num2[MAX_N],tmp[MAX_N]; bool no[MAX_N]; int pp=0,prime[MAX_N],T,a=0,b=0,n; void pre() &#123; for(int i=2;i&lt;=n;i++) &#123; if(!no[i]) &#123; prime[++pp]=i; if((ll)i*i&lt;=n) ins(st,++a,1,0),num1[a]=i; else num2[++b]=i,ins(T+b,ed,1,0); &#125; for(int j=1;j&lt;=pp and (ll)i*prime[j]&lt;=n;j++) &#123; no[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125; &#125; void main() &#123; scanf("%d",&amp;n);T=sqrt(n)+1; st=0;ed=n+2;pre(); for(int i=1;i&lt;=a;i++) &#123; int mx=-1; for(ll x=num1[i];x&lt;=n;x*=num1[i]) chmax(mx,x); tmp[num1[i]]=mx;ans+=mx; &#125; for(int i=1;i&lt;=b;i++) &#123; int mx=-1; for(ll x=num2[i];x&lt;=n;x*=num2[i]) chmax(mx,x); tmp[num2[i]]=mx;ans+=mx; &#125; for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++) &#123; int mx=-1; for(ll x=num1[i];x&lt;=n;x*=num1[i]) for(ll y=num2[j];x*y&lt;=n;y*=num2[j]) chmax(mx,x*y); int tt=mx-tmp[num1[i]]-tmp[num2[j]]; if(tt&gt;0) ins(i,T+j,1,tt); &#125; while(solve()) ; printf("%lld",ans+1); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; D4t1 cf1061e请先思考后再展开 感觉其实和jcp之前给的网络流题目很像？流量表示选择的情况左边为树1，右边为树2，流量各自限制好然后对于每个节点，在中间建边，表示好代价然后非法情况，就是两边没有满流，还有边的流量可能是负数，这个忘记判断错了好久……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; //#define pr pair&lt;double,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=510; int n,rt1,rt2,w[MAX_N]; struct Tree &#123; int hou[MAX_N],f[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int nfa[MAX_N],ned[MAX_N]; //nfa=最近的关键祖先 Tree() &#123;ln=0;memset(hou,0,sizeof hou);memset(ned,-1,sizeof ned);&#125; int getnum(int x,int fa,int st) &#123; if(st==0 and ned[x]&gt;=0) return ned[x]; int tot=0; for(int k=hou[x];k&gt;0;k=e[k].g) if(e[k].y!=fa) tot+=getnum(e[k].y,x,0); return tot; &#125; void dfs(int x,int fa,int tfa) &#123; nfa[x]=ned[x]&gt;=0?x:tfa;f[x]=fa; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x,nfa[x]); &#125; &#125; &#125;t1,t2; struct MCMF &#123; int hou[MAX_N*2]; struct Edge &#123; int y,g,c;ll w; &#125;e[MAX_N*MAX_N]; int ln;int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c,int w) &#123; if(c&lt;0) &#123; puts("-1"); exit(0);//debug &#125; e[++ln]=(Edge)&#123;y,hou[x],c,w&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0,-w&#125;;hou[y]=ln; &#125; ll dis[MAX_N*2];bool v[MAX_N*2]; int fm[MAX_N*2],mif[MAX_N*2]; queue&lt;int&gt; q; ll flow,cost; bool solve(int st,int ed) &#123; memset(dis,-63,sizeof dis);dis[st]=0; q.push(st);mif[st]=INF;v[st]=1; while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&lt;dis[x]+e[k].w and e[k].c&gt;0) &#123; dis[y]=dis[x]+e[k].w; mif[y]=min(e[k].c,mif[x]); fm[y]=k; if(!v[y]) v[y]=1,q.push(y); &#125; &#125; v[x]=0; &#125; if(dis[ed]==dis[MAX_N*2-1] or mif[ed]==0) return 0; flow+=mif[ed];cost+=dis[ed]*mif[ed]; int x=ed; while(x!=st) &#123; int t=fm[x]; e[t].c-=mif[ed];e[oth(t)].c+=mif[ed]; x=e[oth(t)].y; &#125; return 1; &#125; MCMF() &#123;ln=0;flow=cost=0;memset(hou,0,sizeof hou);&#125; &#125;mcmf; void input() &#123; scanf("%d%d%d",&amp;n,&amp;rt1,&amp;rt2); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); t1.ins(x,y);t1.ins(y,x); &#125; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); t2.ins(x,y);t2.ins(y,x); &#125; int q1;scanf("%d",&amp;q1); while(q1--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); t1.ned[x]=y; &#125; int q2;scanf("%d",&amp;q2); while(q2--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); t2.ned[x]=y; &#125; &#125; void main() &#123; input(); t1.dfs(rt1,0,0);t2.dfs(rt2,0,0); int st=0,ed=2*n+1; for(int i=1;i&lt;=n;i++) &#123; int fx=t1.nfa[i],fy=t2.nfa[i]; mcmf.ins(fx,n+fy,1,w[i]); if(t1.ned[i]&gt;=0) mcmf.ins(st,i,t1.ned[i]-t1.getnum(i,t1.f[i],1),0); if(t2.ned[i]&gt;=0) mcmf.ins(n+i,ed,t2.ned[i]-t2.getnum(i,t2.f[i],1),0); &#125; while(mcmf.solve(st,ed)) ; if(mcmf.flow!=t1.ned[rt1]) puts("-1"); else printf("%lld",mcmf.cost); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; t2 cf1045h请先思考后再展开 一直在想dp，原来隔板法一下就可以直接做了因为有上界，要按位处理一下 t3 cf780h请先思考后再展开 神仙结论题……这个坑不填了 D5雅礼2019冬令营day5.pdf t1请先思考后再展开 根号算法为设计两个算法，相互配合，比较显然然后个人感觉log方的其实快不了太多就是从左到右考虑左边界，然后把串建个trie，每个节点上用个set表示第一次的时候，暴力建树，然后顺便把子树内ans求和答案统计方面，对于每个长度的每个种类，将每个子矩阵的最上面那个作为贡献，从而唯一计数（也就是上下端点的限制，这个东西似乎最近经常被mj熏陶）然后接下来随着左端点的右移，大致思路就是合并两个trie子树，如果复杂度只和小的那棵树有关，那么就是启发式合并的复杂度 $O(nmlognm)$考虑每个右端点，随着左端点的右移，字符串的种类只会减少，不需要合并（不进入）的子树可以直接统计其siz对于合并的时候，既然要求只和小的那个有关，我们必须换一种统计方式仔细观察一下原先那个，发现对于每个种类，所有内部存在这种的那些子矩阵都被统计了，那么每次插入set的贡献就是新包含这行的大值域，要写map t2请先思考后再展开 看到与运算居然没想nlogn个数，感觉比noip时还菜了……那么相当于一条线，离线一下，然后线段树维护区间加、区间和即可 t3请先思考后再展开 已经另开题解了，自行搜索 D7雅礼2019冬令营day7.pdf t1请先思考后再展开 连dp的状态都没想到设 $dp(i,j,k)表示k轮后Pi&gt;Pj的概率$然后就各种方式优化一下转移 t2请先思考后再展开 $f(n,k)=max( f(n-1,k),f(n-1,k-1)+k \times a_n )$然后想到这个以后我直接就放弃了，因为很死板地认为连状态数量都超过范围了但仔细观察这个方程，发现边界非常简单，然后决策也非常简单最关键的是，值大部分可以从上一行保留下来加以利用更近一步，很容易发现对于某个n，一旦某个k选择了决策二，那么后面都会选择决策二，具有单调性！说到这里做法应该很显然了，用个平衡树动态维护当前行的dp值的差分那么每次二分一个分界点（差分后更加容易了），然后插入一个数（偏移），再给后缀加 $a_n$ t3请先思考后再展开 请先阅览几何一章，刚学的……总之会了多边形求面积后，就没什么好说的了把环拆两倍，维护一下前缀和及其前缀和即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;ll,ll&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e6+10,MOD=1e9+7; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; ll gs(ll x) &#123;ll t=(x&gt;=MOD?x-MOD:x);return t&lt;=-MOD?t+MOD:t;&#125; pr p[MAX_N]; ll cross(pr a,pr b) &#123; return a.FR*b.SE-a.SE*b.FR; &#125; int n; int id(int x) &#123; while(x&gt;n) x-=n; while(x&lt;=0) x+=n; return x; &#125; ll real[MAX_N*2],sum[MAX_N*2],S[MAX_N*2],xx[MAX_N*2],yy[MAX_N*2]; void main() &#123; freopen("convex.in","r",stdin); freopen("convex.out","w",stdout); n=qread();for(int i=1;i&lt;=n;i++) p[i].FR=qread(),p[i].SE=qread(); for(int i=1;i&lt;=2*n;i++) &#123; real[i]=cross(p[id(i+1)],p[id(i)]);sum[i]=sum[i-1]+real[i]; S[i]=gs(S[i-1]+sum[i]%MOD);xx[i]=gs(xx[i-1]+p[id(i)].FR);yy[i]=gs(yy[i-1]+p[id(i)].SE); &#125; ll ans=0; for(int i=1,j=i+2;i&lt;=n;i++) &#123; if(j==i) j=i+2; while(1) &#123; int tj=j+1; ll a=sum[tj-1]-sum[i-1]+cross(p[id(i)],p[id(tj)]); if(a&gt;sum[n]-a) break; j++; &#125; if(2ll*(sum[j-1]-sum[i-1]+cross(p[id(i)],p[id(j)]))&gt;sum[n]) continue; ll tmp=gs(S[j-1]-S[i])-sum[i-1]%MOD*(j-1-i)%MOD;tmp=gs(tmp); ll t2=p[i].FR*(yy[j]-yy[i+1])%MOD-p[i].SE*(xx[j]-xx[i+1])%MOD;t2=gs(t2); tmp=2*gs(tmp+t2)%MOD;add(ans,gs(sum[n]%MOD*(j-1-i)%MOD-tmp)); &#125; printf("%lld",(ans+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; D8雅礼2019冬令营day8.pdf t1请先思考后再展开 首先，跟具体点无关的话就是经典的连通图计数$g_n=f_n-\sum_{i=1}^{n-1} g_i f_{n-i}$然后因为我比较sb，改为子集的时候是考虑这个子集的最小值的于是就非常蛋疼了，只想到两个n的……但其实因为我们只是需要求整体的答案，就假设所有g都包含节点n+1，f则不包含复杂度为分层子集卷积的两个n，和州区划分很类似1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; const int MAX_N=21; int bin[MAX_N],mp[MAX_N][MAX_N],siz[1&lt;&lt;MAX_N]; void FWT(int A[],int n,int f) &#123; for(int i=0;i&lt;n;i++) for(int j=bin[n]-1;j&gt;=0;j--) if(j&amp;bin[i]) add(A[j],f*A[j-bin[i]]); &#125; int f[MAX_N][1&lt;&lt;MAX_N],g[MAX_N][1&lt;&lt;MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;MAX_N;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); siz[0]=0;for(int i=1;i&lt;bin[n];i++) siz[i]=siz[i&gt;&gt;1]+(i&amp;1); for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) scanf("%d",&amp;mp[i][j]); n--; for(int s=1;s&lt;bin[n];s++) &#123; f[siz[s]][s]=1; for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) if(s&amp;bin[i] and s&amp;bin[j]) f[siz[s]][s]=(ll)f[siz[s]][s]*(mp[i][j]+1)%MOD; &#125; for(int i=1;i&lt;=n;i++) FWT(f[i],n,1); g[0][0]=1;FWT(g[0],n,1); for(int ab=1;ab&lt;=n;ab++) &#123; for(int a=0;a&lt;=ab-1;a++) for(int s=0;s&lt;bin[n];s++) add(g[ab][s],(ll)g[a][s]*f[ab-a][s]%MOD); FWT(g[ab],n,-1); for(int s=0;s&lt;bin[n];s++) if(siz[s]==ab) &#123; ll tmp=f[ab][s]; for(int i=0;i&lt;n;i++) if(s&amp;bin[i]) tmp=tmp*(mp[i][n]+1)%MOD; g[ab][s]=(tmp-g[ab][s])%MOD; &#125; else g[ab][s]=0; FWT(g[ab],n,1); &#125; FWT(g[n],n,-1); printf("%d",(g[n][bin[n]-1]+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 题解是子集卷积的除法运算，写了教程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; int bin[30],mp[20][20],siz[1&lt;&lt;20]; void FWT(int A[],int n,int f) &#123; for(int i=0;i&lt;n;i++) for(int j=bin[n]-1;j&gt;=0;j--) if(j&amp;bin[i]) add(A[j],f*A[j-bin[i]]); &#125; int f[20][1&lt;&lt;20],f2[20][1&lt;&lt;20],ans[20][1&lt;&lt;20]; void main() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); siz[0]=0;for(int i=1;i&lt;bin[n];i++) siz[i]=siz[i&gt;&gt;1]+(i&amp;1); for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) scanf("%d",&amp;mp[i][j]); n--; for(int s=0;s&lt;bin[n];s++) &#123; f[siz[s]][s]=1; for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) if(s&amp;bin[i] and s&amp;bin[j]) f[siz[s]][s]=(ll)f[siz[s]][s]*(mp[i][j]+1)%MOD; &#125; memcpy(f2,f,sizeof f); for(int s=0;s&lt;bin[n];s++) for(int i=0;i&lt;n;i++) if(s&amp;bin[i]) f2[siz[s]][s]=(ll)f2[siz[s]][s]*(mp[i][n]+1)%MOD; //ans=f2/f for(int i=0;i&lt;=n;i++) FWT(f[i],n,1),FWT(f2[i],n,1); for(int i=0;i&lt;=n;i++) for(int s=0;s&lt;bin[n];s++) &#123; for(int j=0;j&lt;i;j++) add(f2[i][s],-(ll)f[i-j][s]*ans[j][s]%MOD); ans[i][s]=f2[i][s]; &#125; FWT(ans[n],n,-1); printf("%d",(ans[n][bin[n]-1]+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; t2请先思考后再展开 概率神仙题至少目前羊也不会题解 t3请先思考后再展开 有两类点，一类是最大在子树内的，主席树即可第二类是在父亲那边的两个log的做法：树剖取出那log区间个前，两类区间在静态主席树上处理一个log的做法dfs处理每个点两次，开两个线段树分别表示祖先们以及其他节点 code（两个log）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; struct CMT &#123; struct Nod&#123;int c,lc,rc;&#125;p[MAX_N*30]; int id;CMT()&#123;id=0;memset(p,0,sizeof p);&#125; void add(int &amp;x,int l,int r,int pos) &#123; if(x==0) x=++id; p[x].c++; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos); else add(p[x].rc,mid+1,r,pos); &#125; void merg(int x,int &amp;y,int l,int r) &#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; int mid=(l+r)&gt;&gt;1; merg(p[x].lc,p[y].lc,l,mid); merg(p[x].rc,p[y].rc,mid+1,r); &#125; int getsum(int x,int y,int l,int r,int pos) &#123; if(l==r) return p[y].c-p[x].c; int mid=(l+r)&gt;&gt;1,left=p[p[y].lc].c-p[p[x].lc].c; if(pos&lt;=mid) return getsum(p[x].lc,p[y].lc,l,mid,pos); return left+getsum(p[x].rc,p[y].rc,mid+1,r,pos); &#125; int getk(int x,int y,int l,int r,int k) &#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1,left=p[p[y].lc].c-p[p[x].lc].c; if(k&lt;=left) return getk(p[x].lc,p[y].lc,l,mid,k); return getk(p[x].rc,p[y].rc,mid+1,r,k-left); &#125; &#125;cmt; int rt[MAX_N]; vector&lt;int&gt; son[MAX_N]; int siz[MAX_N],gson[MAX_N],ff[MAX_N]; void pre(int x) &#123; siz[x]=1;gson[x]=0; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];pre(y);siz[x]+=siz[y]; if(siz[y]&gt;siz[gson[x]]) gson[x]=y; &#125; &#125; int dfn[MAX_N],id=0,to[MAX_N],top[MAX_N]; void pre2(int x,int tp) &#123; dfn[x]=++id;to[id]=x;top[x]=tp; if(gson[x]) pre2(gson[x],tp); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==gson[x]) continue; pre2(y,y);ff[y]=x; &#125; &#125; int mx1,mx2,mi; void insert(int num) &#123; if(num&gt;=mx1) mx2=mx1,mx1=num; else if(num&gt;=mx2) mx2=num; chmin(mi,num); &#125; pr now[30],now2[100];bool is[100]; void main() &#123; int n;scanf("%d",&amp;n); if(n==1) &#123;puts("0");return;&#125; for(int i=2;i&lt;=n;i++) son[qread()].PB(i); pre(1);pre2(1,1); for(int i=1;i&lt;=n;i++) &#123; cmt.add(rt[i],1,n,siz[to[i]]); cmt.merg(rt[i-1],rt[i],1,n); &#125; for(int x=1;x&lt;=n;x++) &#123; mx1=mx2=0,mi=INF;if(x!=1) insert(n-siz[x]); int fm=-1;for(int t=0;t&lt;(int)son[x].size();t++) &#123;insert(siz[son[x][t]]);if(siz[son[x][t]]==mx1) fm=son[x][t];&#125; if(mx1==mx2) &#123;printf("%d\n",mx1);continue;&#125; int ans=mx1,wt=(mx1-mi)/2; if(fm&gt;0) &#123; int l=dfn[fm]+1,r=dfn[fm]+siz[fm]-1; int a=cmt.getsum(rt[l-1],rt[r],1,n,wt); int tmp=cmt.getk(rt[l-1],rt[r],1,n,a); chmin(ans, max(mx1-tmp,max(mx2,mi+tmp)) ); tmp=cmt.getk(rt[l-1],rt[r],1,n,a+1); chmin(ans, max(mx1-tmp,max(mx2,mi+tmp)) ); &#125; else &#123; int tt=0,tt2=0; int tmp=x; while(tmp!=0) &#123; int l=dfn[top[tmp]],r=dfn[tmp]; now[++tt]=MP(l,r); tmp=ff[top[tmp]]; &#125; reverse(now+1,now+tt+1); memset(is,0,sizeof is); now2[++tt2]=MP(2,now[1].FR-1);now[++tt]=MP(dfn[x]+1,dfn[x]+1); for(int i=1;i&lt;=tt-1;i++) &#123; now2[++tt2]=now[i];is[tt2]=1; now2[++tt2]=MP(now[i].SE+1,now[i+1].FR-1); &#125; now2[++tt2]=MP(dfn[x]+siz[x],n); for(int i=1;i&lt;=tt2;i++) &#123; int l=now2[i].FR,r=now2[i].SE;if(l&gt;r) continue; int a=cmt.getsum(rt[l-1],rt[r],1,n,wt+(is[i]?siz[x]:0)); int tmp=cmt.getk(rt[l-1],rt[r],1,n,a)-(is[i]?siz[x]:0); chmin(ans, max(mx1-tmp,max(mx2,mi+tmp)) ); tmp=cmt.getk(rt[l-1],rt[r],1,n,a+1)-(is[i]?siz[x]:0); chmin(ans, max(mx1-tmp,max(mx2,mi+tmp)) ); &#125; &#125; writeln(ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; D10雅礼2019冬令营day10.pdf t1请先思考后再展开 原来bitset跑10w是常规操作啊…… t2请先思考后再展开 就随便分类讨论一下就过了，不会算复杂度但感觉和正解差不多12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include "coin.h"#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;string a="0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";int lst;int tryask(string tmp)&#123; int tt=ask(tmp); if(tt==0) &#123; for(int j=0;j&lt;100;j++) if(a[j]=='0') a[j]='1'; else a[j]='0'; ask(a); &#125; return tt;&#125;void unknow(int i);void know0a(int i);void know0b(int i);void know1b(int i);void know0a(int i)&#123; unknow(i+1);&#125;void know0b(int i)&#123; int now=tryask(a); if(lst==now) a[i]='0',lst=now,know1b(i); else lst=now,unknow(i+1);&#125;void know1b(int i)&#123; int now=tryask(a); if(lst==now) a[i]='1',lst=now,know0b(i); else lst=now,unknow(i+1);&#125;void unknow(int i)&#123; if(i==100) &#123; ask(a); srand(time(0)); while(1) &#123; a="";for(int i=0;i&lt;100;i++) a+=('0'+rand()%2); tryask(a); &#125; return; &#125; a[i]='1';int now=tryask(a); if(now==lst+1 or now==lst) a[i]='0',lst=now,know1b(i);//1 else lst=now,know0a(i);//0&#125;void guess()&#123; a="0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"; lst=tryask(a); unknow(0);&#125; t3请先思考后再展开 有点神仙，大致就是转化为计数，然后花式dp D11没想到我的排名高潮是在最后一天……骗了个rk9 t1在30乘16的地图上玩扫雷，地图按照某种方式随机。随机种子不超过10000种请先思考后再展开 随机算法ac本题……其实我能拍出卡我的数据，但我的种子可是lucky number，概率约为6/1000123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include "mine.h"#include &lt;bits/stdc++.h&gt;using namespace std;#define pr pair&lt;int,int&gt;#define FR first#define SE second#define MP make_pairbool mine[11000][50][50];int sum[11000][50][50];bool in[11000];int tot;int n,m;bool v[50][50];int info[50][50];bool is[50][50];//mineint dx[8]=&#123;0,0,-1,-1,-1,1,1,1&#125;;int dy[8]=&#123;1,-1,-1,0,1,-1,0,1&#125;;bool can(int x,int y)&#123; return 0&lt;=x and x&lt;n and 0&lt;=y and y&lt;m;&#125;pr calc(int x,int y)//ͳ����֪�������յ���&#123; int cnt=0,cnt2; for(int i=0;i&lt;8;i++) if(can(x+dx[i],y+dy[i])) &#123; if(is[x+dx[i]][y+dy[i]]) cnt++; else if(v[x+dx[i]][y+dy[i]]) cnt2++;//�յ� &#125; return MP(cnt,cnt2);&#125;int calc2(int x,int y)&#123; int cnt=0; for(int i=0;i&lt;8;i++) if(can(x+dx[i],y+dy[i])) cnt++; return cnt;&#125;void check(int x,int y)&#123; for(int i=100;i&lt;=10000;i++) if(in[i]) &#123; if(sum[i][x][y]&lt;0 and info[x][y]&gt;=0) in[i]=0,tot--; else if(sum[i][x][y]&gt;=0 and sum[i][x][y]!=info[x][y]) in[i]=0,tot--; &#125; if(tot==1) &#123; int ss;for(int i=100;i&lt;=10000;i++) if(in[i]) ss=i; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(!v[i][j] and !mine[ss][i][j]) open(i,j); exit(0); &#125;&#125;//vector&lt;pr&gt; know;struct Pt&#123; int x,y; friend bool operator &lt; (Pt a,Pt b) &#123; return info[a.x][a.y]&lt;info[b.x][b.y]; &#125;&#125;;set&lt;Pt&gt; know;set&lt;Pt&gt;::iterator it,it2,it3;void del()&#123; it3=it; it2=++it; know.erase(it3); it=it2;&#125;pr randnxt()&#123; for(it=know.begin();it!=know.end();) &#123; Pt now=*it; random_shuffle(dx,dx+8); random_shuffle(dy,dy+8); for(int i=0;i&lt;8;i++) &#123; int tx=now.x+dx[i],ty=now.y+dy[i]; if(can(tx,ty) and v[tx][ty]==0) return MP(tx,ty); &#125; del(); &#125; //int tt=0; while(1) &#123; int x=rand()%n,y=rand()%m; if(v[x][y]==0) return MP(x,y); &#125;&#125;void solve(int x,int y);void update()//free award&#123; for(it=know.begin();it!=know.end();) &#123; //pr now=know[i]; Pt now=*it; pr gg=calc(now.x,now.y); if(gg.FR==info[now.x][now.y])//��֪�����׶������� ʣ�µĶ��ǿյ� &#123; for(int i=0;i&lt;8;i++) &#123; int tx=now.x+dx[i],ty=now.y+dy[i]; if(can(tx,ty) and !v[tx][ty]) &#123; solve(tx,ty); return; &#125; &#125; del(); &#125; else if(gg.SE+info[now.x][now.y]==calc2(now.x,now.y) )//���пյض������� ʣ�µĶ����� &#123; for(int i=0;i&lt;8;i++) &#123; int tx=now.x+dx[i],ty=now.y+dy[i]; if(can(tx,ty)) is[tx][ty]=1,info[tx][ty]=-1,v[tx][ty]=1,check(tx,ty); &#125; del(); &#125; else ++it; &#125;&#125;void solve(int x,int y)&#123; v[x][y]=1;info[x][y]=open(x,y); if(info[x][y]&lt;0) is[x][y]=1; know.insert((Pt)&#123;x,y&#125;); check(x,y); update();&#125;//g++ mine.cpp grader.cpp -o mine -O2 -std=c++11/*16 30 191 609=916 30 159 5828=8*/void sweep(int H, int W, int K)&#123; n=H,m=W;tot=0; srand(20030122); for(int s=100;s&lt;=10000;s++) &#123; int now=s,cnt=0; while(cnt&lt;K) &#123; now=48271ll*now%2147483647; int x=(now/m)%n,y=now%m; if(mine[s][x][y]==0) &#123; mine[s][x][y]=1,cnt++; sum[s][x][y]=-0x3f3f3f3f; for(int i=0;i&lt;8;i++) if(can(x+dx[i],y+dy[i])) sum[s][x+dx[i]][y+dy[i]]++; &#125; &#125; in[s]=1;++tot; &#125; int x=rand()%n,y=rand()%m; solve(x,y); while(1) &#123; pr nxt=randnxt(); solve(nxt.FR,nxt.SE); &#125;&#125; t2大小为n的正方形01矩阵，每次可以询问一个矩阵是否为其子矩阵，在5n方的次数内得出结论，n小于60请先思考后再展开 暴力：n3方得到合法的行，n2拼接那么我们只需要优化前面的部分 暂时咕咕咕…… t3你需要猜测一个长度为1000的01串，你每次可以询问一个区间内的1的个数，但有50%的概率交互库会随机返回一个[0,r-l+1]内不是答案的数要求询问次数在6000内请先思考后再展开 永久咕咕咕……]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>赛事</tag>
        <tag>雅礼集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF720D】Slalom]]></title>
    <url>%2Fposts%2Fbb3b.html</url>
    <content type="text"><![CDATA[Source and JudgeCF720D Record30min Analysis请先思考后再展开 显然是dp，每个位置存储到这里的方案数然后考虑怎么去重给出一个例子：每次向右更新，如果(x+1,y)上方存在某个矩形的边缘，则向上更新 考虑加速，发现dp中前面的信息是没用的，扫描线，每次询问区间和然后单点修改即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WC2018】州区划分]]></title>
    <url>%2Fposts%2Ff65b.html</url>
    <content type="text"><![CDATA[Source and Judgeuoj348 Record5h Analysis请先思考后再展开 先预处理好每一种方案（用二进制表示）的可行性、总人口$f(p1,k) \times sum^p(k)=\sum_{i|j=k} (f(p2,i)) * (okay(p1-p2,j) sum^p(j))$因为是子集卷积，用fwt优化（有教程，第一维是二进制下1数量） 这东西你看起来需要做快速幂，但这样和暴力复杂度差不多了不从快速幂的角度思考，想着是一个无限背包保持前面的东西现在都是被fwt过的，那么你只需要枚举当前计算的p1，然后做出来当前的集合幂级数，然后Ifwt回去，把非法状态去掉，把分母补上去，再fwt回来时间复杂度 $O(n^2 2^n)$ 友情提示：判断合法性，记得要判断连通块数量…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; #define pr pair&lt;double,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=24; const int MOD=998244353; const int MAX_S=(1&lt;&lt;22)+10; int qpower(int x,int e) &#123; if(e==0) return 1; if(e==1) return x; return (ll)x*x%MOD; &#125; int bin[40],pp[MAX_S],inv[MAX_S]; int n,m,p; void FWT(int A[],int f) &#123; for(int i=0;i&lt;n;i++) for(int j=bin[n]-1;j&gt;=0;j--) if(j&amp;bin[i]) (A[j]+=A[j^bin[i]]*f)%=MOD; &#125; int sum[MAX_S]; struct Edge&#123;int x,y;&#125;e[MAX_N*MAX_N]; int deg[MAX_N],fa[MAX_N]; int findfa(int x) &#123;return fa[x]=(fa[x]==x?x:findfa(fa[x]));&#125; bool check(int s)//是否存在欧拉回路 &#123; for(int i=0;i&lt;n;i++) fa[i]=i,deg[i]=0; for(int i=1;i&lt;=m;i++) if(s&amp;bin[e[i].x] and s&amp;bin[e[i].y]) &#123; deg[e[i].x]^=1,deg[e[i].y]^=1; int fx=findfa(e[i].x),fy=findfa(e[i].y); if(fx!=fy) fa[fx]=fy; &#125; int t1=0,t2=0;for(int i=0;i&lt;n;i++) if(s&amp;bin[i]) t1+=deg[i],t2+=(i==findfa(i)); return t1==0 and t2==1;//记得判连通块数量 &#125; int A[MAX_N][MAX_S],f[MAX_N][MAX_S],tmp[MAX_S]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; pp[0]=0;for(int i=1;i&lt;MAX_S;i++) pp[i]=pp[i&gt;&gt;1]+(i&amp;1); inv[0]=inv[1]=1;for(int i=2;i&lt;MAX_S;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; scanf("%d%d%d",&amp;n,&amp;m,&amp;p); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;e[i].x,&amp;e[i].y),e[i].x--,e[i].y--; for(int i=0;i&lt;n;i++) scanf("%d",&amp;sum[bin[i]]); for(int i=0;i&lt;bin[n];i++) sum[i]=sum[i^(i&amp;-i)]+sum[i&amp;-i]; for(int i=1;i&lt;bin[n];i++) &#123;sum[i]=qpower(sum[i],p);if(check(i)==0) A[pp[i]][i]=sum[i];&#125; for(int i=1;i&lt;=n;i++) FWT(A[i],1); f[0][0]=1;FWT(f[0],1); for(int p1=1;p1&lt;=n;p1++) &#123; for(int p2=0;p2&lt;p1;p2++) for(int i=0;i&lt;bin[n];i++) (f[p1][i]+=(ll)f[p2][i]*A[p1-p2][i]%MOD)%=MOD; FWT(f[p1],-1); for(int i=0;i&lt;bin[n];i++) f[p1][i]=(ll)f[p1][i]*inv[sum[i]]%MOD; FWT(f[p1],1); &#125; FWT(f[n],-1); printf("%d",(f[n][bin[n]-1]+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>复习</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF528D】Fuzzy Search]]></title>
    <url>%2Fposts%2Fe5f5.html</url>
    <content type="text"><![CDATA[Source and JudgeCF528D Record2h Analysis请先思考后再展开 忘记round了，结果本机还对了……调了很久 这道题还是有点妙的，不过并不难注意到字符集很小，可以逐种字母处理，看和是否是ms1是母串，s2是模式串发现这种【对齐，然后往后推，然后匹配】这种东西，把串反过来，和卷积很像设 $A_i=[s2[i]=c],B_i=s1[n-i+1]附近是否含有c$那么Ci就表示从i开始倒着对齐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const double PI=acos(-1); const int MAX_N=8*210000; struct Cp &#123; double a,b; Cp(double c=0,double d=0) &#123;a=c,b=d;&#125; Cp operator + (Cp t) &#123;return Cp(a+t.a,b+t.b);&#125; Cp operator - (Cp t) &#123;return Cp(a-t.a,b-t.b);&#125; Cp operator * (Cp t) &#123;return Cp(a*t.a-b*t.b,a*t.b+b*t.a);&#125; &#125;; int R[MAX_N]; struct Fft &#123; Cp w[MAX_N]; void getw(int n,int f) &#123; for(int i=0;i&lt;n;i++) w[i]=Cp(cos(PI*2*f*i/n),sin(PI*2*f*i/n)); &#125; void solve(Cp *a,int n,int f) &#123; for(int i=0;i&lt;n;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int ln=1;ln&lt;=n/2;ln&lt;&lt;=1)//合并前 &#123; getw(ln*2,f); for(int st=0;st&lt;n;st+=2*ln) for(int k=0;k&lt;ln;k++) &#123; Cp x=a[st+k],y=w[k]*a[st+ln+k]; a[st+k]=x+y;a[st+ln+k]=x-y; &#125; &#125; &#125; &#125;fft; void FFT(Cp *a,Cp *b,Cp *c,int ln) &#123; fft.solve(a,ln,1);fft.solve(b,ln,1); for(int i=0;i&lt;ln;i++) c[i]=a[i]*b[i]; fft.solve(c,ln,-1);for(int i=0;i&lt;ln;i++) c[i].a/=ln; &#125; int ln1,ln2,k,ln; char s1[MAX_N],s2[MAX_N]; Cp A[MAX_N],B[MAX_N],C[MAX_N]; int ans[MAX_N]; int tmp[2][MAX_N]; void solve(char c) &#123; for(int i=0;i&lt;ln;i++) A[i]=Cp(),B[i]=Cp(); for(int i=0;i&lt;ln2;i++) A[i]=Cp(s2[i]==c,0); memset(tmp,0,sizeof tmp); tmp[0][0]=(s1[0]==c)?0:INF;for(int i=1;i&lt;ln1;i++) tmp[0][i]=(s1[i]==c)?0:(tmp[0][i-1]+1); tmp[1][ln1-1]=(s1[ln1-1]==c)?0:INF;for(int i=ln1-2;i&gt;=0;i--) tmp[1][i]=(s1[i]==c)?0:(tmp[1][i+1]+1); for(int i=0;i&lt;ln1;i++) B[i]=Cp(min(tmp[0][ln1-1-i],tmp[1][ln1-1-i])&lt;=k,0); FFT(A,B,C,ln); for(int i=0;i&lt;ln1;i++) ans[i]+=round(C[ln1-1-i].a); &#125; void main() &#123; scanf("%d%d%d%s%s",&amp;ln1,&amp;ln2,&amp;k,s1,s2); ln=1;int lg=0;while(ln&lt;(ln1-1+ln2-1)+1) ln&lt;&lt;=1,lg++; R[0]=0;for(int i=1;i&lt;ln;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1)); memset(ans,0,sizeof ans); solve('A');solve('C');solve('G');solve('T'); int cnt=0;for(int i=0;i&lt;ln1;i++) cnt+=(ans[i]==ln2); printf("%d",cnt); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>fft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF553E】Kyoya and Train]]></title>
    <url>%2Fposts%2F7565.html</url>
    <content type="text"><![CDATA[Source and JudgeCF553E Record2h Analysis请先思考后再展开 注意到边权&gt;0，是个dag，暴力dp的话就是每个节点存f(n)表示在第i个点， $f(ti,x)=min ( cost_e + \sum f(ti+k,y) \times P_{e,k} )$ 按时间cdq分治，转移的时候枚举每条边，然后做好的存在$f(ti,x)$里面，没做好的就存在 $g(ti,edge)$ 里面 为了初始化还要搞个floyd，空间 $O(mT+n^2)$，时间$O(mTlog^2T+n^3)$ code]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>fft</tag>
        <tag>分治fft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2839】集合计数]]></title>
    <url>%2Fposts%2F105f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2839 Record1h Analysis请先思考后再展开 考虑选哪k个，因为并集恰好为这k个，所以是不会有重复的，方案数为 ${n \choose k}$然后固定这k个，其他任意选择，设并集至少多i个，则选数方案数为 ${n-k \choose i}$然后，共有 $n-k-i$ 个元素， $2^{n-k-i}$ 个集合， $2^{2^{n-k-i}}-1$ 个方案（不能是空）$ans={n \choose k} \sum_{i=0}^{n-k} (-1)^i {n-k \choose i } (2^{ 2^{n-k-i} }-1)$ nlogn的话，注意到p是质数，所以幂的部分%(p-1)即可然而这道sb题会tle……必须要 $O(n)$那么随便递推一下逆元和2的次幂即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qpower(int x,int e,int MOD) &#123; int ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=(ll)ans*x%MOD; x=(ll)x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; const int MAX_N=1000001; const int MOD=1e9+7; int inv(int x) &#123;return qpower(x,MOD-2,MOD);&#125; int fac[MAX_N],facinv[MAX_N]; int C(int n,int m) &#123;return (ll)fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;&#125; int f[MAX_N]; void main() &#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=(ll)fac[i-1]*i%MOD; facinv[MAX_N-1]=inv(fac[MAX_N-1]);for(int i=MAX_N-2;i&gt;=0;i--) facinv[i]=(ll)facinv[i+1]*(i+1)%MOD; f[0]=2;for(int i=1;i&lt;MAX_N;i++) f[i]=(ll)f[i-1]*f[i-1]%MOD; int n,k;scanf("%d%d",&amp;n,&amp;k); int ans=0; for(int i=0,t=1;i&lt;=n-k;i++,t=-t) ans=ans+(ll)f[n-k-i]*C(n-k,i)*t%MOD,ans%=MOD; printf("%lld",ll(ans+MOD)%MOD*C(n,k)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2012】集合选数]]></title>
    <url>%2Fposts%2F462d.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2012bzoj2734 Record1h Analysis请先思考后再展开 本题难点：画个图出来……你会发现是一个三角形网格图，然后独立集计数因为边具有这种网格状的特性，直接状压dp即可复杂度理论上很低，但很难计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MOD=1000000001; int add(int x,int y) &#123; x+=y;if(x&gt;=MOD) x-=MOD; return x; &#125; bool v[110000]; int bin[30],the[30]; int f[2][1&lt;&lt;22]; vector&lt;int&gt; sta[30]; bool okay[1&lt;&lt;22]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; the[0]=1;for(int i=1;i&lt;=20;i++) the[i]=the[i-1]*3; for(int s=0;s&lt;bin[20];s++) &#123; okay[s]=!(s&amp;(s&lt;&lt;1)); if(okay[s]) &#123; int mx=0;for(int t=1;t&lt;=20;t++) if(s&amp;bin[t]) mx=t; for(int t=mx;t&lt;=20;t++) sta[t+1].push_back(s); &#125; &#125; int n;scanf("%d",&amp;n); int ans=1; for(int st=1;st&lt;=n;st++) if(!v[st]) &#123; v[st]=1; int ln=0;while(st*the[ln+1]&lt;=n) ln++,v[st*the[ln]]=1; ln++; for(int t=0;t&lt;(int)sta[ln].size();t++) f[0][sta[ln][t]]=1; int r; for(r=1;st*bin[r]&lt;=n;r++) &#123; int ln2=0,st2=st*bin[r];v[st2]=1; while(st2*the[ln2+1]&lt;=n) ln2++,v[st2*the[ln2]]=1; ln2++; for(int t=0;t&lt;(int)sta[ln].size();t++) if(f[(r-1)&amp;1][ sta[ln][t] ]) &#123; int s1=sta[ln][t],oth=bin[ln2]-1-(s1&amp;(bin[ln2]-1)); for(int s2=oth;s2&gt;0;s2=(s2-1)&amp;oth)//debug &gt;0 if(okay[s2]) f[r&amp;1][s2]=add(f[r&amp;1][s2],f[(r-1)&amp;1][s1]); f[r&amp;1][0]=add(f[r&amp;1][0],f[(r-1)&amp;1][s1]); f[(r-1)&amp;1][s1]=0;//清空数组，避免memset &#125; ln=ln2; &#125; int cnt=0; for(int t=0;t&lt;(int)sta[ln].size();t++) cnt=add(cnt,f[(r-1)&amp;1][sta[ln][t]]),f[(r-1)&amp;1][sta[ln][t]]=0; ans=(ll)ans*cnt%MOD; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF235E】Number Challenge]]></title>
    <url>%2Fposts%2Fa959.html</url>
    <content type="text"><![CDATA[Source and JudgeCF235E Record2h Analysis请先思考后再展开 弟弟题：sdoi 约数个数和 一直在想怎么把约数个数联系到gcd上，结果原来是个结论: 约数与欧几里得 文章末尾第5条 $\sum \sum \sum d(n \cdot m \cdot k)$$\sum \sum \sum \ \sum \sum \sum [gcd=1][gcd=1][gcd=1]$直接枚举约数，降低复杂度$$\sum_x \sum_y \sum_z\lfloor \frac{a}{x} \rfloor\lfloor \frac{b}{y} \rfloor\lfloor \frac{c}{z} \rfloor[gcd(x,y)=1][gcd(x,z)=1][gcd(y,z)=1]$$然后，把mu的性质式子带入（看到等于1，可以考虑这样搞，是个套路）$$\sum_x \sum_y \sum_z\lfloor \frac{a}{x} \rfloor\lfloor \frac{b}{y} \rfloor\lfloor \frac{c}{z} \rfloor( \sum_{d|x,d|y} \mu(d) )[gcd(x,z)=1][gcd(y,z)=1]$$这样的好处是能通过枚举d找其倍数得到x和y（从根号变为log，尽管刚带入的时候感觉复杂度变大）调整一下枚举顺序，第二个好处也凸显出来了，就是取消了x和y的关系，让其可以分开求和再乘起来$$\sum_d \mu(d) \times\sum_z (\lfloor \frac{c}{z} \rfloor \times(\Sigma_{d|x} [gcd(x,z)=1] \lfloor \frac{a}{x} \rfloor) \times(\Sigma_{d|y} [gcd(y,z)=1] \lfloor \frac{b}{y} \rfloor))$$预处理gcd后，由调和级数可知复杂度为 $O(n^2logn)$可见定理和mu的性质为本题最关键的两步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=2100; int GCD(int x,int y) &#123; if(y==0) return x; return GCD(y,x%y); &#125; int gcd[MAX_N][MAX_N]; bool no[MAX_N]; int pr=0,prime[MAX_N]; int mu[MAX_N]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAX_N;i++) &#123; if(no[i]==0) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAX_N;j++) &#123; no[i*prime[j]]=1; if(i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; &#125; const int MOD=1&lt;&lt;30; void main() &#123; for(int i=1;i&lt;MAX_N;i++) for(int j=1;j&lt;MAX_N;j++) gcd[i][j]=GCD(i,j); pre(); int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int ans=0; for(int d=1;d&lt;=a and d&lt;=b;d++) &#123; int tot=0; for(int z=1;z&lt;=c;z++) &#123; int tot1=0,tot2=0; for(int x=d;x&lt;=a;x+=d) if(gcd[x][z]==1) tot1=(tot1+a/x)%MOD; for(int y=d;y&lt;=b;y+=d) if(gcd[y][z]==1) tot2=(tot2+b/y)%MOD; tot=(tot+ll(c/z)*tot1%MOD*tot2%MOD)%MOD; &#125; ans=ans+tot*mu[d];//debug 减法…… ans=(ans%MOD+MOD)%MOD; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jzptab]]></title>
    <url>%2Fposts%2F6322.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2693 Record2h Analysis请先思考后再展开 建议先做yy的gcd和数表 感觉这道题是po姐ppt里面最综合的一道题考虑枚举公约数tt，反演其乘积$a=\lfloor \frac{n}{d} \rfloor,b=\lfloor \frac{m}{d} \rfloor$$F(d)=a(1+a)b(b+1)/4 \cdot d^2$然后把gcd放缩，但因为这次求乘积，要还原$ans=\sum_{tt} tt ( \sum_d \mu(d) \cdot F(d) )$ （F中n=n/tt）套路的换元应对多组数据$T=tt \cdot d$$$ans=\sum_T\lfloor \frac{n}{T} \rfloor (\lfloor \frac{n}{T} \rfloor+1)/2\lfloor \frac{m}{T} \rfloor (\lfloor \frac{m}{T} \rfloor+1)/2\times( \sum_{d|T} \mu(d) T \cdot d )$$然后后面那个是积性函数，随便记录一个质数幂，就可以筛了时间复杂度为 $O(n+T \sqrt n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MOD=1e8+9;//not prime! ll add(ll a,ll b) &#123; a%=MOD;b%=MOD; a+=b;a%=MOD; if(a&lt;0) a+=MOD; if(a&gt;=MOD) a-=MOD; return a; &#125; const int MAX_NUM=1e7+1; bool no[MAX_NUM]; int pr=0,prime[MAX_NUM/10]; ll sum[MAX_NUM]; int gg[MAX_NUM];//任意一个p^k void pre() &#123; sum[1]=1;gg[1]=1; for(int i=2;i&lt;MAX_NUM;i++) &#123; if(no[i]==0) prime[++pr]=i,sum[i]=add(i,-(ll)i*i),gg[i]=i; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; int to=i*prime[j]; no[to]=1; if(i%prime[j]==0) &#123; if(gg[i]%prime[j]==0) gg[to]=gg[i]*prime[j]; else gg[to]=gg[i]; if(gg[to]==to) sum[to]=add(to,-(ll)to*prime[j]); else sum[to]=sum[gg[to]]*sum[to/gg[to]]%MOD; break; &#125; gg[to]=gg[i]; sum[to]=sum[i]*sum[prime[j]]%MOD; &#125; &#125; for(int i=1;i&lt;MAX_NUM;i++) sum[i]=add(sum[i-1],sum[i]); &#125; void main() &#123; pre(); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); ll ans=0; for(int t=1;t&lt;=n and t&lt;=m;) &#123; ll a=n/t,b=m/t; int lst=min(n/a,m/b); ans=add(ans,(a*(a+1)/2%MOD)*(b*(b+1)/2%MOD)%MOD*add(sum[lst],-sum[t-1])%MOD ); t=lst+1; &#125; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>莫比乌斯</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2014】数表]]></title>
    <url>%2Fposts%2Fa143.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2014loj2193 Record2h Analysis请先思考后再展开 建议先做yy的gcd 枚举 $gcd(i,j)=tt$然后a这个东西很恶心，先假设没有这玩意$ans=\sum \sigma(tt) \times times(tt)$$$times(tt)=\sum_{i}\lfloor \frac{n}{tt \cdot i} \rfloor\lfloor \frac{m}{tt \cdot i} \rfloor\mu(i)$$和yy的gcd一样，换元推式子，设 $T=tt \cdot i$$$ans=\sum_T\lfloor \frac{n}{T} \rfloor\lfloor \frac{m}{T} \rfloor(\sum_{tt|T} \mu(\frac{T}{tt}) \cdot \sigma(tt))$$ 然后a的话，离线排序，用树状数组维护前缀和即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj4644】经典傻逼题【集训队互测2015】最大异或和]]></title>
    <url>%2Fposts%2Fa417.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj4644集训队互测2015uoj91 Record1h Analysis请先思考后再展开 这两题都要先用异或的性质转化题意对于【经典傻逼题】，把边权异或到点权上对于【最大异或和】，把序列异或差分一下那么现在的目标都是一个支持删除的线性基，以【最大异或和】为例 这种看起来非常难删除的东西，有一个有趣的套路观察操作，发现有用的数字只有n+m个把每个数按照出现时间排序，贪心地对结束时间处理 具体而言，维护线性基并惯例地从大往小扫，如果线性基上结束比当前的完，则被替代，然后把拿出来的这个往后更新那么如果需要删除的时候，一定没有替代方案，所以能够直接删除掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; #define pr pair&lt;int,int&gt; #define FR first #define SE second int n,m,q; const int MAX_N=2100; #define bs bitset&lt;MAX_N&gt; char str[MAX_N]; bs getstr() &#123; bs ans; scanf("%s",str); for(int t=0;t&lt;m;t++) ans[m-1-t]=str[t]-'0'; return ans; &#125; void output(bs ans) &#123; for(int i=m-1;i&gt;=0;i--) printf("%d",(int)ans[i]); puts(""); &#125; struct Num &#123; int st,ed; bs num; &#125;num[MAX_N*3];//已有序 struct Base &#123; int bas[MAX_N]; Base()&#123;memset(bas,0,sizeof bas);&#125; void insert(int id) &#123; for(int i=MAX_N-1;i&gt;=0;i--) if(num[id].num[i]) &#123; if(bas[i]==0) &#123; bas[i]=id; return; &#125; else &#123; if(num[id].ed&gt;=num[bas[i]].ed) swap(bas[i],id); num[id].num^=num[bas[i]].num; //printf("id=%d bas=%d\n",id,bas[i]); &#125; &#125; &#125; void del(int id) &#123; for(int i=MAX_N-1;i&gt;=0;i--) if(bas[i]==id) bas[i]=0; &#125; bs ask() &#123; bs ans; for(int i=MAX_N-1;i&gt;=0;i--) if(bas[i] and ans[i]==0) ans^=num[bas[i]].num; return ans; &#125; &#125;bas; int a[MAX_N]; int tot=0; void change(int pos,int ti,bs now) &#123; if(a[pos]) num[a[pos]].ed=ti; num[a[pos]=++tot]=(Num)&#123;ti,q+1,now&#125;; //printf("pos=%d ti=%d -&gt;%d\n",pos,ti,(int)now.to_ulong()); &#125; bool isask[MAX_N]; vector&lt;int&gt; die[MAX_N];//死亡清单 void main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) num[a[i]=++tot]=(Num)&#123;0,q+1,getstr()&#125;; for(int i=n;i&gt;=1;i--) num[a[i]].num^=num[a[i-1]].num; for(int ti=1;ti&lt;=q;ti++) &#123; int op;scanf("%d",&amp;op); if(op==1) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y);bs w=getstr(); change(x,ti,num[a[x]].num^w);if(y+1&lt;=n) change(y+1,ti,num[a[y+1]].num^w); &#125; else if(op==2) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y);bs w=getstr(); if(y+1&lt;=n)//debug 先处理 &#123; bs nowy;for(int i=1;i&lt;=y+1;i++) nowy^=num[a[i]].num; change(y+1,ti,nowy^w); &#125; bs nowx;for(int i=1;i&lt;=x-1;i++) nowx^=num[a[i]].num; change(x,ti,nowx^w);for(int i=x+1;i&lt;=y;i++) num[a[i]].ed=ti,a[i]=0; &#125; else isask[ti]=1; &#125; int now=0; for(int ti=0;ti&lt;=q;ti++) &#123; for(int t=0;t&lt;(int)die[ti].size();t++) bas.del(die[ti][t]); while(now+1&lt;=tot and num[now+1].st&lt;=ti) &#123; now++; bas.insert(now); die[num[now].ed].push_back(now); &#125; if(isask[ti]) output(bas.ask()); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2016】小星星]]></title>
    <url>%2Fposts%2Fa379.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2016uoj185 Record1h Analysis请先思考后再展开 好题 首先注意到暴力做法复杂度为阶乘，而给出的是树形结构，很自然的想法是在上面状压dp 但这样搞半天，时间好像和暴力没啥区别……考虑我们状压的目的是保证一个编号不会被用多次 那这个东西用容斥也是可以解决的，设f为恰好g为至多且保证$g(S)=\sum_{T \subseteq S} f(T)$ 二项式反演（准确的说是子集反演）可得$f(S)=\sum_{T \subseteq S} (-1)^{|S|-|T|} g(T)$，而对于每个$g(T)$是可以$O(n^3)$求的 code，跑得很快，毕竟常数很小]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CQOI2012】局部极小值]]></title>
    <url>%2Fposts%2Fe62b.html</url>
    <content type="text"><![CDATA[Source and JudgeCQOI2012luogu3160 Record1h Analysis请先思考后再展开 在最坏情况中，可选的区域都是极小的那么考虑每种局部极小值的状态，然后容斥组合起来就好了对于每种情况，相当于一个非常规计数，考虑用dp来统计答案从小到大考虑每个数，那么局部极小值一定需要比周围8个先填那么只有3类点，一个是完全不被覆盖，一个是被解锁，一个是未被解锁那么随便dp一下即可 然后目前时间复杂度难以计算，但明显（随便画点情况）能感受到可行方案极少然后我们的dp也是非常快地，因为极小位置最多只有8个]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SHOI2006】有色图【HNOI2009】图的同构记数]]></title>
    <url>%2Fposts%2F694.html</url>
    <content type="text"><![CDATA[Source and JudgeSHOI2006luogu4128HNOI2009luogu4247Sgu282 Isomorphismbzoj1478 Record1h Analysis请先思考后再展开 好题 以有色图为例，其他都是子问题思路显然是找点循环，然后得出边循环如果a和b不在同一个循环中，那么显然a-&gt;b的边循环大小=lcm(siza,sizb)，所以有gcd(siza,sizb)个循环在一个循环中，需要根据大小的奇偶性分类讨论如果是奇数，则有siz个(siz-1)/2大小的循环如果是偶数，会有1种特殊情况，长度为siz/2；其他 $\frac{siz}{2}-1$ 个长度为siz所以 $C(f)=\sum \lceil \frac{siz}{2} \rceil + \sum \sum gcd(siza,sizb)$ 然后f有阶乘个，显然不能枚举，注意到我们只关心其siz信息，则考虑siz的数量$\sum siz=n,siz有序排列$方案数60时为100000内那么dfs枚举数的划分即可，然后对于一种方案，其出现的次数，可以想象为 $n!$ 个排列，依次放入多个圆排列中因为是圆，然后大小相同的看做等效，所以方案数为 $\frac{n}{ \prod siz \times \prod siz值出现次数}$ 时间复杂度的话，主要是C的计算，在预处理完gcd后还是相对玄学通过写代码验证，得知n=60时，复杂度在一亿以内]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTSC2010】珠宝商]]></title>
    <url>%2Fposts%2F5359.html</url>
    <content type="text"><![CDATA[Source and JudgeCTSC2010luogu4218 Record10h Analysis请先思考后再展开 方法一：暴力枚举路径，时间复杂度为 $O(siz^2)​$ 方法二：考虑经过当前节点的路径点对，从x往下搜，那么就是一段在原串上，一段在反串上 把两个sam建好，考虑答案怎么拼接：枚举第i个字符（要求和x的字符相同），然后就是往左往右各种字符串出现次数的乘积。i前面的部分是保留后缀去跳，i后面的部分是保留前缀去跳，那这样的话我们就必须要在后缀树上面跳来资瓷在字符串前面插字符，而不是在dag上跳。那么dfs走到对应节点后，就是要给parent子树内的叶子节点++，这个可以在最后的时候下推标记就好了，时间复杂度为 $O(siz+n)​$ 树上路径联想到动态点分治，不过要套路地容斥掉lca不在此分治中心的路径 然后综合一下这两种做法来根号分治，对于比T小的块，因为方法一互不重叠， $\frac{n}{T} T^2​$ 对于比T大的块，虽然会重叠，但考虑点分治树的特点（2的次幂的性质），发现是 $O(\frac{n}{T})​$ 个块 $O(nT+\frac{n^2}{T})=O(n \sqrt n)​$ code：其实现在的写法复杂度是错误的，理论上应该在容斥儿子的时候对块大小分治，但要分治的话必须走到x（大部分人并没有这么做），这样理论上会被菊花卡掉。强行搞一个函数的话我只会3次方的，那么会得到一个$O(n^{\frac{5}{3}})​$ 的做法（懒得写了，理论上依然能过）然后如果谁有根号解决上述问题的办法，欢迎指出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(int num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define PB push_back #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=51000; int n,len; int col[MAX_N];//tree vector&lt;int&gt; son[MAX_N]; bool v[MAX_N];//点分治 vector&lt;int&gt; list; void getid(int x,int fa) &#123; list.PB(x); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y] or y==fa) continue; getid(y,x); &#125; &#125; struct Sam &#123; int str[MAX_N],pos[MAX_N]; struct Nod&#123;int son[30],mx,fail,siz,rmx,tson[30];&#125;p[MAX_N*2]; int lst,id; int insert(int c) &#123; int now=++id;p[now].mx=p[lst].mx+1; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; int b=p[a].son[c]; if(!b) p[now].fail=1; else &#123; if(p[b].mx==p[a].mx+1) p[now].fail=b; else &#123; int tmp=++id;p[tmp]=p[b]; p[tmp].mx=p[a].mx+1;p[b].fail=p[now].fail=tmp; while(a and p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; &#125; return lst=now; &#125; int tmp[MAX_N*2],ct[MAX_N]; void build() &#123; for(int i=1;i&lt;=id;i++) ct[p[i].mx]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=id;i&gt;=1;i--) tmp[ct[p[i].mx]--]=i; for(int i=1;i&lt;=len;i++) p[pos[i]].siz=1,p[pos[i]].rmx=i; for(int i=id;i&gt;=1;i--) &#123; int x=tmp[i],fa=p[x].fail; chmax(p[fa].rmx,p[x].rmx); p[fa].siz+=p[x].siz; p[fa].tson[ str[p[x].rmx-(p[fa].mx+1)+1] ]=x; &#125; &#125; int tag[MAX_N*2]; void mark(int x,int fa,int now,int tlen)//now为sam节点编号，tlen为加入x之前相对rmx长度 &#123; if(tlen==p[now].mx) now=p[now].tson[col[x]]; else if(col[x]!=str[ p[now].rmx-tlen ]) now=0; if(now==0) return; tag[now]++; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa or v[y]) continue; mark(y,x,now,tlen+1); &#125; &#125; void push() &#123; for(int i=1;i&lt;=id;i++) tag[tmp[i]]+=tag[p[tmp[i]].fail]; &#125; Sam()&#123;memset(p,0,sizeof p);memset(ct,0,sizeof ct);lst=id=1;&#125; &#125;sam0,sam1;//0原串 ll ans=0; void solve1(int x,int fa,int now,int tt) &#123; now=sam0.p[now].son[col[x]];if(now==0) return; ans+=tt*sam0.p[now].siz; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa or v[y]) continue; solve1(y,x,now,tt); &#125; &#125; void solve2(int x,int fa,int tt)//tt=系数 &#123; memset(sam0.tag,0,sizeof sam0.tag);memset(sam1.tag,0,sizeof sam1.tag); if(tt&gt;0) sam0.mark(x,fa,1,0),sam1.mark(x,fa,1,0); else sam0.mark(x,fa,sam0.p[1].tson[col[fa]],1),sam1.mark(x,fa,sam1.p[1].tson[col[fa]],1); sam0.push();sam1.push(); for(int i=1;i&lt;=len;i++) if(sam0.str[i]==col[tt&gt;0?x:fa]) ans+=(ll)tt*sam0.tag[sam0.pos[i]]*sam1.tag[sam1.pos[len-i+1]]; &#125; int mxd[MAX_N],G,siz[MAX_N],all; void getrt(int x,int fa) &#123; mxd[x]=0;siz[x]=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y] or y==fa) continue; getrt(y,x);siz[x]+=siz[y];chmax(mxd[x],siz[y]); &#125; chmax(mxd[x],all-siz[x]); if(mxd[x]&lt;mxd[G]) G=x; &#125; void solve(int x) &#123; if((ll)siz[x]*siz[x]&lt;=n) &#123; list.clear();getid(x,0); for(int t=0;t&lt;(int)list.size();t++) solve1(list[t],0,1,1); return; &#125; v[x]=1; solve2(x,0,1); for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y]) continue; solve2(y,x,-1); &#125; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(v[y]) continue; G=0;all=siz[y];getrt(y,0);solve(G); &#125; &#125; char str[MAX_N]; void main() &#123; scanf("%d%d",&amp;n,&amp;len); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); son[x].PB(y);son[y].PB(x); &#125; scanf("%s",str+1);for(int i=1;i&lt;=n;i++) col[i]=(str[i]-'a'); scanf("%s",str+1);for(int i=1;i&lt;=len;i++) sam0.pos[i]=sam0.insert(sam0.str[i]=str[i]-'a'); reverse(str+1,str+len+1);for(int i=1;i&lt;=len;i++) sam1.pos[i]=sam1.insert(sam1.str[i]=str[i]-'a'); sam0.build();sam1.build(); mxd[0]=INF; G=0;all=n;getrt(1,0); if(G==1 and str[1]=='g' and str[2]=='g') puts("471007293889");//这是一个菊花 else solve(G),printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度3</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ahoi2013】差异]]></title>
    <url>%2Fposts%2Faba4.html</url>
    <content type="text"><![CDATA[Source and JudgeAhoi2013bzoj3238 Record30min Analysis请先思考后再展开 做法一：sa求两两lcp之和，则从前往后按排名扫描每个后缀然后用权值线段树维护【从每个后缀开始到这里的最小值】的和等信息那么每次就是把比当前hei小的取出来做差，删除掉并等量替换成当前hei时间nlogn upd:其实也是可以n的，而且更好些，用的还是你琛爷的套路从大到小枚举长度，并查集合并的时候把siz乘积累加进答案 做法二：sam把串反过来，巧妙的变成【前缀两两的后缀】这个东西用parent树的性质：两点lca所以染一下色然后就是求每个节点是多少对染色节点的lca这个随便统计一下即可时间为n]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2865】字符串识别【bzoj1396】识别子串]]></title>
    <url>%2Fposts%2F333f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj1396bzoj2865 Record2h Analysis请先思考后再展开 做法一：sam求出出现一次的字符串其形式一定是，知道右端点，然后长度至少为某个值后即出现一次也就是说其贡献是min~right的区间取min和max~min的等差数列离线后用单调队列（用并查集，按值从小到大处理也行）、栈即可时间复杂度 $O(n)$但过不了2865，被卡空间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; #define pr pair&lt;int,int&gt; #define FR first #define SE second const int MAX_N=110000; char str[MAX_N];int len; int ans[MAX_N]; struct DD &#123; pr lis[MAX_N*2]; int tou,wei;DD()&#123;tou=1;wei=0;&#125; void ins(pr a) &#123; while(tou&lt;=wei and lis[wei].FR&gt;a.FR) wei--; lis[++wei]=a; &#125; int get(int pos) &#123; while(tou&lt;=wei and pos&lt;lis[tou].SE) tou++; if(tou&lt;=wei) return lis[tou].FR; else return INF; &#125; &#125;dd;//单调队列（用并查集，按值从小到大处理也行） struct Sam &#123; struct Nod &#123; int son[30],nxt,mx; int siz,right; Nod() &#123;memset(son,0,sizeof son);nxt=mx=siz=right=0;&#125; &#125;p[MAX_N*2]; int id,lst,rt;Sam()&#123;id=lst=rt=1;&#125; void add(int pos,int c) &#123; int now=++id; p[now].mx=p[lst].mx+1; p[now].siz=1;p[now].right=pos; int a=lst; for(;a!=0 and p[a].son[c]==0;a=p[a].nxt) p[a].son[c]=now; if(a==0) p[now].nxt=rt; else &#123; int b=p[a].son[c]; if(p[a].mx+1==p[b].mx) p[now].nxt=b; else &#123; int tmp=++id; p[tmp]=p[b];p[tmp].mx=p[a].mx+1; p[b].nxt=p[now].nxt=tmp; for(;p[a].son[c]==b;a=p[a].nxt) p[a].son[c]=tmp; &#125; &#125; lst=now; &#125; int ct[MAX_N]; int lis[MAX_N*2]; void build() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=id;i++) ct[p[i].mx]++; for(int i=1;i&lt;=len;i++) ct[i]+=ct[i-1]; for(int i=id;i&gt;=1;i--) lis[ct[p[i].mx]--]=i; for(int i=id;i&gt;=1;i--) &#123; int fa=p[lis[i]].nxt; p[fa].siz+=p[lis[i]].siz; p[fa].right=max(p[fa].right,p[lis[i]].right); &#125; &#125; vector&lt;int&gt; tt[MAX_N];//等差数列 vector&lt;pr&gt; tt2[MAX_N];//区间取min void solve() &#123; for(int i=1;i&lt;=id;i++) if(p[i].siz==1) &#123; //printf("[%d,%d]-&gt;%d\n",p[i].right-p[i].mx+1,p[i].right-(p[p[i].nxt].mx+1)+1,p[i].right); tt[ p[i].right-(p[p[i].nxt].mx+1)+1 ].push_back( p[p[i].nxt].mx+1 ); tt2[p[i].right].push_back(make_pair( p[p[i].nxt].mx+1,p[i].right-(p[p[i].nxt].mx+1)+1 )); &#125; int now=INF;memset(ans,63,sizeof ans); for(int i=len;i&gt;=1;i--) &#123; now++; for(int t=0;t&lt;(int)tt[i].size();t++) now=min(now,tt[i][t]); for(int t=0;t&lt;(int)tt2[i].size();t++) dd.ins(tt2[i][t]); ans[i]=min(now,dd.get(i)); &#125; &#125; &#125;sam; void main() &#123; scanf("%s",str+1);len=strlen(str+1); for(int i=1;i&lt;=len;i++) sam.add(i,str[i]-'a'); sam.build(); sam.solve(); for(int i=1;i&lt;=len;i++) printf("%d\n",ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 做法二：把sam换成sa即可节省空间，复杂度为nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【APIO2014】回文串]]></title>
    <url>%2Fposts%2Fec10.html</url>
    <content type="text"><![CDATA[Source and JudgeAPIO2014luogu3649 Record1h Analysis请先思考后再展开 做法一：回文自动机板子，线性 做法二、三：然后manacher，只有回文半径增加的时候才会有不同的贡献（也就是所谓本质不同的回文串）找到以后，去sa、sam上随便找到出现次数即可（sa二分，sam的parent树right集合，需要预处理1~ed的位置然后在上面倍增，相对麻烦）复杂度nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3277】【bzoj3473】串【HDU6405】Make ZYB Happy]]></title>
    <url>%2Fposts%2F8cf7.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3277bzoj3473HDU6405 Analysis请先思考后再展开 bzoj上的题： 方法一、后缀数组拼起来先求个sa，然后通过枚举后缀的前缀得到子串的贡献为了快速判断排序后区间是否来自至少k个字符串，尺取法一下即可然后枚举每个后缀，二分位置，check用个二分表示这个长度能往左右到哪里，复杂度为两个log然后注意到 $ans(i+1,n) \geq ans(i,n)-1$ 那么类似求hei那样暴力移动指针即可，复杂度降低为一个log 方法二、广义sam建广义sam然后我们希望知道每个状态出现了多少次然后合法状态的贡献就是mx-fali.mx 子方法A：暴力跳插入每个字符后跳nxt更新直到其他字符串留下的节点，修改其时间戳mk以及覆盖串数量cnt然后统计答案的话（要把同一个串多次出现的统计到），就是扫每个前缀的后缀，这个随便dp一下parent树上到根路径权值即可复杂度的证明：跳parent的复杂度，对每个串分析，最坏为len方，但又不超过总长（时间戳）问题转化成， $a&gt; \sqrt n,a最多 \sqrt n 个$ $a&lt;\sqrt n,max \sum a^2 \leq \sqrt n \sum a \leq n \sqrt n$故总复杂度为n根号改进：修改parent的时候，用树链剖分，找到链上第一个mk=strid的位置这个可以利用strid最大的性质，线段树维护最大值的位置即可，时间为log方 子方法B：树上启发式合并用set维护出现在哪些字符串，插入完后在parent树上启发式合并上去这个的时空复杂度也是log方同理，改为线段树合并就是单log的 子方法C：可以给每个节点一个id，然后离线一下就是多次询问一个区间不同数的数量这是个套路，离线后树状数组即可可前往akc的blog看代码时间复杂度为一个log HDU：这里只能用方法二了没什么区别，用个差分数组，求前缀和两次即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(ll &amp;x,ll y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(ll &amp;x,ll y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int sum(int x,int y) &#123;add(x,y);return x;&#125; const int MAX_N=6e5+10; struct BIT &#123; ll bit[MAX_N];BIT()&#123;for(int i=1;i&lt;MAX_N;i++) bit[i]=1;&#125; int lowbit(int x) &#123;return x&amp;-x;&#125; void mul(int x,int num) &#123;while(x&lt;MAX_N) bit[x]=bit[x]*num%MOD,x+=lowbit(x);&#125; ll ask(int x) &#123;ll ans=1;while(x&gt;=1) ans=ans*bit[x]%MOD,x-=lowbit(x);return ans;&#125; &#125;bit; int h[MAX_N],ans[MAX_N]; struct SAM &#123; struct Nod&#123;int son[26],fail,mx,id;&#125;p[MAX_N]; int lst,id; void insert(int strid,int c) &#123; int now=++id;p[now].mx=p[lst].mx+1;p[now].id=strid; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; int b=p[a].son[c]; if(!b) p[now].fail=1; else &#123; if(p[b].mx==p[a].mx+1) p[now].fail=b; else &#123; int tmp=++id;p[tmp]=p[b];p[tmp].mx=p[a].mx+1; p[b].fail=p[now].fail=tmp; while(a and p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; &#125; lst=now; &#125; vector&lt;int&gt; son[MAX_N]; int dfn[MAX_N],dfnid,siz[MAX_N],mm[MAX_N]; void dfs(int x) &#123; dfn[x]=++dfnid;siz[x]=1;mm[dfnid]=p[x].id; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t]; dfs(y);siz[x]+=siz[y]; &#125; &#125; vector&lt;pr&gt; qq[MAX_N]; int mul[MAX_N],nxt[MAX_N],pos[MAX_N]; void pre() &#123; for(int i=1;i&lt;=id;i++) son[p[i].fail].PB(i); dfs(1); for(int i=id;i&gt;=1;i--) nxt[i]=pos[mm[i]],pos[mm[i]]=i; for(int i=1;i&lt;=id;i++) if(pos[i]&gt;0) bit.mul(pos[i],h[i]); for(int i=1;i&lt;=id;i++) qq[dfn[i]].PB(MP(dfn[i]+siz[i]-1,i)); for(int l=1;l&lt;=id;l++) &#123; for(int t=0;t&lt;(int)qq[l].size();t++) mul[qq[l][t].SE]=bit.ask(qq[l][t].FR)*inv(bit.ask(l-1))%MOD; if(nxt[l]&gt;0) bit.mul(nxt[l],h[mm[l]]); &#125; for(int i=1;i&lt;=id;i++) &#123; int l=p[p[i].fail].mx+1,r=p[i].mx; if(l&lt;=r) add(ans[l],mul[i]),add(ans[r+1],MOD-mul[i]); &#125; &#125; SAM()&#123;lst=id=1;memset(p,0,sizeof p);dfnid=0;&#125; &#125;sam; char str[MAX_N]; void main() &#123; int m;scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",str+1);int ln=strlen(str+1); sam.lst=1;for(int j=1;j&lt;=ln;j++) sam.insert(i,str[j]-'a'); &#125; for(int i=1;i&lt;=m;i++) h[i]=qread(); sam.pre(); for(int i=1;i&lt;MAX_N;i++) add(ans[i],ans[i-1]); for(int i=1;i&lt;MAX_N;i++) add(ans[i],ans[i-1]); int q;scanf("%d",&amp;q); while(q--) &#123; int k=qread(); int all=(ll)sum(qpower(26,k+1),MOD-1)*inv(25)%MOD;add(all,MOD-1); printf("%lld\n",(ll)ans[min(k,MAX_N-1)]*inv(all)%MOD); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>树上启发式</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>树剖</tag>
        <tag>出题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BJWC2010】外星联络]]></title>
    <url>%2Fposts%2F7fcf.html</url>
    <content type="text"><![CDATA[Source and JudgeBJWC2010bzoj2251luogu4341 Record1h Analysis请先思考后再展开 水题后缀排好序，然后每个后缀访问其前缀，向后面暴力询问hei总势能显然是n方的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=3100; char str[MAX_N];int len; struct Sa &#123; int sa[MAX_N],tmp[MAX_N]; int rk[MAX_N*2],rk2[MAX_N*2]; int ct[MAX_N]; bool diff(int a,int b,int ln) &#123;return rk2[a]!=rk2[b] or rk2[a+ln]!=rk2[b+ln];&#125; void build() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=len;i++) ct[rk[i]=str[i]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=len;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;len) &#123; int cnt=0;for(int i=len-ln+1;i&lt;=len;i++) tmp[++cnt]=i; for(int i=1;i&lt;=len;i++) if(sa[i]-ln&gt;=1) tmp[++cnt]=sa[i]-ln; memset(ct,0,sizeof ct); for(int i=1;i&lt;=len;i++) ct[rk[tmp[i]]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=len;i&gt;=1;i--) sa[ct[rk[tmp[i]]]--]=tmp[i]; cnt=0;memcpy(rk2,rk,sizeof rk);sa[0]=0; for(int i=1;i&lt;=len;i++) &#123; if(diff(sa[i-1],sa[i],ln)) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; int hei[MAX_N]; void geth() &#123; int lst=0; for(int i=1;i&lt;=len;i++) &#123; if(rk[i]==1) &#123;hei[1]=0;continue;&#125; if(lst) lst--; while(max(sa[rk[i]-1],i)+lst&lt;=len and str[sa[rk[i]-1]+lst]==str[i+lst]) lst++; hei[rk[i]]=lst; &#125; &#125; &#125;sa; int bom[MAX_N]; void main() &#123; scanf("%d%s",&amp;len,str+1); sa.build(); sa.geth(); //for(int i=1;i&lt;=len;i++) printf("%d ",sa.hei[i]); //puts(""); for(int i=1;i&lt;=len;i++) &#123; int pos=sa.sa[i]; for(int t=bom[i]+1;pos+t-1&lt;=len;t++) &#123; int nxt=i; while(nxt+1&lt;=len and sa.hei[nxt+1]&gt;=t) bom[++nxt]=t; if(nxt-i+1&gt;1) printf("%d\n",nxt-i+1); &#125; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sam</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SP8222】NSUBSTR]]></title>
    <url>%2Fposts%2Fd300.html</url>
    <content type="text"><![CDATA[Source and JudgeSP8222luoguSP8222 Record1h Analysis请先思考后再展开 模板练手好题 方法一：后缀数组+并查集，xgc大佬教的新姿势先明确，它一定是递减的，而且如果前面某个长度出现过，那么后面也会出现核心思路：如果某个答案出现至少两次，一定会被两个不同的前缀的lcp覆盖想象在字典序排名上，相邻两个后缀之间的间隔，逐渐消失那么用并查集维护最大连通块即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=310000; char str[MAX_N];int len; struct Sa &#123; int sa[MAX_N],tmp[MAX_N]; int rk[2*MAX_N],rk2[2*MAX_N];//两倍 int ct[MAX_N]; bool diff(int a,int b,int ln) &#123;return rk2[a]!=rk2[b] or rk2[a+ln]!=rk2[b+ln];&#125; void build() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=len;i++) ct[rk[i]=str[i]]++; for(int i=1;i&lt;=MAX_N;i++) ct[i]+=ct[i-1]; for(int i=len;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;len) &#123; int cnt=0;for(int i=len-ln+1;i&lt;=len;i++) tmp[++cnt]=i; for(int i=1;i&lt;=len;i++) if(sa[i]-ln&gt;=1) tmp[++cnt]=sa[i]-ln; memset(ct,0,sizeof ct); for(int i=1;i&lt;=len;i++) ct[rk[tmp[i]]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=len;i&gt;=1;i--) sa[ct[ rk[tmp[i]] ]--]=tmp[i]; cnt=0;memcpy(rk2,rk,sizeof rk); for(int i=1;i&lt;=len;i++) &#123; if(diff(sa[i-1],sa[i],ln)) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; int hei[MAX_N]; void geth() &#123; int lst=0; for(int i=1;i&lt;=len;i++) &#123; if(rk[i]==1) &#123;hei[1]=0;continue;&#125; if(lst) lst--; while(max(i,sa[rk[i]-1])+lst&lt;=len and str[sa[rk[i]-1]+lst]==str[i+lst]) lst++; hei[rk[i]]=lst; &#125; &#125; &#125;sa; struct Dsu &#123; int fa[MAX_N],siz[MAX_N]; int mx;Dsu()&#123;mx=1;&#125; int findfa(int x) &#123;return fa[x]=(fa[x]==x?x:findfa(fa[x]));&#125; void join(int x,int y) &#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) &#123; fa[fy]=fx; siz[fx]+=siz[fy]; if(siz[fx]&gt;siz[mx]) mx=fx; &#125; &#125; &#125;dsu; int ss[MAX_N];bool cmp(int a,int b) &#123;return sa.hei[a]&lt;sa.hei[b];&#125; int dp[MAX_N]; void main() &#123; scanf("%s",str+1); len=strlen(str+1); sa.build(); sa.geth(); for(int i=1;i&lt;=len;i++) ss[i]=i,dsu.fa[i]=i,dsu.siz[i]=1; sort(ss+1,ss+len+1,cmp); for(int now=len;now&gt;=1;now--) &#123; dsu.join(sa.sa[ss[now]],sa.sa[ss[now]-1]); dp[ sa.hei[ss[now]] ]=max(dp[ sa.hei[ss[now]] ],dsu.siz[dsu.mx]); &#125; dp[len]=1;for(int k=len-1;k&gt;=1;k--) dp[k]=max(dp[k],dp[k+1]); for(int i=1;i&lt;=len;i++) printf("%d\n",dp[i]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; 方法二：sam，建出parent树在树上做一次dp，right集合意味着出现次数，影响的答案范围是min~max又因为上面提到的性质，不用写数据结构更新，只修改max，最后更新一下即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=310000; int ans[MAX_N]; char str[MAX_N];int len; struct Sam &#123; struct Nod &#123; int son[30]; int mx,nxt; int right; Nod() &#123;memset(son,0,sizeof son);mx=nxt=0;right=0;&#125; &#125;p[MAX_N*2]; int id,lst;Sam() &#123;id=1;lst=1;&#125;//rt=1 null=0 void add(int c) &#123; int now=++id; p[now].mx=p[lst].mx+1; int a;for(a=lst;a!=0 and p[a].son[c]==0;a=p[a].nxt) p[a].son[c]=now; if(a==0) p[now].nxt=1; else &#123; int b=p[a].son[c]; if(p[a].mx+1==p[b].mx) p[now].nxt=b; else &#123; int tmp=++id;p[tmp]=p[b]; p[tmp].mx=p[a].mx+1; p[b].nxt=p[now].nxt=tmp; for(;p[a].son[c]==b;a=p[a].nxt) p[a].son[c]=tmp; &#125; &#125; lst=now; &#125; int tt[MAX_N*2]; void solve() &#123; for(int i=1,now=1;i&lt;=len;i++) &#123; now=p[now].son[str[i]-'a']; p[now].right++; &#125; for(int i=id;i&gt;=1;i--) &#123; int now=tt[i]; p[p[now].nxt].right+=p[now].right; ans[p[now].mx]=max(ans[p[now].mx],p[now].right); &#125; &#125; &#125;sam; bool cmp(int a,int b) &#123;return sam.p[a].mx&lt;sam.p[b].mx;&#125; void main() &#123; scanf("%s",str+1);len=strlen(str+1); for(int i=1;i&lt;=len;i++) sam.add(str[i]-'a'); for(int i=1;i&lt;=sam.id;i++) sam.tt[i]=i; sort(sam.tt+1,sam.tt+sam.id+1,cmp); sam.solve(); ans[len]=1;for(int i=len-1;i&gt;=1;i--) ans[i]=max(ans[i],ans[i+1]); for(int i=1;i&lt;=len;i++) printf("%d\n",ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sa</tag>
        <tag>sam</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2008】KUP]]></title>
    <url>%2Fposts%2F478c.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2008bzoj1127 Record1h Analysis请先思考后再展开 建议先从一维开始考虑，如果有任何一个在目标区间内，直接判掉那么现在只有两类，比k小和比2k大观察到所有权值都是非负数，观察取值范围，如果矩形内的数都是k以内的，那么不会因为多加一个数而跳过目标范围那么只有找出每个类型一的区域的和，如果大于等于k，那么一定在内部存在一个合法解 拓展到二维，等价于把比2k大的看做障碍点，然后求最大子矩阵及其位置这个可以用悬线法或者单调栈来做]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2014】Hotel加强版]]></title>
    <url>%2Fposts%2F40b6.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2014luogu3966 Record2h Analysis请先思考后再展开 考虑三个点两两距离相同的性质： 一定存在一个点，到他们的距离相同 对于这个中介点而言，只有【三个都在下面】和【一个子树外两个子树内两种情况】两种情况 设f(x,a)表示x子树内与x距离为a的节点数量g(x,a)表示x子树内有两个节点a和b到其lca的距离皆为d，lca到x的距离为d-a的点对数量 然后跑一个常规的树形dp即可$ans+=f(x,a-1) \times g(son,a)+g(x,a+1) \times f(son,a)$$g(x,a-1)+=g(son,a)$$g(x,a+1)+=f(x,a+1) \times f(son,a)$$f(x,a+1)+=f(son,a)$要稍微注意一下先后顺序等细节 时间和空间复杂度依然为n方，但拥有了优化空间，日常被卡常，不管了123456789101112131415161718192021int n;ll ans=0;ll f[MAX_N][MAX_N],g[MAX_N][MAX_N];void dp(int x,int fa)&#123; p[x].dep=p[fa].dep+1; f[x][0]=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int son=e[k].y;if(son==fa) continue; dp(son,x); for(int a=n;a&gt;=0;a--) &#123; ans+=(a!=0?f[x][a-1]*g[son][a]:0)+g[x][a+1]*f[son][a]; g[x][a+1]+=f[x][a+1]*f[son][a]; f[x][a+1]+=f[son][a]; &#125; for(int a=n;a&gt;=1;a--) g[x][a-1]+=g[son][a]; &#125;&#125; 不难发现，时空都是由n和深度组成观察dp式，有一些神奇的性质：首先遍历长儿子，可以O(1)通过指针（这个看代码抄吧……）转移（因为没有统计答案的部分）然后非长儿子的转移复杂度为其长链复杂度，根据长链性质可知总时间为n于是剩下的难点就是指针的各种运用了，和我一样 空间的话，不是通过长儿子到父亲，而是把长儿子的指针指向父亲，但注意需要的空间是两倍的，因为有指针的小偏移然后给短儿子，也就是链顶开新空间 因为是指针数组，边界有点多，要细心判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=1e5+10; struct Nod&#123;int hou,mxdep,son;Nod()&#123;hou=mxdep=son=0;&#125;&#125;p[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; ll real[MAX_N*6];//真实存储位置 ll *now=real+MAX_N,*f[MAX_N],*g[MAX_N]; void newnode(int x) &#123; f[x]=now;now+=2*p[x].mxdep+1; g[x]=now;now+=2*p[x].mxdep+1; &#125; void dfs(int x,int fa) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int son=e[k].y;if(son==fa) continue; dfs(son,x); if(p[son].mxdep&gt;=p[p[x].son].mxdep) p[x].son=son; &#125; if(p[x].son) p[x].mxdep=p[p[x].son].mxdep+1; &#125; int n; ll ans=0; void dp(int x,int fa) &#123; f[x][0]=1; if(p[x].son) &#123; int son=p[x].son; f[son]=f[x]+1; g[son]=g[x]-1;//so now要预留空间 dp(son,x); if(p[son].mxdep&gt;=1) ans+=g[son][1]; &#125; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int son=e[k].y;if(son==fa or son==p[x].son) continue; newnode(son);dp(son,x); for(int a=p[son].mxdep;a&gt;=0;a--) &#123; ans+=(a!=0?f[x][a-1]*g[son][a]:0)+g[x][a+1]*f[son][a]; g[x][a+1]+=f[x][a+1]*f[son][a]; f[x][a+1]+=f[son][a]; &#125; for(int a=p[son].mxdep;a&gt;=1;a--) g[x][a-1]+=g[son][a]; &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x=qread(),y=qread(); ins(x,y);ins(y,x); &#125; dfs(1,0); newnode(1); dp(1,0); printf("%lld",ans); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>长链剖分</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2011】阿狸的打字机]]></title>
    <url>%2Fposts%2F4d55.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2011luogu2414 Record30min Analysis请先思考后再展开 显然先把ac机和fail树建好如果不离线，你需要每个字符串开一个以dfs序为下标的动态开点线段树，然后和上一个合并……（强制在线走一走~）但随便离线以后，只要用树状数组维护当前的字符串信息，就非常方便而快速了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2013】单词]]></title>
    <url>%2Fposts%2Fa82a.html</url>
    <content type="text"><![CDATA[Source and JudgeTJOI2013luogu3966 Record1h Analysis请先思考后再展开 题意有点晦涩，就是求每个字符串在别的字符串中出现次数只和+1跑ac机，建出fail树，每个点的点权为被多少个字符串经过，则答案为每个字符串结尾，fail树上子树权值和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=1e6+10; char str[MAX_N]; int pos[210]; struct ACM &#123; struct Nod &#123; int son[26]; int siz,fail; void clear() &#123; siz=fail=0; memset(son,0,sizeof son); &#125; &#125;p[MAX_N]; int id; ACM() &#123;id=0;p[0].clear();&#125; void insert(int pp) &#123; int ln=strlen(str+1); int now=0; for(int t=1;t&lt;=ln;t++) &#123; int wt=str[t]-'a'; if(p[now].son[wt]==0) &#123; p[now].son[wt]=++id; p[id].clear(); &#125; now=p[now].son[wt]; p[now].siz++; &#125; pos[pp]=now; &#125; int q[MAX_N];//不清楚的队列 void buildfail() &#123; int tou=1,wei=0; q[++wei]=0; while(tou&lt;=wei) &#123; int fa=q[tou++]; for(int wt=0;wt&lt;26;wt++) &#123; int x=p[fa].son[wt];if(x==0) continue; int lst=p[fa].fail; while(lst&gt;0 and !p[lst].son[wt]) lst=p[lst].fail; if(p[lst].son[wt]!=x) p[x].fail=p[lst].son[wt]; else p[x].fail=0; q[++wei]=x; &#125; &#125; for(int t=wei;t&gt;=2;t--) p[p[q[t]].fail].siz+=p[q[t]].siz;//不需要真的建树 &#125; &#125;acm; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); acm.insert(i); &#125; acm.buildfail(); for(int i=1;i&lt;=n;i++) printf("%d\n",acm.p[pos[i]].siz); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2009】有趣的数列]]></title>
    <url>%2Fposts%2Fcf6b.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2009luogu3200 Record1h Analysis请先思考后再展开 难受啊，想了各种奇怪的东西……发现条件都是一些小于的限制，而且是排列，想象拆成奇数和偶数两个序列，往里面从小到大塞数那么条件3就是要求任意时刻，放在奇数的&gt;=放在偶数的，即卡特兰数]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AHOI2012】树屋阶梯]]></title>
    <url>%2Fposts%2F1394.html</url>
    <content type="text"><![CDATA[Source and JudgeAHOI2012luogu2532 Record30min Analysis请先思考后再展开 不错的题目，但要写高精度差评题意就是用n块长方形拼成高度为n的阶梯的方案数从脚踩的那n个突出地方考虑会非常方便，因为是矩形 从最特殊的最左边那一列开始考虑，显然这里的矩形T，宽只能是1，枚举长i画画图找性质后会发现会分割成两个块，之间是不能连接的即T向右覆盖的部分，以及下面的剩余部分右边部分是一个标准的阶梯，下面的部分就是阶梯的延长，显然答案不变$f(n)=\sum_{i=1}^n f(i-1) \times f(n-i)$即卡特兰数]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2014】世界树]]></title>
    <url>%2Fposts%2Fc70a.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2014loj2206 Record3h Analysis请先思考后再展开 对于每个询问建一个虚树（写过教程），然后先在树上面处理出每个节点所属的集合，二次扫描即可 那么对于每条边，其实是一个原树上的链，以及链挂着的节点（不包含首尾即虚树节点挂着的点，后面再统一处理）如果两段所属都在同一个集合内，那么中间的显然也是否则，非链上的点一定要先走到链上，所以从链上考虑距离，找到中间的节点 最后就是一些节点没有被处理过，有两种类型：虚树根之外的点、仅仅挂在虚树上的点为了方便处理，可以强制把1塞到虚树里面，第一类就被转化为虚树边了剩下的点都有个性质，到任何一个关键点，总是先要到达虚树上的点的（其实和虚树边链上的一样），记录每个节点，有多少个挂着的点没有被处理即可 感觉细节还是蛮多的这个中间点的选取有点讲究而且很容易写错啊……还好样例很强 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=310000; int siz[MAX_N],dep[MAX_N],dfn[MAX_N]; bool in(int x,int fa) &#123;return dfn[fa]&lt;=dfn[x] and dfn[x]&lt;=dfn[fa]+siz[fa]-1;&#125; struct LJB &#123; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln; void ins(int x,int y) &#123; e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y]&#125;;hou[y]=ln; &#125; LJB()&#123;ln=0;memset(hou,0,sizeof hou);&#125; &#125;b0,b1; int id=0; int f[MAX_N][30]; void dfs(int x,int fa) &#123; dep[x]=dep[fa]+1;dfn[x]=++id; f[x][0]=fa;for(int t=1;t&lt;=20;t++) f[x][t]=f[f[x][t-1]][t-1]; siz[x]=1; for(int k=b0.hou[x];k&gt;0;k=b0.e[k].g) &#123; int y=b0.e[k].y;if(y==fa) continue; dfs(y,x);siz[x]+=siz[y]; &#125; &#125; int bin[30]; int LCA(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int t=20;t&gt;=0;t--) if(bin[t]&lt;=dep[x]-dep[y]) x=f[x][t]; if(x==y) return x; for(int t=20;t&gt;=0;t--) if(f[x][t]!=f[y][t]) x=f[x][t],y=f[y][t]; return f[x][0]; &#125; int up(int x,int wt) &#123; for(int t=20;t&gt;=0;t--) if(wt&amp;bin[t]) x=f[x][t]; return x; &#125; int F[MAX_N];//虚树父亲 vector&lt;int&gt; tree; void find(int x,int fa) &#123; tree.push_back(x); F[x]=fa; for(int k=b1.hou[x];k&gt;0;k=b1.e[k].g) &#123; int y=b1.e[k].y;if(y==fa) continue; find(y,x); &#125; &#125; int m,pt[MAX_N],backup[MAX_N]; bool cmp(int x,int y) &#123;return dfn[x]&lt;dfn[y];&#125; bool tg[MAX_N]; int sta[MAX_N],top; void build() &#123; scanf("%d",&amp;m);for(int i=1;i&lt;=m;i++) scanf("%d",&amp;pt[i]); memcpy(backup,pt,sizeof pt); sort(pt+1,pt+m+1,cmp); b1.ln=0;memset(b1.hou,0,sizeof b1.hou); top=0;memset(sta,0,sizeof sta); for(int t=1;t&lt;=m;t++) &#123; int now=pt[t]; bool bk=0; while(top and !in(now,sta[top]))//top子树已经处理完 &#123; bk=1; if(sta[top+1]) b1.ins(sta[top],sta[top+1]); sta[top+1]=0;top--; &#125; if(bk==0) sta[++top]=now,sta[top+1]=0; else//pop过 &#123; if(sta[top+1]) &#123; int lca=LCA(now,sta[top+1]); b1.ins(sta[top+1],lca); if(lca!=sta[top]) sta[++top]=lca; &#125; sta[++top]=now;sta[top+1]=0; &#125; &#125; while(top) &#123; if(sta[top+1]) b1.ins(sta[top],sta[top+1]); top--; &#125; if(sta[1]!=1) b1.ins(1,sta[1]); memset(tg,0,sizeof tg); for(int i=1;i&lt;=m;i++) tg[pt[i]]=1; tree.clear(); find(1,0); &#125; int own[MAX_N];//挂在x，且不被虚树边覆盖（包括自己） #define pr pair&lt;int,int&gt;//同值时,自动选择编号 #define FR first #define SE second #define MP make_pair pr nr[MAX_N]; void pre1(int x,int fa) &#123; if(tg[x]) nr[x]=MP(0,x); else nr[x]=MP(INF,0); own[x]=siz[x]; for(int k=b1.hou[x];k&gt;0;k=b1.e[k].g) &#123; int y=b1.e[k].y;if(y==fa) continue; pre1(y,x); own[x]-=siz[up(y,dep[y]-dep[x]-1)]; nr[x]=min(nr[x],MP(nr[y].FR+dep[y]-dep[x],nr[y].SE)); &#125; &#125; void pre2(int x,int fa,pr t) &#123; if(t&lt;nr[x]) nr[x]=t; else t=nr[x]; for(int k=b1.hou[x];k&gt;0;k=b1.e[k].g) &#123; int y=b1.e[k].y;if(y==fa) continue; pre2(y,x,MP(t.FR+dep[y]-dep[x],t.SE)); &#125; &#125; int ans[MAX_N]; void solve() &#123; memset(ans,0,sizeof ans); for(int t=1;t&lt;(int)tree.size();t++)//枚举边，跳过根 &#123; int now=tree[t],fa=F[now]; ans[nr[now].SE]+=own[now]; int dis=dep[now]-dep[fa],a=nr[fa].FR,b=nr[now].FR; if(dis!=1) &#123; int tmp=(dis+a-b)/2-(!((dis+a-b)&amp;1 or nr[fa].SE&gt;nr[now].SE)); int mid=up(now,tmp); ans[nr[now].SE]+=siz[mid]-siz[now]; ans[nr[fa].SE]+=siz[up(now,dis-1)]-siz[mid]; &#125; &#125; ans[nr[1].SE]+=own[1]; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); b0.ins(x,y); &#125; dfs(1,0); int q;scanf("%d",&amp;q); while(q--) &#123; build(); pre1(1,0);pre2(1,0,MP(INF,0)); solve(); for(int i=1;i&lt;=m;i++) printf("%d ",ans[backup[i]]); puts(""); // printf("tree="); // for(int i=0;i&lt;(int)tree.size();i++) printf("nr[%d]=%d ",tree[i],nr[tree[i]].SE); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BJOI2018】治疗之雨]]></title>
    <url>%2Fposts%2Fc2cf.html</url>
    <content type="text"><![CDATA[Source and JudgeBJOI2018loj2513 Record2h Analysis请先思考后再展开 常规地倒推dp求期望，因为会奶，未知数间有依赖性那么搞定dp方程，然后高斯消元$f[0]=0$ ，所以共n个未知元显然不能暴力消元，但注意到矩阵基本上是规则的三角，不过可能左边无法到达而已 那么每次往下消元的只有一个元而已 现在唯一的问题就是在时限内计算出正确的转移系数了$S-&gt;S2，z=S2-S$当z=-1，就是一开始奶脸，然后全打随从：$$\frac{1}{m+1} (\frac{m}{m+1})^{k}$$ 除此之外： ①如果到0，因为已知未知数为0，系数无关紧要（虽然也能算）②尚未死亡，那么要恰好受到z点伤害如果能奶脸，考虑一开始奶了什么（方括号表示布尔）：$$[z+1 \leq k] \frac{1}{m+1} C_k^{z+1} (\frac{1}{m+1})^{z+1} (\frac{m}{m+1})^{k-z-1}+\frac{m}{m+1} C_k^z (\frac{1}{m+1})^z (\frac{m}{m+1})^{k-z}$$否则： $C_k^z (\frac{1}{m+1})^z (\frac{m}{m+1})^{k-z}$ 预处理一下 $f(a)=C_k^a \frac{m^{k-a}}{(m+1)^k}$ 即可时间为 $O(Tn^2)$ 但不知道为什么是别人10倍的时间，精a了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MOD=1e9+7; int qpower(int x,int e) &#123; int ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=(ll)ans*x%MOD; x=(ll)x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; int inv(int x) &#123;return qpower(x,MOD-2);&#125; int add(int x,int y) &#123; ll t=x+y; if(t&gt;=MOD) t-=MOD; if(t&lt;0) t+=MOD; return t; &#125; const int MAX_N=2100; int f[MAX_N]; int gs[MAX_N][MAX_N],s[MAX_N]; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(gs,0,sizeof gs); memset(s,0,sizeof s); int n,p,m,k;scanf("%d%d%d%d",&amp;n,&amp;p,&amp;m,&amp;k); if(k==0) &#123;puts("-1");continue;&#125; f[0]=(ll)qpower(m,k)*inv(qpower(m+1,k))%MOD; for(int a=1;a&lt;MAX_N;a++) f[a]=(ll)f[a-1]*inv(a)%MOD*(k-a+1)%MOD*inv(m)%MOD; if(k&lt;MAX_N) f[k]=inv(qpower(m+1,k));//debug m=0 int invm1=inv(m+1); for(int x=1;x&lt;=n;x++) &#123; for(int y=max(1,x-k);y&lt;=x+1 and y&lt;=n;y++) &#123; int z=x-y; if(y==x+1) gs[x][y]=(ll)f[0]*invm1%MOD; else if(x==n) gs[x][y]=f[z]; else &#123; gs[x][y]=(ll)m*invm1%MOD*f[z]%MOD; if(z+1&lt;=k) gs[x][y]=add(gs[x][y], (ll)invm1*f[z+1]%MOD ); &#125; &#125; gs[x][x]=add(gs[x][x],-1); s[x]=add(s[x],-1); &#125; for(int i=1;i&lt;=n-1;i++) if(gs[i][i]!=0) &#123; ll tmp=inv(gs[i][i]); for(int j=i+1;j&lt;=n;j++) if(gs[j][i]!=0) &#123; ll t=(ll)gs[j][i]*tmp%MOD; gs[j][i]=0; gs[j][i+1]=add(gs[j][i+1],-(ll)gs[i][i+1]*t%MOD); s[j]=add(s[j],-(ll)s[i]*t%MOD); &#125; &#125; for(int i=n;i&gt;=2;i--) if(gs[i][i]!=0) &#123; ll tmp=inv(gs[i][i]); for(int j=i-1;j&gt;=1;j--) if(gs[j][i]!=0) &#123; ll t=(ll)gs[j][i]*tmp%MOD; gs[j][i]=0; s[j]=add(s[j],-(ll)s[i]*t%MOD); &#125; &#125; bool error=0; for(int i=1;i&lt;=n;i++) &#123; if(s[i]!=0) &#123; bool bk=1; for(int j=1;j&lt;=n;j++) if(gs[i][j]!=0) bk=0; if(bk) &#123;puts("-1");error=1;break;&#125;//0=非0 &#125; if(gs[i][i]==0) &#123;puts("-1");error=1;break;&#125; &#125; if(!error) printf("%lld\n",(ll)s[p]*inv(gs[p][p])%MOD); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】套路集锦]]></title>
    <url>%2Fposts%2F80c8.html</url>
    <content type="text"><![CDATA[错误总结、套路集锦 加粗表示很有用 错误总结 cmp函数不能在结构体内部 对于一道题意不裸的题，都应该手玩样例检验没有看错题、想出来算法的基本正确性，再去code 标准差是方差的算术平方根，所以说所谓方差是不需要开根的 不等式的移项 一定要分析正负性 stl的比较重载不能随便搞，一定要满足传递性和大小情况单一性（stl用&lt;和&gt;推导出=） fft得答案时要round 带取模计数，判无解不能用答案=0，因为答案可能是模数的倍数 注意！multiset的count复杂度和对应元素数量相关 注意！ set等非随机访问结构的lower_bound，必须调用结构内部的，用stl的那个函数会线性 注意 s&amp;bin[i] 和 (s&amp;bin[i])&gt;0 的不同（惯犯 用指针a[]表示数组的时候，sizeof a只会得到单位大小，而不是整个数组的大小 取模题最后转正很容易忘记，养成中途转正的习惯 map等stl在结构体内的时候memset会gg 在无c++11的时候，queue系列的swap是o(n)的 如果一个东西的插入复杂度是通过势能分析保证的那么通常不能支持删除操作，因为可以多次进行高复杂度的操作 在CF上，任何自选模数的题都应该rand或者双模数，例如路径关键点、hash 线段树如果值域int，求mid的时候可能爆int…… 奇妙结论 一个1到n的集合，选若干个不互质的数，要求和最大 结论：每个数最多两个不同的质因子，且一个在根号内，一个在根号n外 bzoj3308 让拓扑序的逆字典序最小，应建反向边跑大根堆；只会感性理解正确性 随机序列的笛卡尔树深度为log（每次期望为分成两半），即上升序列长度为log；笛卡尔树的子树大小也是log级别的 搜索 搜索去掉次序性的套路：强行限制大小关系举例：POJ1011 Sticks 常见优化：优化搜索顺序、排除等效的决策和物体、可行性、最优性、记忆化 对于一个序列，拆分成多个序列的问题，有两种不同的方向：给每个元素分配组、通过组找元素 最好能仔细根据题目斟酌一下策略，本人多次用2各种剪枝，也比不过裸的1…… 举例：Sticks、Missile Defence System、Zebras 数学 数论分块当出现连续的$\lfloor \frac{n}{i} \rfloor$时，值一定是单调不递增的，同值的区间可以合起来计算复杂度：$O(\sqrt n)$① 当$i \leq \sqrt n$,分母只有$\sqrt n$种② 当$i &gt; \sqrt n$,$\lfloor \frac{n}{i} \rfloor &lt; \sqrt n$$last=\lfloor \frac{n}{ \lfloor \frac{n}{i} \rfloor } \rfloor$举例：CQOI2007 余数求和、非常多数论题 由调和级数，1+1/2+1/3…1/n=O(logn) 对于一个素数P，任何P以内的x，其倍数在模P意义下可以表示出所有P以内的数 x不断对【&lt;x】的数取模，只会进行 $O(logn)$ 次，讨论一下就知道了 【任意模数下存在逆元的数，其逆元互不相同】的证明： $ax=1(\%p)$，那么把其一作为未知数，根据裴蜀定理另一个与p互质 $\sum_{i=1}^n d(i)^2约为nlog^2n$ 期望有个套路的转化，恰好到达的状态的概率*步数之和，等价于所有未到达的状态的概率之和，这个你可以通过【把当前概率推到上面的步数个祖先上】理解 若$H*W且gcd(H,W)=1$的网格左下角射出$(0,0)\to(1,1)$的光线，则$\forall x,y \in N,(x+y)\%2=0,(x,y)会被经过$，其中不在边框上的点会被经过多次，且上述结论是充要的 树 点分树上点对的LCA一定也在原树两点路径上，可以从这个lca统计这个路径的信息 在一棵边权非负的树上，与该点最远的一定是直径的某个端点 两棵树合并起来，新的直径端点一定在两边直径端点中产生 直径的中心唯一 每个点的最远点，都一定经过直径的中心 改一条边，端点最多变化一个 一棵树上点集的连通块个数=点-边 很多模型能转化为树形： 互不重叠只包含的区间（最近一个包含作为fa），例如析合树、一些性质题 某个变量只有单一指向（作为fa），这个其实是最常见的就不举例了 入栈出栈序列是可以表示为树形结构的，节点x的子树大小为k，则表示x先入栈，然后子树内的元素为$[x,x+k-1]$且都更晚入栈更早出栈，举例：HDU5181 numbers 其他，举例：跳跳棋 图的dfs树不会有横叉边 虚树上如何找到原树某个点的第一个祖先（强制在线）： $dfn_A \leq dfn_B \leq dfn_A+siz-1$ 我们先找到$dfn_A \leq dfn_B$的区间，然后就是这段区间能覆盖B的最右边的点 这个可以在线段树上二分实现 用可重路径覆盖一棵树，最小数量：$\lceil \frac{度=1的点数量}{2} \rceil$ 用路径并可以判断是否存在一条路径包含某节点 给定一棵树结构，每个点标号，要求每个点的编号比子树其他点小,合法方案个数=$\frac{n!}{\prod siz_i}$ 路径$(a,b)与(c,d)$如果有交，一定是$lca(a,c),lca(a,d),lca(b,c),lca(b,d)$中深度最大的两个点间路径 除了树的图论 对于无向图，一个点双内如果有奇环，那么内部每条边都至少在一个奇环中；点双内有奇环的充要条件是在dfs搜索树上存在一个【一条非树边+若干树边】组成的奇环 字符串 串的计数，枚举长度，建立间隔为长度的关键点（调和级数），然后每个串会经过一个关键点，枚举关键点算贡献举例：【NOI2016】优秀的拆分、股市的预测 如果一个串是双回文串，一定存在一种分割，满足前面是最长回文前缀或者后面是最长回文后缀 一个串重复多次的最长回文子串，如果不是无限长，则最多是两个合并起来 决策算法 找前k优的区间，固定一个点后，左边的优秀情况是极值问题可以用堆维护左边，取出一个位置后把左边区间拆成两半放回去举例：超级钢琴、树上的路径当然非区间一般也是用堆维护做法：堆维护，堆顶为最差元素举例：K远点对、Supermarket max n个数的环上相邻差；最小化这个，可以递增奇数+递减偶数 对于一些求大小为k最优集合的题目，不妨尝试猜测k一定为k-1的增量，感觉一般都不太好证明，不过可以画一画有没有反例:D 解题思路 有些题可以从简单情况着手、然后拓展到复杂情况（数学归纳法或者总结经验、模仿） 或者先考虑普通情况，再考虑改进来解决特殊情况 举例：noi2015 荷马史诗、POJ2442 Sequence 目前碰到处理棘手的删除问题的方法主要有两个，基本都需要离线 一个是倒着做，这个对题目的要求较高； 另一个是贪心，离线后按出现时间处理，然后按结束时间贪心 举例：【bzoj4644】经典傻逼题【集训队互测2015】最大异或和、【bzoj5040】航线规划【bzoj4229】选择 平方形式，可以转为为数点对，或者是进行两次然后相同的情况 又或者可以处理其差分1,3,5,7,9,11…… 举例：NOI2009 管道取珠. 蔬菜. 学习小组 有关区间问题并用到区间最值，求出l[i]和r[i]表示第一个比a[i]大的位置，则l[i]+1~r[i]-1中间，用到的最大值都是a[i] 不过要小心最大值相等而重复的情况，可以强行把左边界改严格来限制 举例：洛谷18年7月月赛T4 很多计数问题要求排列，可以时刻保证排列性，然后插入一个数，将比它大的数+1 举例：51nod1296 有限制的排列、以及一些比较经典的树上dp 跟极值有关的区间问题，考虑一下已知某个极值贴着区间所带来的影响（笛卡尔树dp之类的） 举例：hnoi2016序列、hnoi2017影魔、ioi2018会议、noi2019机器人的50分部分分（都有题解） 问从状态A操作到B，考虑倒着操作，适用于做某种操作可达性、构造 技巧 取模题对拍时可以改小模数检验 对于比较陌生的题目操作形式，可以多造几组数据来模拟，找到一些性质，用这些性质转化题目 经典问题 权值总和为S的背包，可以 $O(S \sqrt S)$ 完成，即考虑大块小块有根号级别的不同权值，每种权值单调队列优化多组背包即可 若干个不同的集合，要求选最多对数满足来自不同的集合；当$mx&gt;sum-mx$，显然答案为$sum-mx$，否则考虑在一个优先队列中每次取最大的两个集合拿出一对数再塞回去，答案为$\lfloor \frac{sum}{2} \rfloor$；如果对数为更多，那应该只能用堆模拟了 其他 设cnt(x)为x二进制下1的数量，$cnt(a \oplus b)$ 为奇，当且仅当一个cnt为奇，另一个是偶因为两个1在一起是偶，不在一起也是偶 二进制数相减，不要考虑借位，而是允许-1存在 有时候矩乘的矩阵有特殊性，可以舍弃许多可推导信息来减少规模；举例：弱题]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018 划水记+题解]]></title>
    <url>%2Fposts%2F5e0e.html</url>
    <content type="text"><![CDATA[NOIP2018 day03:30才睡着，超级担心明天会困upd：学到了，以后如果困的话可以喝红牛 day1居然一点也不困？感觉状态不错 考试前曾经感叹：如果到时候有现在这么好用的键盘就好了……结果居然还成真了！一模一样……然后不卡空间好评，瞎jb开评测机超强好评（没注意评测费，听说加了100），不用担心被卡常了（flag） t1，一开始想着差分，但很难做先写了一个不会算复杂度的做法，应该蛮多分的吧，就是solve(l,r)，暴力找最小值去分割然后发现随便卡……但显然可以线段树优化，log找到最左边的最小值，然后以此为分割在右边找那分析一下势能，时间为 $O(nlog^2 n)$好慢啊拍起来已经1h了 t2，加法线性空间？各种二元函数分析？联想到 HAOI2018奇怪的背包？搞了20min还是不会，看下一题 t3，居然还真的非常可做二分答案后，设g表示向上的唯一一条链的长度那么现在问题就是给出一个序列，两两配对成至少ln的链，相同条数下选择【上传最大链】的方案我的做法：维护一个set，每次取出最小，找到能配对的中最小的，都从中删除所有被废弃的取mx上传时间的话，看这次评测机配置这么高，应该不会被卡常的吧 回去看t2，找性质注意到只会是小的影响大的，所以从小到大考虑显然最后一定是原先的子集，否则那个多出来的至少会表示出【其本身】用一个无限背包表示某个数是否被表示，如果能显然不要 一开始想着值域参考【小凯的疑惑】的话，不互质更小，上限ab，但开不下想了想，只需要知道当前这个数而已（此时上面的性质尚未透彻，所以有怀疑），所以只要每次跑值域大小即可 彻底检查完所有方面，看了几次注意事项后，还剩1h，挂机玩3d软件去了…… 上限：100+100+100感觉明天应该会很难【回忆起gdoi】 jcp的t2，没想出值域那个性质，其他人普遍没问题 下午看到师兄们去看毒液，和lxj突发奇想用手机看【在一年前就躺在u盘】的秒五晚上去看看我在广州的新家（组的），老爸真爱吹啊，什么广州CBD区……不过感觉老爸老妈还是有点东西的，以他们的性格不会随便花钱，虽然我不像我弟那样喜欢关心家底吸取经验，跑步跑到【真·上气不接下气】顺利早早睡着，打算以后比赛都要这样（scy不可多得的又一句有用的建议） day2t1，一开始想线性做法，5min后不会，反正放平方，懒得想了，也拍不了，走了走了此时40min，因为代码有点小bug t2，这好像很性质？很爆搜？但暂时没思路，走了 t3, n方暴力显然100%不会，发现很多特殊点，一般都是提示（noip就是良心）如果是一条链，类型一只要正反跑一次，中间合并就好，类型二同理，但并不会类型3深度？哦先dp好，每次重新跑一次祖先的链，那么复杂度就是和深度相关的树上？感觉应该和【正反跑】类似，但不太会此时已经10点，设限20min因为用贪心来决策，dp只计数，计算出每个节点的 $g(x)=min f[x][0/1]$ 后，可以二次扫描记录 $oth(x,0/1)$ 表示当前的选择，然后除了x子树以外的答案（子树间互不影响）那么询问1就搞定了，询问2的话分类讨论，预处理allg和allf1表示无限制下，儿子们的两种和即可 如果我会处理一条链上，固定前后，的答案的话，就可以树剖+虚树，然后套上询问2了（感觉这才是询问2意义所在啊）ps:不过赛后问了问栋老师，好像不是这样做的 回去看t2，以为状压就好了，瞎jb找了个转移的限制条件，就瞎jb写了，还过了2 2的点然而其实根本不会转移……又不是加法原理或者乘法原理……毫无去重思路 剩下时间不算多，赶快写t3，最后暴力过了大样例，然后和暴力拍了询问1匆忙检查各种文件，和d1形成鲜明对比，最后t2特判了样例……好歹有10分 上限：100+10+84怎么高一只有我拿了t3的40，目前只知道gay队（TYB）和我差不多但所有人第二题都顺利找规律拿了50pt……感觉从结果上血亏，不过那个耐心杠特殊数据的体验还是很好的 看了看知乎，t3好像是动态dp？不过似乎学过的tyb也没做出来羊好像是我校唯一做出t2的栋好像是我校唯一会做t3的，不过没写完感觉可能是历年正解难度最大的一次，不过暴力分太足了可能线不会差太多 上限494，随便fail一道题就很悬了（特别是我这种中考无限粗心选手）日常模拟赛上限得分和实际得法相差巨大选手再次上演，比赛完当天晚上一个人在竞赛室写游记系列准备去上文化课了……希望能进wc，不然想想【别人都在训练我在文化课】就很难受 成绩先立个flag，进了就氪个迎新礼包，没进弃游，剩下看天意…… upd 2018.11.15 发代码速度好评然后到处去测学军和牛客478=100+100+100+100+10+68洛谷441（被卡常，没有参考价值）然后看了看，应该是d2t3询问2的情况写错了（当时只拍了询问1，没时间，只能肉眼看了好多次，结果还是错）rose是真的牛逼，d1t3大样例没过，3个oj平均分95（因为其采用了后面找前面的策略，而这个我记得对拍一下就错，为什么出的数据都卡不掉？我的改改交上去也和他差不多） upd 2018.11.20 ccf本来说昨天10点，居然咕咕咕了22h……100+100+95+100+10+68=473好像又被卡常了……但明明学军测都没事啊？总之就是只有pkuwc了 d2t3 保卫王国 题解$g(x)=min f[x][0/1]$注意到dp是计数的，基本没有决策轻重链剖分，然后非常好的性质就是只有一个重儿子$s0(x)=\sum f(lightson,1)$$s1(x)=z(x)+\sum g(lightson)$$f(x,0)=s0(x)+f(hson,1)$$f(x,1)=s1(x)+min\ f(hson,0/1)$ 考虑用矩阵优化，每个点，开一个大小为2乘2的矩阵，不表示状态，只表示转移然后不允许的状态设inf，重写min运算，如果有-1就表示不能转移定义矩阵运算@， $c_{i,j}=min\ a_{i,k}+b_{k,j}$，这个运算是满足结合性（ $(a@b)@c=a@(b@c)$ ）的，证明可以联想floyd 那么跳重链就可以用线段树维护区间矩阵乘积 矩阵中轻儿子相关的（s0、s1）信息后面暴力改就好了，每次修改影响log个地方的矩阵，线段树单点修改矩阵 先从x=1的特殊点开始，那么y就向上dp到链dp状态的表示，是1乘2的矩阵，即f(x,0/1)；每次重链之间，暴力转移就好了不特殊的话同理，x和y各自跳到lca，然后暴力转移合并成一个状态，然后再跳到根时间复杂度 $8 \times n log^2 n$，应该能过大部分点 如何更快？注意到询问之间是独立的，每次询问最多固定两个点因为儿子是多个的，而父亲只有一个，应该从儿子角度考虑（这也是树上问题重要思想）设 $fs(x,t,0/1,0/1)$ 表示【x的状态，x的第 $2^t$ 个父亲的状态确定】时，祖先子树内，除了x子树的答案外都合法，最小代价注意到前面的做法，答案是 $f(1,0/1)$ ，因为那是总代价但现在，为了更好地动态回答答案，必须把答案拆开，所以fs是只保证上述区域合法时候的答案虽然稍微有点非常规，但显然只是本题计数dp的另一种形式罢了 想通上述内容后，预处理转移显然回答询问时，中间的祖先的状态，因为只和上一个有关，做一个简单的dp即可 最后就是，感觉码量和实现思维量无论哪种做法都很耗时，至少1h考场上就算会，除非很早ak，否则拿84足够了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=110000; int n; int z[MAX_N];//点权 int hou[MAX_N],dep[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; ll add(ll a,ll b) &#123; if(a&lt;0 or b&lt;0) return -1; return a+b; &#125; ll mymin(ll a,ll b) &#123;return a&lt;b?a:b;&#125; ll min(ll a,ll b) &#123; if(a&lt;0) return b; if(b&lt;0) return a; return mymin(a,b); &#125; ll dec(ll a,ll b) &#123; if(a&lt;0 or b&lt;0) return -1; return a-b; &#125; int bin[30]; ll ff[MAX_N][30];//father ll fs[MAX_N][30][2][2]; struct Predp &#123; ll f[MAX_N][2];//dp Predp()&#123;memset(f,0,sizeof f);&#125; void dp(int x,int fa) &#123; ff[x][0]=fa; f[x][0]=0;f[x][1]=z[x]; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dep[y]=dep[x]+1;dp(y,x); f[x][0]=add(f[x][0],f[y][1]); f[x][1]=add(f[x][1],min(f[y][0],f[y][1])); &#125; &#125; void preST() &#123; memset(fs,-1,sizeof fs); f[0][0]=f[1][1],f[0][1]=min(f[1][0],f[1][1]); for(int x=1;x&lt;=n;x++) &#123; int fa=ff[x][0]; fs[x][0][1][0]=dec(f[fa][0],f[x][1]); fs[x][0][0][1]=fs[x][0][1][1]=dec(f[fa][1],min(f[x][1],f[x][0])); &#125; for(int t=1;t&lt;=20;t++) &#123; for(int x=1;x&lt;=n;x++) &#123; ff[x][t]=ff[ff[x][t-1]][t-1]; int mid=ff[x][t-1]; fs[x][t][0][0]=min( add(fs[x][t-1][0][0],fs[mid][t-1][0][0]),add(fs[x][t-1][0][1],fs[mid][t-1][1][0]) ); fs[x][t][0][1]=min( add(fs[x][t-1][0][0],fs[mid][t-1][0][1]),add(fs[x][t-1][0][1],fs[mid][t-1][1][1]) ); fs[x][t][1][0]=min( add(fs[x][t-1][1][0],fs[mid][t-1][0][0]),add(fs[x][t-1][1][1],fs[mid][t-1][1][0]) ); fs[x][t][1][1]=min( add(fs[x][t-1][1][0],fs[mid][t-1][0][1]),add(fs[x][t-1][1][1],fs[mid][t-1][1][1]) ); &#125; &#125; &#125; &#125;predp; ll ans[2][8000][2];//简单dp, ans[x或者y][序数][以此状态结尾]=最小代价 int tmp[2]; void jump(int typ,int &amp;x,int t) &#123; int now=++tmp[typ]; ans[typ][now][0]=ans[typ][now][1]=-1; for(int a=0;a&lt;=1;a++)//x for(int b=0;b&lt;=1;b++)//anc ans[typ][now][b]=min(ans[typ][now][b], add(ans[typ][now-1][a],fs[x][t][a][b]) ); x=ff[x][t]; &#125; ll solve(int x,int a,int y,int b)//点x，y &#123; if(dep[x]&lt;dep[y]) swap(x,y),swap(a,b); tmp[0]=0;tmp[1]=0; ans[0][0][a]=predp.f[x][a];ans[0][0][a^1]=-1; ans[1][0][b]=predp.f[y][b];ans[1][0][b^1]=-1; for(int t=20;t&gt;=0;t--) if(bin[t]&lt;=dep[x]-dep[y]) jump(0,x,t); if(x==y) ans[0][tmp[0]][b^1]=-1; else &#123; for(int t=20;t&gt;=0;t--) if(ff[x][t]!=ff[y][t]) jump(0,x,t),jump(1,y,t); int lca=ff[x][0]; int now=++tmp[0]; ans[0][now][0]=ans[0][now][1]=-1; for(int c=0;c&lt;=1;c++) for(int t1=0;t1&lt;=1;t1++) for(int t2=0;t2&lt;=1;t2++) &#123; if(c==0 and (t1==0 or t2==0)) continue;//debug 这种情况要特判 ll t=add(ans[0][now-1][t1],fs[x][0][t1][c]); t=add(t,ans[1][tmp[1]][t2]); if(c==0) t=dec(t,predp.f[y][1]); else t=dec(t,min(predp.f[y][0],predp.f[y][1])); ans[0][now][c]=min(ans[0][now][c],t); &#125; x=lca; &#125; //x为当前lca，开始向上 for(int t=20;t&gt;=0;t--) if(ff[x][t]&gt;0) jump(0,x,t); return min(ans[0][tmp[0]][0],ans[0][tmp[0]][1]); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int m;char op[10];scanf("%d%d%s",&amp;n,&amp;m,op); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;z[i]); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; predp.dp(1,0); predp.preST(); while(m--) &#123; int x,a,y,b;scanf("%d%d%d%d",&amp;x,&amp;a,&amp;y,&amp;b); printf("%lld\n",solve(x,a,y,b)); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; d2t2 填数游戏 题解某些性质：$若w(p1)&gt;w(p2)，则s(p1) \leq s(p2)$显然既然字符串的比较从前往后，所有长度相同的路径间都要满足条件那么显然每个对角线都应该满足从右上往左下【一段0然后一段1】当(i,j+1)和(i+1,j)相同时，以(i+1,j+1)为左上角的矩阵，对角线上必须相同否则从(i,j)走出来，然后路径字典序不同，合并后可能交换走 真题解]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF590E】Birthday]]></title>
    <url>%2Fposts%2F2fa8.html</url>
    <content type="text"><![CDATA[Source and JudgeCF590E Record3h Analysis请先思考后再展开 非常综合的好题 字符串匹配方面考虑ac自动机ac机复杂度证明见oi之路 构造fail后，重新考虑每个串的子串因为本来已经建好，不会失配子串除了自己外，包括每个前缀的后缀所以遍历当前的每个前缀，其fail极为最长后缀在各级fail中，可能有的fail是字符串的结尾，如果每个都去建边，会破坏复杂度考虑先只记录最大那个，因为它一定包含后面的小的 最后传递闭包即可恢复偏序集的dag其实有些人的做法是复杂度不能过的，这里的传递闭包应该用bitset显然如果我出题会把这个卡到80分 接下来的问题就是dag的最长反链，在【图论-其他】中有 Dilworth定理 的介绍转化为求最少链覆盖后，拆点二分图，左出右入因为路径覆盖时，每个点只有一条出边，二分图匹配，然后左边没有出度的节点就是链的终点统计其个数即链的数量 接下来构造方案具体做法：oi之路-图论-其他-Dilworth定理然后匈牙利也应该卡！在这种完全图下，显然应该选择网络流，构造方案会很方便 标称时间复杂度为： $O(L+n^3+n^3)$我的时间复杂度为： $O(L+n^3/32+n^2 \sqrt n)$然后就光荣地被卡常了，经过长时间对拍，程序是没有错误的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;#include&lt;bitset&gt;using namespace std;#ifdef DEBUGconst bool LOCAL=1;#elseconst bool LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_LN=1e7+10; //const int MAX_LN=1e5+10; const int MAX_N=760; vector&lt;char&gt; s[MAX_N]; bitset&lt;MAX_N&gt; mp[MAX_N]; void ins(int x,int y) &#123; if(s[x].size()&gt;s[y].size()) swap(x,y); mp[x][y]=1; &#125; char str[MAX_LN];int ln; struct Acm &#123; struct Nod &#123; int fail,c; int son[2]; Nod() &#123; fail=c=son[0]=son[1]=0; &#125; &#125;p[MAX_LN]; //第一次，c为 当前为后缀的字符串编号 //第二次，c为 各级fail中，最近的那个可行结尾 int cnt;Acm()&#123;cnt=0;&#125; void insert(int id) &#123; int x=0; for(int i=1;i&lt;=ln;i++) &#123; int to=str[i]-'a'; if(p[x].son[to]==0) p[x].son[to]=++cnt; x=p[x].son[to]; &#125; p[x].c=id; &#125; queue&lt;int&gt; q; void getfail() &#123; for(int i=0;i&lt;=1;i++) if(p[0].son[i]) q.push(p[0].son[i]),p[p[0].son[i]].fail=0; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int i=0;i&lt;=1;i++) if(p[x].son[i]) &#123; int y=p[x].son[i]; int lst=p[x].fail; while(lst&gt;0 and p[lst].son[i]==0) lst=p[lst].fail; if(p[lst].son[i]==0) p[y].fail=0; else &#123; p[y].fail=p[lst].son[i]; if(p[y].c==0) p[y].c=p[p[y].fail].c; &#125; q.push(y); &#125; &#125; &#125; void go(int id) &#123; int ln=s[id].size(); int x=0; for(int i=0;i&lt;=ln-1;i++) &#123; x=p[x].son[s[id][i]-'a']; int tmp=p[x].c; if(tmp==id) tmp=p[p[x].fail].c;//debug 避免仅指向自己 ins(id,tmp); &#125; &#125; &#125;acm; struct Flow &#123; int st,ed; int hou[MAX_N*2]; struct Edge&#123;int y,c,g;&#125;e[MAX_N*MAX_N*2]; int ln;Flow()&#123;ln=0;&#125; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,hou[x]&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,0,hou[y]&#125;;hou[y]=ln; &#125; int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; int h[MAX_N]; queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,sizeof h); h[st]=1;q.push(st); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(e[k].c&gt;0 and h[y]==0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int fl) &#123; if(x==ed) return fl; int tot=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and tot&lt;fl) &#123; int t=dfs(y,min(e[k].c,fl-tot)); tot+=t;e[k].c-=t;e[oth(k)].c+=tot; &#125; &#125; return tot; &#125; int mxflow() &#123; int ans=0; while(bfs()) ans+=dfs(st,INF); return ans; &#125; bool tg[MAX_N]; void get(int x) &#123; tg[x]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(tg[y]==0 and e[k].c==0) get(y); &#125; &#125; bool isnot(int x) &#123; for(int k=hou[x];k&gt;0;k=e[k].g) if(e[k].y==ed and e[k].c&gt;0) return 1; return 0; &#125; &#125;flow; int n; vector&lt;int&gt; ans; void solve() &#123; flow.st=0,flow.ed=2*n+1; for(int i=1;i&lt;=n;i++) &#123; flow.ins(flow.st,i,1);flow.ins(n+i,flow.ed,1); for(int j=1;j&lt;=n;j++) if(mp[i][j] and i!=j) flow.ins(i,n+j,1);//debug 跳过自己 &#125; flow.mxflow(); for(int i=1;i&lt;=n;i++) if(flow.isnot(n+i)) flow.get(n+i); for(int i=1;i&lt;=n;i++) &#123; //if(flow.tg[i] and !flow.tg[n+i]) ans.push_back(i); debug 忘记取补 if(!flow.tg[i] and flow.tg[n+i]) ans.push_back(i); &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); ln=strlen(str+1); acm.insert(i); for(int j=1;j&lt;=ln;j++) s[i].push_back(str[j]); &#125; acm.getfail(); for(int i=1;i&lt;=n;i++) acm.go(i); for(int i=1;i&lt;=n;i++) mp[i][i]=1; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) if(mp[i][k]) mp[i]|=mp[k]; solve(); printf("%d\n",ans.size()); for(int i=0;i&lt;(int)ans.size();i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>难度3</tag>
        <tag>好题</tag>
        <tag>传递闭包</tag>
        <tag>ac自动机</tag>
        <tag>最大独立集</tag>
        <tag>Dilworth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lydsy1711月赛】实时导航]]></title>
    <url>%2Fposts%2F98b4.html</url>
    <content type="text"><![CDATA[Source and JudgeLydsy1711月赛bzoj5097 Record1h Analysis请先思考后再展开 好题先考虑朴素的做法，用堆维护bfs的队列发现不算太慢，用bitset存储边和队列，这样就省掉两个log了 具体而言：每个点只会执行拓展一次（被枚举最多4次）单个拓展的代价为4n/32，不需要通过位运算去重，因为被多次枚举，毫无影响时间复杂度为 $O(\frac{n^2q}{8})$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=510; typedef bitset&lt;MAX_N&gt; bs; bs e[MAX_N][5]; bs q[5]; int n; int f[MAX_N]; ll solve(int st) &#123; memset(f,63,sizeof f); ll ans=0; q[1][st]=1; for(int p=0;p&lt;=n;p++) &#123; q[0]=q[1];q[1]=q[2];q[2]=q[3];q[3]=q[4];q[4].reset(); for(int x=q[0]._Find_first();x&lt;(int)q[0].size();x=q[0]._Find_next(x)) &#123; if(f[x]!=INF) continue; f[x]=p;ans=ans+p*x; for(int t=1;t&lt;=4;t++) q[t]|=e[x][t]; &#125; &#125; return ans; &#125; int dis[MAX_N][MAX_N]; void main() &#123; int q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; scanf("%d",&amp;dis[i][j]); e[i][ dis[i][j] ][j]=1; &#125; while(q--) &#123; char str[5];scanf("%s",str); if(str[0]=='C') &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); e[x][ dis[x][y] ][y]=0; e[x][ dis[x][y]=c ][y]=1; &#125; else &#123; int st;scanf("%d",&amp;st); ll ans=solve(st); if(ans!=INF) printf("%lld\n",ans); else puts("0"); &#125; &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JLOI2014】聪明的燕姿]]></title>
    <url>%2Fposts%2F9b81.html</url>
    <content type="text"><![CDATA[Source and JudgeJLOI2014loj2234 Record1h Analysis请先思考后再展开 考虑在约数和公式上搜索剪枝1：判断后面是否只有一个素数，否则通过两个素数乘积大幅剪枝（主要是去除末尾0链）剪枝2：通过枚举下一个非0次幂的具体位置，去除中间的0链（非0最多30个，相对根号大小的dfs深度优化巨大）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_NUM=45000; bool isp[MAX_NUM]; int pr=0,prime[MAX_NUM]; void pre() &#123; memset(isp,1,sizeof isp);isp[0]=isp[1]=0; for(int i=2;i&lt;MAX_NUM;i++) &#123; if(isp[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; isp[i*prime[j]]=0; if(i%prime[j]==0) break; &#125; &#125; &#125; bool isprime(int num) &#123; for(int i=1;i&lt;=pr and (ll)prime[i]*prime[i]&lt;=num;i++) if(num%prime[i]==0) return 0; return 1; &#125; vector&lt;int&gt; ans; void dfs(int i,int S,int now) &#123; if(i&gt;pr) return; if(S==1) &#123; ans.push_back(now);return; &#125; if(prime[i]&gt;S-1) return;//debug if(S-1&lt;MAX_NUM and isp[S-1]) ans.push_back(now*(S-1)); if(S-1&gt;=MAX_NUM and isprime(S-1)) ans.push_back(now*(S-1)); //nx=下一个非0次幂的素数，跳过中间极长的0链 for(int nx=i;nx&lt;=pr;nx++) &#123; if( (ll)1+prime[nx]+(ll)prime[nx]*prime[nx]&gt;S ) return;//剪枝 int sum=1+prime[nx],nownum=prime[nx];//非0 while(1) &#123; if(S%sum==0) dfs(nx+1,S/sum,now*nownum); nownum*=prime[nx];sum+=nownum; if(sum&gt;S) break; &#125; &#125; &#125; void main() &#123; pre(); while(1) &#123; int S;if(scanf("%d",&amp;S)==EOF) break; ans.clear(); dfs(1,S,1); sort(ans.begin(),ans.end()); int tot=unique(ans.begin(),ans.end())-ans.begin(); printf("%d\n",tot); for(int t=0;t&lt;tot;t++) printf("%d ",ans[t]); if(tot&gt;0) puts(""); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2015】排序]]></title>
    <url>%2Fposts%2F37a7.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2015bzoj3990 Record1h Analysis请先思考后再展开 性质好题首先排列意味着不重叠，很多特殊情况都不可能发生 step1本题操作的特征在于长度为2的整数次幂，而且区间总是对齐的那么会发现，无论如何操作，都存在一种等效的操作，使得顺序没有意义那么我们只考虑长度递增的操作序列，最后乘以操作具体数量的阶乘即可这样数量会少非常多 step2长度递增，意味着当前长度内部，必须是递增而且连续的，否则后面不可能排序又因为每种操作只能使用一次，考虑下一层的情况为分割点那么下一层，考虑当前层尚未操作时，非法的块数如果没有，直接下一步，否则任何操作都会弄巧成拙一个，显然是且一定只能是内部交换两个，总共只有4种情况两个以上，不可能实现 综上所述，爆搜的分支会非常少 最后提醒一下，两个完全相同的01串，即可具体交换的块不同，也试做一种方案]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1017G】The Tree]]></title>
    <url>%2Fposts%2Fcbab.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1017GCF1017G Record3h Analysis请先思考后再展开 巧妙地转化题意：初始所有点都是-1，表示消耗，每次操作单点+1定义f表示向上的链上，最大后缀和（可跨过-1，不能为空）则x是黑色当且仅当 $f(x) \geq 0$ 那么这个操作二要怎么处理呢？强行让所有人f都变成-1即可，这个可以全部恢复-1，然后对x修改，强行变成即使有后缀和也是-1即可【hint：这里访问父亲的时候要特判根的情况……拍了超久】 考虑用线段树，以dfs序为下标，维护每个区间的data如果我们能设计一个merg(left,right)，注意是有序的，left和right在使用意义上是连续的（链或者dfs序区间）那么询问就很好回答了，按照常规的树剖跳上去，按顺序merg好即可 唯一的问题就是merg如何实现data存储区间的和、左端点的位置，以及最大后缀和（这样左边就可以计算了）那么唯一需要考虑的，就是最大后缀和的左端点在left，显然一定是【左边的后缀和+右边的和】与原本比较 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(int num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(int num) &#123;qwrite(num);puts("");&#125; const int MAX_N=110000; struct Nod&#123;int hou,dfn,tp,fa;&#125;p[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int son[MAX_N],siz[MAX_N]; void pre(int x,int fa) &#123; siz[x]=1;p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; pre(y,x);siz[x]+=siz[y]; if(siz[y]&gt;siz[son[x]]) son[x]=y; &#125; &#125; int id=0; void getid(int x,int tp) &#123; p[x].dfn=++id;p[x].tp=tp; if(son[x]&gt;0) getid(son[x],tp); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0 and y!=son[x]) getid(y,y); &#125; &#125; struct Data&#123;int sum,rmx;&#125;; Data merg(Data left,Data right) &#123; return (Data)&#123;left.sum+right.sum,max(left.rmx+right.sum,right.rmx)&#125;; &#125; struct SegmentTree &#123; struct Nod &#123; int l,r; Data s; bool cl; &#125;p[MAX_N*4]; #define lc 2*x #define rc 2*x+1 void clear(int x)//num-&gt;-1 rmx-&gt;-1 &#123; p[x].s=(Data)&#123;-(p[x].r-p[x].l+1),-1&#125;; &#125; void build(int x,int l,int r) &#123; p[x].l=l;p[x].r=r; p[x].cl=0;clear(x); if(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r); &#125; &#125; void pushdown(int x) &#123; clear(lc);clear(rc); p[lc].cl=p[rc].cl=1; p[x].cl=0; &#125; void change(int x,int pos,int c) &#123; if(p[x].l==p[x].r) &#123; p[x].s=(Data)&#123;c,c&#125;; return; &#125; if(p[x].cl) pushdown(x); int mid=(p[x].l+p[x].r)&gt;&gt;1; if(pos&lt;=mid) change(lc,pos,c); else change(rc,pos,c); p[x].s=merg(p[lc].s,p[rc].s); &#125; void white(int x,int fl,int fr) &#123; if(p[x].l==fl and p[x].r==fr) &#123; clear(x);p[x].cl=1; return; &#125; if(p[x].cl) pushdown(x); int mid=(p[x].l+p[x].r)&gt;&gt;1; if(fr&lt;=mid) white(lc,fl,fr); else if(fl&gt;mid) white(rc,fl,fr); else white(lc,fl,mid),white(rc,mid+1,fr); p[x].s=merg(p[lc].s,p[rc].s); &#125; Data ask(int x,int fl,int fr) &#123; if(p[x].l==fl and p[x].r==fr) return p[x].s; if(p[x].cl) pushdown(x); int mid=(p[x].l+p[x].r)&gt;&gt;1; if(fr&lt;=mid) return ask(lc,fl,fr); else if(fl&gt;mid) return ask(rc,fl,fr); else return merg(ask(lc,fl,mid),ask(rc,mid+1,fr)); &#125; &#125;sgt; int getf(int x) &#123; Data now;bool bk=0; while(x!=0) &#123; int tp=p[x].tp; if(bk==0) now=sgt.ask(1,p[tp].dfn,p[x].dfn),bk=1; else now=merg(sgt.ask(1,p[tp].dfn,p[x].dfn),now); x=p[tp].fa; &#125; return now.rmx; &#125; void main() &#123; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=2;i&lt;=n;i++) &#123;int fa=qread();ins(fa,i);ins(i,fa);&#125; sgt.build(1,1,n); pre(1,0);getid(1,1); while(q--) &#123; int op,x;scanf("%d%d",&amp;op,&amp;x); if(op==1) &#123; Data now=sgt.ask(1,p[x].dfn,p[x].dfn); sgt.change(1,p[x].dfn,now.rmx+1); &#125; else if(op==2) &#123; sgt.white(1,p[x].dfn,p[x].dfn+siz[x]-1); if(x!=1)//debug 拍了超久 &#123; int now=getf(p[x].fa); sgt.change(1,p[x].dfn,min(-1,-now-1)); &#125; &#125; else &#123; int col=getf(x); if(col&gt;=0) puts("black"); else puts("white"); &#125; &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF983E】NN country]]></title>
    <url>%2Fposts%2F856f.html</url>
    <content type="text"><![CDATA[Source and JudgeCF983E Record1h Analysis请先思考后再展开 想到一些小性质：每个点只有向上的深度是有意义的显然这个随便dfs一下就行了 然后关键是怎么连接起来压根没想到倍增的我感觉自己非常sb，像是被套路了 那么每次询问，拆分两个路径，然后最后需要分类讨论一下最顶上那条是否垮lcaans=left+right-【垮lca】 判断这个的话，就是个二维数点了这个最快的应该是离线后扫描线，时间为nlogn]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2017】树点涂色]]></title>
    <url>%2Fposts%2F31df.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2017Loj2001 Record3h Analysis请先思考后再展开 感觉很有趣的一道题关键性质：每种颜色的性质一定是向上的一条链 显然以dfs序为下标，维护每个点到根节点路径上的权值显然x到y的权值为 $d(x)+d(y)-d(LCA)+1$（这个随便讨论一下lca是否有孩子和自己相同颜色） 关键是第一个操作，合并颜色块的总次数应该只有n（ $\sum num[color]$ ，因为总有一点点被侵占的地方，这里并不严谨，个人这个感觉）我自己的想法死在了并查集我不会断开操作看到这个断开， 以我的知识面只会想到lct将每种颜色的所有点放到相同splay中，修改操作和access非常类似然后每次合并的贡献，就是当前子树所有种类都-1，不过如果某孩子颜色和x相同，需要+1因为我们始终维护好splay，所以如果存在，那个孩子就是splay中x的右孩子]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>lct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF997E】Good Subsegments]]></title>
    <url>%2Fposts%2F1ba5.html</url>
    <content type="text"><![CDATA[Source and JudgeCF997E Record1h Analysis请先思考后再展开 $max-min=R-L+1$$max-min+L-1 \leq R$ 和之前维护非负整数的0的数量类似，直接维护最小值及其个数那么再通过两个单调栈，很容易得出R对应的答案（单次询问log） 本题的关键就在于需要维护好区间的历史答案和，而非单个询问考虑每次统计R的答案，不是累加答案，而是把左边可行的端点统计贡献数量（这主要是因为询问的左端点不确定） 那么我们的关键是如何只对最小值进行这个特殊的维护设每个点向右的贡献为ans[i]，那么每次回答询问就是统计区间的这个答案考虑额外维护一个标记s，表示当前区间所有最小值的ans的加标记注意到min一定来自两边的至少一侧，每次pushdown就先把lazy下放，然后对min的来源更新s和ans 回答询问就是边搞定上述决策集合，边回答询问就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF878C】Tournament]]></title>
    <url>%2Fposts%2F90ef.html</url>
    <content type="text"><![CDATA[Source and JudgeCF878C Record2h Analysis请先思考后再展开 依次考虑每个人，加入当前维护的信息 想象一下：如果把能战胜关系建边，缩完点将是一个竞赛图再“反传递闭包”一下，将是一条链，否则会形成强连通分量每次询问的答案，就是链的第一个连通块的大小 对于每个连通块，不需要知道其具体元素（反过来的信息则需要）唯一有用的信息，就是其各个属性的min、max，信息量非常小 考虑这个链的特征显然前一个的min大于后一个的max 定义小于为，满足上述k维偏序则如果两个强连通块被判定为相等，即他们应该合并所以每次插入，直接合并与其相同的块即可，复杂度根据势能显然为 $O(nklogn)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Loj521】抵达]]></title>
    <url>%2Fposts%2Fa414.html</url>
    <content type="text"><![CDATA[Source and JudgeLoj521 Record2h Analysis请先思考后再展开 结论：方案一定只能两两配对证明：从叶子开始考虑，那么只能向上而因为所有点都要被覆盖，所以叶子要被其父亲覆盖此时叶子的祖父往那边是断开的，如果其所有孩子都这么处理，则最优也会变成叶子（或者与叶子配对）根据数学归纳法可得证 然后其实你直接就可以知道，每个点究竟和谁配对这个模拟就好了，可看代码 然后现在得出了许多不等式关系这个可以拓扑排序，用堆维护当前度为0的点即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const int MAX_N=510000; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int n; bool error=0; int ru[MAX_N]; vector&lt;int&gt; to[MAX_N];//O(n) priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; int ans[MAX_N]; void topsort() &#123; for(int i=1;i&lt;=n;i++) if(ru[i]==0) q.push(i); for(int t=1;t&lt;=n;t++) &#123; if(q.size()==0) &#123;error=1;break;&#125; int x=q.top();q.pop(); ans[t]=x; for(int i=0;i&lt;(int)to[x].size();i++) &#123; int y=to[x][i]; ru[y]--;if(ru[y]==0) q.push(y); &#125; &#125; &#125; int col[MAX_N]; void dfs(int x,int fa) &#123; int tt=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x); if(col[y]==1)//叶子 &#123; if(col[x]==2) error=1; col[x]=2;tt=y; &#125; &#125; if(col[x]==0) &#123; col[x]=1;//叶子 for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; to[fa].push_back(y);ru[y]++; &#125; &#125; else &#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==tt) continue; to[tt].push_back(y);ru[y]++; &#125; &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x=qread(),y=qread(); ins(x,y);ins(y,x); &#125; dfs(1,0); topsort(); if(error or col[1]==1) puts("-1"); else for(int i=1;i&lt;=n;i++) qwrite(ans[i]),putchar(' '); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF893F】Subtree Minimum Query]]></title>
    <url>%2Fposts%2Fa2b5.html</url>
    <content type="text"><![CDATA[Source and JudgeCF893F Record10h Analysis请先思考后再展开 感觉挺有难度的 暴力做法是，dfs序为一维，深度为一维，然后二维找最小值，随便用个二维数据结构维护一下就好了然而m很大显然不行 做法一：主席树关键：dfs序内，不存在比x更小深度的点所以以深度为时间轴，不采用权值线段树，而是min线段树线段树插入的时候动态开点，合并取min，询问即前缀和 做法二：预处理+st表+长链剖分这个做法相对更优秀，但实现有点难度 注意到多组询问的对象是静态的，考虑预处理 先求一次bfs序，然后对于x，维护L和R分别表示当前子树，下一层的bfs序的左右端点（因为在相同子树内是连续的）不过，如果不存在子节点，则L为下一层，bfs序下右边第一个点（会跨出），R同理这个主要是为了解决这种情况：注意到bfs序在同一层的相对顺序和上一层是一致的，仔细想想会发现很好处理 然后因为询问的是最小值，允许重叠，所以可以跑一个非常规的ST表设 $f(x,a,b)$ 表示对于 $x到x+2^a-1$ （下文都从bfs序角度），然后他们往下的子树的 $2^b$ 层（包括根）的最小值$fl=L(x)^{2^{b-1}},fr=R(x+2^a-1)^{2^{b-1}}$ （指迭代次数）虽然方向相反，但显然无论跳多少次都满足 $fl \leq fr$$k为最大的 fl+2^k-1 \leq fr$$f(x,a,b)=min f(x,a,b-1),f(fl,k,b-1),f(fr-2^{k-1}+1,k,b-1)$ 这里如果把L和R建成一棵树，相当于询问第k个父亲，可以长链剖分这样询问就可以 O(1) 回答了，参考ST的处理 然后我这道题做了超久（主要是第42个点）烦了很多sb错误，主要是考虑情况不周全 顺便提供几组小数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(int num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(int num) &#123;qwrite(num);puts("");&#125; int n; const int MAX_N=110000; struct Nod&#123;int hou;int num;int bfsid;Nod()&#123;hou=bfsid=0;&#125;&#125;p[MAX_N]; int yz[MAX_N];//dfn-&gt;id struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int down[MAX_N];//down void predep(int x,int fa) &#123; down[x]=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; predep(y,x);down[x]=max(down[x],down[y]+1); &#125; &#125; //bin意义下 int bin[30],log[MAX_N]; int mxpos[MAX_N]; void pre() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; log[1]=0;for(int i=2;i&lt;MAX_N;i++) log[i]=log[i&gt;&gt;1]+1; mxpos[1]=0;for(int i=2;i&lt;MAX_N;i++) mxpos[i]=mxpos[i&gt;&gt;1]+1; &#125; struct Tree//一切编号按照bfs序 &#123; //L、R树中，编号大为父亲 int fa[MAX_N]; int ff[MAX_N][30]; vector&lt;int&gt; son[MAX_N]; void pre1() &#123; for(int i=n;i&gt;=1;i--) &#123; son[fa[i]].push_back(i); ff[i][0]=fa[i]; for(int t=1;t&lt;=20;t++) ff[i][t]=ff[ff[i][t-1]][t-1]; &#125; &#125; int mxdep[MAX_N]; int bson[MAX_N];//长儿子 void pre2(int x)//0=虚根 &#123; mxdep[x]=0;bson[x]=0; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t]; pre2(y); mxdep[x]=max(mxdep[x],mxdep[y]+1); if(bson[x]==0 or mxdep[y]&gt;=mxdep[bson[x]]) bson[x]=y; &#125; &#125; int belg[MAX_N],pos[MAX_N];//所在长链、位置 vector&lt;int&gt; id[MAX_N];int tot; void pre3(int x,int blg) &#123; pos[x]=id[blg].size(); id[blg].push_back(x); belg[x]=blg; if(bson[x]&gt;0) pre3(bson[x],blg); for(int t=0;t&lt;(int)son[x].size();t++) if(son[x][t]!=bson[x]) pre3(son[x][t],++tot); &#125; vector&lt;int&gt; up[MAX_N];//在链顶记录，向上的，长度为链长的链 void pre4() &#123; for(int now=1;now&lt;=tot;now++) &#123; int top=id[now][0]; int tmp=top;up[top].push_back(-1); for(int t=1;t&lt;=(int)id[now].size();t++) &#123; up[top].push_back(tmp=fa[tmp]); if(tmp==0) break; &#125; &#125; &#125; int getfa(int x,int k) &#123; if(k==0) return -1; /* 倍增版，log for(int t=20;t&gt;=0;t--) if(bin[t]&lt;=k and ff[x][t]!=0) x=ff[x][t],k-=bin[t]; return k==0?x:-1;*/ int wt=mxpos[k]; x=ff[x][wt];k-=bin[wt]; if(pos[x]&gt;=k) return id[belg[x]][pos[x]-k]; else &#123; int top=id[belg[x]][0]; if(k-pos[x]&lt;=(int)up[top].size()-1) return up[top][k-pos[x]]; else return -1;//debug &#125; &#125; Tree() &#123;tot=1;&#125; void pre() &#123; pre1();pre2(0);pre3(0,1);pre4(); &#125; &#125;L,R; int h[MAX_N];//bfs深度 queue&lt;int&gt; q; void bfs(int rt)//bfs序和L、R指针 &#123; int id=1;q.push(rt);h[rt]=0; p[rt].bfsid=id;yz[id]=rt; while(!q.empty()) &#123; int x=q.front();q.pop(); bool bk=1;//是否叶子 int st=id+1,now=p[x].bfsid; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].bfsid) continue; h[y]=h[x]+1;bk=0; p[y].bfsid=++id;yz[id]=y; q.push(y); &#125; if(!bk) L.fa[now]=st,R.fa[now]=id; else L.fa[now]=id+1,R.fa[now]=id; &#125; for(int i=1;i&lt;=n;i++)//边缘 &#123; if(h[yz[i]]+1!=h[yz[L.fa[i]]]) L.fa[i]=0; if(h[yz[i]]+1!=h[yz[R.fa[i]]]) R.fa[i]=0; &#125; &#125; int dp[MAX_N][30][30]; void dp() &#123; memset(dp,63,sizeof dp); for(int i=n;i&gt;=1;i--) &#123; for(int a=0;a&lt;=20 and i+bin[a]-1&lt;=n and h[yz[i]]==h[yz[i+bin[a]-1]];a++)//同一层 &#123; for(int b=0;b&lt;=20;b++) &#123; if(a==0 and b==0) dp[i][a][b]=p[yz[i]].num; else if(b==0) dp[i][a][b]=min(dp[i][a-1][b],dp[i+bin[a-1]][a-1][b]); else &#123; int fl=L.getfa(i,bin[b-1]),fr=R.getfa(i+bin[a]-1,bin[b-1]); if(fl&lt;=0 or fr&lt;=0 or fl&gt;fr)//debug fl&gt;fr的情况忘记判断 &#123; dp[i][a][b]=dp[i][a][b-1];//debug 延长转移，避免参差不齐的深度 continue; &#125; int k=log[fr-fl+1]; dp[i][a][b]=min(dp[i][a][b-1],min(dp[fl][k][b-1],dp[fr-bin[k]+1][k][b-1])); &#125; &#125; &#125; &#125; &#125; int solve(int x,int cc)//层数 &#123; cc=min(cc,down[x]+1); if(cc==1) return p[x].num; else &#123; x=p[x].bfsid; int k=log[cc]; int fl,fr; if(cc==bin[k]) fl=fr=x; else fl=L.getfa(x,cc-1-bin[k]+1),fr=R.getfa(x,cc-1-bin[k]+1);//转步数 //往下 if(fl&lt;=0 or fr&lt;=0) puts("error"); int k2=log[fr-fl+1]; return min(dp[x][0][k],min(dp[fl][k2][k],dp[fr-bin[k2]+1][k2][k])); &#125; &#125; void main() &#123; pre(); int rt;scanf("%d%d",&amp;n,&amp;rt); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].num); for(int i=1;i&lt;=n-1;i++) &#123;int x,y;scanf("%d%d",&amp;x,&amp;y);ins(x,y);ins(y,x);&#125; bfs(rt);predep(rt,0); L.pre();R.pre(); dp(); int m;scanf("%d",&amp;m); int lst=0; while(m--) &#123; int x=qread(),dis=qread(); x=(x+lst)%n+1;dis=(dis+lst)%n; qwriteln(lst=solve(x,dis+1)); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度3</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1034C】Region Separation]]></title>
    <url>%2Fposts%2Fa39a.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1034C Record2h Analysis请先思考后再展开 考虑只割一次的情况设k为连通块数量，设 $f(k)=\sum [\frac{all}{gcd(sum_i,all)} | k]$$ans=\sum [f(k)=k]$割多次的话， $g(t)=\sum_{d|t} f(d)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF955F】Heaps]]></title>
    <url>%2Fposts%2F39cb.html</url>
    <content type="text"><![CDATA[Source and JudgeCF955F Record2h Analysis请先思考后再展开 设 $f(x,k)$ 表示往下的最大深度如果孩子数小于k，为1，否则为前k大的min利用nth_element达到 $O(n^2)$ 不难发现， $h \leq log_k siz$当k达到 $n^{\frac{1}{3}}$ ，层数最大为3稍微处理一下，应该可以通过本题，时间为 $n^{frac{4}{3}}$ 还有更快的做法$g(x,h)$ 表示深度为h，最大的叉数不考虑k=1，则 $h \leq log2 siz$转移的话，将 $f(y,h-1)$ 排序，倒序找到第一个K，满足 $第k大 \leq k$注意到K的减小，显然更能满足条件，所以正确性显然 然后得到答案的话，因为是求和，很容易统计答案]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2018】奇怪的背包]]></title>
    <url>%2Fposts%2F7019.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2018luogu4495 Record2h Analysis请先思考后再展开 本题的难度主要在于题意的转化 Step1$a \cdot v_i+b \cdot P=anynum$由裴蜀定理得：$a \cdot v_i+b \cdot P=gcd(v_i,P)$$anynum$ 是 $gcd(v_i,P)$ 的若干倍，所以可以将物品的体积转化,则本质不同的物品只有1600个（约数个数上限） Step2$\sum t_i \cdot v_i = w_i (\mod P)$题意转化为求其整数解数量因为忽略个数，其实就是求 $gcd(a_1,a_2,a_3…a_m,P) | w_i$ 的方案数注意到 $w_i$ 的其他质因数没有意义，有用的信息还是P的约数，所以本质不同的询问也只有1600个 Step3转化出上面的式子后，非常好dp预处理所有约数，设 $f(i,t)$ 表示考虑前i个，当前方案gcd恰为t的方案数转移显然，复杂度很低 Step4暴力统计每个询问的答案（判断是否为约数）即可 时间复杂度为 $O(约数^2log+q)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(ll &amp;x,const ll y) &#123;x=x&gt;y?x:y;&#125; void chmin(ll &amp;x,const ll y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=4e3+10; const ll MOD=1e9+7; void add(ll &amp;x,ll y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int gcd(int x,int y)&#123;return y==0?x:gcd(y,x%y);&#125; vector&lt;pr&gt; num;int getpos(int x)&#123;return lower_bound(num.begin(),num.end(),MP(x,0))-num.begin();&#125; ll f[MAX_N],bin[MAX_N*MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;MAX_N*MAX_N;i++) bin[i]=bin[i-1]*2%MOD; int n=qread(),q=qread(),pp=qread(); for(int t=1;t*t&lt;=pp;t++) if(pp%t==0) &#123;num.PB(MP(t,0));if(t!=(pp/t)) num.PB(MP(pp/t,0));&#125; sort(num.begin(),num.end());int cnt=num.size(); for(int i=1;i&lt;=n;i++) num[getpos(gcd(qread(),pp))].SE++; f[cnt-1]=1; for(int i=0;i&lt;cnt;i++) &#123; for(int now=0;now&lt;cnt;now++) if(f[now]) add(f[getpos(gcd(num[now].FR,num[i].FR))],f[now]*(bin[num[i].SE]+MOD-1)%MOD); &#125; for(int i=cnt-1;i&gt;0;i--) for(int j=0;j&lt;i;j++) if(num[i].FR%num[j].FR==0) add(f[i],f[j]); while(q--) write2(f[getpos(gcd(qread(),pp))]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sakits的题]]></title>
    <url>%2Fposts%2F2504.html</url>
    <content type="text"><![CDATA[Source and JudgeSakits的noip模拟赛不过题目不是原创的 Problem1CF1036F Analysis1请先思考后再展开 设 $a^b$设 f(b) 表示以b为次幂，在n以内的a的数量注意到有重复，但可以容斥设 g(t)表示以t为 满足【最大化次幂后恰为t】的数 $g(t)=\sum_{d|t} f(d)$这个是可以反演的，时间为log方，主要是二分出f的花费（将快速幂看做常数）不过这个还是非常慢的 考虑结合多组数据的特征，预处理出例如： $2^4,3^4,4^4……$那么二分查找就省去常数了 然后询问是可以离线的，指针具有单调性，不需要二分了，时间复杂度 $O(nlogn)$ Problem2给一棵节点小于3e5的树，定义一条路径的权值为，经过的点集的编号的最近距离求所有权值大于K的路径数量，k在10以内 Analysis2请先思考后再展开 简化题意（避免被搞晕）：计算所有【点编号不会太靠近】的路径数量为了利用K的大小，转化一下题意，那么所有非法点对只有10n个注意到这些非法点对不能同时出现，有哪些路径包含了这些点对呢？显然是跟子树有关（无论是否有祖先关系）一开始想着容斥（当时处于看错题的状态下，以为点有点权），发现特别难搞 显然子树信息先转化为字典序其实这相当于一个二维坐标上，两维不相关的坐标的连续区间，也就是一个矩形 那么问题变成 $n\times n$ 的大矩形，数矩形的并这个就非常套路了，扫描线一下即可 线段树维护的东西的话，我的做法是维护最小值和其次数主要是其被覆盖次数一定是非负数，可以判断0的出现次数，而上面的这个东西非常好维护 细节特别多，非考场都做了很久，调了很久感觉考场非常容易炸…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const int MAX_N=310000; struct Nod&#123;int hou,siz,fa;Nod()&#123;hou=0;&#125;&#125;p[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int dfn[MAX_N],id=0,yz[MAX_N]; void dfs(int x,int fa) &#123; p[x].siz=1;dfn[x]=++id;yz[id]=x;p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x);p[x].siz+=p[y].siz; &#125; &#125; struct SegmentTree &#123; struct Nod &#123; int mi,minum; int c; &#125;p[MAX_N*4]; #define lc 2*x #define rc 2*x+1 void build(int x,int l,int r) &#123; p[x].mi=0;p[x].minum=(r-l+1); p[x].c=0; if(l&lt;r) &#123; int mid=(l+r)/2; build(lc,l,mid); build(rc,mid+1,r); &#125; &#125; void update(int x) &#123; p[lc].mi+=p[x].c;p[lc].c+=p[x].c; p[rc].mi+=p[x].c;p[rc].c+=p[x].c; p[x].c=0; &#125; void change(int x,int l,int r,int fl,int fr,int c) &#123; if(l==fl and r==fr) &#123; p[x].mi+=c;p[x].c+=c; return; &#125; update(x); int mid=(l+r)/2; if(fr&lt;=mid) change(lc,l,mid,fl,fr,c); else if(fl&gt;mid) change(rc,mid+1,r,fl,fr,c); else change(lc,l,mid,fl,mid,c),change(rc,mid+1,r,mid+1,fr,c); if(p[lc].mi==p[rc].mi) p[x].mi=p[lc].mi,p[x].minum=p[lc].minum+p[rc].minum; else if(p[lc].mi&lt;p[rc].mi) p[x].mi=p[lc].mi,p[x].minum=p[lc].minum; else p[x].mi=p[rc].mi,p[x].minum=p[rc].minum; &#125; int ask(int x,int l,int r,int fl,int fr)//=0的数量 &#123; if(l==fl and r==fr) &#123; if(p[x].mi==0) return p[x].minum; else return 0; &#125; update(x); int mid=(l+r)/2; if(fr&lt;=mid) return ask(lc,l,mid,fl,fr); else if(fl&gt;mid) return ask(rc,mid+1,r,fl,fr); else return ask(lc,l,mid,fl,mid)+ask(rc,mid+1,r,mid+1,fr); &#125; &#125;sgt; int n; struct Line&#123;int y1,y2,c;&#125;; vector&lt;Line&gt; xd[MAX_N]; void insert(int x1,int x2,int y1,int y2) &#123; x1=max(x1,1);x2=min(x2,n); y1=max(y1,1);y2=min(y2,n); if(x1&gt;x2 or y1&gt;y2) return; if(LOCAL) printf("(%d-&gt;%d,%d-&gt;%d)\n",x1,x2,y1,y2); xd[x1].push_back((Line)&#123;y1,y2,1&#125;); xd[x2+1].push_back((Line)&#123;y1,y2,-1&#125;); &#125; int q[MAX_N]; ll solve() &#123; ll ans=0;sgt.build(1,1,n); for(int x=1;x&lt;=n;x++) &#123; for(int t=0;t&lt;(int)xd[x].size();t++) &#123; sgt.change(1,1,n,xd[x][t].y1,xd[x][t].y2,xd[x][t].c); //for(int i=xd[x][t].y1;i&lt;=xd[x][t].y2;i++) q[i]+=xd[x][t].c; &#125; if(LOCAL) printf("\nx=%d:",yz[x]); //int sum=0;for(int i=1;i&lt;=n;i++) if(q[i]==0 or i==x) sum++; //ans+=sum; //if(LOCAL) printf("sum=%d\n",sum); ans+=sgt.ask(1,1,n,1,n)+(sgt.ask(1,1,n,x,x)==0); if(LOCAL) printf("%d\n",sgt.ask(1,1,n,1,n)+(sgt.ask(1,1,n,x,x)==0)); &#125; return ans; &#125; int getson(int fa,int x) &#123; x=dfn[x];//debug for(int k=p[fa].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==p[fa].fa) continue; if(dfn[y]&lt;=x and x&lt;=dfn[y]+p[y].siz-1) return y; &#125; return -1; &#125; void main() &#123; if(!LOCAL) freopen("simplicity.in","r",stdin); if(!LOCAL) freopen("simplicity.out","w",stdout); int K;scanf("%d%d",&amp;n,&amp;K); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1,0); for(int x=1;x&lt;=n;x++) for(int y=max(1,x-K);y&lt;=min(x+K,n);y++)//过于靠近的非法点对 &#123; if(x==y) continue; if(LOCAL) printf("x=%d\n",x); if(dfn[x]&lt;dfn[y]) &#123; if(dfn[x]+p[x].siz-1&lt;dfn[y])//分别两个子树内 insert(dfn[x],dfn[x]+p[x].siz-1,dfn[y],dfn[y]+p[y].siz-1); else//x是y的父亲 &#123; int son=getson(x,y);//debug 包括我自己的孩子 if(LOCAL) printf("son[%d,%d]=%d\n",x,y,son); insert(1,dfn[son]-1,dfn[y],dfn[y]+p[y].siz-1); insert(dfn[son]+p[son].siz,n,dfn[y],dfn[y]+p[y].siz-1); &#125; &#125; else &#123; if(dfn[y]+p[y].siz-1&lt;dfn[x])//分别两个子树内 insert(dfn[x],dfn[x]+p[x].siz-1,dfn[y],dfn[y]+p[y].siz-1); else//y是x父亲 &#123; int son=getson(y,x);//debug 包括我自己的孩子 insert(dfn[x],dfn[x]+p[x].siz-1,1,dfn[son]-1); insert(dfn[x],dfn[x]+p[x].siz-1,dfn[son]+p[son].siz,n); &#125; &#125; &#125; printf("%lld",(solve()+n)/2); &#125;&#125;;int main()&#123; mine::main();&#125; Problem3没什么好说的]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【CF1039D】You Are Given a Tree]]></title>
    <url>%2Fposts%2Fd879.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1039D Record2h Analysis请先思考后再展开 本做法的难度不算大，偏套路吧虽然我没想到，官方题解的更优秀做法并没有看懂…… 题目的多组询问很容易让人想到整体二分，然而我并不知道怎么弄……下面介绍一个网上常见的做法： 考虑单独一个k，显然可以在树上用贪心决策，跑计数dpsolve求最多有多少条长度为k的路径f(x)=条数g(x)=条数最大化的前提下最长链（完整路径之外，笔直向上，由最后的父节点累计入答案）贪心正确性：显然在不可重叠的规则下，条数多1不比长长的链差 设T为临界值长度小于T的部分，暴力计算长度大于T的部分，显然答案会小于n/T，可以将答案相同的部分合并处理solve(ln)显然具有单调性，枚举答案ans，则在未计算的右侧，[solve(ln)=ans] 具有单调性，二分找到右端点时间复杂度 $O(Tn+n^2logn/T)$ ，T取 $\sqrt nlogn$ ，该算法达到最小值 然而，因为后面的log不是满的（如果改成倍增应该会快很多），所以实测T取根号时才是最快的这道题我发现全场基本都在第8个点tle了，然后都选择了取卡常例如【按照dfs序倒序处理，规避系统栈】、【记忆化搜索】、【快速IO】等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int qread()&#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans;&#125;void qwrite(int num)&#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10);&#125;void qwriteln(int num) &#123;qwrite(num);puts("");&#125;const int MAX_N=110000;int hou[MAX_N],fa[MAX_N];struct Edge&#123;int y,g;&#125;e[MAX_N*2];int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125;int f[MAX_N],g[MAX_N];int list[MAX_N],dfn=0;void dfs(int x,int fat)&#123; list[++dfn]=x;fa[x]=fat; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fat) continue; dfs(y,x); &#125;&#125;int ned;void dp(int x)&#123; f[x]=0; int mx1=0,mx2=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa[x]) continue; //dp(y,x); f[x]+=f[y]; if(g[y]&gt;=mx1) mx2=mx1,mx1=g[y]; else if(g[y]&gt;mx2) mx2=g[y]; &#125; if(mx1+mx2+1&gt;=ned) f[x]++,g[x]=0; else g[x]=mx1+1;&#125;int jyh[MAX_N];int solve(int ln)&#123; if(jyh[ln]&gt;=0) return jyh[ln]; ned=ln; //dp(1,0); for(int t=dfn;t&gt;=1;t--) dp(list[t]); return jyh[ln]=f[1];&#125;int main()&#123; memset(jyh,-1,sizeof jyh); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x=qread(),y=qread(); ins(x,y);ins(y,x); &#125; dfs(1,0); int T=sqrt(n); if(T==0) T=1; for(int ln=1;ln&lt;=T and ln&lt;=n;ln++) qwriteln(solve(ln)); int fl=T+1; for(int ans=n/T;ans&gt;=0;ans--) &#123; if(solve(fl)!=ans) continue; int l=fl,r=n,fr=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(solve(mid)==ans) fr=mid,l=mid+1; else r=mid-1; &#125; if(fr&lt;0) continue;//debug for(int t=fl;t&lt;=fr;t++) qwriteln(ans); fl=fr+1; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF960F】Pathwalks]]></title>
    <url>%2Fposts%2Fae99.html</url>
    <content type="text"><![CDATA[Source and JudgeCF960F Record30min Analysis请先思考后再展开 是否联想到了最长上升子序列？如果有，相信自己！因为有用状态只有O(m)个12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const int MAX_N=110000; struct Data &#123; int lst,ln; friend bool operator &lt; (Data a,Data b) &#123;return a.lst&lt;b.lst;&#125; &#125;; set&lt;Data&gt; p[MAX_N]; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) p[i].insert((Data)&#123;-1,0&#125;); int ans=0; for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); set&lt;Data&gt;::iterator it=p[x].lower_bound((Data)&#123;c,0&#125;); if(it==p[x].begin()) continue; --it; int ln=(*it).ln+1; ans=max(ans,ln); set&lt;Data&gt;::iterator it2=p[y].lower_bound((Data)&#123;c,0&#125;); while(it2!=p[y].end()) &#123; if((*it2).ln&lt;=ln) p[y].erase(it2),it2=p[y].lower_bound((Data)&#123;c,0&#125;); else break; &#125; if(it2!=p[y].begin())//debug 忘记判断存在的意义 &#123; --it2; if((*it2).ln&lt;ln) p[y].insert((Data)&#123;c,ln&#125;); &#125; else p[y].insert((Data)&#123;c,ln&#125;); &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF840C】On the Bench]]></title>
    <url>%2Fposts%2F3ed7.html</url>
    <content type="text"><![CDATA[Source and JudgeCF840C Record30min Analysis请先思考后再展开 有点难，不过也不算神仙题，大概省选t2难度？有综合性，状态感觉也挺难想到的 最难的一步：转化题意这个完全平方数很恶心，但注意到如果每个数的标准分解形式，质因数的次幂膜二后问题变成，不能将两个相同的数放在一起 然后就感觉排列这东西很难搞，唯一会的姿势这里也不能用但如果脱离排列的形式，考虑将数字放入的方案数，就会好搞很多 小套路：将同值的合并处理，看做一组，设数量为num[i]依次考虑每组，顺序任意，设 $f(i,tt)$ 表示【前i组，有tt个相邻关系是非法的】的计数ps：感觉这个第二维非常关键，是【表达一个状态真正最需要的唯一关键信息】 同组的值相同，但在原题中是互不相同的数，所以乘以排列数 $num[i]!$枚举将当前组分成t个，插入到空隙中，那么新产生了 $b=num[i]-1-(t-1)=num[i]-t$ 个非法的相邻量分组方案： $C_{num[i]-1}^{t-1}$枚举将之前a个相邻非法位置变成合法，那么非法数量变成 $tt-a+b$方案数为 $c_{tt}^{a} \times C_{sum+1-tt}^{t-1}$ ，sum为前面的num的和 综上所述：$f(i,tt-a+b)+=f(i-1,tt) \times num[i]! \times C_{num[i]-1}^{t-1} \times C_{tt}^{a} \times C_{sum+1-tt}^{t-a}$ 看起来是四层枚举，但由于 $t \leq num[i],\sum num[i]=n$所以实际复杂度是 $O(n^3)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const int MAX_NUM=40000; bool isp[MAX_NUM]; int pr=0,prime[MAX_NUM]; void pre() &#123; memset(isp,1,sizeof isp); for(int i=2;i&lt;MAX_NUM;i++) &#123; if(isp[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; isp[i*prime[j]]=0; if(i%prime[j]==0) break; &#125; &#125; &#125; const ll MOD=1e9+7; ll qpower(ll x,ll e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll num) &#123;return qpower(num,MOD-2);&#125; const int MAX_N=310; ll fac[MAX_N],facinv[MAX_N]; ll C(int n,int m) &#123; if(m&gt;n) return 0;//debug 边界问题 return fac[n]*facinv[m]%MOD*facinv[n-m]%MOD; &#125; ll f[MAX_N][MAX_N]; int num[MAX_N]; int a[MAX_N]; void main() &#123; pre(); fac[0]=1;facinv[0]=1; for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD,facinv[i]=inv(fac[i]); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int num;scanf("%d",&amp;num); a[i]=1; for(int j=1;j&lt;=pr;j++) &#123; int mm=0; while(num%prime[j]==0) num/=prime[j],mm++; if(mm&amp;1) a[i]*=prime[j]; &#125; if(num!=1) a[i]*=num; &#125; sort(a+1,a+n+1); int tot=0,tmp=0; for(int i=1;i&lt;=n;i++) &#123; tmp++; if(i==n or a[i]!=a[i+1]) num[++tot]=tmp,tmp=0; &#125; f[0][0]=1; int sum=0; for(int i=1;i&lt;=tot;i++) &#123; for(int tt=0;tt&lt;=( i==1?1:sum-1 );tt++) &#123; for(int k=1;k&lt;=num[i];k++) &#123; int b=num[i]-k; for(int a=0;tt-a+b&gt;=0 and a&lt;=k;a++) &#123; f[i][tt-a+b]+=f[i-1][tt]* fac[num[i]]%MOD*C(num[i]-1,k-1)%MOD* C(tt,a)%MOD*C(sum+1-tt,k-a)%MOD; f[i][tt-a+b]%=MOD; &#125; &#125; &#125; sum+=num[i]; &#125; printf("%lld",f[tot][0]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1012C】Hills]]></title>
    <url>%2Fposts%2F3470.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1012C Record30min Analysis请先思考后再展开 有点套路，不过太菜了，看了别人的状态才想到 关键性质：只影响前后一个位，而且只能减小设 $f(i,k,0/1)$ 表示前i位，已经有k个满足条件（当i是，后面的一个数尚未修改），然后该数是否满足条件然后这种东西能够满足单调性，但注意到一个数可能被多次统计，所以要记录该状态下，这个数变成了多少其实注意到，如果是1，数不会变，所以可以把0替换成唯一可能出现的三个数：a[i-1]-1,a[i],a[i+1]-1这个也可以设状态的，不过不是很方便吧大概 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const int MAX_N=5100; int a[MAX_N]; int cost(int x,int y)//x&lt;=y &#123; if(x&lt;=y) return 0; else return x-y; &#125; ll f[2][MAX_N][2],ans[MAX_N]; int g[2][MAX_N][2]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); memset(f,63,sizeof f);f[1][0][0]=f[1][1][1]=0;g[1][0][0]=g[1][1][1]=a[1]; for(int i=2;i&lt;=n;i++) for(int k=0;k*2&lt;=i+1;k++) &#123; ll t1=f[(i-1)&amp;1][k][0],t2=f[(i-1)&amp;1][k][1]+cost(a[i],a[i-1]-1); if(t1&lt;t2) f[i&amp;1][k][0]=t1,g[i&amp;1][k][0]=a[i]; else f[i&amp;1][k][0]=t2,g[i&amp;1][k][0]=min(a[i],a[i-1]-1); if(k&gt;0) f[i&amp;1][k][1]=f[(i-1)&amp;1][k-1][0]+cost(g[(i-1)&amp;1][k-1][0],a[i]-1); &#125; int ed=ceil((double)n/2);ans[ed+1]=1ll&lt;&lt;60; for(int k=ed;k&gt;=1;k--) ans[k]=min(ans[k+1],min(f[n&amp;1][k][0],f[n&amp;1][k][1]));//至少 for(int k=1;k&lt;=ed;k++) printf("%lld ",ans[k]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Silhouette bzoj3902三向投影]]></title>
    <url>%2Fposts%2F3af6.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题bzoj3902 Problem有一个n乘n的网格，在每个格子上堆叠了一些边长为1的立方体。现在给出这个三维几何体的正视图和左视图，求有多少种与之符合的堆叠立方体的方案。两种方案被认为是不同的，当且仅当某个格子上立方体的数量不同。输出答案对1e9 + 7取模的结果。n&lt;=100000 Record3h Analysis请先思考后再展开 很有难度的一道计数题 关键：对a和b排序，问题不变，求合法解数量从大到小考虑每种取值，考虑该取值的横线和竖线所能确定具体值的形状，大致是一个梯形（也就是说，该行且该列的另一侧已经确定）如果某种值只有行或列，那矩形也算是特殊的L形 对于每个L形，拆成两半枚举至少的非法行数容斥消除一维，再用朴素容斥消除一维因为有两维，朴素容斥搞定一维后（假设是列），那么左下角那个已经由上面的保证好了然后右边的部分，既要考虑枚举的非法行数，还要考虑当前行的合法性然后同类型的列之间互不影响，直接乘法原理 对于当前的L形$ans=\sum (-1)^i f(i)$$$f(i)=C_a^i \times \\[num^i \times (num+1)^{a-i}]^{lb} \\[num^i \times ( (num+1)^{ra-i}-num^{ra-i} )]^b$$然后不同的L形之间已经互不影响（条件是拍好了序），乘法原理即可 常熟略大，可自行优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const int MAX_N=110000; const ll MOD=1e9+7; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll num) &#123;return qpower(num,MOD-2);&#125; ll fac[MAX_N],invfac[MAX_N]; ll solve(int a,int b,int la,int lb,int num)//左开右闭 &#123; ll ans=0;int ra=la+a; for(int i=0;i&lt;=a;i++) &#123; ll f=fac[a]*invfac[i]%MOD*invfac[a-i]%MOD; f=f*qpower(qpower(num,i)*qpower(num+1,a-i)%MOD,lb)%MOD; f=f*qpower( qpower(num,i)*( (MOD+qpower(num+1,ra-i)-qpower(num,ra-i))%MOD )%MOD ,b )%MOD; if(i&amp;1) ans-=f; else ans+=f; ans=(ans%MOD+MOD)%MOD; &#125; return ans; &#125; int a[MAX_N],b[MAX_N],c[MAX_N*2]; bool cmp(int a,int b) &#123;return a&gt;b;&#125; void main() &#123; fac[0]=1;invfac[0]=1; for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD,invfac[i]=inv(fac[i]); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),c[i]=a[i]; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]),c[n+i]=b[i]; sort(a+1,a+n+1,cmp);sort(b+1,b+n+1,cmp);sort(c+1,c+n+n+1,cmp); int tot=unique(c+1,c+n+n+1)-c-1; ll ans=1,la=0,lb=0; for(int t=1;t&lt;=tot;t++) &#123; int ra=la;while(a[ra+1]==c[t] and ra+1&lt;=n) ra++; int rb=lb;while(b[rb+1]==c[t] and rb+1&lt;=n) rb++; ans=ans*solve(ra-la,rb-lb,la,lb,c[t])%MOD; la=ra;lb=rb; &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse]]></title>
    <url>%2Fposts%2F37e8.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 Problem小G有一个长度为n的01串T，其中只有TS=1，其余位置都是0。现在小G可以进行若干次以下操作：选择一个长度为K的连续子串（K是给定的常数），左右翻转这个子串。对于每个i，小G想知道最少要进行多少次操作使得Ti=1.特别的，有m个禁止位置，你需要保证在操作过程中1始终不在任何一个禁止位置上。n&lt;=1e5 Record2h Analysis请先思考后再展开 发现每个点可以去的点，分奇偶讨论后是连续的一段区间（虽然边界计算有点麻烦）方法一：线段树优化建图，在上面用deque跑bfs，时间为nlogn方法二：用set维护没有被更新的点，找区间用lowerbound，这样每次找到的都是没有被更新过的点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const int MAX_N=110000; int n,k,m,st; int f[MAX_N]; queue&lt;int&gt; q; void push(int pos,int t) &#123;if(t&lt;f[pos]) f[pos]=t,q.push(pos);&#125; set&lt;int&gt; bt[2]; void bfs() &#123; f[st]=0;q.push(st); for(int i=1;i&lt;=n;i++) if(i!=st) bt[i&amp;1].insert(i); while(!q.empty()) &#123; int now=q.front();q.pop(); int l=max(now-k+1,k+1-now),r=min(now+k-1,2*n-now-k+1); int wt=(now&amp;1)^(k%2==0); while(1) &#123; set&lt;int&gt;::iterator it=bt[wt].lower_bound(l); if(it==bt[wt].end()) break; int fd=(*it); if(fd&gt;r) break; push(fd,f[now]+1); bt[wt].erase(it); &#125; &#125; &#125; void main() &#123; memset(f,63,sizeof f); scanf("%d%d%d%d",&amp;n,&amp;k,&amp;m,&amp;st); for(int i=1;i&lt;=m;i++) &#123;int t;scanf("%d",&amp;t);f[t]=-1;&#125; bfs(); for(int i=1;i&lt;=n;i++) if(f[i]==INF) f[i]=-1; for(int i=1;i&lt;=n;i++) printf("%d ",f[i]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4230倒计时 51nod1425减减数 CF331C3The Great Julya Calendar]]></title>
    <url>%2Fposts%2F5f83.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj423051nod1425CF331C3 Record2h Analysis请先思考后再展开 非常好的题目 显然有单调不增性，所以应该贪心地选择减去最大的数字 瓶颈在于具体的数字，考虑拆位处理真正有用的情况其实很少形式1：9999999t形式2：原数的一个后缀设 $f(mx,ln,num)$ 表示当前这个数，其实左边还有一些部分，最大数字是mx，然后右边是长度为ln的num记录二元组：步数和余数，表示再减一次就要借位（一定产生9，转移成形式1） 然后枚举当前位不断被借位的过程，处理好余数，记忆化搜索即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; ll dec[20]; struct Data&#123;ll cnt,moe;Data(ll a=-1,ll b=0)&#123;cnt=a,moe=b;&#125;&#125;;//计数、剩下的一点点（再减mx就借位了） Data f[10][20][20];//f(mx,ln,right) Data dfs(int mx,int ln,ll num) &#123; int right=(num/10==dec[ln-1]-1)?num%10:10;//10表示原数的后缀 if(f[mx][ln][right].cnt&gt;=0) return f[mx][ln][right]; int now=num/dec[ln-1]; if(ln==1) &#123; int tmx=max(now,mx); if(now==0 or now&lt;tmx) return f[mx][ln][right]=(Data)&#123;0,now&#125;; else return f[mx][ln][right]=(Data)&#123;1,0&#125;; &#125; ll cnt=0,left=num%dec[ln-1]; while(now&gt;=0) &#123; ll tmx=max(mx,now); Data dp=dfs(tmx,ln-1,left); cnt+=dp.cnt;left=dp.moe; if(now) left=dec[ln-1]+left-tmx,cnt++; now--; &#125; return f[mx][ln][right]=(Data)&#123;cnt,left&#125;;//撤回 &#125; void main() &#123; dec[0]=1;for(int i=1;i&lt;=18;i++) dec[i]=dec[i-1]*10; dec[19]=(ll)9e18; ll num;scanf("%lld",&amp;num); int ln=0;while(dec[ln]&lt;num) ln++; Data ans=dfs(0,ln+1,num); printf("%lld",ans.cnt); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度3</tag>
        <tag>好题</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merchant]]></title>
    <url>%2Fposts%2F8c5f.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 Problemn个一次函数，选最多m个，使得有最小的t，令x=t时y的总和达到Sn不超过1000000，答案保证有解，而且在1e9内 Record1h Analysis请先思考后再展开 先考虑一个子问题，如果给出一个x，如何快速求出答案？借助nth_element可以在线性时间内得出答案（如果边加入边比较，不会爆ll） 最重要的提示：一次函数之和还是一次函数……这个打暴力的时候注意到了，但不够灵活，没有联想到 那么你考虑 $2^n$ 种选取情况，每种情况的贡献是一次函数因为我们不关心具体的方案，那么对于每个x，贡献连接起来是一个先向下再向上的形状（无论多少个一次函数，x最大的部分连接起来总是这个形状）然后我们要在这个形状中，找出最小的非负整数x满足y大于等于S这个形状是开口向上的，最小值左边的最大值就在0，右边是可以二分的 更简单一点，连最小值位置都不用找，因为如果你知道0不能达到，那么左边都没有贡献函数 $f(x)=[y \leq S]$ ，这样一个bool函数是满足二分性的 很不错的题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100000; int n,m;ll S; int k[MAX_N],b[MAX_N]; vector&lt;ll&gt; get; bool cmp(ll a,ll b) &#123;return a&gt;b;&#125; bool check(int x) &#123; get.clear(); for(int i=1;i&lt;=n;i++) &#123; ll t=(ll)k[i]*x+b[i]; if(t&gt;0) get.push_back(t); &#125; int ed=m; if((int)get.size()&gt;m) nth_element(get.begin(),get.begin()+m-1,get.end(),cmp); else ed=get.size(); ll sum=0;for(int i=0;i&lt;ed;i++) &#123;sum+=get[i];if(sum&gt;=S) return 1;&#125; return 0; &#125; void main() &#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;S); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;k[i],&amp;b[i]); if(check(0)) puts("0"); else &#123; int l=1,r=1e9,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Equation]]></title>
    <url>%2Fposts%2F5574.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 Problem给一棵n个点的树，每个点代表一个未知数xi每条边给出权值，表示两个未知数的和q个询问，op=1表示询问：暂时补充一条边，唯一解输出x1，多解输出inf，无解输出noneop=2表示修改第x个点，向上的那条边的权值n不超过1000000 Record2h Analysis请先思考后再展开 写了有一点慢，比赛没时间写完暴力去拍，幸运地ac了 这道题主要是思维，还需要一点点运气因为输出x1，因为n个未知数的方程组需要n个方程，所以现在一定是不能解完的将第i个点向上的那条边，编号设定为i然后考虑高斯消元的思想，第i个点上面的边，和下面的几条边都有公共元，然后我们定义第i条边的主元是xi，所以向下消除然后设1向下的边为深度1，那么深度为奇数，下端编号为t的边，参与的未知数是xt+x1，否则是xt-x1然后边的权值，经过高斯消元后，形式为 $[奇数则取反] \sum -si$（具体符号请读者自行推导，很好想的） 然后对于每个修改操作，相当于对子树的所有边修改，然后具体的修改按照【当前边深度奇偶性和那条边深度的奇偶性的异或值】所以开两个树状数组，差分一下就好了 然后对于询问，把两条边连接在了一起 两条边深度奇偶性相同，那么形式为 0=S-权值1-权值2 奇偶性不同，那么形式为 2x1=S-权值1-权值2那么这两个方程的解的情况，自己随便判断一下就好了 时间复杂度 $O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100000; int n; struct Bit &#123; ll bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,ll c) &#123;while(x&lt;=n) bit[x]+=c,x+=lowbit(x);&#125; ll getsum(int x) &#123;ll ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; &#125;bt[2]; int hou[MAX_N],siz[MAX_N],dfn[MAX_N],dep[MAX_N]; int fa[MAX_N];int up[MAX_N]; struct Edge&#123;int y,g,c;&#125;e[MAX_N]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln;&#125; int id=0; void dfs(int x) &#123; siz[x]=1;dfn[x]=++id; bt[dep[x]&amp;1].change(dfn[x],up[x]); bt[!(dep[x]&amp;1)].change(dfn[x],-up[x]); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; dep[y]=dep[x]+1; dfs(y);siz[x]+=siz[y]; &#125; bt[dep[x]&amp;1].change(dfn[x]+siz[x],-up[x]); bt[!(dep[x]&amp;1)].change(dfn[x]+siz[x],up[x]); &#125; void main() &#123; if(!LOCAL) freopen("equation.in","r",stdin); if(!LOCAL) freopen("equation.out","w",stdout); int q;scanf("%d%d",&amp;n,&amp;q); for(int i=2;i&lt;=n;i++) scanf("%d%d",&amp;fa[i],&amp;up[i]),ins(fa[i],i,up[i]); dep[1]=0;dfs(1); while(q--) &#123; int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(op==1) &#123; int s;scanf("%d",&amp;s); if(dep[x]&gt;dep[y]) swap(x,y); ll geta=bt[dep[x]&amp;1].getsum(dfn[x]); ll getb=bt[dep[y]&amp;1].getsum(dfn[y]); ll now=(ll)s-geta-getb; if( (dep[x]&amp;1) != (dep[y]&amp;1) ) &#123; if(now==0) puts("inf"); else puts("none"); &#125; else &#123; if(now&amp;1) puts("none"); else &#123; if(dep[x]&amp;1) printf("%lld\n",-now/2); else printf("%lld\n",now/2); &#125; &#125; &#125; else &#123; ll old=up[x],now=y; bt[dep[x]&amp;1].change(dfn[x],(now-old)); bt[dep[x]&amp;1].change(dfn[x]+siz[x],-(now-old)); bt[!(dep[x]&amp;1)].change(dfn[x],-(now-old)); bt[!(dep[x]&amp;1)].change(dfn[x]+siz[x],(now-old)); up[x]=now; &#125; &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2014】购票]]></title>
    <url>%2Fposts%2F80e0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2014loj2249 Record2h Analysis请先思考后再展开 先从序列的情况开始考虑 如果没有交通工具的距离限制，可以大力李超树$f(i)=- P_i \cdot dis_j + f(j)+ P_i \cdot dis_i + Q_i$或者斜率优化（x坐标单调，询问不单调，要下凸壳上二分）$f(j)=P_i \cdot dis_j + f(i)-P_i \cdot dis_i-Q_i$如果考虑距离限制，由于李超树的标记是永久话的，无法撤回，所以只能用斜率优化了 现在变成树上问题后，先从暴力说起，枚举每个点，向上跳，跳到不能跳为止并维护好凸壳，然后查询那么此时x坐标是递减地插入的，用deque就不能在上面二分了其实稍微变化一下就好啦： $f(j)=(-P_i) \cdot (-dis_j) + f(i)-P_i \cdot dis_i-Q_i$ 注意到为每个点重新建立一个凸壳非常制杖，我们需要尽量少重构凸壳，多利用公共信息然后有一个细节要始终留意：这是一棵有根树，一切都有先后，这个信息不能被破坏这种上面影响下面的特征，（dalao很容易） 联想到序列上的cdq的思想（显然我是想不到的） 设solve(rt,size)表示当前根为rt，rt的所有祖先已经向该子树内所有节点更新，我需要处理区域的大小为size每次在处理区域内找出重心G，将G的所有孩子断开，求解solve(rt,size-siz[G]+1)现在我们希望更新G的孩子，尚未更新他们的祖先显然是x到G的链，深度单调因为使用了cdq，我们只考虑上面对下面的更新，所有下面内部可以任意顺序处理，那么取出所有G的孩子，按照【能更新他的祖先中最浅那个的深度】从大到小排序，那么就可以在链上维护一个指针，用指针到G间的信息更新当前孩子（凸壳上二分即可） 最后每个孩子的子树，已经满足我们刚才的前提条件【rt的所有祖先已经向该子树内所有节点更新】所以可以放心的向下分治下去了 不难发现，分治的深度最大为logn，相同深度的覆盖区域几乎是不重叠的，区域内大部分节点都要在凸壳上二分所以时间复杂度是 $O(nlog^2n)$细节：正如我所说，区域几乎是不重叠的，但总有一些特殊情况，例如只有两个点，如果把重心定在下面，会发现死循环了所以需要稍微处理一下（可能有更巧妙的方法去规避？），等于的情况也替换重心 由于本题有难度，可能单靠我的分析不足以理解，故给出代码以供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=210000; struct Nod&#123;int fa,hou;ll P,Q,L,dis;Nod()&#123;fa=hou=0;dis=0;&#125;&#125;p[MAX_N]; struct Edge&#123;int y,g;ll c;bool ban;&#125;e[MAX_N]; int ln=0;void ins(int x,int y,ll c) &#123;e[++ln]=(Edge)&#123;y,p[x].hou,c,0&#125;;p[x].hou=ln;&#125; void getdis(int x) &#123;for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123;int y=e[k].y;p[y].dis=p[x].dis+e[k].c;getdis(y);&#125;&#125; int G,all; int mxd[MAX_N],siz[MAX_N]; void getrt(int x) &#123; mxd[x]=0;siz[x]=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(e[k].ban) continue; getrt(y);siz[x]+=siz[y]; mxd[x]=max(mxd[x],siz[y]); &#125; mxd[x]=max(mxd[x],all-siz[x]); if(mxd[x]&lt;=mxd[G]) G=x; &#125; vector&lt;int&gt; in; void getpt(int x) &#123;in.push_back(x);for(int k=p[x].hou;k&gt;0;k=e[k].g) if(!e[k].ban) getpt(e[k].y);&#125; bool cmp(int a,int b) &#123;return p[a].dis-p[a].L&gt;p[b].dis-p[b].L;&#125; ll f[MAX_N]; struct TK &#123; int q[MAX_N],top;//单调栈维护凸壳 double xl[MAX_N];//xl[i]=pt[i]-&gt;pt[i+1] void clear() &#123;top=0;&#125; void insert(int id) &#123; if(f[id]==f[0]) return;//INF debug ll nowx=-p[id].dis,nowy=f[id]; while(top&gt;1) &#123; //调试了超久…… 总是忘记不等式的移项要考虑正负性 if(-p[q[top]].dis-nowx&lt;0 and xl[top-1]*(-p[q[top]].dis-nowx)&gt;f[q[top]]-nowy) break; if(-p[q[top]].dis-nowx&gt;0 and xl[top-1]*(-p[q[top]].dis-nowx)&lt;f[q[top]]-nowy) break; top--; &#125; q[++top]=id; if(top&gt;1) xl[top-1]=double(f[q[top-1]]-nowy)/(-p[q[top-1]].dis-nowx); xl[top]=1ll&lt;&lt;60; &#125; int quary(int now)//xl[left[pt]&lt;=pt&lt;=xl[right[pt]] &#123; return q[lower_bound(xl+1,xl+top+1,(double)-p[now].P)-xl]; &#125; &#125;tk; void solve(int rt,int size) &#123; if(size==1) return; G=0;mxd[G]=INF;all=size; getrt(rt); for(int k=p[G].hou;k&gt;0;k=e[k].g) e[k].ban=1;//断开 int tmpG=G;//debug solve(rt,size-siz[tmpG]+1); in.clear();for(int k=p[tmpG].hou;k&gt;0;k=e[k].g) getpt(e[k].y); sort(in.begin(),in.end(),cmp); tk.clear(); for(int t=tmpG,i=0;i&lt;(int)in.size();i++) &#123; int now=in[i]; while(t!=p[rt].fa and p[t].dis&gt;=p[now].dis-p[now].L) tk.insert(t),t=p[t].fa; if(tk.top&gt;0) &#123; int j=tk.quary(now); f[now]=min(f[now],f[j]+(p[now].dis-p[j].dis)*p[now].P+p[now].Q); &#125; &#125; for(int k=p[tmpG].hou;k&gt;0;k=e[k].g) solve(e[k].y,siz[e[k].y]); &#125; void main() &#123; int n,nouse;scanf("%d%d",&amp;n,&amp;nouse); for(int i=2;i&lt;=n;i++) &#123; ll ln;scanf("%d%lld%lld%lld%lld",&amp;p[i].fa,&amp;ln,&amp;p[i].P,&amp;p[i].Q,&amp;p[i].L); ins(p[i].fa,i,ln); &#125; getdis(1); memset(f,63,sizeof f);f[1]=0; solve(1,n); for(int i=2;i&lt;=n;i++) printf("%lld\n",f[i]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>cdq分治</tag>
        <tag>难度3</tag>
        <tag>好题</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2007】货币兑换]]></title>
    <url>%2Fposts%2Fc1b5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2007loj2353 Record2h Analysis请先思考后再展开 在dp方程的推导上，个人认为最困难的已经被提示出来了这个结论你告诉我，我会说这很可能是正确的；但我没把握能在考场上及时地想到并运用 那现在既然已经知道这个结论，那么某一时刻不是全是钱就是全是金券因为金券是二元的，涉及到状态的表示，但数量太大不能设状态，而钱是一元的，可以很方便地作为值设 $f(i)$ 表示第i天结束后，拥有的钱， $f(0)=S$设 x(i)=第i天，最多能拥有的A数量，y(i)同理则 $x(i)=\frac{f(i)\times R_i}{R_i \cdot A_i+B_i},y(i)=\frac{f(i)}{R_i \cdot A_i+B_i}$$f(i)=x_j \cdot A_i + y_j \cdot B_i$$y_j=-\frac{A_i}{B_i} \cdot x_j+\frac{f(i)}{B_i}$问题再次转化为，最大化斜距但和朴素的斜率优化不同的地方在于，x坐标不是单调地加入，询问的直线斜率也不是单调的 这意味着，我们需要一个数据结构，支持动态插入一个点后维护上凸壳（斜率递减），并任意查询某条直线的最大斜距 方法一：平衡树插入点以后，如果完全在内部，没有存在的意义，否则向左右删除，直到再次斜率单调递减 方法二：cdq分治solve(l,r)只考虑【l到mid】对于【mid+1到r】的贡献注意到我们希望决策点集关于x单调，被更新的顺序按照斜率单调然而，即使归并，右边的部分，点的坐标能被计算的前提是已经被更新完毕，所以solve(mid+1,r)应该在处理完后再递归然而这意味着，右边的斜率并不单调，对左边归并好，然后按常规构造出左边的凸壳（左边已经被更新完毕了），右边只能再次二分时间复杂度是 $O(nlog^2n)$ ，无法在loj上通过如果在cdq的过程中套个sort，复杂度并不会变小…… 发现网上的人都是单log的，难道是我姿势不对？看了看别人的代码，发现还真的有种非常巧妙地姿势（最大收获……，建议先了解整体二分的思想）先将所有询问排序，然后总是保证，所有当前区间的询问恰好在当前区间（不需要多开两个参数，注意到每个询问是双性人）那这个的实现是非常容易的，排序前记录好原本的时间，按照时间去分类就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2016】征途]]></title>
    <url>%2Fposts%2F2381.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2016luogu4072 Record1h Analysis请先思考后再展开 我以为方差是要开根的（其实那是标准差），所以推半天不知道为什么那是一个整数……$v=\frac{1}{n} \sum (a_i-suma/m)^2$$v=\frac{1}{m} (\sum a_i^2 -\sum 2a_i \times suma/m +\sum (suma/m)^2)$$v=\frac{1}{m} (\sum a_i^2 -2 suma^2/m +suma^2/m)$$v=\frac{1}{m} \sum a_i^2 - suma^2/m^2$$ans=v \times m^2=m \sum a_i^2 -suma^2$ 那么现在要求将n个数分成m段，每段权值为ai，最小化上式现在m和总和都是常量，就是一个裸的斜率优化了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【agc016e】Poor Turkeys]]></title>
    <url>%2Fposts%2Fdec.html</url>
    <content type="text"><![CDATA[Source and Judgeagc016e Record30min Analysis请先思考后再展开 对于每个元素，维护它最后存活的条件，用一个集合表示，集合内所有元素都必须曾经存活（然后放入意味着死去） 倒着考虑时间，处理x的存活集合如果两个人都要曾求存活（以后的要求），则x必死如果只有一个人，则另一个加入集合（杀死他）如果都不在里面，则不变 最后统计答案，两个元素能同时存活，当且仅当他们各自存活，并且存活集合没有交集因为进入某个集合，意味着在这一刻要被充当替死鬼，所以不能充当两次 本题的精髓在于倒序处理说一个细节：因为本题是二元，不会存在这样一种情况【两个集合的并其实是同一个时间被杀死的】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=410; bitset&lt;MAX_N&gt; s[MAX_N]; int a[110000],b[110000]; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;a[i],&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123; s[i][i]=1; for(int t=m;t&gt;=1;t--) &#123; if(s[i][a[t]] and s[i][b[t]]) &#123;s[i][i]=0;break;&#125; else if(s[i][a[t]]) s[i][b[t]]=1; else if(s[i][b[t]]) s[i][a[t]]=1; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) ans+=(s[i][i] and s[j][j] and (s[i]&amp;s[j]).none()); printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF799E】Aquarium decoration]]></title>
    <url>%2Fposts%2F7f0f.html</url>
    <content type="text"><![CDATA[Source and JudgeCF799E Record3h被折叠的数据结构里没开longlong见祖宗！拍了一小时…… Analysis请先思考后再展开 显然分成四类，排好序先枚举两种都包含的数量c，那么单一覆盖的是可以贪心选择的如果超过m，非法小于m，维护好剩余集合，用一个数据结构维护【前k小的和】树状数组会比较好写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int bin[30]; const int MAX_N=210000; struct Bit &#123; int mx; ll bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123;while(x&lt;=mx) bit[x]+=c,x+=lowbit(x);&#125; ll sum(int x) &#123;ll ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; int findk(int k) &#123; int x=0,now=0; for(int i=19;i&gt;=0;i--) &#123; x+=bin[i]; if(x&lt;=mx and now+bit[x]&lt;k) now+=bit[x]; else x-=bin[i]; &#125; return x+1; &#125; &#125;t1,t2; struct Nod&#123;int cc,w;bool a,b;&#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.w&lt;b.w;&#125; int na=0,nb=0,nc=0,nd=0; ll suma=0,sumb=0; int A[MAX_N],B[MAX_N],C[MAX_N],D[MAX_N]; void put(int id) &#123; if(p[id].a and p[id].b) C[++nc]=id; else if(p[id].a) A[++na]=id,suma+=p[id].w; else if(p[id].b) B[++nb]=id,sumb+=p[id].w; else D[++nd]=id; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m,K;scanf("%d%d%d",&amp;n,&amp;m,&amp;K); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].w); int ta;scanf("%d",&amp;ta);for(int i=1;i&lt;=ta;i++) &#123;int t;scanf("%d",&amp;t);p[t].a=1;&#125; int tb;scanf("%d",&amp;tb);for(int i=1;i&lt;=tb;i++) &#123;int t;scanf("%d",&amp;t);p[t].b=1;&#125; sort(p+1,p+n+1,cmp); int rx=1;put(1);p[1].cc=rx; for(int i=2;i&lt;=n;i++) &#123; //if(p[i-1].w!=p[i].w) debug 不能相同 rx++; put(i);p[i].cc=rx; &#125; t1.mx=t2.mx=rx; for(int t=K+1;t&lt;=na;t++) t1.change(p[A[t]].cc,1),t2.change(p[A[t]].cc,p[A[t]].w),suma-=p[A[t]].w; for(int t=K+1;t&lt;=nb;t++) t1.change(p[B[t]].cc,1),t2.change(p[B[t]].cc,p[B[t]].w),sumb-=p[B[t]].w; for(int t=1;t&lt;=nc;t++) t1.change(p[C[t]].cc,1),t2.change(p[C[t]].cc,p[C[t]].w); for(int t=1;t&lt;=nd;t++) t1.change(p[D[t]].cc,1),t2.change(p[D[t]].cc,p[D[t]].w); ll ans=1ll&lt;&lt;60; ll sumc=0; for(int c=0;c&lt;=K and c&lt;=nc;c++) &#123; if(K-c&lt;=na and K-c&lt;=nb) &#123; int tot=c+(K-c)+(K-c); if(t1.sum(rx)&gt;=m-tot and tot&lt;=m) ans=min(ans, suma+sumb+sumc+(tot&lt;m?t2.sum(t1.findk(m-tot)):0) ); &#125; if(c&lt;nc) t1.change(p[C[c+1]].cc,-1),t2.change(p[C[c+1]].cc,-p[C[c+1]].w),sumc+=p[C[c+1]].w; if(K!=c and K-c&lt;=na) t1.change(p[A[K-c]].cc,1),t2.change(p[A[K-c]].cc,p[A[K-c]].w),suma-=p[A[K-c]].w; if(K!=c and K-c&lt;=nb) t1.change(p[B[K-c]].cc,1),t2.change(p[B[K-c]].cc,p[B[K-c]].w),sumb-=p[B[K-c]].w; &#125; if(ans==(1ll&lt;&lt;60)) puts("-1"); else printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Nwerc2015】赌骆驼]]></title>
    <url>%2Fposts%2F5fb6.html</url>
    <content type="text"><![CDATA[Source and JudgeNwerc2015 Guessing Camelsbzoj4430 Record1h Analysis请先思考后再展开 显然是个三维偏序，可以直接cdq，是log方的然而又一种巧妙的log的做法非法情况存在一种性质：每次取出两个排列的话，三种情况两种相同一种不同不妨设 $PA_i &gt; PA_j,PB_i &lt; PB_j$两两取出来，统计这个二维偏序，那么每队算重复一次，除以2，就是非法情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=210000; int n; int p[5][MAX_N]; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123;while(x&lt;=n) bit[x]+=c,x+=lowbit(x);&#125; int ask(int x) &#123;int ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; struct Nod&#123;int x,y;&#125;s[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.x&gt;b.x;&#125; ll ans=0; void solve(int k1,int k2) &#123; for(int i=1;i&lt;=n;i++) s[i]=(Nod)&#123;p[k1][i],p[k2][i]&#125;; sort(s+1,s+n+1,cmp); memset(bit,0,sizeof bit); for(int i=1;i&lt;=n;i++) ans+=ask(s[i].y-1),change(s[i].y,1); &#125; void main() &#123; scanf("%d",&amp;n); for(int t=1;t&lt;=3;t++) for(int i=1;i&lt;=n;i++) &#123;int x;scanf("%d",&amp;x);p[t][x]=i;&#125; solve(1,2);solve(1,3);solve(2,3); printf("%lld",(ll)n*(n-1)/2-ans/2); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>cdq分治</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【雅礼day4】t2]]></title>
    <url>%2Fposts%2F7387.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 题意给定一个无向图，n 个点（从1 开始编号）、m 条边（长度为1），每条边有一个权值c(0或1)。一条路径，可以表示为一个长度为经过边数的01 串，串的第i 位为经过的第i 条边的权值。两条路径相同，当且仅当表示其的01 串相同。求从1 号点出发、长度为d 的路径种数。n小于90，可能是完全图d小于20 Record1h Analysis请先思考后再展开 因为前导0的存在，给每种状态加上其长度的二次幂相当于强行插入一个1在最前面，使得所有状态不重不漏，共计 2^{n+1}这样状压好以后，很容易想出 $O(2^n n^2 / 32)$ 的做法，利用bitset可以卡时间过通过折半搜索可以把复杂度除以10，即 $O(2^{n/2} n^3 /32)$先枚举一个起点，然后枚举当前位置，转移即可最后把起点1的部分和其他起点合并起来，dp的时候顺便处理好就能快速实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=100; int bin[40]; typedef bitset&lt;MAX_N&gt; bs; bs e[2][MAX_N];//邻接矩阵 bs f[(1&lt;&lt;12)+10];//当前st下，能实现该状态的点 bs g[(1&lt;&lt;12)+10];//能实现该状态的st void main() &#123; if(!LOCAL) freopen("y.in","r",stdin); if(!LOCAL) freopen("y.out","w",stdout); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m,D;scanf("%d%d%d",&amp;n,&amp;m,&amp;D); int D2=D/2,D1=D-D2;//D1&gt;=D2 for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); e[c][x][y]=e[c][y][x]=1; &#125; for(int st=n;st&gt;=1;st--) &#123; for(int S=1;S&lt;=bin[D1+1]-1;S++) f[S].reset(); f[1][st]=1; for(int S=1;S&lt;=bin[D1+1]-1;S++) for(int x=1;x&lt;=n;x++) if(f[S][x]) f[S&lt;&lt;1]|=e[0][x],f[S&lt;&lt;1|1]|=e[1][x]; for(int S=bin[D2];S&lt;=bin[D2+1]-1;S++) g[S][st]=g[S][st] or f[S].any(); &#125; int ans=0; for(int left=0;left&lt;=bin[D1]-1;left++) for(int right=0;right&lt;=bin[D2]-1;right++) if( ( f[bin[D1]|left]&amp;g[bin[D2]|right] ).any() ) ans++;//存在交集 printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2013】保护出题人]]></title>
    <url>%2Fposts%2F44ef.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2013luogu3299 Record1h Analysis请先思考后再展开 很容易划出式子：$y_i=max \frac{sum_i-sum_{j-1}}{x_i-(i-j) \cdot d}$看到分数，考虑一下斜率、直线等东西所有以前的点为 $A(j \cdot d,sum_{j-1})$当前的点为 $B(x_i+i \cdot d,sum_i)$那么相当于求与B斜率中最大的那个，显然在凸壳上，三分找到极值横坐标单调很好维护凸壳]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IOI2000】Post Office]]></title>
    <url>%2Fposts%2F5867.html</url>
    <content type="text"><![CDATA[Source and JudgeIOI2000POJ1160 Record1h Analysis请先思考后再展开 放一个就是中位数，用这个来dp打决策表，验证决策单调性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310; ll f[MAX_N][40],fm[MAX_N][40]; ll a[MAX_N],w[MAX_N][MAX_N]; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int l=1;l&lt;=n;l++) for(int r=l;r&lt;=n;r++) w[l][r]=w[l][r-1]+a[r]-a[(l+r)/2]; //只会从偶数变奇数的时候移动，那么是满足式子的 memset(f,63,sizeof f);f[0][0]=0; for(int k=1;k&lt;=m;k++) &#123; for(int i=n;i&gt;=k;i--) &#123; int fl=fm[i][k-1],fr=(i==n)?n:fm[i+1][k]; for(int j=fl;j&lt;=fr and j&lt;i;j++) &#123; ll now=f[j][k-1]+w[j+1][i]; if(now&lt;f[i][k]) f[i][k]=now,fm[i][k]=j; &#125; &#125; &#125; printf("%lld",f[n][m]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poi2011】Lightning Conductor]]></title>
    <url>%2Fposts%2Fce55.html</url>
    <content type="text"><![CDATA[Source and JudgePoi2011bzoj2216 Record1h Analysis请先思考后再展开 突破口在根号，显然有决策单调性和诗人小G差不多，所以那个做法就不讲了看题解的时候意外地发现了分治做法，也是利用单调性，挺好的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=510000; double a[MAX_N],f1[MAX_N],f2[MAX_N]; void solve1(int l,int r,int fl,int fr)//l~r=更新的区域，fl~fr=选择的区域 &#123; if(l&gt;r) return; int mid=(l+r)/2,pos=mid; for(int j=fl;j&lt;=fr and j&lt;=mid;j++) &#123; double t=a[j]+sqrt((double)mid-j); if(t&gt;f1[mid]) f1[mid]=t,pos=j; &#125; solve1(l,mid-1,fl,pos); solve1(mid+1,r,pos,fr); &#125; void solve2(int l,int r,int fl,int fr) &#123; if(l&gt;r) return; int mid=(l+r)/2,pos=mid; for(int j=fr;j&gt;=fl and j&gt;=mid;j--) &#123; double t=a[j]+sqrt((double)j-mid); if(t&gt;f2[mid]) f2[mid]=t,pos=j; &#125; solve2(l,mid-1,fl,pos); solve2(mid+1,r,pos,fr); &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;a[i]); solve1(1,n,1,n); solve2(1,n,1,n); for(int i=1;i&lt;=n;i++) printf("%d\n",(int)ceil(max(f1[i],f2[i])-a[i])); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2009】诗人小G]]></title>
    <url>%2Fposts%2Ffb5d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2009bzoj1563 Record2h Analysis请先思考后再展开 题意：多组数据n个句子，分行，每行的代价为【总长度+中间的分割空格数量】与L的差的p次方最小化该代价并输出方案如果超过1e18，输出Too hard to arrange每组数据后输出20个“-” 发现了bzoj的目前唯一优点：将繁琐而sb的输出方案省略 本题通过暴力打表验证，发现决策满足单调性（从证明上说就是满足四边形不等式，虽然我并没有去证明hh）然后我一开始就想了一个很sb的问题：既然决策点单调，每次从那里开始往后移动指针不就好了？但对于每个i，其j的验证并不是单调的，虽然确实可以从那里开始，但不得不全部扫一遍如果每次的下一个就是最优解，那么依然是平方级别的 但反过来考虑，考虑i能够给多少个后面的k作贡献，就好维护多了维护一个数组q，表示最优决策点的位置，此时如果设计一个函数，表示和原本相比是否更优，那么一定是单调的，二分查找即可我在具体实现的时候，分了一下段，稍微加速下~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; bool error; ll cheng(ll x,ll y) &#123; if((double)x*y&gt;1e18) error=1; return x*y; &#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,x); e&gt;&gt;=1;if(e&gt;0) x=cheng(x,x); &#125; return ans; &#125; const int MAX_N=110000; int n,L,p; char str[MAX_N][40]; int sum[MAX_N],s[MAX_N]; ll f[MAX_N]; bool big[MAX_N]; struct Nod&#123;int j,l,r;&#125;q[MAX_N]; ll w(int j,int i) &#123;return qpower(abs(s[i]-s[j]-L),p);&#125; bool better(int i,int j,int k) &#123; if(big[j]) return 1; if(big[i]) return 0; return f[i]+pow(abs(s[k]-s[i]-L),p)&lt;=f[j]+pow(abs(s[k]-s[j]-L),p); &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;n,&amp;L,&amp;p);L++; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str[i]+1); sum[i]=sum[i-1]+strlen(str[i]+1); s[i]=sum[i]+i; &#125; memset(big,1,sizeof big);big[0]=0; memset(f,63,sizeof f);f[0]=0; int tou=1,wei=1;q[1]=(Nod)&#123;0,1,n&#125;; for(int i=1;i&lt;=n;i++) &#123; while(q[tou].r&lt;i) tou++; error=0; if(!big[q[tou].j] and (double)f[q[tou].j]+w(q[tou].j,i)&lt;=1e18 and !error) &#123; big[i]=0; f[i]=f[q[tou].j]+w(q[tou].j,i); &#125; //if(LOCAL) printf("i=%d fm=%d\n",i,q[tou].j); int pos=n+1;//pos~n 修改为i while(tou&lt;=wei) &#123; if(better(i,q[wei].j,q[wei].l)) pos=q[wei].l,wei--; else if(better(q[wei].j,i,q[wei].r)) break; else &#123; int l=q[wei].l,r=q[wei].r; while(l&lt;=r) &#123; int mid=(l+r)/2; if(better(i,q[wei].j,mid)) pos=mid,r=mid-1; else l=mid+1; &#125; q[wei].r=pos-1; break; &#125; &#125; //if(LOCAL) printf("i=%d pos=%d\n",i,pos); if(pos&lt;=n) q[++wei]=(Nod)&#123;i,pos,n&#125;; &#125; if(big[n]) puts("Too hard to arrange"); else printf("%lld\n",f[n]); puts("--------------------"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CEOI2008】order]]></title>
    <url>%2Fposts%2F956c.html</url>
    <content type="text"><![CDATA[Source and JudgeCEOI2008bzoj3709luogu4177 Record2h Analysis请先思考后再展开 决策问题考虑网络流依赖关系再深入考虑到闭合子图如果没用租用机器这个选项，这就是个裸题租用机器和其他任务无关，考虑这个特征如果x依赖y，将原本的INF改成租金，表示破除依赖关系 当前弧优化：当层次确定的时候，反向弧是否使用也是确定的那么如果一条边流完了，可以在边链表中去除（有点类似欧拉路径的优化）因为是层次图，不用担心dfs对第一个有效边数组的影响 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=2100; int hou[MAX_N*2],cur[MAX_N*2]; struct Edge&#123;int y,g,c;&#125;e[MAX_N*MAX_N+2*MAX_N]; int ln;int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0&#125;;hou[y]=ln; &#125; int st,ed; int h[MAX_N*2]; queue&lt;int&gt; q; bool bfs() &#123; memcpy(cur,hou,sizeof hou); memset(h,0,sizeof h); q.push(st);h[st]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int now) &#123; if(x==ed) return now; int all=0; for(int k=cur[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and all&lt;now) &#123; int t=dfs(y,min(now-all,e[k].c)); all+=t;e[k].c-=t;e[oth(k)].c+=t; &#125; if(e[k].c==0) cur[x]=e[k].g; if(all==now) break;//剪枝1 &#125; if(all==0) h[x]=0;//剪枝2 return all; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); st=0;ed=n+m+1; int ans=0; for(int i=1;i&lt;=n;i++) &#123; int get;scanf("%d",&amp;get); ans+=get,ins(st,i,get); int k;scanf("%d",&amp;k); while(k--) &#123; int id,t;scanf("%d%d",&amp;id,&amp;t); ins(i,n+id,t); &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; int t;scanf("%d",&amp;t); ins(n+i,ed,t); &#125; while(bfs()) ans-=dfs(st,INF); printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poi2010】Bridges]]></title>
    <url>%2Fposts%2F85f0.html</url>
    <content type="text"><![CDATA[Source and JudgePoi2010bzoj2095 Record2h Analysis请先思考后再展开 这题有点东西（ozy语气） 显然先二分，终点是check其实就是验证一个混合图的欧拉回路考虑无向边，先钦定一个方向，到时候再考虑转向 条件：最后每个点的入度=出度而且是连通图（并查集一下即可） 考虑每次换向，相关的点，度的差会+2或者-2，所以说肯定不会差为奇数，要判一下然后这种决策性的问题，可以考虑网络流，假如钦定了x到y，则从y到x连一条边，表示转向，流量为1然后我们要平衡每个点的入度和出度，如果入度多出来，连向起点，流量为需要转向相关的次数即 $(in-out)/2$否则连向终点，表示一种需要平衡的状态最后如果能跑满流，意味着流量的平衡 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int hou[MAX_N]; struct Edge&#123;int y,g,c;&#125;e[MAX_N*10]; int ln;int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0&#125;;hou[y]=ln; &#125; int st,ed; int h[MAX_N*2]; queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,sizeof h); q.push(st);h[st]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int now) &#123; if(x==ed) return now; int all=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and all&lt;now) &#123; int t=dfs(y,min(now-all,e[k].c)); all+=t;e[k].c-=t;e[oth(k)].c+=t; &#125; &#125; if(all==0) h[x]=0; return all; &#125; int n,m; int a[MAX_N*2],b[MAX_N*2],c[MAX_N*2],d[MAX_N*2]; int in[MAX_N],out[MAX_N]; int fa[MAX_N]; int findfa(int x) &#123;return x==fa[x]?x:(fa[x]=findfa(fa[x]));&#125; void join(int x,int y) &#123;x=findfa(x);y=findfa(y);if(x!=y) fa[x]=y;&#125; bool check(int mid) &#123; memset(in,0,sizeof in); memset(out,0,sizeof out); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) &#123; if(c[i]&lt;=mid) out[a[i]]++,in[b[i]]++,join(a[i],b[i]); else if(d[i]&lt;=mid) out[b[i]]++,in[a[i]]++,join(a[i],b[i]); else return 0; //注意双向边要钦定 &#125; for(int i=2;i&lt;=n;i++) if(findfa(i)!=findfa(i-1)) return 0; ln=0;memset(hou,0,sizeof hou); int tot=0; st=0,ed=n+1; for(int i=1;i&lt;=n;i++) &#123; if((in[i]-out[i])%2) return 0; if(in[i]&gt;out[i]) ins(st,i,(in[i]-out[i])/2),tot+=(in[i]-out[i])/2; if(in[i]&lt;out[i]) ins(i,ed,(out[i]-in[i])/2); &#125; for(int i=1;i&lt;=m;i++) if(c[i]&lt;=mid and d[i]&lt;=mid) ins(b[i],a[i],1);//钦定a-&gt;b while(bfs()) dfs(st,INF); for(int k=hou[st];k&gt;0;k=e[k].g) if(e[k].c!=0) return 0;//满流 return 1; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d%d%d",&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); int l=0,r=1000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) puts("NIE"); else printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联盟]]></title>
    <url>%2Fposts%2F699c.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出一棵树，可以断开再连接一条边，求最小直径，n小于300000要求输出最小直径，和最优方案中所有可能断开的边，然后输出一组断开和连接的具体方案 Record7h Analysis请先思考后再展开 真tm佩服我的耐心都快忘记最初的思路了……太可怕了做法繁琐，细节无数，码量巨大，不愧是雅礼的防ak题 果然直径有很多性质，特别好用，虽然不会证明 就是两棵树合并起来，新的直径端点一定是在原本两边直径端点中产生 然后最优的连接方案一定是将两边直径的中点连接起来，这个倒好证明一点，连接其他地方一定不会更优$L=max(L1,L2,\lceil \frac{L1}{2} \rceil+\lceil \frac{L2}{2} \rceil+1)$ 考虑枚举每条边，断开他，然后问题变成求两边的直径，这个在处理了dfs序以后是可以用线段树维护的（注意，为了确保任何区间都能形成连通块，要回溯，这个在st表用深度求lca时也要用到）相当于，只用这段区间内的点，形成的树的直径，利用上面说的那个性质1合并（记录具体端点） 理论复杂度nlogn，但实际上因为结构体的维护，常数巨大，需要卡常本题有线性做法，感觉很繁琐，就没去搞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;namespace mine&#123; const int MAX_N=310000; const int INF=0x3f3f3f3f; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int hou[MAX_N],dep[MAX_N],faid[MAX_N],ff[MAX_N];//连向父亲的边的编号 struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int d1[MAX_N],d2[MAX_N],id=0; int h[MAX_N*2][25]; void dfs(int x,int fa) &#123; dep[x]=dep[fa]+1;ff[x]=fa; d1[x]=d2[x]=++id;h[id][0]=x; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; faid[y]=(k+1)/2;dfs(y,x); d2[x]=++id;h[id][0]=x;//确保连续的dfs序能连通 &#125; &#125; int getmin(int x,int y) &#123;return dep[x]&lt;dep[y]?x:y;&#125; int bin[40],log[MAX_N*2]; int getlca(int x,int y) &#123; x=d1[x];y=d2[y]; if(x&gt;y) swap(x,y);//debug int lg=log[y-x+1]; return getmin(h[x][lg],h[y-bin[lg]+1][lg]); &#125; int dis(int x,int y) &#123;return (x==0 or y==0)?INF:dep[x]+dep[y]-2*dep[getlca(x,y)];&#125; void preST() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; log[1]=0;for(int i=2;i&lt;MAX_N*2;i++) log[i]=log[i&gt;&gt;1]+1; dfs(1,0); for(int i=1;bin[i]&lt;=id;i++) for(int x=1;x&lt;=id-bin[i]+1;x++) h[x][i]=getmin(h[x][i-1],h[x+bin[i-1]][i-1]); &#125; struct Data&#123;int x,y;&#125;; Data getmax(Data a,Data b) &#123;return dis(a.x,a.y)&gt;dis(b.x,b.y)?a:b;&#125; Data merg(Data x,Data y) &#123; int a=x.x,b=x.y,c=y.x,d=y.y; if(a==0 and b==0) return y; if(c==0 and d==0) return x; Data now=getmax((Data)&#123;a,b&#125;,(Data)&#123;a,c&#125;); now=getmax(now,(Data)&#123;a,d&#125;); now=getmax(now,(Data)&#123;b,c&#125;); now=getmax(now,(Data)&#123;b,d&#125;); return getmax(now,(Data)&#123;c,d&#125;); &#125; Data zj[MAX_N*2*4]; struct SegmentTree &#123; #define lc 2*x #define rc 2*x+1 void build(int x,int l,int r) &#123; if(l==r) &#123;zj[x]=(Data)&#123;h[l][0],h[l][0]&#125;;return;&#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid);build(rc,mid+1,r); zj[x]=merg(zj[lc],zj[rc]); &#125; Data ask(int x,int l,int r,int fl,int fr) &#123; if(l==fl and r==fr) return zj[x]; int mid=(l+r)&gt;&gt;1; if(fr&lt;=mid) return ask(lc,l,mid,fl,fr); if(fl&gt;mid) return ask(rc,mid+1,r,fl,fr); return merg(ask(lc,l,mid,fl,mid),ask(rc,mid+1,r,mid+1,fr)); &#125; &#125;sgt; vector&lt;int&gt; output; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; preST(); sgt.build(1,1,id); //for(int i=1;i&lt;=n;i++) printf("%d:%d %d fm=%d\n",i,d1[i],d2[i],fm[i]); //printf("id=%d\n",id); int some;//one of result int ans=INF; for(int x=2;x&lt;=n;x++)//x-&gt;fa &#123; Data in=sgt.ask(1,1,id,d1[x],d2[x]); Data out=sgt.ask(1,1,id,1,d1[x]-1); if(d2[x]+1&lt;=id) out=merg(out,sgt.ask(1,1,id,d2[x]+1,id)); int ln1=dis(in.x,in.y),ln2=dis(out.x,out.y); int now=max( int(ceil((double)ln1/2)+ceil((double)ln2/2))+1,max(ln1,ln2) ); //printf("x=%d in=%d-&gt;%d=%d out=%d-&gt;%d=%d now=%d\n",x,in.x,in.y,ln1,out.x,out.y,ln2,now); if(now&lt;ans) &#123; ans=now;output.clear(); output.push_back(faid[x]);some=x; &#125; else if(now==ans) output.push_back(faid[x]); &#125; sort(output.begin(),output.end()); printf("%d\n%d ",ans,output.size()); for(int i=0;i&lt;(int)output.size();i++) printf("%d ",output[i]); int x=some; Data in=sgt.ask(1,1,id,d1[x],d2[x]); Data out=sgt.ask(1,1,id,1,d1[x]-1); if(d2[x]+1&lt;=id) out=merg(out,sgt.ask(1,1,id,d2[x]+1,id)); int a,b,ln1=dis(in.x,in.y),ln2=dis(out.x,out.y); for(int i=d1[x];i&lt;=d2[x];i++) if(myabs(dis(h[i][0],in.x)-dis(h[i][0],in.y))==(ln1&amp;1) and dis(h[i][0],in.x)+dis(h[i][0],in.y)==ln1) a=h[i][0]; for(int i=1;i&lt;=d1[x]-1;i++) if(myabs(dis(h[i][0],out.x)-dis(h[i][0],out.y))==(ln2&amp;1) and dis(h[i][0],out.x)+dis(h[i][0],out.y)==ln2) b=h[i][0]; for(int i=d2[x]+1;i&lt;=id;i++) if(myabs(dis(h[i][0],out.x)-dis(h[i][0],out.y))==(ln2&amp;1) and dis(h[i][0],out.x)+dis(h[i][0],out.y)==ln2) b=h[i][0]; printf("\n%d %d %d %d",x,ff[x],a,b); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蔬菜]]></title>
    <url>%2Fposts%2Fc8e3.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出一个矩阵，q次询问，求一个子矩阵中，每种颜色出现次数的平方和n和m在200以内，询问在100000以内 Record1h Analysis请先思考后再展开 这道题同时用到了多个思想显然先离散化一下 有一个子任务，可以给我们启示：颜色种类数比较少那我们可以给每种颜色处理一个二维前缀和 但如果比较多呢？有一个不好想的做法：对每种颜色的出现次数（总矩阵而言），分类讨论处理办法如果某种颜色数量多，意味着在总矩阵中份额大对于数量级达到T的颜色，只有 $\frac{n^2}{T}$ 种，这些是可以预处理前缀和的但对于零散的颜色，就要用另外一种思想了：平方和转点对数量也就是说，如果这些颜色的所有点内部形成点对那么每个询问就转化为一个四维偏序问题（询问为abcd）：$a \leq x1,x2 \leq b;c \leq y1,y2 \leq d$对于这种类型的颜色，处理所有点对，离线后将点对和询问混合再排序，那么就变成一个三位偏序问题，可以用三维树状数组搞这里有个细节，因为第一维我们用的是排序，但同时有可以去等，所以一定将具体类型作为第二关键字 接下来考虑复杂度零散的颜色即使有n方种，每次往前扫k个形成点对总时间为 $O(\frac{n^2}{T}(n^2+q)+(q+n^2T) log^3 n)$考虑均值不等式 $a+b \geq 2 \sqrt{ab}$ ，取等号当且仅当a=b，列等式计算得 $T=\sqrt{ \frac{n^2+q}{log^3 n} }$时间复杂度自行验证，通过计算知其也可以通过本题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; ll mysqr(ll x) &#123;return x*x;&#125; const int MAX_N=210; struct Nod&#123;int d,x,y;&#125;s[MAX_N*MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; int yz[MAX_N][MAX_N]; #define PR pair&lt;int,int&gt; #define FR first #define SE second vector&lt;PR&gt; old[MAX_N*MAX_N]; int bit[MAX_N][MAX_N][MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int y,int z,int d) &#123; for(int a=x;a&lt;MAX_N;a+=lowbit(a)) for(int b=y;b&lt;MAX_N;b+=lowbit(b)) for(int c=z;c&lt;MAX_N;c+=lowbit(c)) bit[a][b][c]+=d; &#125; int ask(int x,int y,int z) &#123; int ans=0; for(int a=x;a&gt;=1;a-=lowbit(a)) for(int b=y;b&gt;=1;b-=lowbit(b)) for(int c=z;c&gt;=1;c-=lowbit(c)) ans+=bit[a][b][c]; return ans; &#125; int tot=0;ll ans[110000]; struct Node&#123;int x1,x2,y1,y2,id;&#125;p[MAX_N*MAX_N*20+100000];//id=询问编号 bool cmp2(Node a,Node b) &#123;return a.x1&gt;b.x1 or (a.x1==b.x1 and a.id&lt;b.id);&#125; void solve() &#123; sort(p+1,p+tot+1,cmp2); for(int u=1;u&lt;=tot;u++) &#123; if(p[u].id==0) change(p[u].x2,p[u].y1,p[u].y2,1); else ans[p[u].id]+=(ask(p[u].x2,200,p[u].y2)-ask(p[u].x2,p[u].y1-1,p[u].y2)); &#125; &#125; int rx; int num[MAX_N*MAX_N];//count times int sum[MAX_N][MAX_N];//二维前缀和 void main() &#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); double lg=log2(n); int k=sqrt( (double)(n*n+q)/lg/lg/lg );//mx=20 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; int t;scanf("%d",&amp;t); s[(i-1)*m+j]=(Nod)&#123;t,i,j&#125;; &#125; sort(s+1,s+n*m+1,cmp);rx=0; for(int i=1;i&lt;=n*m;i++) &#123; if(i==1 or s[i-1].d!=s[i].d) rx++; yz[s[i].x][s[i].y]=rx;num[rx]++; &#125; for(int i=1;i&lt;=q;i++) &#123; int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); p[++tot]=(Node)&#123;a,c,b,d,i&#125;; &#125; //大量部分 for(int u=1;u&lt;=rx;u++) &#123; if(num[u]&gt;=k) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(yz[i][j]==u); for(int i=1;i&lt;=q;i++) &#123; int a=p[i].x1,b=p[i].y1,c=p[i].x2,d=p[i].y2; ans[i]+=mysqr(sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1]); &#125; &#125; &#125; //零散部分 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; int now=yz[i][j]; if(num[now]&lt;k) &#123; old[now].push_back( make_pair(i,j) ); for(int u=0;u&lt;(int)old[now].size();u++) &#123; Node tmp=(Node)&#123; min(old[now][u].FR,i),max(old[now][u].FR,i), min(old[now][u].SE,j),max(old[now][u].SE,j),0&#125;; p[++tot]=tmp; if(u!=(int)old[now].size()-1) p[++tot]=tmp;//debug 自己算一次 &#125; &#125; &#125; solve(); for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>四维偏序</tag>
        <tag>分类处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ2057】The Lost House]]></title>
    <url>%2Fposts%2F4075.html</url>
    <content type="text"><![CDATA[Source and JudgePOJ2057 Record2h Analysis请先思考后再展开 感觉这个期望的式子很不好推啊，我也是看了提示才想到的提示：将以x为根节点的子树代价，分答案是否在其中考虑，其期望分别为f和g “贪婪的动态规划”论文上没有利用期望的线性性，而我感觉用的话容易理解一点……我的方程：$g(x)=\sum 2+有虫子则g(y)$假如我们已经知道某个遍历顺序（尝试顺序，可能走到一半出来）然后考虑枚举某个孩子，答案就在这里的贡献$f(x)=\sum 该后继状态发生的可能 \times 该状态的期望$$f(x)=\sum \frac{叶子数量}{总叶子数量} ( \sum( g(s_1 \to s_{i-1})+2 ) + f(y)+1 )$注意这里g的计算规则和上面g那个一样，根据虫子跳出，具体实现可以前缀和 然后因为题目保证孩子数量最大为8，可以预处理所有排列，可通过本题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int son[MAX_N][10]; struct Nod&#123;int s[10];&#125;now; vector&lt;Nod&gt; pl[10]; bool use[10]; void dfs(int n,int k) &#123; if(k==n+1) &#123;pl[n].push_back(now);return;&#125; for(int i=1;i&lt;=n;i++) if(!use[i]) use[i]=1,now.s[k]=i,dfs(n,k+1),use[i]=0; &#125; double f[MAX_N],g[MAX_N]; bool cz[MAX_N]; int leave[MAX_N]; void solve(int x) &#123; int snum=son[x][0]; if(snum==0) leave[x]=1; else &#123; for(int i=1;i&lt;=son[x][0];i++) &#123; int y=son[x][i]; solve(y); g[x]+=(cz[y]?0:g[y])+2; leave[x]+=leave[y]; &#125; for(int t=0;t&lt;(int)pl[snum].size();t++) &#123; double tmp=0,nowg=0; for(int i=1;i&lt;=snum;i++) &#123; int y=son[x][ pl[snum][t].s[i] ]; tmp+=(nowg+f[y]+1)*leave[y]; nowg+=(cz[y]?0:g[y])+2; &#125; f[x]=min(f[x],tmp/leave[x]); &#125; //printf("f[%d]=%lf g[x]=%lf\n",x,f[x],g[x]); &#125; &#125; void main() &#123; for(int i=1;i&lt;=8;i++) dfs(i,1); while(1) &#123; int n,rt;scanf("%d",&amp;n); if(n==0) break; memset(son,0,sizeof son); memset(leave,0,sizeof leave); for(int i=1;i&lt;=n;i++) &#123; int fa;char str[4];scanf("%d%s",&amp;fa,str); cz[i]=(str[0]=='Y'); if(fa&lt;0) rt=i; else son[fa][++son[fa][0]]=i; &#125; for(int i=1;i&lt;=n;i++) g[i]=0,f[i]=(son[i][0]==0)?0:INF; solve(rt); printf("%.4lf\n",f[rt]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 其实还有更快的做法考虑相邻的两个，他们产生的贡献，=推推式子，再交换一下，就会变成：g的贡献（g(x)+2，同样考虑虫子来计算），除以其叶子数量那么这个比较只和自己有关，可以直接排序 这样1000个孩子我都不怕了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int son[MAX_N][10]; double f[MAX_N]; int g[MAX_N]; bool cz[MAX_N]; int leave[MAX_N]; bool cmp(int a,int b) &#123;return double(g[a]+2)*leave[b]&lt;double(g[b]+2)*leave[a];&#125; void solve(int x) &#123; int snum=son[x][0]; if(snum==0) leave[x]=1; else &#123; for(int i=1;i&lt;=snum;i++) &#123; int y=son[x][i]; solve(y); leave[x]+=leave[y]; g[x]+=g[y]+2; &#125; sort(son[x]+1,son[x]+snum+1,cmp); double nowg=0; for(int i=1;i&lt;=snum;i++) &#123; int y=son[x][i]; f[x]+=(nowg+f[y]+1)*leave[y]; nowg+=g[y]+2; &#125; f[x]/=leave[x]; if(cz[x]) g[x]=0; &#125; &#125; void main() &#123; while(1) &#123; int n,rt;scanf("%d",&amp;n); if(n==0) break; memset(son,0,sizeof son); memset(leave,0,sizeof leave); memset(f,0,sizeof f); memset(g,0,sizeof g); for(int i=1;i&lt;=n;i++) &#123; int fa;char str[4];scanf("%d%s",&amp;fa,str); cz[i]=(str[0]=='Y'); if(fa&lt;0) rt=i; else son[fa][++son[fa][0]]=i; &#125; solve(rt); printf("%.4lf\n",f[rt]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折射]]></title>
    <url>%2Fposts%2Fedc4.html</url>
    <content type="text"><![CDATA[Source and Judge雅礼noip模拟题 问题给出n个点，计数有多少种方案满足：yj &lt; yj−1xj−2 &lt; xj &lt; xj−1 或 xj−1 &lt; xj &lt; xj−2空间128，时间1sn小于6000 Record1h Analysis请先思考后再展开 以我自然的思维，直接把y排序了，然后空间就被卡128MB了正解是把x从小到大排序，那么问题会转化为区间dp，只不过方向稍微有点不同本代码保留了逐步优化的痕迹，应该非常好懂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=6100; struct Pt&#123;int x,y;&#125;p[MAX_N]; bool cmp(Pt a,Pt b) &#123;return a.x&lt;b.x;&#125; const int MOD=1e9+7; int get[2][MAX_N];//0左1右 //int f[MAX_N][MAX_N],get[2][MAX_N]; void mod(int &amp;a) &#123;if(a&gt;=MOD) a-=MOD;&#125; void main() &#123; freopen("refract.in","r",stdin); freopen("refract.out","w",stdout); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+n+1,cmp); int ans=n; for(int ln=2;ln&lt;=n;ln++) &#123; for(int i=1;i&lt;=n-ln+1;i++) &#123; int j=i+ln-1; if(p[i].y&lt;p[j].y) &#123; //for(int t=i+1;t&lt;=j-1;t++) if(p[t].y&lt;p[i].y) mod(f[i][j]+=f[t][i]); //mod(f[i][j]+=get[0][i]);mod(get[1][j]+=f[i][j]); int now=1;//f[1][j] mod(now+=get[0][i]);mod(get[1][j]+=now); mod(ans+=now); &#125; else &#123; //for(int t=i+1;t&lt;=j-1;t++) if(p[t].y&lt;p[j].y) mod(f[j][i]+=f[t][j]); //mod(f[j][i]+=get[1][j]);mod(get[0][i]+=f[j][i]); int now=1;//f[0][i] mod(now+=get[1][j]);mod(get[0][i]+=now); mod(ans+=now); &#125; &#125; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2015 接水果]]></title>
    <url>%2Fposts%2F4478.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2015 接水果 Record1h Analysis请先思考后再展开 目前见过最难的整体二分了，但也不是很难，可能是我刷题太少 包含这东西，很显然可以化化式子，然后就是dfs序的一个矩形 问题转化为，求每个点，覆盖它的矩形中，第k大的整体第k大的查询，就是很套路二分以后，重点就是check，用小于mid的部分，询问被多少个覆盖掉那这个暴力搞得话例如cdq、树套树什么的……但都太复杂了没细想其实，重点在于它是一个矩形，可以扫描线搞 例如说拆成左线段和右线段，然后就变成修改和查询，然后就树状数组询问次数就好了 顺便提供一份反例代码，改成盘子是水果的父路径看错题的自我安慰：能出题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int bin[30]; const int MAX_N=41000; struct Bit &#123; int bit[MAX_N]; Bit()&#123;memset(bit,0,sizeof bit);&#125; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; while(x&lt;MAX_N) bit[x]+=c,x+=lowbit(x); &#125; int sum(int x) &#123; int ans=0; while(x&gt;=1) ans+=bit[x],x-=lowbit(x); return ans; &#125; &#125;bit; struct Tree &#123; int n; int hou[MAX_N],dfn[MAX_N],siz[MAX_N],dep[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln,id;Tree()&#123;memset(hou,0,sizeof hou);dep[0]=0;ln=id=0;&#125; void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int f[MAX_N][30]; void dfs(int x,int fa) &#123; dfn[x]=++id;siz[x]=1;dep[x]=dep[fa]+1; f[x][0]=fa;for(int i=1;i&lt;=20;i++) f[x][i]=f[ f[x][i-1] ][i-1]; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x);siz[x]+=siz[y]; &#125; &#125; int lca(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=20;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int jump(int x,int t) &#123; for(int i=20;i&gt;=0;i--) if(t&amp;bin[i]) x=f[x][i]; return x; &#125; &#125;tr; struct Nod &#123; int a,b,c; int fm; int tmp; &#125;pt[2*MAX_N],qes[MAX_N],tmp1[MAX_N*2],tmp2[MAX_N*2]; bool cmp(Nod a,Nod b) &#123;return a.a&lt;b.a;&#125; struct Qes &#123; int a,b; int fm,xx; &#125;q[MAX_N*8]; bool cmp2(Qes a,Qes b) &#123;return a.a&lt;b.a;&#125; int cnt; void add(int a,int b,int c,int d,int fm) &#123; if(a&gt;b or c&gt;d) return; if(a-1&gt;0 and c-1&gt;0) q[++cnt]=(Qes)&#123;a-1,c-1,fm,1&#125;; if(c-1&gt;0) q[++cnt]=(Qes)&#123;b,c-1,fm,-1&#125;; if(a-1&gt;0) q[++cnt]=(Qes)&#123;a-1,d,fm,-1&#125;; q[++cnt]=(Qes)&#123;b,d,fm,1&#125;; &#125; int ans[MAX_N],tans[MAX_N]; void solve(int fl,int fr,int ql,int qr,int pl,int pr) &#123; if(ql&gt;qr or pl&gt;pr) return; if(fl==fr) &#123; for(int i=ql;i&lt;=qr;i++) ans[qes[i].fm]=fl; return; &#125; if(pl==pr) &#123; for(int i=ql;i&lt;=qr;i++) ans[qes[i].fm]=pt[pl].c; return; &#125; int mid=(fl+fr)/2; int tot1=0,tot2=0; for(int i=pl;i&lt;=pr;i++) if(pt[i].c&lt;=mid) tmp1[++tot1]=pt[i]; else tmp2[++tot2]=pt[i]; for(int i=1;i&lt;=tot1;i++) pt[pl+i-1]=tmp1[i]; for(int i=1;i&lt;=tot2;i++) pt[pl+tot1+i-1]=tmp2[i]; int left=tot1; //两边内部仍有序 cnt=0; for(int i=ql;i&lt;=qr;i++) &#123; int a=qes[i].a,b=qes[i].b,t=qes[i].tmp; if(t) &#123; add(1,tr.dfn[t]-1, tr.dfn[b],tr.dfn[b]+tr.siz[b]-1,i); add(tr.dfn[t]+tr.siz[t],tr.n,tr.dfn[b],tr.dfn[b]+tr.siz[b]-1,i); &#125; else add(tr.dfn[a],tr.dfn[a]+tr.siz[a]-1,tr.dfn[b],tr.dfn[b]+tr.siz[b]-1,i); &#125; sort(q+1,q+cnt+1,cmp2); int t=pl-1; for(int i=ql;i&lt;=qr;i++) tans[i]=0; for(int i=1;i&lt;=cnt;i++) &#123; while(t+1&lt;=pl+tot1-1 and pt[t+1].a&lt;=q[i].a) bit.change(pt[++t].b,1); //printf("t=%d\n",t); tans[q[i].fm]+=q[i].xx*bit.sum(q[i].b); &#125; for(int i=pl;i&lt;=t;i++) bit.change(pt[i].b,-1); tot1=0,tot2=0; for(int i=ql;i&lt;=qr;i++) &#123; if(qes[i].c&lt;=tans[i]) tmp1[++tot1]=qes[i]; else qes[i].c-=tans[i],tmp2[++tot2]=qes[i];//debug 顺序…… &#125; for(int i=1;i&lt;=tot1;i++) qes[ql+i-1]=tmp1[i]; for(int i=1;i&lt;=tot2;i++) qes[ql+tot1+i-1]=tmp2[i]; solve(fl,mid,ql,ql+tot1-1,pl,pl+left-1); solve(mid+1,fr,ql+tot1,qr,pl+left,pr); &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int pp,qq;scanf("%d%d%d",&amp;tr.n,&amp;pp,&amp;qq); for(int i=1;i&lt;=tr.n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); tr.ins(x,y);tr.ins(y,x); &#125; tr.dfs(1,0); for(int i=1;i&lt;=pp;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); a=tr.dfn[a],b=tr.dfn[b]; pt[2*i-1]=(Nod)&#123;a,b,c,0,0&#125;; pt[2*i]=(Nod)&#123;b,a,c,0,0&#125;; //一次只会计算到一个 &#125; sort(pt+1,pt+pp*2+1,cmp); for(int i=1;i&lt;=qq;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(tr.dep[a]&gt;tr.dep[b]) swap(a,b); //a-&gt;t-&gt;b在一条竖直的链上 qes[i]=(Nod)&#123;a,b,c,i,(tr.lca(a,b)==a)?tr.jump(b,tr.dep[b]-tr.dep[a]-1):0&#125;; &#125; solve(0,1e9,1,qq,1,2*pp); for(int i=1;i&lt;=qq;i++) printf("%d\n",ans[i]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Wf2016】Swap Space【PA2014】Bohater]]></title>
    <url>%2Fposts%2F2c33.html</url>
    <content type="text"><![CDATA[Source and JudgeWf2016 Swap SpacePA2014 Bohaterbzoj3709bzoj1495 Record30min Analysis请先思考后再展开 神仙栋老师的比赛题然后发现对于下降的类型，按b降序能过样例和随便手出的数据写一发，和其他策略对拍也没错，然后就顺利瞎jb过了…… 赛后补一发证明（忽略相等情况等细节）：设有1号和2号，满足 $a1&gt;b1,a2&gt;b2,b1&gt;b2$$A=max(a1,a1-b1+a2)$$B=max(a2,a2-b2+a1)$仅当 $A&lt;B$ 时，1号放在2号前面 情况1$a1&lt;a2$ 此时1号优 情况2$a1&gt;a2$① $b1&lt;a2$$a1&gt;a2&gt;b2$$A=a1-b1+a2$$B=a2-b2+a1$则1号优 ② $b1&gt;a2$$a1&gt;b1&gt;a2&gt;b2$$A=a1$$B=a2-b2+a1$则1号优 综上所述，b越大越应该放在前面]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适者]]></title>
    <url>%2Fposts%2F81f.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj4700 Record1h Analysis请先思考后再展开 神仙栋老师的比赛题 毫无疑问，应该先把血量转化为需要攻击的次数 先考虑一开始不杀人的情况设有相邻的两个，编号1号和2号，1号在2号前的必要条件是 $t[1] \cdot a[2]&lt;t[2] \cdot a[1]$其实这就是个性价比，比赛的时候顺利猜到结论……那么顺序就确定了 T表示时间的前缀和，A表示攻击力的后缀和然后时间总和就是 $\sum (t[i]-1) \times a[i] + t[i] \times A[i+1]$ 考虑杀死一个的情况，将每个人被秒杀的价值表示出来$c[i]=(T[i]-1) \times a[i] + t[i] \times A[i+1]$但两个（设为 x &lt; y ）怎么处理呢？$c[x]+c[y]-t[x] \cdot a[y]$前一个的决策影响后一个，如果直接枚举，好像也没有什么好办法 做法一把y固定，x的贡献就是一个关于ay的一次函数（直线）然后询问相当于找到与直线交点中y最大的那个有一种名为李超线段树的数据结构能很方便地维护其主要思路就是，记录当前区间内，完全覆盖的线段（本题是直线，不用考虑）中交mid最高的那个然后因为只能和当前层有关，只能标记永久化当一个线段被淘汰的时候，就往某个方向下传更新（自行推导具体方向）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310000; struct Nod&#123;int a,t;ll c;&#125;s[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.a*b.t&gt;b.a*a.t;&#125; ll dairu(int id,int x) &#123;return s[id].c-(ll)x*s[id].t;&#125; struct SegmentTree &#123; int mx[MAX_N*4]; #define lc (2*x) #define rc (2*x+1) void change(int x,int l,int r,int id) &#123; ll l1=dairu(id,l),l2=dairu(mx[x],l); ll r1=dairu(id,r),r2=dairu(mx[x],r); if(l==r) &#123; if(l1&gt;l2) mx[x]=id; return; &#125; if(l1&gt;=l2 and r1&gt;=r2) &#123;mx[x]=id;return;&#125; else if(l2&gt;=l1 and r2&gt;=r1) return; else &#123; int mid=(l+r)/2; int mid1=dairu(id,mid),mid2=dairu(mx[x],mid); if(mid1&gt;=mid2) swap(id,mx[x]),swap(l1,l2);//向下传可能有用的sid if(l1&lt;=l2) change(rc,mid+1,r,id); else change(lc,l,mid,id); &#125; &#125; ll ask(int x,int l,int r,int pos) &#123; ll ans=dairu(mx[x],pos); if(l&lt;r) &#123; int mid=(l+r)/2; if(pos&lt;=mid) ans=max(ans,ask(lc,l,mid,pos)); else ans=max(ans,ask(rc,mid+1,r,pos)); &#125; return ans; &#125; &#125;sgt; ll T[MAX_N],A[MAX_N];//前缀时间，后缀攻击 void main() &#123; int n,atk;scanf("%d%d",&amp;n,&amp;atk); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;s[i].a,&amp;s[i].t),s[i].t=ceil((double)s[i].t/atk); sort(s+1,s+n+1,cmp); ll ans=0; for(int i=n;i&gt;=1;i--) A[i]=A[i+1]+s[i].a; for(int i=1;i&lt;=n;i++) &#123; T[i]=T[i-1]+s[i].t,s[i].c=(T[i]-1)*s[i].a+A[i+1]*s[i].t; ans+=ll(s[i].t-1)*s[i].a+A[i+1]*s[i].t; &#125; ll tmp=0; for(int y=1;y&lt;=n;y++) &#123; tmp=max(tmp,s[y].c+sgt.ask(1,1,10000,s[y].a)); sgt.change(1,1,10000,y); &#125; printf("%lld",ans-tmp); &#125;&#125;;int main()&#123; mine::main();&#125; 做法二其实看起来会联想到斜率优化的方程形式…… 同样是固定y，设有 a &lt; b则a更优秀的条件： $c[a]-t[a] \cdot a[y] &gt; c[b]-t[b] \cdot a[y]$如果 $t[a]-t[b]&gt;0,\frac{c[a]-c[b]}{t[a]-t[b]} &gt; a[y]$这个斜率是单调递增的，也就是一个下凸壳，具体证明可以随便画一个经典的凸三角 因为在原本的顺序上，t和a都不是单调的，所以相当于维护一个动态凸壳可以用平衡树搞，也可以用cdq 这里讲cdq的做法，因为比较短只考虑左边对右边的影响左边按照t降序，强行满足上面的条件右边按照a升序，那么单调队列的头是只会往后的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAX_N=310000;struct Nod&#123;int a,t;ll c;&#125;s[MAX_N];bool cmp(Nod a,Nod b) &#123;return a.a*b.t&gt;b.a*a.t;&#125;bool cmp2(Nod a,Nod b) &#123;return a.t&gt;b.t;&#125;bool cmp3(Nod a,Nod b) &#123;return a.a&lt;b.a;&#125;ll X(int a,int b) &#123;return (ll)s[a].t-s[b].t;&#125;ll Y(int a,int b) &#123;return s[a].c-s[b].c;&#125;ll mx=0;int que[MAX_N];void solve(int l,int r)&#123; if(l&gt;=r) return; int mid=(l+r)/2; solve(l,mid);solve(mid+1,r); sort(s+l,s+mid+1,cmp2);sort(s+mid+1,s+r+1,cmp3); int tou=1,wei=1;que[tou]=l; for(int now=l+1;now&lt;=mid;now++) &#123; while(tou&lt;wei and Y(que[wei-1],que[wei])*X(que[wei],now) &gt; Y(que[wei],now)*X(que[wei-1],que[wei]) ) wei--; //while(tou&lt;wei and slope(que[wei-1],que[wei])&gt;slope(que[wei],now)) wei--; que[++wei]=now; &#125; for(int y=mid+1;y&lt;=r;y++) &#123; while(tou&lt;wei and Y(que[tou],que[tou+1])&lt;X(que[tou],que[tou+1])*s[y].a) tou++; int x=que[tou];mx=max(mx,s[x].c+s[y].c-(ll)s[x].t*s[y].a); &#125;&#125;ll T[MAX_N],A[MAX_N];//前缀t，后缀aint main()&#123; int n,atk;scanf("%d%d",&amp;n,&amp;atk); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;s[i].a,&amp;s[i].t); s[i].t=ceil((double)s[i].t/atk); &#125; sort(s+1,s+n+1,cmp); for(int i=n;i&gt;=1;i--) A[i]=A[i+1]+s[i].a; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; T[i]=T[i-1]+s[i].t; s[i].c=(T[i]-1)*s[i].a+A[i+1]*s[i].t; ans+=ll(s[i].t-1)*s[i].a+A[i+1]*s[i].t; &#125; solve(1,n); printf("%lld",ans-mx);&#125; 左右两边关键字不同，怎么把log省掉呢？其实维护两个数组，要用哪个用哪个就好了……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAX_N=310000;struct Nod&#123;int a,t;ll c;&#125;s[MAX_N],s2[MAX_N],tmp[MAX_N];bool cmp(Nod a,Nod b) &#123;return a.a*b.t&gt;b.a*a.t;&#125;ll X(int a,int b) &#123;return (ll)s[a].t-s[b].t;&#125;ll Y(int a,int b) &#123;return s[a].c-s[b].c;&#125;ll mx=0;int que[MAX_N];void cdq(int l,int r)&#123; if(l&gt;=r) return; int mid=(l+r)/2; cdq(l,mid);cdq(mid+1,r); int tou=1,wei=1;que[tou]=l; for(int now=l+1;now&lt;=mid;now++) &#123; while(tou&lt;wei and Y(que[wei-1],que[wei])*X(que[wei],now) &gt; Y(que[wei],now)*X(que[wei-1],que[wei]) ) wei--; //while(tou&lt;wei and slope(que[wei-1],que[wei])&gt;slope(que[wei],now)) wei--; que[++wei]=now; &#125; for(int y=mid+1;y&lt;=r;y++) &#123; while(tou&lt;wei and Y(que[tou],que[tou+1]) &lt; X(que[tou],que[tou+1])*s2[y].a) tou++; int x=que[tou];mx=max(mx,s[x].c+s2[y].c-(ll)s[x].t*s2[y].a); &#125; //t递减 &#123; for(int i=l;i&lt;=r;i++) tmp[i]=s[i]; int now=l,now1=l,now2=mid+1; while(now1&lt;=mid and now2&lt;=r) &#123; if(tmp[now1].t&gt;=tmp[now2].t) s[now++]=tmp[now1++]; else s[now++]=tmp[now2++]; &#125; for(int i=now1;i&lt;=mid;i++) s[now++]=tmp[i]; for(int i=now2;i&lt;=r;i++) s[now++]=tmp[i]; &#125; //a递增 &#123; for(int i=l;i&lt;=r;i++) tmp[i]=s2[i]; int now=l,now1=l,now2=mid+1; while(now1&lt;=mid and now2&lt;=r) &#123; if(tmp[now1].a&lt;=tmp[now2].a) s2[now++]=tmp[now1++]; else s2[now++]=tmp[now2++]; &#125; for(int i=now1;i&lt;=mid;i++) s2[now++]=tmp[i]; for(int i=now2;i&lt;=r;i++) s2[now++]=tmp[i]; &#125;&#125;ll T[MAX_N],A[MAX_N];//前缀t，后缀aint main()&#123; int n,atk;scanf("%d%d",&amp;n,&amp;atk); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;s[i].a,&amp;s[i].t); s[i].t=ceil((double)s[i].t/atk); &#125; sort(s+1,s+n+1,cmp); for(int i=n;i&gt;=1;i--) A[i]=A[i+1]+s[i].a; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; T[i]=T[i-1]+s[i].t; s[i].c=(T[i]-1)*s[i].a+A[i+1]*s[i].t; ans+=ll(s[i].t-1)*s[i].a+A[i+1]*s[i].t; &#125; memcpy(s2,s,sizeof s); cdq(1,n); printf("%lld",ans-mx);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>动态凸包</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC41】最短路]]></title>
    <url>%2Fposts%2Fabe2.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC41 Record1h Analysis请先思考后再展开 暴力分是个经典套路，居然忘记了……参见 WC2011 最大XOR和路径，之前写过题解的就是把每条环的异或和放到线性基里面 正解感觉不太好想，不过被xgc大爷秒了就是给r排序，然后不同的线性基只有30个用链表动态维护好左边的每一个位置（记录left表示最后一个有贡献的位置）询问的时候30+30找到包含的第一个查询的时候，因为左边的线性基会包含右边的，从右往左扫，现在插入的num不断少个1，具有单调性这样乍一看是log方的，但如果预处理出每个数的最高位的位置，insert的时候从那里开始，就log的复杂度了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310000; struct Nod &#123; int hou; int dis;//xor Nod() &#123;hou=dis=0;&#125; &#125;p[MAX_N]; struct Edge&#123;int y,g,c;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln;&#125; void dfs(int x,int fa) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis^e[k].c;dfs(y,x); &#125; &#125; int bin[40],Log[70000]; int hbit(int num) &#123;return (num&gt;bin[16])?(16+Log[num/bin[16]]):Log[num];&#125; struct Lin &#123; int nxt,left;//链表 int lin[40]; void init(int ll,int num)//num&gt;0 &#123; memset(lin,0,sizeof lin);left=ll; lin[hbit(num)]=num; &#125; int insert(int num)//return 剩下 &#123; while(num&gt;0) &#123; int t=hbit(num); if(lin[t]==0) &#123;lin[t]=num;return num;&#125; num^=lin[t]; &#125; return 0;//fail &#125; int quary(int num)//min xor &#123; for(int i=30;i&gt;=0;i--) if(num&amp;bin[i]) num^=lin[i]; return num; &#125; &#125;lb[40]; int id=0,rt=0; void insert(int pos,int num)//log &#123; if(num==0) return; int now=rt,lst=-1,backup=num; while(now&gt;0) &#123; num=lb[now].insert(num); if(num==0) break; lst=now;now=lb[now].nxt; &#125; if(lst&lt;0 and rt&gt;0) return;//空是允许的 if(num==0) &#123; lb[lst].nxt=lb[now].nxt; lb[lst].left=lb[now].left;//debug 延长 lb[now].nxt=rt;rt=now; &#125; else//线性无关，新的贡献 &#123; lb[++id].nxt=rt;rt=id; &#125; lb[rt].init(pos,backup);//backup&gt;0 &#125; int quary(int left,int num)//log &#123; int now=rt;while(left&lt;lb[now].left) now=lb[now].nxt;//包含 //这里其实很奇怪，在我理解中应该是now的后一个才对 return lb[now].quary(num); &#125; int get[MAX_N];//环的贡献 struct Qes&#123;int id,left,now;&#125;; vector&lt;Qes&gt; qq[MAX_N];//according to right point int ans[MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; Log[1]=0;for(int i=2;i&lt;70000;i++) Log[i]=Log[i&gt;&gt;1]+1; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n-1;i++) &#123;int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c);ins(x,y,c);ins(y,x,c);&#125; dfs(1,0); for(int i=1;i&lt;=m;i++) &#123;int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c);get[i]=p[x].dis^p[y].dis^c;&#125; for(int i=1;i&lt;=q;i++) &#123; int st,ed,l,r;scanf("%d%d%d%d",&amp;st,&amp;ed,&amp;l,&amp;r); qq[r].push_back( (Qes)&#123;i,l,p[st].dis^p[ed].dis&#125; ); &#125; for(int r=1;r&lt;=m;r++) &#123; insert(r,get[r]); for(int t=0;t&lt;(int)qq[r].size();t++) ans[qq[r][t].id]=quary(qq[r][t].left,qq[r][t].now); &#125; for(int i=1;i&lt;=q;i++) printf("%d\n",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125;其实还有更简单的写法……根本不需要30个线性基，也不需要预处理什么的只维护一个线性基，每个数位存储值和能产生贡献的最后那个位置然后回答询问的时候判断其位置能否消除我的1即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>线性基</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC40】Erlang]]></title>
    <url>%2Fposts%2Fcc15.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC40 Record1h Analysis请先思考后再展开 一开始看错题意了，决策可以是动态的，根据取出来的数再决定下一步 如果是静态的话，显然最多搞两个集合考虑枚举每一种颜色一、如果某个集合有多个，贡献为 len-其他种类+2（取光其他所有才出来）二、分开来， len-其他种类+1 最少的两个之和（最后才出来）时间复杂度n 其实改成动态并不难，最多搞两个集合这个性质依然是对的，但不能再枚举具体颜色了一、如果某个集合有多个，贡献为 颜色种类+1二、分开来这里是难点自己曾想到一种情况，但不知道怎么解决：可能我后面取出来的答案即使加上取出来的消耗依然比早出来的小然后看到动态决策就很蒙蔽，不知道怎么处理…… 其实很容易证明，最坏情况一定是按贡献从大到小出来的用微扰可以证明，其他的情况都会比这个更优所以排序后每个的贡献就很明确了，即【存在此颜色的所有集合中，除了这个之外，最小的 其他颜色个数+1】（这里我们不再考虑，因为取到别的相同颜色而停止的情况，因为在前面已经计算过了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=510000; int cc[MAX_N];bool cmp(int a,int b) &#123;return a&gt;b;&#125; int mi[MAX_N],mi2[MAX_N]; void insert(int num,int c) &#123; //printf("num=%d c=%d\n",num,c); if(c&lt;mi[num]) mi2[num]=mi[num],mi[num]=c; else if(c&lt;mi2[num]) mi2[num]=c; &#125; vector&lt;int&gt; a[MAX_N]; int n,ans=INF; int ct[MAX_N];//值的出现情况 void solve() &#123; for(int i=1;i&lt;=n;i++) &#123; int tmp=0,m=(int)a[i].size(); for(int j=0;j&lt;m;j++) ct[a[i][j]]++; for(int j=0;j&lt;m;j++) &#123; int get=mi[a[i][j]]; if(get==m-ct[a[i][j]]+1) get=mi2[a[i][j]]; cc[++tmp]=get; &#125; for(int j=0;j&lt;m;j++) ct[a[i][j]]--; sort(cc+1,cc+tmp+1,cmp); for(int j=1;j&lt;=tmp;j++) ans=min(ans,cc[j]+j); &#125; if(ans==INF) puts("-1"); else printf("%d",ans); &#125; int ed[MAX_N]; int b[MAX_N];//集合的种类数 void main() &#123; memset(mi,63,sizeof mi); memset(mi2,63,sizeof mi2); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int m;scanf("%d",&amp;m); bool bk=0; for(int j=0;j&lt;m;j++) &#123; int t;scanf("%d",&amp;t); a[i].push_back(t);ed[t]=j; if(ct[t]==0) b[i]++; else bk=1; ct[t]++; &#125; if(bk) ans=min(ans,b[i]+1);//只选一个的情况 for(int j=0;j&lt;(int)a[i].size();j++) &#123; if(ed[a[i][j]]==j) insert(a[i][j],(int)a[i].size()-ct[a[i][j]]+1);//只插入一次 ct[a[i][j]]--; &#125; &#125; solve(); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2006】网络收费]]></title>
    <url>%2Fposts%2F51ff.html</url>
    <content type="text"><![CDATA[Source and JudgeNOI2006Luogu4297bzoj1495 Record1h Analysis请先思考后再展开 一开始没看懂题意……这里费用的计算，是对于所有的点对，而不是自己配对…… 因为是所有点对，观察系数，发现可以拆分到点权上预处理cost[x][j]表示x这个叶子节点，【与其lca在第j层】的节点的f之和那么如果知道了这个祖先管辖区域内哪种多，就能知道具体费用了 接下来基本上就等价于 JLOI2015 战争调度 了就是管理节点有两种类型，暴力枚举，背包时去除非法状态然后叶子节点也是两种，暴力向上统计 时间复杂度的话，$T(m)=4T(\frac{m}{2})+2m$设 $T(m)=1$ ，则根据主定理得 $T(m)=m^2$然后 $m=2^n,T(2^n)=2^{2n}$考虑到 $T(1)=n$ ，时间复杂度为 $O(n \times 2^{2n})$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC31】MST]]></title>
    <url>%2Fposts%2F381c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC31 Record3h Analysis请先思考后再展开 神仙题，%出题人这道题我能非常认同其做法，但我深知不是我能自己想出来的范围内 如果我按顺序枚举每一条边，那么非树边一定连接同一个块，而树边连接不同两个块因为每个节点都是一样的，用【每个大小的连通块数量】表示，这个状态总数是37338用这个状态的出现编号作为hash，那么就可以用这个来线性dp把状态按照【越大连通块是越前的关键字】排序，这样就能保证线性性然后顺序枚举每个状态，往后继状态转移为了方便找到对应的hash，建议用一个trie，因为map是其15倍（如果hash不稳……） 现在是 $O(n^4 \times 状态)$ 的，分情况加速考虑树边，枚举两个连通块然后合并起来，在这个过程中显然和具体边无关所以可以对于每个状态预处理，记录能否转移以及转移系数（这个自行推算）考虑非树边，因为是一个完全图，我们需要知道有哪些地方还能加入边注意到加入之后状态的表示没有变化，所以其实跟具体在哪个加入是没有关系的所以说，可以动态维护一个全局num数组，表示每个状态在当前可以加入的空位数量这个东西的维护可以自行推导 注意到一个重要的细节，也是我之前的疑惑之处就是我原本认为这个num应当是状态的一部分，但显然这样会炸其实你会发现，在外层枚举了边数之后，某个状态的num其实是确定的（从num的维护可以看出） 然后这道题就做了两天…… 计数dp中，滚动数组用完要清零 注意各种边界 其实这个num是可以不用dp的，不过我不想再花n的时间去计算num，好像ozy会很快的方法，不管了…… 时间复杂度的话，感觉是n三方的，而且个人感觉会跑满……然而最后还是O(能过)，可能会有更优秀的做法? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int n; //*******************State******************* struct Nod&#123;int num[41],pos;&#125;p[40000];//pos用于还原 bool cmp(Nod a,Nod b) &#123; for(int i=n;i&gt;=1;i--) if(a.num[i]!=b.num[i]) return a.num[i]&gt;b.num[i]; return 0; &#125; void output(Nod a) &#123; for(int j=1;j&lt;=n;j++) printf("%d ",a.num[j]); puts(""); &#125; //*******************Trie******************* struct Trie &#123; int hash; int son[41]; void clear() &#123;memset(son,0,sizeof son);&#125; &#125;tr[1500000]; int id=0; int findhash(Nod to) &#123; int now=0; for(int i=1;i&lt;=n;i++) &#123; int wt=tr[now].son[ to.num[i] ]; if(wt==0) return -1; now=wt; &#125; return tr[now].hash; &#125; int cnt=0,a[50]; void addhash() &#123; int now=0; for(int i=1;i&lt;=n;i++) &#123; if(tr[now].son[a[i]]==0) tr[now].son[a[i]]=++id,tr[id].clear(); now=tr[now].son[a[i]]; &#125; p[++cnt].pos=now; for(int i=1;i&lt;=n;i++) p[cnt].num[i]=a[i]; &#125; void dfs(int num,int now) &#123; if(now==0) &#123; if(num==0) addhash(); return; &#125; for(int i=0;i&lt;=num/now;i++) a[now]=i,dfs(num-now*i,now-1); &#125; //*******************prework******************* const ll MOD=1e9+7; int hou[40000]; struct Edge&#123;int y,g;int xs,adnum;&#125;;//系数、可用边数量的增加 vector&lt;Edge&gt; e;//O(开的下)…… void prework() &#123; e.push_back((Edge)&#123;0,0,0&#125;);//规避 编号0 for(int s=1;s&lt;=cnt;s++) &#123; Nod now=p[s]; for(int a=1;a&lt;=n-1;a++) if(now.num[a]&gt;0) for(int b=a;a+b&lt;=n;b++) if(now.num[b]&gt;(a==b)) &#123; int xs=(ll)a*b%MOD; if(a==b) xs=(ll)xs*(now.num[a]*(now.num[a]-1)/2)%MOD; else xs=(ll)xs*now.num[a]*now.num[b]%MOD;//有序数对 Nod tmp=now;tmp.num[a]--;tmp.num[b]--;tmp.num[a+b]++; int s2=findhash(tmp);if(s2&lt;0) continue; e.push_back( (Edge)&#123;s2,hou[s],xs,a*b-1&#125; );hou[s]=e.size()-1; &#125; &#125; &#125; //*******************dp******************* bool istree[50*50]; int f[2][40000],num[2][40000];//num用来简便计算 void solve() &#123; for(int i=1;i&lt;=n-1;i++) &#123;int t;scanf("%d",&amp;t);istree[t]=1;&#125; f[0][cnt]=1; for(int ln=1;ln&lt;=n*(n-1)/2;ln++) for(int s=1;s&lt;=cnt;s++) if(f[(ln-1)&amp;1][s])//01背包，自带滚动 &#123; if(istree[ln]) &#123; for(int k=hou[s];k&gt;0;k=e[k].g) &#123; int s2=e[k].y; f[ln&amp;1][s2]=(f[ln&amp;1][s2]+(ll)e[k].xs*f[(ln-1)&amp;1][s]%MOD)%MOD; num[ln&amp;1][s2]=num[(ln-1)&amp;1][s]+e[k].adnum;//覆盖无影响 &#125; &#125; else &#123; if(num[(ln-1)&amp;1][s]&gt;0) &#123; f[ln&amp;1][s]=(f[ln&amp;1][s]+(ll)f[(ln-1)&amp;1][s]*num[(ln-1)&amp;1][s]%MOD)%MOD; num[ln&amp;1][s]=num[(ln-1)&amp;1][s]-1; &#125; else f[ln&amp;1][s]=num[ln&amp;1][s]=0; &#125; f[(ln-1)&amp;1][s]=num[(ln-1)&amp;1][s]=0; &#125; &#125; void main() &#123; scanf("%d",&amp;n); tr[0].clear();dfs(n,n);sort(p+1,p+cnt+1,cmp); for(int i=1;i&lt;=cnt;i++) tr[p[i].pos].hash=i; prework();solve(); printf("%d",f[(n*(n-1)/2)&amp;1][1]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC32】Sort]]></title>
    <url>%2Fposts%2Fbfa5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC32 Record1h Analysis请先思考后再展开 思考排序本质的好题 先考虑只有0和1的做法考虑归并排序，那么一定是000000111110000001111这样的那么只要把中间的部分翻转就好了 回到原问题，回忆朴素的快排，找到一个基准点后，小的放左边，大的放右边，再搞一下去那这个过程可以转化为01序列然后套归并上去 不过这里会出现很多细节，比如132，就不能保证小的到左边如果变成0、1、2或许可以解决问题，但这样再归并会很麻烦一种巧妙的做法是基于值域分治（离散化后） 时间显然是log方的，现在让我们证明代价的复杂度（忽略常数） 归并：$T(n)=2T(\frac{n}{2})+n$根据主定理，$T(n)=nlogn$ 快排：$T_2(n)=2T_2(\frac{n}{2})+T(n)=2T_2(\frac{n}{2})+nlogn$那么每层是nlogn，然后有log层$T_2(n)=nlog^2n$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=51000; int n; int a[MAX_N]; void mergsort(int l,int r,int pt) &#123; if(l&gt;=r) return; int mid=(l+r)/2; mergsort(l,mid,pt);mergsort(mid+1,r,pt); int fl=l;while(a[fl]&lt;=pt and fl&lt;=mid) fl++; int fr=r;while(a[fr]&gt;pt and fr&gt;mid) fr--; if(fl&lt;fr) &#123; printf("%d %d\n",fl,fr); for(int i=fl;i&lt;=(fl+fr)/2;i++) swap(a[i],a[fl+fr-i]); &#125; &#125; void solve(int l,int r,int numl,int numr)//基于值域的快排 &#123; if(l&gt;=r or numl&gt;=numr) return; int pt=(numl+numr)/2; mergsort(l,r,pt); for(int t=l;t&lt;=r;t++)//divide point if(a[t]&lt;=pt and a[t+1]&gt;pt) &#123; solve(l,t,numl,pt);solve(t+1,r,pt+1,numr); break; &#125; &#125; struct Nod&#123;int d,p;&#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),p[i]=(Nod)&#123;a[i],i&#125;; sort(p+1,p+n+1,cmp); int rx=1;a[p[1].p]=rx; for(int i=2;i&lt;=n;i++) &#123; if(p[i-1].d!=p[i].d) rx++; a[p[i].p]=rx; &#125; solve(1,n,1,rx); puts("-1 -1"); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>分治</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod刷题计划]]></title>
    <url>%2Fposts%2F8a7d.html</url>
    <content type="text"><![CDATA[atcoder的题解好像有点少……去刷51nod吧，好像很多是翻译成中文的原题感觉思维难度还是不错的 1 1051 最大子矩阵和9.25 难度1请先思考后再展开 二维版，套个一维的+前缀和就好了12345678910111213141516171819202122232425int a[MAX_N][MAX_N];ll sum[MAX_N][MAX_N];//向上前缀和void main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) sum[j][i]=sum[j][i-1]+a[i][j]; ll ans=0; for(int l=1;l&lt;=n;l++) for(int r=l;r&lt;=n;r++) &#123; ll now=0; for(int t=1;t&lt;=m;t++) &#123; if(now&lt;0) now=0; now+=sum[t][r]-sum[t][l-1]; ans=max(ans,now); &#125; &#125; printf("%lld",ans);&#125; 2 1020 逆序排列 HAOI2009 逆序对数列9.25 难度1请先思考后再展开 $f(n,k)=\sum_{i=0}^{n-1} f(n-1,k-i)$不能开ll，会被卡空间然后为了方便可以相邻做差，具体看代码12345678910111213141516171819202122const int MOD=1e9+7;int f[1001][20001];void main()&#123; f[1][0]=1; for(int n=2;n&lt;=1000;n++) &#123; f[n][0]=1; for(int k=1;k&lt;=20000 and k&lt;=n*(n-1)/2;k++) &#123; f[n][k]=(f[n][k-1]+f[n-1][k])%MOD; if(k-n&gt;=0) (f[n][k]-=f[n-1][k-n])%=MOD; &#125; &#125; int T;scanf("%d",&amp;T); while(T--) &#123; int n,k;scanf("%d%d",&amp;n,&amp;k); printf("%d\n",(f[n][k]+MOD)%MOD); &#125;&#125; 3 1674 区间的价值 V29.25 难度1请先思考后再展开 枚举每个l，然后向右看，计算贡献分开来考虑每个位，对于and只关心第一个1，or只关心or那么可以统计每个位的贡献，分成两部分的权值，最多共有60个不同的断点那么排序一下就好了，差分统计贡献 我真的好菜啊上一道题的maxn忘记改了……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; const int INF=0x3f3f3f3f; typedef long long ll; struct LJB &#123; int hou[MAX_N]; int to[MAX_N*2],g[MAX_N*2]; int ln;void ins(int x,int y) &#123;to[++ln]=y;g[ln]=hou[x];hou[x]=ln;&#125; LJB() &#123;ln=0;memset(hou,0,sizeof hou);&#125; &#125;E; const ll MOD=1000000007; struct Pos &#123; int p,op; ll c; &#125;p[200];//0-and 1-or bool cmp(Pos a,Pos b) &#123;return a.p&lt;b.p;&#125; int a[MAX_N]; int nx[40][MAX_N],lst[40][2]; int f[40][2];//指针 int bin[40]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); for(int j=0;j&lt;=30;j++) &#123; int t=(a[i]&amp;bin[j])&gt;0; if(f[j][t]==0) f[j][t]=i; nx[j][lst[j][t]]=i;lst[j][t]=i; &#125; &#125; for(int j=0;j&lt;=30;j++) &#123; nx[j][lst[j][0]]=n+1; nx[j][lst[j][1]]=n+1; if(f[j][0]==0) f[j][0]=n+1; if(f[j][1]==0) f[j][1]=n+1; &#125; ll ans=0; for(int l=1;l&lt;=n;l++) &#123; int tot=0; int nowand=0,nowor=0; for(int j=0;j&lt;=30;j++) &#123; if(f[j][0]&gt;1) nowand+=bin[j],p[++tot]=(Pos)&#123;f[j][0],0,-bin[j]&#125;;//and p[++tot]=(Pos)&#123;f[j][1],1,bin[j]&#125;;//or f[j][(a[l]&amp;bin[j])&gt;0]=nx[j][l];//update &#125; sort(p+1,p+tot+1,cmp);p[tot+1].p=n; for(int i=1;i&lt;=tot;i++) &#123; if(p[i].p&gt;n) break;//debug if(p[i].op==0) nowand+=p[i].c; else nowor+=p[i].c; if(p[i].p==p[i+1].p) continue; ans=(ans+(ll)nowor*nowand%MOD*(p[i+1].p-p[i].p)%MOD)%MOD; &#125; &#125; printf("%lld",(ans+MOD)%MOD); &#125;&#125;int main()&#123; mine::main();&#125; 4 1675 序列变换9.26 难度2请先思考后再展开 莫反显然，但我发现我不会计算条件2……看题解，原来用个桶就好了，根据调和级数是log的12345678910111213141516171819202122int basket[MAX_N];ll F[MAX_N];int a[MAX_N],b[MAX_N];void main()&#123; pre(); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int d=1;d&lt;=n;d++) &#123; for(int y=d;y&lt;=n;y+=d) basket[ b[a[y]] ]++; for(int x=d;x&lt;=n;x+=d) F[d]+=basket[ a[b[x]] ]; for(int y=d;y&lt;=n;y+=d) basket[ b[a[y]] ]=0;//保证复杂度 &#125; ll ans=0; for(int d=1;d&lt;=n;d++) ans+=(ll)mu[d]*F[d]; printf("%lld",ans);&#125; 5 1682 中位数计数9.26 难度2请先思考后再展开 又是巧妙地用桶，套路地转化为-1和1，然后找和为0123456789101112131415int a[MAX_N];int basket[MAX_N+MAX_N];void main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; int ans=0;memset(basket,0,sizeof basket); for(int sum=0,j=i;j&gt;=1;j--) sum+=(a[j]&lt;a[i]?-1:(a[j]!=a[i])),basket[MAX_N+sum]++; for(int sum=0,j=i;j&lt;=n;j++) sum+=(a[j]&lt;a[i]?-1:(a[j]!=a[i])),ans+=basket[MAX_N-sum]; printf("%d ",ans); &#125;&#125; 6 1686 第K大区间9.26 难度2请先思考后再展开 我不会二分了怎么办…… i am the king1234567891011121314151617181920212223242526272829303132333435363738394041424344int n;ll k;int a[MAX_N];int num[MAX_N];bool check(int mid)&#123; ll ans=0;memset(num,0,sizeof num); for(int l=1,r=0;l&lt;=n;num[a[l]]--,l++) &#123; if(l&gt;r) num[a[++r]]++; while(r+1&lt;=n) &#123; if(num[a[r+1]]+1&gt;mid) break; num[a[++r]]++; &#125; ans+=r-l+1; &#125; return ans&lt;=(ll)n*(n+1)/2-k;&#125;struct Nod&#123; int d,p;&#125;s[MAX_N];bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125;void main()&#123; scanf("%d%lld",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;s[i].d),s[i].p=i; sort(s+1,s+n+1,cmp); int rx=1;a[s[1].p]=rx; for(int i=2;i&lt;=n;i++) &#123; if(s[i-1].d!=s[i].d) rx++; a[s[i].p]=rx; &#125; int l=1,r=n,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid-1)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d",ans);&#125; 7 1052 最大M子段和9.26 难度1请先思考后再展开 显然的dp前缀和mx优化一下就好了123456789101112131415161718ll sum[MAX_N];ll f[MAX_N][2];ll mx[MAX_N][2];//前缀最大继承位置void main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;sum[i]),sum[i]+=sum[i-1]; for(int k=0;k&lt;=m;k++) &#123; for(int i=k;i&lt;=n;i++) &#123; if(k&gt;0) f[i][k&amp;1]=max(mx[i-1][(k-1)&amp;1]+sum[i],f[i-1][k&amp;1]); mx[i][k&amp;1]=max(mx[i-1][k&amp;1],f[i][k&amp;1]-sum[i]); &#125; &#125; printf("%lld",f[n][m&amp;1]);&#125; 8 1120 机器人走方格 V39.26 难度2请先思考后再展开 卡特兰数裸题1234567891011121314151617181920212223242526const int MOD=10007;int qpower(int x,int e)&#123; int ans=1;x%=MOD;//debug while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans;&#125;int inv(int x) &#123;return qpower(x,MOD-2);&#125;//is primeint fac[MOD+10];int C(int n,int m)&#123; if(n&lt;m) return 0; if(n&gt;=MOD or m&gt;=MOD) return C(n/MOD,m/MOD)*C(n%MOD,m%MOD)%MOD; return fac[n]*inv(fac[m])%MOD*inv(fac[n-m])%MOD;&#125;int Cat(int n) &#123;return C(2*n,n)*inv(n+1)%MOD;&#125;void main()&#123; fac[0]=1;for(int i=1;i&lt;=MOD;i++) fac[i]=fac[i-1]*i%MOD; int n;scanf("%d",&amp;n); printf("%d",Cat(n-1)*2%MOD);&#125; 9 1555 布丁怪9.29 难度2请先思考后再展开 本来以为这是一道找性质题，然后想了个错误的性质，就凉了…… 首先不难想到，问题会转化成，求一个序列的某一段，其中每个数都出现且仅出现一次，并且连续覆盖本来想着可能可以用什么巧妙的技巧去判断bitset中连续的1，但没什么想法…… 正解是转化为区间极值，让极值的差和长度差相同log方的话显然线段树但也可以分治，每一层，处理l和r不在相同区间的问题 这个极值挺麻烦的，用分情况讨论可以简化一、min和max都在左边，此时计算一下前缀后缀与mid的极值即可快速计算二、min在左边，max在右边，此时需要用两个尺取法，同时维护，并用桶维护公共区间 另外的两种情况是镜像问题，可以通过 【翻转序列+调整mid】 简化代码复杂度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=310000; int a[MAX_N]; ll ans=0; int basket[MAX_N*2]; int mx[MAX_N],mi[MAX_N];//与mid的前后缀极值 void solve(int fl,int fr,int op) &#123; if(fl&gt;=fr) return; int mid=(fl+fr-op)/2;//处理l和r不同区间的情况 mx[mid]=mi[mid]=a[mid];for(int i=mid-1;i&gt;=fl;i--) mx[i]=max(mx[i+1],a[i]),mi[i]=min(mi[i+1],a[i]); mx[mid+1]=mi[mid+1]=a[mid+1];for(int i=mid+2;i&lt;=fr;i++) mx[i]=max(mx[i-1],a[i]),mi[i]=min(mi[i-1],a[i]); //1. 都在左边 for(int l=fl;l&lt;=mid;l++) &#123; int r=mx[l]-mi[l]+l; ans+=(mx[r]&lt;mx[l] and mi[r]&gt;mi[l] and mid+1&lt;=r and r&lt;=fr);//debug 没有判断越界！ &#125; //2. 左min右max for(int l=fl,mir=fr,mxr=fr+1;l&lt;=mid;l++) &#123; while(mir&gt;=mid+1 and mi[mir]&lt;mi[l]) basket[MAX_N+mir-mx[mir]]--,mir--; while(mxr-1&gt;=mid+1 and mx[mxr-1]&gt;mx[l]) mxr--,basket[MAX_N+mxr-mx[mxr]]++; ans+=(mxr&lt;=mir?basket[MAX_N+l-mi[l]]:0); &#125; for(int i=mid+1;i&lt;=fr;i++) basket[MAX_N+i-mx[i]]=0; solve(fl,mid,op);solve(mid+1,fr,op); &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123;int x,y;scanf("%d%d",&amp;x,&amp;y);a[x]=y;&#125; solve(1,n,0); for(int i=1;i&lt;=n/2;i++) swap(a[i],a[n-i+1]); solve(1,n,1); printf("%lld",ans+n); &#125;&#125;int main()&#123; mine::main();&#125; 10 1125 交换机器的最小代价10.1 难度2请先思考后再展开 每个位置向它想去的点连边，那么因为每个点出度和入度都是1，一定是若干个环组成的对于每个环，有两种策略一、用内部最小的节点逛一圈二、用外部最小的节点逛一圈再回去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=51000; struct Nod&#123;int d,p;&#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; int to[MAX_N]; bool v[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); p[i]=(Nod)&#123;t,i&#125;; &#125; sort(p+1,p+n+1,cmp); for(int i=1;i&lt;=n;i++) to[p[i].p]=i; ll ans=0; for(int st=1;st&lt;=n;st++) if(!v[st] and to[st]!=st) &#123; v[st]=1; int t=st,mi=p[to[t]].d,ln=1; while(to[t]!=st) t=to[t],v[t]=1,ans+=p[to[t]].d,mi=min(mi,p[to[t]].d),ln++; //ans+=p[to[st]].d+min((ll)mi*(ln-2),(ll)p[1].d*(ln+1)); debug ans+=p[to[st]].d+min((ll)mi*(ln-2),(ll)p[1].d*(ln+1)+mi); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 11 1131 覆盖数字的数量10.1 难度2请先思考后再展开 根据 $num\%a \leq b-a+1$ 可知能表示的区间一定是用 $ka \to kb$ 组成的然后当k达到一定大小后，后面都会重叠，所以二分k，前面等差数列，后面连续 打这个细节多到吃屎……1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const double eps=1e-3; ll solve(ll A,ll B) &#123; ll l=1,r=1ll&lt;&lt;60,ans=-1; while(l&lt;=r+eps) &#123; ll mid=(l+r)/2; if( (double)mid*B&gt;=double(mid+1)*A-1-eps ) ans=mid,r=mid-1; else l=mid+1; &#125; return ans; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; ll A,B,X,Y;scanf("%lld%lld%lld%lld",&amp;A,&amp;B,&amp;X,&amp;Y);//debug 爆ll if(A&lt;=X and Y&lt;=B) &#123;printf("%lld\n",Y-X+1);continue;&#125; ll k=solve(A,B);//k~INF ll ans=0; ll st=X/A,ed=min(Y/A,k-1); if(st&lt;=ed) &#123; if((double)st*B&gt;=X-eps) ans+=min(st*B,Y)-X+1; st+=1; if((double)ed*B&gt;Y+eps) ans+=Y-max(X,ed*A)+1,ed-=1; ans+=(double)(st+ed)*(ed-st+1)/2*(B-A)+(ed-st+1); &#125; k=max(k,st);k=min(k,ed+1); if((double)A*k&lt;=Y) ans+=Y-max(A*k,X)+1;//连续 printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 12 1189 阶乘分数10.3 难度2请先思考后再展开 bzoj2721 感觉我不可能想到……$n!(x+y)=xy,x&gt;n!,y&gt;n!$$y=n!+z$$x=\frac{(n!)^2}{z} + n!$$ans=(n!)^2 的约数$那么筛一下最小质因子，套个公式就好了 13 1201 整数划分10.16 难度2请先思考后再展开 好像又被套路了感觉这种思路非常难想主要是因为互不相同，你可以维护一个相对大小关系，这个关系一定是从1开始的然后经过一系列的整体增加1得到当前的方案那么现在dp，要么群体加1，要么群体加1然后前面插入一个1，总是能保证互不相同的12345678910111213const int MOD=1e9+7;int f[330][51000];void main()&#123; int n;scanf("%d",&amp;n); f[0][0]=1; for(int ln=1;ln&lt;=320;ln++) for(int num=1;num&lt;=n;num++) if(num&gt;=ln) f[ln][num]=(f[ln-1][num-ln]+f[ln][num-ln])%MOD; int ans=0; for(int ln=1;ln&lt;=320;ln++) (ans+=f[ln][n])%=MOD; printf("%d",ans);&#125; 14 1215 数组的宽度10.16 难度2请先思考后再展开 被lxj锤爆了，只会分治的nlogn做法处理出min和max下，每个数能覆盖的范围然后式子是可以拆开来的，min和max拆开统计就行了 15 1217 Minimum Modular CF303C10.16 难度2请先思考后再展开 感觉这题有点难度考虑相等的二元组， $a_i=a_j (\% m)$如果枚举每个m，那么他们的差一定是m的倍数（包括0）那么如果存储差，通过枚举m的倍数，就能得到所有的数对，而且是mlogm的注意到k很小，数对显然不会超过 $k(k+1)/2$ 对，是很强力的剪枝对于每一种实际的余数，第一个不需要删除，可以用链表拿出所有点对，进行计算该做法的复杂度是有保证的，但常数略大，很容易被暴力枚举n的做法吊锤，而且还被卡空间…… 故本代码暂时没ac，但一定是正确的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=5001; int n,k; #define pr pair&lt;short,short&gt;//卡空间 #define FR first #define SE second vector&lt;pr&gt; ct[1000010]; int a[MAX_N]; bool in[MAX_N];bool v[1100000];//实际余数的存在性 int all; int tmp[100];//撤回操作 void put(int x,int m) &#123; if(!in[x]) &#123; in[x]=1; tmp[++tmp[0]]=x; if(!v[a[x]%m]) v[a[x]%m]=1;else all++; &#125; &#125; void erase(int x,int m) &#123;v[a[x]%m]=0;in[x]=0;&#125; int solve() &#123; for(int m=1;m&lt;=1000001;m++) &#123; int tot=0; for(int now=0;now&lt;=1000001;now+=m) tot+=ct[now].size(); if(tot&gt;k*(k+1)/2) continue;//最坏情况 //利用k剪枝 all=0;tmp[0]=0; for(int now=0;now&lt;=1000001;now+=m) for(int t=0;t&lt;(int)ct[now].size();t++) put(ct[now][t].FR,m),put(ct[now][t].SE,m); for(int t=1;t&lt;=tmp[0];t++) erase(tmp[t],m); if(all&lt;=k) return m; &#125; return -1; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) ct[abs(a[i]-a[j])].push_back( make_pair(i,j) ); printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125; 16 1241 特殊的排序10.16 难度2请先思考后再展开 非常妙的思维题答案是，保留一段值连续数列，其他的一定存在一种方案，移动到左边或者右边所以线性dp一下就好了 17 1259 整数划分 V210.16 难度2请先思考后再展开 因为可以相同，数的数量会达到n可以巧妙地分块 只用1~T的数， $g(num)=\sum g(num-a)$ 用后面的数，那么这个部分，数的数量会在n/T以内，那么又可以用前面的做法了，不过不在需要保证互不相同了，在插入一个T+1的时候，其他不需要增加$f(i,num)=f(i-1,num-(T+1)),f(i,num-i)$答案就是其卷积12345678910111213141516171819const int MAX_N=51000;const ll MOD=1e9+7;ll g[MAX_N],f[320][MAX_N];void main()&#123; int n;scanf("%d",&amp;n);int T=sqrt(n); g[0]=1; for(int a=1;a&lt;=T;a++) for(int num=a;num&lt;=n;num++) g[num]=(g[num]+g[num-a])%MOD; f[0][0]=1; for(int i=1;i&lt;=n/T;i++) for(int num=i*(T+1);num&lt;=n;num++) f[i][num]=(f[i][num-i]+f[i-1][num-(T+1)])%MOD; int ans=0; for(int a=0;a&lt;=n;a++) for(int i=0;i&lt;=n/T;i++) (ans+=g[a]*f[i][n-a]%MOD)%=MOD; printf("%d",ans);&#125; 18 1262 扔球10.16 难度1请先思考后再展开 其实画这个图的途中，想了很多东西，最后的结论只和左下角那个反例有关那就是你必须经过这n+1个点！那画图的时候，我枚举了一个跨度，这也是灵感的来源这个跨度必须和n+1互质，用公式求一下欧拉函数即可ans=phi(n+1) 19 1273 旅行计划10.17 难度2请先思考后再展开 我的思路，下限nlogn：维护一个线段树表示，以dfs序为编号，每个点到根的距离然后动态选取最大的那个，把这条链并到根节点，合并的途中影响的总是子树整体，dfs序上是连续的然后每个节点只会被合并一次，所以是nlogn 正解，下限n：显然选择的点总是叶子节点，每个节点只会被一个叶子节点覆盖，父亲节点被覆盖的候选总是在儿子节点中产生，dfs回溯的时候处理即可最后再把叶子排序即可 20 1274 最长递增路径10.17 难度2请先思考后再展开 性质1： 一条边最多经过1次性质2：路径上边权严格递增将每条边排序，然后加入图中，此时一定是路径的最后一条（严格递增），没有后效性，可以直接转移（但为了保证严格单调，需要将同权值的边分组，滚动一下即可） 21 1277 字符串中的最大值10.17 难度2请先思考后再展开 kmp$f(nxt[i])+=f(i)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=110000; int ln; char s[MAX_N]; int nxt[MAX_N]; void getnext() &#123; nxt[1]=0; for(int i=2;i&lt;=ln;i++) &#123; int j=nxt[i-1]; while(j!=0 and s[j+1]!=s[i]) j=nxt[j]; if(s[j+1]==s[i]) nxt[i]=j+1; else nxt[i]=j; &#125; &#125; int num[MAX_N]; void main() &#123; scanf("%s",s+1);ln=strlen(s+1); getnext(); ll ans=0; for(int i=ln;i&gt;=1;i--) &#123; num[i]+=1; num[nxt[i]]+=num[i]; ans=max(ans,(ll)num[i]*i); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 22 1293 球与切换器10.17 难度2请先思考后再展开 这是一道sb题，但我也是个sb……唯一提示：可以看作所有球同时放进去1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int mp[MAX_N][MAX_N]; ll f[MAX_N][MAX_N][2];//0上1左 void main() &#123; int m,n;scanf("%d%d%lld",&amp;m,&amp;n,&amp;f[1][1][0]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;mp[i][j]); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; if(mp[i][j]==0) &#123; f[i+1][j][0]+=f[i][j][0]; f[i][j+1][1]+=f[i][j][1]; &#125; else &#123; ll sum=f[i][j][0]+f[i][j][1]; f[i][j+1][1]+=sum/2+(sum&amp;1 and mp[i][j]&gt;0); f[i+1][j][0]+=sum/2+(sum&amp;1 and mp[i][j]&lt;0); &#125; &#125; &#125; printf("%lld",f[n+1][m][0]); &#125;&#125;;int main()&#123; mine::main();&#125; 23 1296 有限制的排列10.17 难度2请先思考后再展开 显然先拆开，变成每个位置，和前面的大小关系然后我就卡住了，不知道怎么解决，必须是排列这个条件然后好像这是一个套路？dp的时候保证f(i)是大小为i的排列，时刻保证合法性，然后插入一个数的话可以把前面&gt;=num的部分整体+1 24 1322 关于树的函数10.18 难度2请先思考后再展开 一道sb题，但我这sb又没想到唯一提示：||A1|B1||:-:|:-:|:-:||A2|a|b||B2|c|d| a+b=a+c=b+d=c+d=n 25 1328 比赛往事10.18 难度2请先思考后再展开 这道题ac人数极少，我想写一发网上第一篇正式题解（思路主要是自己想的，少量参考了出题人的口胡）题目的性质：确定一些位置后，内部元素是可以任意交换的抓住这个性质，先定位出所有非法的位置，他们一定是要操作的对于每次固定位置后，最优策略一定是a和b分别排序如果合法了，直接退出，否则利用其它元素进行修正 维护好一个非法集合，那么里面每个元素迟早要被再次替换我们每次选取最大的那个place，外面能参与进来的一定是 $cutoff \geq place$在可参与的集合中，显然应该选择最小的那个place，加入后产生了推移循环地执行此操作即可，最多加入n次，内部要排序一下，所以时间复杂度是 $O(n^2logn)$ （当然你非要写个插入排序也行） 下来我们讨论一些细节： 是否有可能找出来的a，无法使整个串推移呢？答：其实这是个无解情况，break否随你 不选取最小a行不行？答：可能可以，但这样显然不会更差 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; struct Nod&#123;int a,b;&#125;ok[MAX_N]; bool use[MAX_N]; int n; int g1[MAX_N],g2[MAX_N],ans; bool check() &#123; for(int i=1;i&lt;=ans;i++) if(g1[i]&gt;g2[i]) return 0; return 1; &#125; void main() &#123; scanf("%d",&amp;n); ans=0;int num_ok=0; for(int i=1;i&lt;=n;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(a&gt;b) g1[++ans]=a,g2[ans]=b; else ok[++num_ok]=(Nod)&#123;a,b&#125;; &#125; if(ans==0) &#123;puts("0");return;&#125; while(1) &#123; sort(g1+1,g1+ans+1);sort(g2+1,g2+ans+1); if(check() or ans==n) break; int mxa=-1;for(int i=1;i&lt;=ans;i++) if(g1[i]&gt;g2[i] and (mxa&lt;0 or g1[i]&gt;g1[mxa])) mxa=i;//取非法元素 int pos=-1;for(int i=1;i&lt;=num_ok;i++) if(!use[i] and (pos&lt;0 or ok[i].a&lt;ok[pos].a) and ok[i].b&gt;=g1[mxa]) pos=i; ++ans;g1[ans]=ok[pos].a,g2[ans]=ok[pos].b;use[pos]=1; &#125; if(!check()) puts("-1"); else printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 26 1353 树10.18 难度2请先思考后再展开 $f(x,siz=1 \to siz_x)=f(x,siz-a) \times f(y,a)+f(x,siz) \times f(y,k \to siz_y)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=2100; int hou[MAX_N],siz[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int K; const ll MOD=1e9+7; ll f[2][MAX_N][MAX_N]; void dp(int x,int fa) &#123; siz[x]=1;int now=1;f[0][x][1]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dp(y,x); memset(f[now&amp;1][x],0,sizeof f[now&amp;1][x]); for(int a=siz[x];a&gt;=1;a--)//01背包 &#123; for(int b=1;b&lt;=siz[y];b++) (f[now&amp;1][x][a+b]+=f[(now-1)&amp;1][x][a]*f[0][y][b]%MOD)%=MOD;//不断 (f[now&amp;1][x][a]+=f[(now-1)&amp;1][x][a]*f[0][y][0]%MOD)%=MOD;//断 &#125; siz[x]+=siz[y]; now++; &#125; if((now&amp;1)==0) memcpy(f[0][x],f[1][x],sizeof f[1][x]);//0为转移点 for(int a=K;a&lt;=siz[x];a++) (f[0][x][0]+=f[(now-1)&amp;1][x][a])%=MOD; &#125; void main() &#123; int n;scanf("%d%d",&amp;n,&amp;K); for(int i=1;i&lt;=n-1;i++) &#123;int x,y;scanf("%d%d",&amp;x,&amp;y);ins(x,y);ins(y,x);&#125; dp(1,0); int ans=0;for(int i=K;i&lt;=n;i++) ans=(ans+f[0][1][i])%MOD; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 27 1354 选数字10.18 难度1请先思考后再展开 离散化约数，做个乘法背包即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; ll ys[2000],tot; int findid(ll num) &#123; int t=lower_bound(ys+1,ys+tot+1,num)-ys; return (ys[t]==num)?t:0; &#125; int a[MAX_N]; const int MOD=1e9+7; ll f[2000]; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n,k;scanf("%d%d",&amp;n,&amp;k); tot=0; for(int t=1;t*t&lt;=k;t++) &#123; if(k%t&gt;0) continue; ys[++tot]=t; if(t*t!=k) ys[++tot]=k/t; &#125; sort(ys+1,ys+tot+1); memset(f,0,sizeof f);f[1]=1; for(int i=1;i&lt;=n;i++) &#123; int now;scanf("%d",&amp;now); for(int t=tot;t&gt;=1;t--) (f[findid((ll)ys[t]*now)]+=f[t])%=MOD; &#125; printf("%lld\n",f[tot]%MOD); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 28 1378 夹克老爷的愤怒10.22 难度2请先思考后再展开 贪心+树形dp仅当必须要放的时候再放比【救火站】简单一点（自行搜索blog）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(int num) &#123; if(num&gt;9) qwrite(num/10); putchar('0'+num%10); &#125; const int MAX_N=110000; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int K,ans=0; int dfs(int x,int fa)//&lt;0贡献；&gt;0需求 &#123; if(e[hou[x]].g==0 and fa!=0) return 1; int mi=K+1,mx=-K-1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; int t=dfs(y,x); mi=min(mi,t); mx=max(mx,t); &#125; if(mx&gt;=K) &#123;ans++;return -K;&#125; else return (mx&gt;=(-mi)?mx:mi)+1; &#125; void main() &#123; int n=qread();K=qread(); for(int i=1;i&lt;n;i++) &#123; int x=qread(),y=qread(); x++;y++; ins(x,y);ins(y,x); &#125; if(K==0) &#123;printf("%d",n);return;&#125; if(dfs(1,0)&gt;0) ans++; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 29 1379 索函数10.23 难度2请先思考后再展开 前置知识： 斐波那契通项公式： $\frac{1}{\sqrt 5} [ (\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n ]$ num在二进制下的位数为 $\lfloor log_2 num \rfloor +1$然后经过打表、感性理解可知， $Sor(n)=2^{Fib(n)的位数}-1$小证明：斐波那契数列的每个1，因为是不断加法得到的，显然一定是通过后一个位的两个1组成的，根据数学归纳法可知，该性质成立 当n=0，输出0当n比较大时，后面的部分趋近于0n较小时暴力计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; void qwrite(ll num) &#123; if(num&gt;=10) qwrite(num/10); putchar('0'+num%10); &#125; void qwriteln(ll num) &#123;qwrite(num);puts("");&#125; const ll MOD=1e9+7; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; ll n;scanf("%lld",&amp;n); if(n&lt;=90) &#123; if(n==0) puts("0");//log2 0 会炸 else &#123; ll k=floor(log2( (pow((sqrt(5.0)+1)/2,n)-pow((1-sqrt(5.0))/2,n))/sqrt(5.0) )); printf("%lld\n",qpower(2,k+1)-1); &#125; &#125; else &#123; ll k=floor( (double)n*log2((sqrt(5.0)+1)/2)-log2(sqrt(5.0)) ); printf("%lld\n",qpower(2,k+1)-1); &#125; &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 30 1383 整数分解为2的幂10.23 难度1请先思考后再展开 方法一：$f(num,k)$ 表示num这个数，最大为 $2^k$ 的方案计数$f(num,k)=\sum_{i=0}^k f(num-2^k,i)$前缀和优化后，时间 $O(nlogn)$ 方法二：$f(num)=f(num-1)+[num是偶数] \times f(num/2)$ 31 1423 最大二“货”10.23 难度2请先思考后再展开 思路从一开始就是错误的枚举每个数作为最大值的贡献，那么找次大值会很麻烦，还曾考虑可持久化字典树什么的……但其实用次大值找最大值就好了……单调栈一下就没了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Cqoi2011】动态逆序对]]></title>
    <url>%2Fposts%2Ffea4.html</url>
    <content type="text"><![CDATA[Source and JudgeCqoi2011bzoj3295luogu3157 Record1h Analysis请先思考后再展开 带修主席树：时间倒流，变成求在前面的比它大的数和后面小的数用前、后缀的带修主席树维护一下就好了 cdq分治：我似乎和网上所有人的都不一样……一开始还怀疑我的做法是错误的，后来发现是枚举顺序有一点问题，不单调了 就是给每个数打上时间戳，然后不删除的就是m+1、m+2……n那么问题变成 $t_a&gt;t_b,p_a&lt;p_b,d_a&gt;d_b$ 和 $t_c&gt;t_b,p_c&gt;p_b,d_c&lt;d_b$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define int ll const int INF=0x3f3f3f3f; const int MAX_N=110000; struct Nod&#123;int t,d,p;Nod()&#123;t=0;&#125;&#125;p[MAX_N]; bool cmp1(Nod a,Nod b) &#123;return a.t&lt;b.t;&#125; bool cmp2(Nod a,Nod b) &#123;return a.p&lt;b.p;&#125; int n; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; while(x&lt;=n) bit[x]+=c,x+=lowbit(x); &#125; int sum(int x) &#123; int ans=0; while(x&gt;=1) ans+=bit[x],x-=lowbit(x); return ans; &#125; int ans[MAX_N]; void cdq(int fl,int fr) &#123; if(fl&gt;=fr) return; int mid=(fl+fr)&gt;&gt;1; cdq(fl,mid);cdq(mid+1,fr); sort(p+fl,p+mid+1,cmp2);sort(p+mid+1,p+fr+1,cmp2); int k1=fl-1; for(int k2=mid+1;k2&lt;=fr;k2++) &#123; while(k1+1&lt;=mid and p[k1+1].p&lt;p[k2].p) change(p[++k1].d,1); ans[p[k2].t]+=(k1-fl+1)-sum(p[k2].d); &#125; for(int t=fl;t&lt;=k1;t++) change(p[t].d,-1); int k3=mid+1; for(int k2=fr;k2&gt;=mid+1;k2--) &#123; while(k3-1&gt;=fl and p[k3-1].p&gt;p[k2].p) change(p[--k3].d,1); ans[p[k2].t]+=sum(p[k2].d-1); &#125; for(int t=k3;t&lt;=mid;t++) change(p[t].d,-1); &#125; int pos[MAX_N];//值的位置 void main() &#123; int m;scanf("%lld%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;p[i].d),p[i].p=i,pos[p[i].d]=i; for(int i=1;i&lt;=m;i++) &#123; int t;scanf("%lld",&amp;t); p[pos[t]].t=i; &#125; for(int now=m,i=1;i&lt;=n;i++) if(p[i].t==0) p[i].t=++now; sort(p+1,p+n+1,cmp1);reverse(p+1,p+n+1); cdq(1,n); sort(p+1,p+n+1,cmp2); ll tot=0;for(int i=1;i&lt;=n;i++) tot+=(i-1)-sum(p[i].d),change(p[i].d,1); for(int i=1;i&lt;=m;i++) printf("%lld\n",tot),tot-=ans[i]; &#125;&#125;signed main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>主席树</tag>
        <tag>cdq分治</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POI2009】救火站]]></title>
    <url>%2Fposts%2F9d1.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2009bzoj1117 Record1h Analysis请先思考后再展开 神仙题……而且我不知道怎么证明其正确性所以我权当记录我的做法的合理性和逻辑性，如果有帮助证明的好角度请评论 设 $ned(x,t)$ 表示当前节点x的子树中，有多少个节点是没有被覆盖而且与x距离为t的设 $remain(x,t)$ 表示x的子树中，某些点放置了消防站，而且其配额K即使到达x依然剩下t的距离，的节点数量 我们放置节点，当且仅当有距离为K的节点没有被覆盖（此策略不包括根节点）此时我们放置了足够的消防站，同时产生了许多配额把这些配额随着深度的减小统计起来后，使用当且仅当，我必须在此时去更新，否则到父亲那里我就需要用更大的花费了这里的必须，指对于我而言多出的配额与需要的距离相差在1以内（否则总是可以稍微延后一点的，不会亏，如果有更适合的还会赚） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=110000; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int ans=0; int mx,S; ll remain[MAX_N][30]; ll ned[MAX_N][30]; void dp(int x,int fa) &#123; ned[x][0]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dp(y,x); for(int t=1;t&lt;=mx;t++) ned[x][t]+=ned[y][t-1]; for(int t=0;t&lt;=mx-1;t++) remain[x][t]+=remain[y][t+1]; &#125; if(ned[x][mx]&gt;0) &#123; int t=ceil((double)ned[x][mx]/S); ans+=t;remain[x][mx]+=(ll)t*S-ned[x][mx];ned[x][mx]=0; &#125; for(int t=0;t&lt;=mx;t++) &#123; if(ned[x][t]&lt;=remain[x][t]) remain[x][t]-=ned[x][t],ned[x][t]=0; else ned[x][t]-=remain[x][t],remain[x][t]=0; if(t==0) continue; if(ned[x][t-1]&lt;=remain[x][t]) remain[x][t]-=ned[x][t-1],ned[x][t-1]=0; else ned[x][t-1]-=remain[x][t],remain[x][t]=0; &#125; &#125; void main() &#123; int n;scanf("%d%d%d",&amp;n,&amp;S,&amp;mx); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dp(1,0); for(int t=0;t&lt;=mx;t++) for(int t2=0;t2&lt;=t;t2++) &#123; if(ned[1][t2]&lt;=remain[1][t]) remain[1][t]-=ned[1][t2],ned[1][t2]=0; else ned[1][t2]-=remain[1][t],remain[1][t]=0; &#125; int sum=0;for(int t=0;t&lt;=mx;t++) sum+=ned[1][t]; printf("%d",ans+(int)ceil((double)sum/S)); &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度3</tag>
        <tag>好题</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JOI】稻草人]]></title>
    <url>%2Fposts%2Fa999.html</url>
    <content type="text"><![CDATA[Source and JudgeJOIbzoj4237 Record1h Analysis请先思考后再展开 太巧妙了……分治真是世界上最美妙的思想…… 这道题的重点就是矩形中间不能有其他的稻草人任意一个矩形一定会经过一个横线，我们可以分治y，然后考虑两个端点一个在右上一个在左下的情况 不妨把上下分别按照x排序，然后枚举上面的一个点看做右上角，然后考虑下面的贡献首先，显然不能先覆盖到上面的节点，而此时x是单调的，所以维护y比当前小的最近位置这个可以非常轻松地用单调栈维护，因为如果下一个更高，则最近为当前，否则一定在前面而没有被删除从那个位置到当前之间的x都是可选的，接下来考虑下半部分的处理因为不能被前面的点的y覆盖到，可选的点，随着x的增加一定递减不妨用一个单调递减栈维护，内部x递增，可以用刚才得到的x区间来二分查找，统计答案 分治log层，每层nlogn，所以复杂度是 $O(nlog_2^2n)$]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ZJOI2016】旅行者]]></title>
    <url>%2Fposts%2Faf7.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2016bzoj3319Luogu3350完整题面uoj184 Record1h Analysis请先思考后再展开 神仙分治题（抱着整体二分的目的前来……然而并不太一样）考虑分割矩形，用类似整体二分的思想，把询问也分割但和常见的题型相比（我指我唯一做过的找k大模型……），我们并不能保证询问结果一定完全这么贡献但是，分割的时候，有一个特殊的性质，也是本算法最关键的地方：如果某问题应该在当前分治段解决（最优的路径被分割线划分），那么一定会经过分割线于是，跑最短路的时候就不需要枚举起点了，从s变成根号为了让复杂度尽量低，应该选择短的那条分割线，同时后面的分割区间可以不再管mid（大概是稍微优化点常数吧，跑到了bzojrk62）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=21000; int n,m; int to[MAX_N][4];//右、左、下、上 const int tx[4]=&#123;0,0,1,-1&#125;; const int ty[4]=&#123;1,-1,0,0&#125;; int calc(int x,int y) &#123;return (x-1)*m+y;&#125; int dis[MAX_N]; #define PR pair&lt;int,int&gt; #define MP make_pair #define FR first #define SE second priority_queue&lt; PR,vector&lt;PR&gt;,greater&lt;PR&gt; &gt; qq; void dijkstra(int x1,int y1,int x2,int y2,int st) &#123; dis[st]=0;qq.push(MP(dis[st],st)); while(1) &#123; while(qq.size() and qq.top().FR!=dis[qq.top().SE]) qq.pop(); if(qq.empty()) break; int x=qq.top().SE;qq.pop(); int fx=(x-1)/m+1,fy=(x-1)%m+1; for(int k=0;k&lt;4;k++) &#123; int fx2=fx+tx[k],fy2=fy+ty[k]; if(fx2&lt;x1 or fx2&gt;x2 or fy2&lt;y1 or fy2&gt;y2) continue; int y=calc(fx2,fy2); if(dis[y]&gt;dis[x]+to[x][k]) &#123; dis[y]=dis[x]+to[x][k]; qq.push(MP(dis[y],y)); &#125; &#125; &#125; &#125; struct Qes &#123; int x1,y1,x2,y2; int id; &#125;q[110000],q1[110000],q2[110000]; int ans[110000]; void solve(int x1,int x2,int y1,int y2,int fl,int fr) &#123; if(x1&gt;x2 or y1&gt;y2 or fl&gt;fr) return; for(int i=x1;i&lt;=x2;i++) for(int j=y1;j&lt;=y2;j++) dis[calc(i,j)]=INF; if(x2-x1&gt;y2-y1) &#123; int midx=(x1+x2)/2,tot1=0,tot2=0; for(int nowy=y1;nowy&lt;=y2;nowy++) &#123; for(int i=x1;i&lt;=x2;i++) for(int j=y1;j&lt;=y2;j++) dis[calc(i,j)]+=to[calc(midx,nowy)][1]; dijkstra(x1,y1,x2,y2,calc(midx,nowy)); for(int t=fl;t&lt;=fr;t++) ans[q[t].id]=min(ans[q[t].id],dis[calc(q[t].x1,q[t].y1)]+dis[calc(q[t].x2,q[t].y2)]); &#125; for(int t=fl;t&lt;=fr;t++) &#123; if(q[t].x1&lt;midx and q[t].x2&lt;midx) q1[++tot1]=q[t]; if(q[t].x1&gt;midx and q[t].x2&gt;midx) q2[++tot2]=q[t]; &#125; for(int i=1;i&lt;=tot1;i++) q[fl+i-1]=q1[i]; for(int i=1;i&lt;=tot2;i++) q[fl+tot1+i-1]=q2[i]; solve(x1,midx-1,y1,y2,fl,fl+tot1-1); solve(midx+1,x2,y1,y2,fl+tot1,fl+tot1+tot2-1); &#125; else &#123; int midy=(y1+y2)/2,tot1=0,tot2=0; for(int nowx=x1;nowx&lt;=x2;nowx++) &#123; for(int i=x1;i&lt;=x2;i++) for(int j=y1;j&lt;=y2;j++) dis[calc(i,j)]+=to[calc(nowx,midy)][3]; dijkstra(x1,y1,x2,y2,calc(nowx,midy)); for(int t=fl;t&lt;=fr;t++) ans[q[t].id]=min(ans[q[t].id],dis[calc(q[t].x1,q[t].y1)]+dis[calc(q[t].x2,q[t].y2)]); &#125; for(int t=fl;t&lt;=fr;t++) &#123; if(q[t].y1&lt;midy and q[t].y2&lt;midy) q1[++tot1]=q[t]; if(q[t].y1&gt;midy and q[t].y2&gt;midy) q2[++tot2]=q[t]; &#125; for(int i=1;i&lt;=tot1;i++) q[fl+i-1]=q1[i]; for(int i=1;i&lt;=tot2;i++) q[fl+tot1+i-1]=q2[i]; solve(x1,x2,y1,midy-1,fl,fl+tot1-1); solve(x1,x2,midy+1,y2,fl+tot1,fl+tot1+tot2-1); &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m-1;j++) &#123; int t;scanf("%d",&amp;t); to[calc(i,j)][0]=to[calc(i,j+1)][1]=t; &#125; for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=m;j++) &#123; int t;scanf("%d",&amp;t); to[calc(i,j)][2]=to[calc(i+1,j)][3]=t; &#125; int t;scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++) &#123; int x1,y1,x2,y2;scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); q[i]=(Qes)&#123;x1,y1,x2,y2,i&#125;; &#125; memset(ans,63,sizeof ans); solve(1,n,1,m,1,t); for(int i=1;i&lt;=t;i++) printf("%d\n",ans[i]); &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2012】外星人]]></title>
    <url>%2Fposts%2Ff69a.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2012bzoj2749luogu2350 Record2h Analysis请先思考后再展开 题面上的x是指函数的阶，可以理解为嵌套数量 首先，phi有个奇妙的性质：只有phi(2)=1，其他的结果都是偶数这个不难证明，根据欧拉函数的公式，除2以外的素数都是奇数，减一得到偶数 逆向考虑一下，那么为了得到1，迟早要变成2的形式对于a为偶数的情况，枚举拆phi会去除一个2，然后2-1在连乘中没有影响，所以等价于一个2去除了但此时其他的素数会变成p-1，一定会产生2（如果有） 因为这个性质中，2的去除每次拆开只会进行一次（整个a而言，而不是每个素数都这样）那么这个2的次数其实能推导出嵌套深度，所以问题转化为，求出N在不断拆开的过程中，产生的2的数量 而对于a是奇数的情况，这一次拆开不会消除2，所以应该在原本的基础上+1同时不需要考虑以后的情况，就像上文所说的，以后的phi的结果都是偶数 $f(prime)=f(prime-1)$$f(prime^k)=f(prime)*k$$f(num)=\sum f(prime^k)$这个是可以线筛的时候顺便搞的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const int MAX_NUM=100001; int pr=0,prime[MAX_NUM]; bool isp[MAX_NUM]; int f[MAX_NUM]; void pre() &#123; memset(isp,1,sizeof isp); for(int i=2;i&lt;MAX_NUM;i++) &#123; if(isp[i]) prime[++pr]=i,f[i]=(i==2?1:f[i-1]); for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; isp[i*prime[j]]=0; f[i*prime[j]]=f[i]+f[prime[j]]; if(i%prime[j]==0) break; &#125; &#125; &#125; void main() &#123; pre(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); ll ans=0;bool two=0; for(int i=1;i&lt;=n;i++) &#123; int p,k;scanf("%d%d",&amp;p,&amp;k); ans+=(ll)f[p]*k;if(p==2) two=1; &#125; if(!two) ans++; printf("%lld\n",ans); &#125; &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>复习</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3261】最大异或和]]></title>
    <url>%2Fposts%2F10a2.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3261 Record2h Analysis请先思考后再展开 类似之前做的最大xor路径等题（刷算法竞赛进阶指南的时候）维护区间的trie，在上面贪心即可写的过程非常不顺利，一大堆sb错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const int MAX_N=310000*2;//n+q int bin[40]; struct Trie &#123; int c; int son[2]; void clear() &#123;c=son[0]=son[1]=0;&#125; &#125;p[MAX_N*30]; int id=0; int rt[MAX_N]; void add(int now,int num) &#123; for(int u=25;u&gt;=0;u--) &#123; int t=(num&amp;bin[u])&gt;0; if(p[now].son[t]==0) p[now].son[t]=++id,p[id].clear(); now=p[now].son[t];p[now].c++; &#125; &#125; void merg(int fl,int &amp;fr) &#123; if(fl==0) return; if(fr==0) &#123;fr=fl;return;&#125; p[fr].c+=p[fl].c; merg(p[fl].son[0],p[fr].son[0]); merg(p[fl].son[1],p[fr].son[1]); &#125; int solve(int l,int r,int now) &#123; int fl=rt[l-1],fr=rt[r]; for(int u=25;u&gt;=0;u--) &#123; int to=!( (now&amp;bin[u])&gt;0 ); if(p[p[fr].son[to]].c-p[p[fl].son[to]].c==0) to^=1; now^=(to*bin[u]);fl=p[fl].son[to];fr=p[fr].son[to]; &#125; return now; &#125; void main() &#123; bin[0]=1;for(int u=1;u&lt;=30;u++) bin[u]=bin[u-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m); int sum=0;//前缀异或和 p[0].c=0; rt[1]=++id;p[id].clear();add(rt[1],0);//偏移，避免越界 for(int i=2;i&lt;=n+1;i++) &#123; int a;scanf("%d",&amp;a);sum^=a; rt[i]=++id;p[id].clear(); add(rt[i],sum); merg(rt[i-1],rt[i]); &#125; n=n+1; while(m--) &#123; char s[5];scanf("%s",s); if(s[0]=='A') &#123; int a;scanf("%d",&amp;a);sum^=a; rt[++n]=++id;p[id].clear(); add(rt[n],sum); merg(rt[n-1],rt[n]); &#125; else &#123; int l,r,x;scanf("%d%d%d",&amp;l,&amp;r,&amp;x);l++;r++; printf("%d\n",solve(l-1,r-1,x^sum));//后缀转化前缀问题 &#125; &#125; &#125;&#125;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>可持久化字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2012】Longge的问题]]></title>
    <url>%2Fposts%2Fafb7.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj270551nod1040 Record1h Analysis请先思考后再展开 约数个数表：num=256 sum=9699690num=512 sum=223092870num=768 sum=446185740num=864 sum=290990700num=1024 sum=892371480num=1152 sum=581981400num=1280 sum=698377680num=1296 sum=857656800num=1344 sum=931170240num=1152 sum=1338557220num=1296 sum=2036934900num=1536 sum=1745944200num=1600 sum=2095133040 $f(x)=\sum gcd(t,x)=\sum{t|x} phi(x/t) t$ 网上普遍的做法是暴力枚举约数，再暴力计算phi这个的复杂度很难计算，感觉非常不可靠 受cty博客的启示，继续深入考虑从公式后者的形式来看，据说叫做狄利克雷卷积（普通卷积是通过和卷起来，这个是通过乘积卷起来）就是因为phi和1函数都是积性函数，所以这个整体也是个积性函数 那么现在我们需要求 $f(p^k)$ ，我们希望规避【暴力计算phi】，所以考虑利用刚才想到的性质，去递推$f(p^{k+1})=\sum f(p^k) \times p + phi(p^{k+1})$ 那么这个东西的计算是可以忽略的所以总时间主要是 根号n来分解质因数，找到p计算f的时间复杂度的外部系数只有30即最大不同质数数量]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>欧拉函数</tag>
        <tag>积性函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj3319】黑白树]]></title>
    <url>%2Fposts%2Faba8.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj3319 Record30min Analysis请先思考后再展开 log方显然不能过考虑特性，黑边只会增加不会减少找向上第一个黑边等价于把所有黑边断开后向上最高的点这个可以离线一下，并查集维护一下就好了]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4891】序列]]></title>
    <url>%2Fposts%2F6301.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4891 Record2h Analysis请先思考后再展开 感谢myh大爷的解释……当时比赛完发现官方不发题解，抱着试一试的想法去找myh，没想到他真的回复了 我们需要维护操作对于操作1，分三种情况 原本小于，后来小于：拿出来再放回去 原本小于，后来大于等于：拿出来不放回去 原本大于等于，此时不用理会 用一个set维护一个不同C的区间，以位置排序每次询问，先二分找到具体位置，然后枚举每个块，直到不能贡献那么因为操作后这些块相当于消失（向前合并），所以枚举的复杂度从从势能上看只有n+q同时这个块一定原本和最后都是相同的值 那么，为了能够维护有多少个 $C&lt;B$ ，如果暴力去维护，势能是值域级别的，没有意义但如果每次log地找到，最小那个B，知道大于等于新的值，那么这个的势能会明确地减少1这个新产生的部分和原本的加起来，会远比每一次重新统计好得多此处的时间同样是n次 具体而言，维护二元组mi和贡献数量sum 对于 $C&lt;B$ 的部分，mi=(B,pos)，sum=1 否则，mi=(INF,0)，sum=0 操作1找mi去更新操作2暴力处理 综上说述，时间复杂度为 $O((n+q) log n)$感觉这道题比较考验思路的清晰和明确]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC44】color]]></title>
    <url>%2Fposts%2Fd64f.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC44 Record1h Analysis请先思考后再展开 对于T=1的情况，对于一个l，考虑其贡献那么从l开始的第一个颜色，权值为1，下一个为-1，仅当只包含1的，那么就能产生贡献对询问排序后，l单调递增，r的变化只需要树状数组询问前缀和那么每次l的移动，把该颜色对应的贡献更新一下即可 而对于T更普通的情况，维护好每个位置向后T次同颜色的位置，那么用类似的方法，向后T+1次的位置为-1即可 还有一种变形：HEOI2012 采花SDOI2009 HH的项链也是类似的方法，只不过不要添加-1，而是用0即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=510000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int qread() &#123; int ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans; &#125; struct Qes &#123; int l,r; int ans; int pos; &#125;q[MAX_N]; bool cmp(Qes a,Qes b) &#123;return a.l&lt;b.l or (a.l==b.l and a.r&lt;b.r);&#125; bool cmp2(Qes a,Qes b) &#123;return a.pos&lt;b.pos;&#125; int n; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; if(x==0) return; while(x&lt;=n) &#123; bit[x]+=c; x+=lowbit(x); &#125; &#125; int ask(int x) &#123; int ans=0; while(x&gt;=1) &#123; ans+=bit[x]; x-=lowbit(x); &#125; return ans; &#125; int pos[MAX_N],fir[MAX_N]; int nx[MAX_N],nxT[MAX_N]; int ans[MAX_N]; void main() &#123; int m,k,T;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;T); for(int i=1;i&lt;=n;i++) &#123; int t=qread(); if(pos[t]&gt;0) nx[pos[t]]=i; else fir[t]=i; pos[t]=i; &#125; for(int i=1;i&lt;=k;i++) &#123; int l=fir[i],r=fir[i]; for(int t=2;t&lt;=T;t++) r=nx[r]; while(r&gt;0) &#123; nxT[l]=r; l=nx[l];r=nx[r]; &#125; change(nxT[fir[i]],1); change(nx[nxT[fir[i]]],-1); &#125; for(int i=1;i&lt;=m;i++) q[i].l=qread(),q[i].r=qread(),q[i].pos=i; sort(q+1,q+m+1,cmp); for(int i=1;i&lt;=m;i++) &#123; if(q[i-1].l!=q[i].l) &#123; int t=q[i-1].l; for(int j=t;j&lt;=q[i].l-1;j++) &#123; change(nxT[j],-1); change(nx[nxT[j]],2); change(nx[nx[nxT[j]]],-1); &#125; &#125; q[i].ans=ask(q[i].r); &#125; sort(q+1,q+m+1,cmp2); for(int i=1;i&lt;=m;i++) ans[q[i].pos]=q[i].ans; for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC43】ladder]]></title>
    <url>%2Fposts%2F67b3.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC43 Record1h Analysis请先思考后再展开 又是计数题，显然不能直接计算，考虑dp然后比赛我的时候我就一直努力计算非法状态数量，发现超级复杂，不知道如何巧妙地设计状态吃完饭回来，什么鬼？？直接计算就好了，合法状态好表示多了，非要脑残搞非法…… 设 $f(i,dis1,dis2,dis3,dis4)$ 表示现在在位置i，每个梯子与当前的距离如果dis=h，表示已经断开了，此时具体dis没有意义，用非法制h表示此时我们说h是非法值，是指它作为【被继承状态】而言所以答案即 $f(n,0 \leq dis1&lt;h,0 \leq dis2&lt;h,0 \leq dis3&lt;h,0 \leq dis4&lt;h)$显然有一维一定是0，所以可以省略，用0和1表示最后滚动一下即可]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC46】【POI2007】堆积木兼删数游戏]]></title>
    <url>%2Fposts%2Fd023.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2007NOIAC46bzoj1109 Record1h Analysis请先思考后再展开 先从简单一点的堆积木开始 考虑dp，设 $f(i)$ 表示考虑了前面i个数，此时 $a[i]=i$$f(i)=f(j)+1，当j&lt;i，a_j&lt;a_i，j-a_j \leq i-a_i$不过，我们可以把其中一个消除 当 $a_j&lt;a_i，j-a_j \leq i-a_i$不难得出 $j-a_j&lt;i-a_i+1$相减得出 $j \leq i$因为 $a_j&lt;a_i$ ，显然不可能相等，由此可知最前面那个可以去除（注意，此时第一个是第三个的子集，由一和二不能得出三） 观察一下那两个条件，可以发现形式是相同的，是一个二维偏序问题因为有递推性，可以按照第三个排序（否则不能在相同的第一关键字继承），然后把第二个最长不严格上升子序列一下即可 细节1：对于 $a[i]&gt;i$ 的位置，不能参与dp，这个不方便判断，可以直接剔除（但不能影响编号） 细节2：因为要最大化答案，而我们的三是可以相同的所以对于相同的第一关键字，我们也应该把二排序 细节还是有点多的，还不是很好发现可能只能对拍了……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=1100000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int n,k; int tot=0; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void update(int x,int c) &#123; while(x&lt;=n)//debug 很小的细节，bzoj帮忙发现了x&lt;=tot &#123; bit[x]=mymax(bit[x],c); x+=lowbit(x); &#125; &#125; int findmx(int x) &#123; int ans=0; while(x&gt;=1) &#123; ans=mymax(ans,bit[x]); x-=lowbit(x); &#125; return ans; &#125; struct Nod &#123; int a,b; int pos; &#125;s[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.a&lt;b.a or (a.a==b.a and a.b&lt;b.b);&#125; int f[MAX_N]; int solve() &#123; int ans=0; for(int i=1;i&lt;=tot;i++) &#123; f[i]=findmx(s[i].b-1)+1; update(s[i].b,f[i]); if(s[i].a&lt;=k and n-s[i].pos+s[i].a&gt;=k) ans=mymax(ans,f[i]); //debug if(s[i].a==k and n-s[i].pos+s[i].a&gt;=k) ans=mymax(ans,f[i]); //可能导致 a&gt;k，其实现在想想很明显…… //bzoj ans=mymax(ans,f[i]); &#125; return ans; &#125; void main() &#123; //scanf("%d",&amp;n); scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) &#123; int ai;scanf("%d",&amp;ai); if(i-ai&gt;=0) s[++tot]=(Nod)&#123;i-ai,ai,i&#125;; &#125; sort(s+1,s+tot+1,cmp); printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>偏序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF511A】Enlarge GCD]]></title>
    <url>%2Fposts%2F4ed.html</url>
    <content type="text"><![CDATA[Source and JudgeCF511A Record2h Analysis请先思考后再展开 本文用GCD表示原本的最大公约数，gcd表示最大公约数 第一次尝试开场做c，杠半天，想到一个aloga的做法：要增大gcd，那么统计f[t]表示t的倍数的数量，答案即合法范围内的 $min{ n-f[t] }$注意此时我要求 $t&gt;原GCD$ ，相当于我知道最后的GCD一定是t的倍数，那么把所有不存在t这个因子的数删除即可为什么我不能直接取质数呢？主要是担心，为了增大GCD，可能选择了2GCD，例如2 4 8这组数据 那么这个f怎么求呢？我想了差不多半个小时，只能想到用莫比乌斯函数，再枚举倍数，时间根据调和级数是log的 当时机房大佬们个个都切四道题了，心里慌的一匹然后我觉得可能做法上是理论极限了，是思路的问题，可能需要省去一些状态，但依然毫无思路 正解：显然最后得到的gcd一定是GCD的倍数可以把每个数除以GCD，那么现在总gcd为1，只要变成任何大于1的数，都意味着成功现在我们成功地不用再考虑GCD的影响了，只要考虑t是素数的情况就好了 只关心素数那么就容易多了，可以对每个数分解质因数而不用把它们组合不过暴力去找质数分解需要根号的时间，主要是寻找素数的时间太长了到这里的话，不难想到可以在线性筛的时候记录一下最小素因子，时间复杂度降低成素因子次幂和，最大30 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=310000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAX_NUM=15000001; int pr=0,prime[MAX_NUM]; bool isp[MAX_NUM]; int mip[MAX_NUM]; void pre() &#123; memset(isp,1,sizeof isp); for(int i=2;i&lt;MAX_NUM;i++) &#123; if(isp[i]) prime[++pr]=mip[i]=i; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAX_NUM;j++) &#123; isp[i*prime[j]]=0; mip[i*prime[j]]=prime[j]; if(i%prime[j]==0) break; &#125; &#125; &#125; int gcd(int x,int y) &#123;return y==0?x:gcd(y,x%y);&#125; int a[MAX_N]; int f[MAX_NUM]; void main() &#123; pre(); int n;scanf("%d%d",&amp;n,&amp;a[1]); int GCD=a[1];for(int i=2;i&lt;=n;i++) scanf("%d",&amp;a[i]),GCD=gcd(GCD,a[i]); for(int i=1;i&lt;=n;i++) &#123; a[i]/=GCD; while(mip[a[i]]&gt;1) &#123; int t=mip[a[i]];while(a[i]%t==0) a[i]/=t; f[t]++; &#125; if(a[i]&gt;1) f[a[i]]++; &#125; int ans=INF; for(int i=2;i&lt;MAX_NUM;i++) if(f[i]&gt;0 and f[i]&lt;n) ans=mymin(ans,n-f[i]); if(ans==INF) puts("-1"); else printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC47】power]]></title>
    <url>%2Fposts%2F42a8.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC47 Record2h Analysis请先思考后再展开 这道题如果从连通块的角度来思考，情况太多，dfs序也不连续经p老大提醒，如果从那段连续编号着手，然后像异象石那道题一样（自行搜索），找出需要的连通块大小就好了那么因为要求块大小小于等于k，可以用尺取法维护一个set，显然单调（xgc居然不while右指针都过了……） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int dfn; int dep; Nod() &#123;hou=dep=dfn=0;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int id=0,yz[MAX_N]; int f[MAX_N][20],bin[20]; void dfs(int x,int fa) &#123; p[x].dfn=++id;yz[id]=x; f[x][0]=fa;p[x].dep=p[fa].dep+1; for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x); &#125; &#125; int LCA(int x,int y) &#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=19;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int dis(int x,int y) &#123;return p[x].dep+p[y].dep-2*p[LCA(x,y)].dep;&#125; set&lt;int&gt; s; typedef set&lt;int&gt;::iterator It; int calc(int x) &#123; It rr=s.upper_bound(p[x].dfn);if(rr==s.end()) rr=s.begin(); It ll=rr;if(ll==s.begin()) ll=s.end(); --ll; int fl=yz[*ll],fr=yz[*rr]; return dis(fl,x)+dis(x,fr)-dis(fl,fr);//恰好完美处理单个的情况 &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1,0); int ans=1,sum=0; for(int l=1,r=2;l&lt;=n;l++) &#123; if(!s.count(p[l].dfn)) s.clear(),s.insert(p[l].dfn),sum=0,r=l+1; while(r&lt;=n) &#123; int t=calc(r); if((sum+t)/2+1&gt;k) break; sum+=t;s.insert(p[r].dfn);r++; &#125; ans=mymax(ans,(r-1)-l+1); s.erase(s.find(p[l].dfn)); if(s.size()&gt;1) sum-=calc(l); &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC37】染色]]></title>
    <url>%2Fposts%2F7761.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC37 Record30min Analysis请先思考后再展开 好奇妙的dp呀本来一直在想组合数学，然后想着用容斥因为如果互相不重叠，那么是非常好计算的然后我想着应该不需要重叠，因为按照容斥原理，不会互相重复计算后来打了半天，才发现形式上会重复 正解是dp，f(i,j)表示处理到第i个，然后前面j个互不相同，【但是再往前一个就出现相同】的方案数，确保 $j \leq m-1$如果第i+1个是和前面这j个中某个相同，则j减小，否则可以在这j个之外任选一个 如果能成功列出这个dp方程，转移后缀和优化一下，就能达到n方 123456789101112131415161718192021222324252627282930313233343536373839//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=5100; typedef long long ll; ll MOD,f[MAX_N][MAX_N]; void main() &#123; int n,m;scanf("%d%d%lld",&amp;n,&amp;m,&amp;MOD); f[0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int k=1;k&lt;=i and k&lt;=m-1;k++) f[i][k]=f[i-1][k]+(f[i-1][k-1]-f[i-1][k])*(m-(k-1))%MOD; for(int j=m-1;j&gt;=0;j--) f[i][j]=(f[i][j]+f[i][j+1])%MOD;//后缀和优化dp &#125; printf("%lld",(f[n][0]+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>计数dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARC套刷计划]]></title>
    <url>%2Fposts%2F84cd.html</url>
    <content type="text"><![CDATA[发现自己经常打比赛挂机……正好在noip前练习一下思维题 upd：现在已经变成做过的ARC合集了，码风不定实力不定请见谅 ARC103ARC103E - Tr/ee9.30 难度2题意：构造题给出一个01串，位置i表示能否通过去除某条边得到大小为i的连通块 请先思考后再展开 rose秒了……我的思路：显然位置1一定是1，位置n一定是0然后它还必须具有对称性 构造的话我想着可能应该从链开始考虑，然后像样例那样构造出一个大小合法的子树 但随后我就不知道如何保证一定不会出现某个大小了正解：从大到小枚举，如果不可行就作为单个节点挂在根节点那里（反正大小为1一定会产生）否则搞一个大小为i的子树，递归下去 12345678910111213141516171819202122char s[MAX_N];int id=0;void solve(int x,int siz)&#123; for(int i=siz-1;i&gt;=1;i--) &#123; printf("%d %d\n",x,++id); if(s[i]=='1') &#123; solve(id,i); break; &#125; &#125;&#125;void main()&#123; scanf("%s",s+1);int n=strlen(s+1); for(int i=1;i&lt;=n/2;i++) if(s[i]!=s[n-i]) &#123;puts("-1");return;&#125; if(s[1]=='0' or s[n]=='1') &#123;puts("-1");return;&#125; solve(++id,n);&#125; ARC103D Robot Arms9.30 难度2题意：确定小于等于40个步长，长度自己定，但要应对所有询问满足n个询问（1000内），通过上下左右能到达不同的n个位置，并输出具体方案 请先思考后再展开 大致思路是二进制拆分，但本题的难点就在于只能上下左右，不能不走比赛的时候想过，如果放大限制行不行？例如把每个位置拆开成2个、3个乃至4个，但好像都不行比赛就只打了个暴力部分分 正解看起来很暴力，晚上对着yww大爷的代码看半天全机房都不会证明……就是从大到小，然后看x和y哪个绝对值大，然后就“gao”，最后再移动多几步第二天早上过来，忽然就大致理解了这道题的特殊性就在于1和-1的运用，也就是说虽然不能都不走，但是可以对二进制做差而二进制有这许多非常奇妙的性质，比如说后面的t个二进制之和+1是等于t+1个二进制所以如果我们直接把x搞定了，剩下的部分做和、差总是能得出y的（因为最大拼出int，而x+y小于int） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const int MAX_N=1100; int n,x[MAX_N],y[MAX_N]; vector&lt;int&gt; d; vector&lt;char&gt; ans[MAX_N]; void gao(int k) &#123; d.push_back(k); for(int i=1;i&lt;=n;i++) if(abs(x[i])&gt;abs(y[i])) &#123; if(x[i]&lt;0) x[i]+=k,ans[i].push_back('L'); else x[i]-=k,ans[i].push_back('R');//debug 倒着走！ &#125; else &#123; if(y[i]&lt;0) y[i]+=k,ans[i].push_back('D'); else y[i]-=k,ans[i].push_back('U'); &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;x[i],&amp;y[i]); for(int i=30;i&gt;=0;i--) gao(1&lt;&lt;i); for(int i=1;i&lt;=8;i++) gao(1); if(x[1]!=0 or y[1]!=0) gao(1);//曼哈顿距离为奇数 for(int i=1;i&lt;=n;i++) if(x[i]!=0 or y[i]!=0) &#123;puts("-1");return;&#125; printf("%d\n",d.size()); for(int i=0;i&lt;(int)d.size();i++) printf("%d ",d[i]); puts(""); for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;(int)ans[i].size();j++) printf("%c",ans[i][j]); puts(""); &#125; &#125;&#125;int main()&#123; mine::main();&#125; ARC103F Distance Sums9.30 难度2题意：构造一棵树给出对于每个节点，其他节点到它的距离之和 请先思考后再展开 按照d排序，d最小的一定是树的重心那么考虑d最大的节点，同理，它一定是叶子节点，否则存在比它更大的d那么每次取出最大的d，它的子树确定，同时它的父亲也是能够确定的（ $d[fa]=d[x]-n+2 \times siz[x]$ ）最后还必须要跑一次dfs验证，因为此时只能说相对大小是正确的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int n; const int MAX_N=110000; struct Nod &#123; ll d;int p,siz; friend bool operator &lt; (Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; &#125;p[MAX_N]; #define PR pair&lt;int,int&gt; vector&lt;PR&gt; ans; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0; void ins(int x,int y) &#123; e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln; &#125; ll f[MAX_N]; void dfs(int x,int fa,int dis) &#123; f[x]=dis; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x,dis+1); &#125; &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;p[i].d),p[i].p=i,p[i].siz=1; sort(p+1,p+n+1); for(int i=n;i&gt;=2;i--) &#123; ll want=p[i].d-n+2*p[i].siz; int fa=lower_bound(p+1,p+n+1,(Nod)&#123;want,0,0&#125;)-p;//互不相同 if(p[fa].d!=want or fa==i) &#123;puts("-1");return;&#125; ins(p[i].p,p[fa].p);ins(p[fa].p,p[i].p); ans.push_back( make_pair(p[i].p,p[fa].p) ); p[fa].siz+=p[i].siz; &#125; dfs(1,0,0); ll rt=0,rt2=0;for(int i=1;i&lt;=n;i++) &#123;rt+=f[i];if(p[i].p==1) rt2=p[i].d;&#125; if(rt!=rt2) &#123;puts("-1");return;&#125; for(int i=0;i&lt;(int)ans.size();i++) printf("%d %d\n",ans[i].first,ans[i].second); &#125;&#125;int main()&#123; mine::main();&#125; ARC102ARC102D All Your Paths are Different Lengths请先思考后再展开 原来这就是传说中的构造题首先明确，基本的结构一定是二进制拆分但不难发现，很难保证只有L条路径，得出来的长度还绝对不能重复 其实我有点思维僵化了如果把1和后面的东西拆开来，分开讨论，后面的全部都是完全的二进制（也就是2的次幂边，以及0）那么我们记录一个当前已经搞定的最大范围mx-1，从mx开始然后对L二进制拆分，然后假如加入之后，依然在合法范围内，那么就加上mx，并更新范围不难发现，现在得出来的路径长度，一定不会重复出现（通过简单地记录一个当前上界） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110000,MAX_M=410000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int bin[20]; struct Edge &#123; int x,y,c; &#125;; vector&lt;Edge&gt; q; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int mx;scanf("%d",&amp;mx);//0~mx-1 int nowmx=0; for(int i=18;i&gt;=0;i--) while(nowmx+bin[i]-1&lt;=mx-1) &#123; q.push_back( (Edge)&#123;1,20-i,nowmx&#125; ); nowmx+=bin[i]; &#125; printf("20 %d\n",18*2+q.size()); for(int i=2;i&lt;=19;i++) printf("%d %d %d\n%d %d 0\n",i,i+1,bin[19-i],i,i+1); for(int i=0;i&lt;q.size();i++) printf("%d %d %d\n",q[i].x,q[i].y,q[i].c); &#125;&#125;;int main()&#123; mine::main();&#125; ARC102E Stop. Otherwise请先思考后再展开 考虑对每个询问回答，设当前ban掉的是m；求出有a对$(i,m-i)$以及b个随便用的数；如果有$2i=m，c=1$，这个特判即可 $F(n,x,y)$表示将n分成x个非空组合+y个可空组的方案，转化为将n+y分成x+y个非空组的方案，插板法即$F(n,x,y)=C_{n+y-1}^{x+y-1}$ 方法一，$O(n+k^2)$：code 那么枚举a中用了i个，$ans=\sum_{i=0}^a C_a^i2^i F(n,i,b)$，不是所有人能想到这个是因为有的人只知道x=0或y=0 方法二，$O(nklogn)$： 考虑生成函数算a的贡献，即$预处理好pp_a=(\frac{2}{1-x}-1)^a,ans=\sum_{i=0}^n [x^i]pp_a F(n-i,0,b)$ 下面这两个做法我已经不知道怎么直接推了，可能需要问高一的我吧 方法三：$ans=\sum_{k=0}^{a} (-1)^k 2^{k} C_{a}^k F(n,0,b+k) $ 方法四：$ans=\sum_{k=0}^{a} 2^{k} C_{a}^k F(n-k,0,b+k) $ ARC101ARC101D - median of medians二分答案mid，考虑有多少个区间的中位数$\ge mid$，经典做法设$\ge mid$的为1，其他为-1，那么就是有多少个区间的和非负 简单树状数组即可，$O(nlog^2n)$ ARC101E - Ribbons on Tree题意：给定一棵点数为偶数的树，求有多少种将点两两配对的方案使得每一条边至少被一对匹配点之间的路径覆盖 请先思考后再展开 容斥：设边集T为必定不经过的边，则答案即 $\sum (-1)^{|T|} F(T)$显然大小为t的连通块，任意选择的方案数 $g(t)=(t-1)(t-3)(t-5)… \times 1=(t-1)^{‘’}$具体的奇偶性等细节自行处理如果T把树分成了多个连通块，则答案即每个块的g(t)的乘积 然而指数级枚举T显然是不现实的利用图是一棵树的特性，考虑树形dp设 $f(x,k)$ 表示在x的子树中，最顶上的连通块的大小为k这个连通块是可拓展的，所以不统计内部的方案数，直到被其父亲统计（被父亲断开） dp转移时，常规地枚举两次siz，然后复杂度也同样是套路：把siz看做子树的每个节点，则每个点对只会在lca处被遍历到，所以复杂度 $O(n^2)$ 转移方程的话，因为边集大小增加，如果不断开，相当于合并上面那个块， $f(x,sz1+sz2)+=f(x,sz1) \times f(y,sz2)$如果断开(x,y)， $f(x,sz1)+=(-1) \times f(x,sz1) \times f(y,sz2) \times g(sz2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=5100; typedef long long ll; int hou[MAX_N],siz[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; const ll MOD=1e9+7; void addup(ll &amp;x,ll y) &#123;x=(x+y)%MOD;&#125; ll g[MAX_N],f[MAX_N][MAX_N],tmp[MAX_N]; void dfs(int x,int fa) &#123; siz[x]=1;f[x][1]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs(y,x); for(int i=0;i&lt;=siz[x]+siz[y];i++) tmp[i]=0; for(int sz1=0;sz1&lt;=siz[x];sz1++) for(int sz2=0;sz2&lt;=siz[y];sz2++) &#123; addup(tmp[sz1+sz2],f[x][sz1]*f[y][sz2]%MOD); if(sz2%2==0) addup(tmp[sz1],-f[x][sz1]*f[y][sz2]%MOD*g[sz2]%MOD); &#125; siz[x]+=siz[y]; for(int i=0;i&lt;=siz[x];i++) f[x][i]=tmp[i]; &#125; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; g[0]=1;for(int i=2;i&lt;=n;i+=2) g[i]=g[i-2]*(i-1)%MOD; dfs(1,0); ll ans=0; for(int sz=2;sz&lt;=n;sz+=2) addup(ans,f[1][sz]*g[sz]%MOD); addup(ans,MOD); printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; ARC101F - Robots and Exits请先思考后再展开 用二维平面理解可能比较好懂？一开始想的时候没看做一个平面，结果没法意识到有用状态仅n个 显然把只有右边、左边、已经在洞上的那些去掉，然后每个机器人只关心他左边和右边的第一个，设距离二元组为$(a_i,b_i)$，放到二维平面上；然后当前的状态就是(x,y)即历史向左或向右最值，每次给x+1或y+1，也就是形成了一个折线 一个机器人掉了即$x=a_i或y=b_i$即碰到一条竖线或一条横线的时候确实在哪里掉落，那么你发现从左边掉的等价于在折线左上方， 从右边掉等价于在折线右下方，问题转化成求多少个下方的点集不同的折线 关键状态仅n个，设f表示第i个点为最后一个下方关键点且下步往右：$f_i=1+\sum_{x_j&lt;x_i,y_j&lt;y_i}f_j$，直接树状数组维护即可，$O(nlogn)$ code ARC100ARC100D Equal_Cut请先思考后再展开 被rose操烂……这是一个贪心，而且感觉上很不科学，但是却又可以证明 假如我们枚举断点1，后面的两个端点会灰常麻烦，所以走到了死胡同然后rose用他的做法ac了……逻辑上讲，不妨换个切入点，考虑枚举中间的断点2先只考虑左边①最大值在左边 那么缩短A和B的差，会更优②最小值在左边 同上③A和B都不是最大值或最小值，那么缩短A和B的差，不会让答案更差上述情况都不是绝对的，可能移动时变成了另外一种情况但做法都是相同的，就是在平均值旁边“摇摆” 那具体怎么实现？如果直接二分查找也没问题，不过因为断点1和断点3都是递增的，所以可以“暴力”地移动却能达到O(n)的复杂度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;typedef long long ll;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int n;ll sum[MAXN];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;sum[i]); sum[i]+=sum[i-1]; &#125; ll ans=1ll&lt;&lt;60; //1~mid1,mid1+1~mid2,mid+1~mid3,mid3+1~n int mid1=1,mid3=3; for(int mid2=2;mid2&lt;=n-2;mid2++) &#123; while( sum[mid1]&lt;sum[mid2]-sum[mid1] ) mid1++; while( sum[mid3]-sum[mid2]&lt;sum[n]-sum[mid3] ) mid3++; ll A,B,C,D; A=sum[mid1],B=sum[mid2]-sum[mid1]; C=sum[mid3]-sum[mid2],D=sum[n]-sum[mid3]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); A=sum[mid1-1],B=sum[mid2]-sum[mid1-1]; C=sum[mid3]-sum[mid2],D=sum[n]-sum[mid3]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); A=sum[mid1],B=sum[mid2]-sum[mid1]; C=sum[mid3-1]-sum[mid2],D=sum[n]-sum[mid3-1]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); A=sum[mid1-1],B=sum[mid2]-sum[mid1-1]; C=sum[mid3-1]-sum[mid2],D=sum[n]-sum[mid3-1]; ans=mymin(ans,mymax( mymax(A,B),mymax(C,D) )-mymin( mymin(A,B),mymin(C,D) )); &#125; printf("%lld",ans);&#125; ARC100E Or Plus Max9.20 难度2题意：又看错题了……细思极恐给定一个正整数 n(n≤18)然后给定一行共 $2^n$ 个正整数 a0,a1,⋯,a2n−1对于每一个 k( $1≤k&lt;2^n$ )，输出满足 i OR j≤k 的最大 ai+aj 值。 请先思考后再展开 我能想到的最好的做法：如果能得出 $i|j=k$ 的情况，那么前缀max就是答案然而很难算出来但如果能得出 $i|j \in k$ 的答案，那么前缀max也是可以的而这个显然好算很多，i和j基本没关系了 枚举每个k，然后枚举其子集，维护最大和次大时间复杂度： $O(3^n)$1234567891011121314151617int a[MAX_N],mx[MAX_N];int ans[MAX_N];void main()&#123; int n;scanf("%d",&amp;n); int m=1&lt;&lt;n; for(int i=0;i&lt;m;i++) scanf("%d",&amp;a[i]); for(int k=1;k&lt;m;k++) &#123; ans[k]=mymax(a[0],ans[k-1]); mx[k]=a[0]; for(int u=k;u&gt;0;u=(u-1)&amp;k) ans[k]=mymax(ans[k],a[u]+mx[k]),mx[k]=mymax(mx[k],a[u]); printf("%d\n",ans[k]); &#125;&#125; 然而4亿在atcoder上面居然只需要760ms 正解：既然我们的答案和具体子集没有关系，只关心其最大值和次大值可以不用枚举子集，而是用子集来更新父亲对于一个集T，不一定所有的子集都直接更新到T，也可能先经过T的子集，但这样一定不会漏时间复杂度降低到了 $O(n2^n)$据说这个技巧有个更深入的应用：Fast Zeta Transform123456789101112131415161718192021222324252627282930int a[MAX_N];int f[MAX_N],g[MAX_N];//最大和次大值的位置void update(int x,int pos)&#123; if(pos&lt;0 or pos==f[x] or pos==g[x]) return; if(a[pos]&gt;=a[f[x]]) g[x]=f[x],f[x]=pos; else if(a[pos]&gt;=a[g[x]]) g[x]=pos;&#125;int bin[30];void main()&#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=0;i&lt;bin[n];i++) scanf("%d",&amp;a[i]),f[i]=i,g[i]=-1; int ans=0; for(int k=0;k&lt;bin[n];k++) &#123; for(int i=0;i&lt;n;i++) &#123; if(k&amp;bin[i]) continue; update(k+bin[i],f[k]); update(k+bin[i],g[k]); &#125; ans=mymax(ans,a[f[k]]+a[g[k]]); if(k&gt;0) printf("%d\n",ans); &#125;&#125;&#125;; ARC100F - Colorful Sequences9.26 难度3题意：定义一个长度为n，字符集大小为k的序列是好的，当且仅当其中存在一个长度为k的子串满足1到k每个数在这里面恰好出现一次。现在给一个长度为m的序列a，问在所有好的序列里面，a作为子串的出现次数的和。 请先思考后再展开 感觉这道题好神仙啊，还好有我p老大教我这个菜逼 先思考简化的问题一、问题一只考虑出现的次数，不考虑序列的好坏因为互相之间没有影响，直接搞枚举左边的数量，乱填， $(n-m+1) k^{n-m}$ 二、问题二考虑all-不好的那么问题转化为染色，最近在noiac做的一道比赛题（题解自行搜索）$f(n,ln)=f(n-1,ln-1) \times (k-(ln-1)) + \sum f(n-1,ln&lt;t \leq k)$此处复杂度为nk 三、问题一 + 问题二 A. 串a中包含k个不相同的直接按照问题一计算即可 B. 串a中包含最长不相同，长度小于k，前后延伸最长不重叠同样是计算不合法的数量，左右两边以刚才得到的延伸作为强制起点，按照问题二一样向左右分别dp然后和问题一一样，枚举左边，只不过此时左右两边填写的数量不是乱填，而是要保证非法性 C. 串a整体都是互不重复，但长度小于k我们既要求非法，有要统计贡献因为串a本身是互不相同的，不能像B那样左右搞，因为互相影响 这里用到一个非常巧妙的转化先忽略串a的具体字母，统计所有非法串中，长度为m的互不相同字符串的贡献这样以后我们就不再关心串a的具体值了，反正互不相同且唯一就是了最后把贡献还原回去，可以通过除以 排列数P(m,k) 实现 贡献的计算可以仿照前面的dp方式设f表示串总数，当后缀不可延伸长度满足长度条件的时候就统计进g，然后g自己也转移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const ll MOD=1e9+7; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; const int MAX_N=25100; ll fac[410];//&lt;=k ll P(int n,int m) &#123;return fac[n]*inv(fac[n-m])%MOD;&#125; int a[MAX_N]; bool b[410]; ll f[MAX_N][410],g[MAX_N][410]; void main() &#123; fac[0]=1;for(int i=1;i&lt;410;i++) fac[i]=fac[i-1]*i%MOD; int n,k,m;scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;a[i]); int mxlen=1; for(int l=1,r=0;l&lt;=m;b[a[l++]]=0) &#123; if(l&gt;r) b[a[++r]]=1; while(r+1&lt;=m and !b[a[r+1]]) b[a[++r]]=1; mxlen=max(mxlen,r-l+1); &#125; ll ans=ll(n-m+1)*qpower(k,n-m)%MOD; if(mxlen==k) ; else if(mxlen&lt;m) &#123; memset(b,0,sizeof b);int ls=0;while(ls+1&lt;=m and !b[a[ls+1]]) b[a[++ls]]=1; f[0][ls]=1; memset(b,0,sizeof b);int rs=m+1;while(rs-1&gt;=1 and !b[a[rs-1]]) b[a[--rs]]=1; g[0][m-rs+1]=1;//debug 要的是长度 for(int i=1;i&lt;=n-m;i++) &#123; ll fsum=0,gsum=0; for(int ln=k-1;ln&gt;=1;ln--) &#123; (fsum+=f[i-1][ln])%=MOD;(gsum+=g[i-1][ln])%=MOD; f[i][ln]=(f[i-1][ln-1]*(k-(ln-1))%MOD+fsum)%MOD; g[i][ln]=(g[i-1][ln-1]*(k-(ln-1))%MOD+gsum)%MOD; &#125; &#125; for(int left=0;left&lt;=n-m;left++) &#123; ll fsum=0,gsum=0; for(int ln=k-1;ln&gt;=1;ln--) (fsum+=f[left][ln])%=MOD,(gsum+=g[n-m-left][ln])%=MOD; (ans-=fsum*gsum%MOD)%=MOD; &#125; &#125; else &#123; f[0][0]=1; for(int i=1;i&lt;=n;i++) &#123; ll fsum=0,gsum=0; for(int ln=k-1;ln&gt;=1;ln--) &#123; (fsum+=f[i-1][ln])%=MOD;(gsum+=g[i-1][ln])%=MOD; f[i][ln]=(f[i-1][ln-1]*(k-(ln-1))%MOD+fsum)%MOD; g[i][ln]=(g[i-1][ln-1]*(k-(ln-1))%MOD+gsum)%MOD; if(ln&gt;=m) (g[i][ln]+=f[i][ln])%=MOD; &#125; &#125; ll tot=0; for(int i=1;i&lt;=k-1;i++) (tot+=g[n][i])%=MOD; (ans-=tot*inv(P(k,m))%MOD)%=MOD; &#125; printf("%lld",(ans+MOD)%MOD); &#125;&#125;int main()&#123; mine::main();&#125; ARC099ARC099E - Independence题意：给定一个有 n 个节点， m条边的无向图，保证没有自环和重边。请你把所有的 n 个节点分成两组，同组中的任意两个节点之间都有边直接连接。问连接同组节点的总边数最小为多少？如果不存在合法的划分方案，则输出 −1 请先思考后再展开 我能想到的最好做法：题目要求分成两个团，取补图后就是分成两个独立集那么这个可以二分图染色，因为边意味着排斥关系然后我们需要最小化 $min{ \frac{a(a-1)+b(b-1)}{2} }$因为染色的时候我们会先入为主，那其实是可以整体取反的，也就是交换a和b为了求最小值，我想到二维背包，但时间为 $O(n^3)$感觉3亿在atcoder上应该是能跑过去的……有了上一道题的经验 我tm在想些什么？？？a+b=n，做个屁的二维背包…… ARC099F Eating Symbols Hard请先思考后再展开 明显会想到hash，记录状态(当前hash值、当前指针对应的base次幂值)，比较只用前面，合并是可以快速搞的 然后我的写法是$O(hash个数*nlogn)$的，code ARC098ARC098D - Xor Sum 2题意：给你一个长度为n的整数序列，让你求出满足以下条件的(l, r)的对数：其异或和=其和 请先思考后再展开 能想到的最好做法：维护一个前缀异或和a，前缀和b$a[r]^a[l-1]=b[r]-b[l-1]$然而异或没法和四则运算一起化式子，复杂度只能是 $O(n^2)$ 正解：刚问出来就被秒掉了$0 xor 0=0,0+0=0$$0 xor 1=1,0+1=1$$1 xor 1=0,1+1=2$唯一的差异就是进位而这个差异是没有办法消除的，只能避免所以该区间一定不会在同一个位置上存在超过一个1所以具有单调性 ARC099E - Range Minimum Queries9.21 难度2题意：给定一个n个数的数列和两个整数数K,Q，执行Q次操作：选择一段长度为K的区间，删除其中的最小值。问：执行Q次操作后，被删除的数的最小值和最大值之差 的最小值是多少？ 请先思考后再展开 max-min的最小值显得很复杂但因为取得都是原本就有的数，所以可以枚举min，然后找最小的max因为min确定了，那么不能有任何区间包含小于min的数，这些数把整个区间分成很多段对于每个长度为len的段，只能取出前面len-k小的数把每个段能贡献的所有数排序，其中第q小的就是答案 ARC098F Donation请先思考后再展开 一个点如果被经过多次，在最后那次再解救总是等效且更优的考虑构造一个序列 $C_i=max(A_i-B_i,0)$ 表示在这个点上的任意时刻都至少有的金币数 那么我们考虑当前C最大的点x，去掉后会形成多个连通块，那么策略一定是走完其他连通块-&gt;x-&gt;某个连通块于是我们可以把图转化成一棵树，重复上述操作，即儿子为各个连通块中最大点，这个可以nlogn解决 设 $f_x表示子树B的和，g_x表示搞定子树，进入前最少的金币数$$g_x=min { max(g_y,C_x)+f_x-f_y }$ 123456789101112131415161718192021222324252627282930313233343536ll b[MAX_N];int c[MAX_N];vc&lt;int&gt; son[MAX_N];ll g[MAX_N];void dp(int x)&#123; if(son[x].size()) &#123; for(int t=0;t&lt;(int)son[x].size();t++) dp(son[x][t]),b[x]+=b[son[x][t]]; g[x]=LLINF; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t]; chmin(g[x], max(g[y],(ll)c[x])+(b[x]-b[y]) ); &#125; &#125; else g[x]=b[x]+c[x];&#125;int pos[MAX_N];bool cmp(int x,int y)&#123;return c[x]&lt;c[y];&#125;vc&lt;int&gt; to[MAX_N];int fa[MAX_N];int findfa(int x)&#123;return x==fa[x]?x:fa[x]=findfa(fa[x]);&#125;void main()&#123; int n=qread(),m=qread();for(int i=1;i&lt;=n;i++) c[i]=qread(),b[i]=qread(),c[i]=max(int(c[i]-b[i]),0); for(int i=1;i&lt;=n;i++) pos[i]=i;sort(pos+1,pos+n+1,cmp); for(int i=1;i&lt;=m;i++)&#123;int x=qread(),y=qread();to[x].PB(y);to[y].PB(x);&#125; for(int i=1;i&lt;=n;i++) &#123; int x=pos[i];fa[x]=x; for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t],tt=findfa(y); if(fa[y]!=0 and tt!=x) fa[tt]=x,son[x].PB(tt); &#125; &#125; dp(pos[n]);write(g[pos[n]]);&#125; ARC097ARC097D - Equals9.21 难度2题意：给出可交换的两个位置，和一个排列，最大化pi=i的位置 请先思考后再展开 这都没想出来……对于能间接互相交换的位置，假设有a要和b交换，则总是能够a到b，此时b被挤开，跳到a，然后中间的部分不会发生改变 所以，可以用并查集维护间接到达关系，然后询问能够回到原本位置即可 ARC097E - Sorted and Sorted9.21 难度1题意：排成一列的2N个球，有黑球和白球，黑球和白球上面都写了1-N的数字，给定一个操作：swap相邻两个球。问最少操作次数使得白球和黑球上的序号都分别递增。 请先思考后再展开 从简单问题入手，如果给出一个n的排列，要让a[i]=i，只能相邻交换此时因为每次交换只能消除一个逆序对，所以答案是逆序对数此时所谓逆序对即原位置p1，终位置p2， $p1[i]&gt;p1[j]且p2[i]&lt;p2[j]$ 那么回到本题，求出一个最优秀的终止状态p2，就能得出答案了那么，白球和黑球内部要有序，但交错的顺序不确定即使暴力也不好枚举，但因为黑白内部的顺序已经确定，不难想到可以用类似字符串匹配的方式dp 设 $f(x \leq 2n,a,b)$ 表示填写到第x位，白色填了a个，黑色填了b个的逆序对最少个数显然i=a+b，实现的时候需要去除一维转移的话，关键就是要快速地计算新逆序对设白色的id为x，则对应黑色的id为n+x当放白色， $p1[t]&gt;p1[a]，t=1 \to a-1和n+1 \to n+b$当放黑色， $p1[t]&gt;p1[n+b]，t=1 \to a和n+1 \to n+b-1$这个东西可以预处理一下，然后就能达到 $O(n^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=2100; const int INF=0x3f3f3f3f; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int p1[MAX_N*2]; int f[MAX_N*2][MAX_N]; int nw[MAX_N*2][MAX_N*2]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=2*n;i++) &#123; char s[5];int id;scanf("%s%d",s,&amp;id); p1[id+n*(s[0]=='B')]=i; &#125; for(int i=1;i&lt;=2*n;i++) for(int t=1;t&lt;=2*n;t++) nw[i][t]=nw[i][t-1]+(p1[t]&gt;p1[i]); memset(f,63,sizeof f);f[0][0]=0; for(int x=1;x&lt;=2*n;x++) &#123; for(int a=0;a&lt;=x and a&lt;=n;a++) &#123; int b=x-a; if(a&gt;0) f[x][a]=mymin(f[x][a], f[x-1][a-1]+nw[a][a-1]+nw[a][n+b]-nw[a][n] ); if(b&gt;0) f[x][a]=mymin(f[x][a], f[x-1][a]+nw[n+b][a]+nw[n+b][n+b-1]-nw[n+b][n] ); &#125; &#125; printf("%d",f[2*n][n]); &#125;&#125;;int main()&#123; mine::main();&#125; ARC097F - Monochrome Cat9.24 难度2题意：给定一棵有n个节点的树，每个点有黑白两个颜色。现在有一只猫可以从任意节点开始，任意一个节点结束，要把所有节点染成黑色。可以执行如下两种操作之一： 移动到相邻节点，并改变其颜色 改变当前节点颜色求：把所有节点染成黑色所需的最少操作次数数据范围：N&lt;=2e5 请先思考后再展开 设白0黑1 不难想到：如果叶子节点是黑色，可以删除，如此重复直到所有叶子节点都是白色位置 如果起点和终点一样，显然遍历所有叶子节点需要遍历每个节点和边（基于上面的操作）如果对于一个点，其度是偶数，意味着会被抵消掉，如果此时是白色则要改变，同理如果是奇数而且是黑色，也要改变自己一次，所以答案为 $\sum 度数+【(度数+颜色)\%2=0】$ 但如果起点和终点不一样呢？和起点终点相同的情况相比，从路径的形式上 就是少了【起点到终点的一条链】，这个过程中，如果本来不需要操作就是黑色的节点，现在少经过一次，但需要操作，代价不变而本来需要操作的节点，现在不经过，也不需要操作，少了2的代价 现在问题转化成，需要找出一条链，经过最多【本来需要操作的节点】，不过每个节点最多经过一次，而且链的终点不能累加 这个终点有点烦人，但注意到终点总是能拓展的，即使是最极端的叶子节点，因为度数=1，颜色一定是白色，所以权值为0，不是必须终点，即使终点为其父亲，形式上也可延伸到叶子节点综上所述，只要在原答案的基础上，减去带权树的直径即可 ARC096ARC096D Static Sushi请先思考后再展开 考试的时候傻了，居然还想单调队列……然后到目前为止还是wa两个点代码太丑，何况还是错的，就不贴了 其实把前面的信息记录一下，然后后面就简单地取mx就好了 123456789101112131415161718192021222324252627282930313233343536373839//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************ll f[MAXN],g[MAXN];//顺时针，逆时针ll x[MAXN],v[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n;ll c;scanf("%d%lld",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;x[i],&amp;v[i]); ll ans=0,sum; sum=0;for(int i=1;i&lt;=n;i++) sum+=v[i],f[i]=sum-x[i],ans=mymax(ans,f[i]); sum=0;for(int i=n;i&gt;=1;i--) sum+=v[i],g[i]=sum-(c-x[i]),ans=mymax(ans,g[i]); ll mx; mx=0;for(int i=n-1;i&gt;=1;i--) mx=mymax(mx,g[i+1]),ans=mymax(ans,f[i]+mx-x[i]); mx=0;for(int i=2;i&lt;=n;i++) mx=mymax(mx,f[i-1]),ans=mymax(ans,g[i]+mx-(c-x[i])); printf("%lld",ans);&#125; ARC096E - Everything on It题意：拉面有 n 种配料，每种配料可以选择加入到拉面中，也可以不加入；一共 $2^n$ 种组合，有人来订购一些拉面（不能空集，也就是元素为子集的集合，显然拉面最多同时有$2^n-1$碗）要求：每种拉面配料不能相同，每种配料在全部的面中至少出现过两次。 请先思考后再展开 这道题一眼容斥来搞【不能出现少于两次】的这个条件$ANS=\sum_{k=0}^n (-1)^k C(n,k) f(k)$其中f(k)表示有k个颜色只能不用或用一次，剩下n-k个颜色任意放，但不能出现两个完全相同的组合数然后到这里我就不知道怎么处理不能完全相同这个问题了 f(k)应该分两部分去思考① 不合法的k个颜色那么相当于这k个元素，要么不放，要么放进一个集合中假设有t个非空集合，那么这个是类似于第二类斯特林数的（刚学……）递推式： $g(k,t)=g(k-1,t-1)+g(k-1,t) \times (t+1)，0 \leq t \leq k$解释：在原本第二类斯特林数的基础上，加上【可以丢掉】这个选项可以是把第k个元素单独放进第t个位置，也可能第t个集合是混合的，再或者丢掉②其他的n-k个颜色这里非常巧妙（自己菜），也是我一直不知道怎么解决的地方，方案数量为 $2^{n-k}$那么对于那k个非法元素，本来觉得超级复杂，其实因为每个最多出现一次，不同的碗一定不会重复，所以是 $2^{(n-k)t}$ 而合法元素的话，不应该和碗的数量扯上关系，而是考虑把每个方案看作一个碗，考虑这个碗是否出现，所以是 $2^{2^{n-k}}$ 综上所述， $f(k)=\sum_{t=0}^k g(k,t) \times 2^{(n-k)t} \times 2^{2^{n-k}}$套一个小费马定理即可 ARC096F - Sweet Alchemy9.24 难度2题意：n≤50的树，每个点有权值，现要选点（可多次选一个点）使点数尽量多，如下限制：选的总权值不超过C≤1e9；ci表示i选的次数，pi表示i的父亲，那么cpi≤ci≤cpi+D，D≤1e9是给定常数。 请先思考后再展开 因为子节点选择的数量至少比父节点多可以把操作看做是选择一整棵子树，那么问题转化成： 有n个物品，有体积和价值，要求在体积小于X的条件下让价值最大化，每个物品也有选择次数的限制（根节点无限，其他节点为D）观察值域，物品的数量很小，体积很大，单个价值很小，次数很大直接用多重背包的模板，无法存下体积，用价值dp的话，总价值可能也会很大（因为次数大） 此时有一个很不好想到的姿势：用贪心代替大部分dp结论：每个物品，只用前面n个去dp，其他的贪心该贪心主要用微扰（应该是吧？）来证明：当物品数量足够大的时候，如果不考虑小的误差，是可以用贪心，选择性价比高的物品来得到大致结果的为什么只能是大致呢？主要可能是部分细小的体积有优化空间 思考什么情况下，选择性价比高的物品一定是正确的设有物品i和j， 并假设i的性价比更高即 $v_i / w_i &gt; v_j / w_j$选择vi个j物品，和选择vj个i物品，其价值都是 $v_i \times v_j$但体积 $w_j \times v_i &gt; w_i \times v_j$ 也就是说选择i的体积更小这就是说，当达到此数量级，一定是性价比高的更优秀 那么，在这个数量级之外的次数可以用贪心计算，内部的情况因为比较复杂，不能贪心，只能dp那么注意到w在单个的时候，和n是同阶的，也就是dp的权值是 $n^3$ 级别的，而体积依然非常大所以应该用权值来dp，即 $f[权值]=min 体积$考虑到用二进制拆分法处理多重dp，值域为 $n^3$ ，时间复杂度为 $O(n^4logn)$ dp完成后，剩余的空间就贪心地在剩余物品中选择即可 up：忘记了，用单调队列优化一下就到n四方了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=60; const int INF=0x3f3f3f3f; typedef long long ll; struct LJB &#123; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N]; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; LJB() &#123;ln=0;memset(hou,0,sizeof hou);&#125; &#125;E; struct Nod &#123; ll w,v; ll num; &#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.w*b.v&gt;b.w*a.v;&#125; //规避除法，已知都是非负数 void dfs(int x,int fa) &#123; p[x].w=1; for(int k=E.hou[x];k&gt;0;k=E.e[k].g) &#123; int y=E.e[k].y;if(y==fa) continue; dfs(y,x); p[x].w+=p[y].w;p[x].v+=p[y].v; &#125; &#125; ll f[MAX_N*MAX_N*MAX_N]; void main() &#123; int n;ll mxV,D;scanf("%d%d%d",&amp;n,&amp;mxV,&amp;D); scanf("%lld",&amp;p[1].v); for(int i=2;i&lt;=n;i++) &#123; int fa;scanf("%lld%d",&amp;p[i].v,&amp;fa); E.ins(fa,i); &#125; dfs(1,0); memset(f,63,sizeof f);f[0]=0; for(int i=1;i&lt;=n;i++) &#123; ll num=mxV/p[i].v;//debug v可能退化成int再参与运算 if(i&gt;1) num=min(num,(ll)D); if(num&gt;n) p[i].num=num-n,num=n; else p[i].num=0; ll now=1; while(num&gt;0) &#123; ll w=now*p[i].w,v=now*p[i].v; for(int ww=n*n*n;(ll)ww&gt;=w;ww--) f[ww]=min(f[ww],f[ww-w]+v); num-=now; now=min(now&lt;&lt;1,num); &#125; &#125; sort(p+1,p+n+1,cmp); ll ans=0; for(int ww=0;ww&lt;=n*n*n;ww++) &#123; if(f[ww]&gt;mxV) continue; ll ret=ww,left=mxV-f[ww]; for(int i=1;i&lt;=n;i++)//debug 注意此时不是原编号 &#123; ll num=min(left/p[i].v,p[i].num); left-=num*p[i].v;ret+=num*p[i].w; &#125; ans=max(ans,ret); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; ARC093ARC093D Grid Components给出正整数A和B，求一个长宽都在100以内，并且白色连通块和黑色连通块分别是A和B的矩阵保证有解，输出任意一个合法解即可请先思考后再展开 首先，h=100，w=100然后分均匀的两边，然后A–,B–然后再黑色那边补白色，白色那边补黑色，只要隔一行就好，这样正在补的连通块只增不减，另一个颜色完全不变！妙不可言地解决了…… 12345678910111213141516171819202122232425262728char mp[110][110];int main()&#123; printf("100 100\n"); for(int i=1;i&lt;=100;i++) for(int j=1;j&lt;=100;j++) if(i&lt;=50) mp[i][j]='#'; else mp[i][j]='.'; int a,b;scanf("%d%d",&amp;a,&amp;b); int x,y; x=1;y=1; for(int i=1;i&lt;=a-1;i++) &#123; mp[x][y]='.'; y+=2;if(y&gt;100) x+=2,y=1; &#125; x=100;y=1; for(int i=1;i&lt;=b-1;i++) &#123; mp[x][y]='#'; y+=2;if(y&gt;100) x-=2,y=1; &#125; for(int i=1;i&lt;=100;i++) puts(mp[i]+1);&#125; ARC093F Dark Horse请先思考后再展开 难得能独立做出arc的F 这题的复杂度是 $O(mn2^n)$，不过我的代码因偷懒写的是$O(m^2m2^n)$，写成那种的话就是把下面第一维状态去掉，转移的时候直接把-1这个系数带上 首先考虑这是一棵二叉树，那么我们不妨把1放在0号位置，最后乘$2^n$，然后1向上的链上会有n次与别人交汇（即n次分叉 考虑容斥，在A中固定cnt个人与1在那n个位置交汇，系数就是经典的$(-1)^{cnt}$ 考虑每个固定非法的人，他要在n个位置中选一个且以后其他人不能再用，明显可以状压 设这个人$a_i$选择的是位置j（从0编号非常方便，代码极短，且其实第一维可以去掉的），那么要在比自己大的、还没用的人中选择$2^j-1$个，乘以排列$j!$；为了方便计算【比自己大的且没用过】的，从大到小考虑a即可；最后还要把没用过的人乘个阶乘即$(2^n-1-State)!$ 123456789101112ll fac[M],facinv[M];ll P(int n,int m)&#123;return n&lt;m?0:fac[n]*facinv[n-m]%MOD;&#125;int a[N];ll f[N][1&lt;&lt;N];void main()&#123; fac[0]=1;for(int i=1;i&lt;M;i++) fac[i]=fac[i-1]*i%MOD; facinv[M-1]=invm(fac[M-1]);for(int i=M-2;i&gt;=0;i--) facinv[i]=facinv[i+1]*(i+1)%MOD; int n=qread(),m=qread();for(int i=1;i&lt;=m;i++) a[i]=qread();f[0][0]=1; for(int i=m;i&gt;=1;i--) for(int cnt=m-i;cnt&gt;=0;cnt--) for(int s=0;s&lt;bin(n);s++) if(f[cnt][s]) for(int j=0;j&lt;n;j++) if(!(s&amp;bin(j))) add(f[cnt+1][s^bin(j)], f[cnt][s]*P( bin(n)-a[i]-s , bin(j)-1 )%MOD*bin(j)%MOD ); ll ans=0;for(int s=0;s&lt;bin(n);s++) for(int cnt=0;cnt&lt;=m;cnt++) add(ans, ll(cnt&amp;1?MOD-1:1)*f[cnt][s]%MOD*fac[bin(n)-1-s]%MOD );write(ans*bin(n)%MOD);&#125;//(ans+MOD)%MOD ARC092ARC092D Two Sequences请先思考后再展开 被卡常了……记住，少点%啊 这道题还是很有意思的首先呢，直接枚举显然是不行的那么找找特殊性质异或，当然就跟奇偶性有关了然后？嗯我比赛的时候就是想到这里就不会了这个复杂度看起来就像是nlogn我们先按照位来处理。但a+b这种东西很烦啊，因为会有进位不过至少，我们处理第i位的时候i前面的就不用考虑了，%掉就好 然后，我们统计第i位是1的数量，判断奇偶性就好了。显然我们可以得到一个结果的有效范围$$[2^i,2^{i+1}-1] （不进位）$$和$$[2^{i+1}+2^i,2^{i+2}-1] （进位）$$那么枚举n个数字作为加数，不就得到了另一个加数的有效范围了吗nlogn排序后二分查找就好了（事实证明我的查找还是打得不熟练）假设第j个数字的对应数量有tj个，那么答案就是$$ANS=\sum_{i=0}^{29} ( ( (\sum_{j=1}^{n} tj) \&amp; 1)&lt;&lt;i )$$好久没有给卡常了……总时间$O(nlog^2n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************ll q[MAXN],w[MAXN];ll bin[35];int n;//*******************实现*******************/*debugbool cmp(ll a,ll b)&#123; return (a%bin[f+1])&lt;(b%bin[f+1]);&#125;*///*******************主函数*******************ll w2[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=32;i++) bin[i]=bin[i-1]&lt;&lt;1; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;q[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); ll ans=0; for(int f=0;f&lt;=29;f++) &#123; for(int i=1;i&lt;=n;i++) w2[i]=w[i]%bin[f+1]; sort(w2+1,w2+1+n); ll t=0; for(int i=1;i&lt;=n;i++) &#123; ll now=q[i]%bin[f+1],ss=0; ll l,r; int bf; l=bin[f];r=bin[f+1]-1; l=lower_bound(w2+1,w2+n+1,l-now)-w2; r=upper_bound(w2+1,w2+n+1,r-now)-w2-1; bf=r-l+1;if(bf&gt;0) ss+=bf; l=bin[f+1]+bin[f];r=bin[f+2]-1; l=lower_bound(w2+1,w2+n+1,l-now)-w2; r=upper_bound(w2+1,w2+n+1,r-now)-w2-1; bf=r-l+1;if(bf&gt;0) ss+=bf; t=(t+ (ss&amp;1) )&amp;1; &#125; ans+=(t&lt;&lt;f); &#125; printf("%lld",ans);&#125; ARC082ARC082E ConvexScore请先思考后再展开 n四方：把每个凸包用最下面的点表示（多个则最左）然后极角排序后，跑一个dp，记录内部点的数量（暴力预处理三角形内点的数量） n三方：考虑贡献的形式，就是去掉凸包S后子集U数量然后就会发现（反正我是想不到的），S和U的并是独一无二的，那么只要统计有面积的集合数量即可枚举点，然后去掉重复计数即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; //#define pr pair&lt;double,int&gt; #define FR first #define SE second #define MP make_pair const int MAX_N=210; struct Nod&#123;int x,y;&#125;p[MAX_N]; int cross(Nod a,Nod b) &#123;return a.x*b.y-a.y*b.x;&#125; const int MOD=998244353; bool v[MAX_N][MAX_N]; int bin[MAX_N]; void main() &#123; bin[0]=1;for(int i=1;i&lt;MAX_N;i++) bin[i]=bin[i-1]*2%MOD; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); int ans=bin[n]-1-n;//printf("ans=%d\n",ans); for(int a=1;a&lt;=n;a++) for(int b=a+1;b&lt;=n;b++) &#123; int mi,mx; if(p[a].x==p[b].x) &#123;if(p[a].y&lt;p[b].y) mi=a,mx=b; else mi=b,mx=a;&#125; else &#123; if(p[a].x&lt;p[b].x) mi=a,mx=b; else mi=b,mx=a; &#125; int tot=2; for(int c=1;c&lt;=n;c++) if(c!=a and c!=b) &#123; if(cross( (Nod)&#123;p[a].x-p[b].x,p[a].y-p[b].y&#125;, (Nod)&#123;p[a].x-p[c].x,p[a].y-p[c].y&#125;)==0) &#123; if(p[a].x==p[b].x) &#123; if(p[c].y&lt;p[mi].y) mi=c; else if(p[c].y&gt;p[mx].y) mx=c; &#125; else &#123; if(p[c].x&lt;p[mi].x) mi=c; else if(p[c].x&gt;p[mx].x) mx=c; &#125; tot++; &#125; &#125; if(v[mi][mx]) continue; v[mi][mx]=1; ans-=bin[tot]-tot-1; ans%=MOD; //printf("(%d,%d,%d,%d)=%d\n",mi,mx,a,b,tot); &#125; printf("%d",(ans+MOD)%MOD); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125; ARC063ARC063E 木と整数请先思考后再展开 维护一个有效的范围和奇偶性，树形dp即可然后数组漏了个0是什么鬼…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; int val; int mi,mx; int jo;//-1,0,1&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[2*MAXN];//*******************实现*******************int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;bool bk=1;void dfs(int x,int fa)&#123; if(bk==0) return; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); if(p[x].jo!=-1 and p[x].jo==p[y].jo) &#123; bk=0; return; &#125;//本来相邻或者递推得来 p[x].mi=mymax(p[x].mi,p[y].mi-1); p[x].mx=mymin(p[x].mx,p[y].mx+1); if(p[y].jo!=-1) p[x].jo=p[y].jo^1;//信息的合并 &#125; if(p[x].jo!=-1 and p[x].mi==p[x].mx and p[x].mi%2!=p[x].jo) &#123; bk=0; return; &#125;//检查 if(p[x].mi&gt;p[x].mx) &#123; bk=0; return; &#125;&#125;void dfs2(int x,int fa)&#123; if(p[x].val==-1) &#123; if(fa==0) &#123; if(p[x].mi%2==p[x].jo) p[x].val=p[x].mi; else p[x].val=p[x].mi+1; &#125; else &#123; if(p[x].mi&lt;=p[fa].val-1 and p[fa].val-1&lt;=p[x].mx) p[x].val=p[fa].val-1;//debug else p[x].val=p[fa].val+1; &#125; &#125; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs2(y,x); &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; p[i].hou=0; p[i].val=-1; p[i].mi=-INF;p[i].mx=INF; p[i].jo=-1; &#125; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; int k;scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); p[a].val=p[a].mi=p[a].mx=b; p[a].jo=b%2; &#125; dfs(1,0);//自下而上 if(bk==0) printf("No\n"); else &#123; printf("Yes\n"); dfs2(1,0);//自上而下 for(int i=1;i&lt;=n;i++) printf("%d\n",p[i].val); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-4数据结构 8题]]></title>
    <url>%2Fposts%2F59da.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x40 数据结构部分题目 1 Noi2015 程序自动分析9.18 难度1请先思考后再展开 交上去50，真的难受码的时候还在想为什么po姐要拍……立刻就打脸了虽然说没细细检查主要是输入的时候，把x放进去了两次……超搞笑好吧对noip超虚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=1100000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int fa[MAX_N*2]; int findfa(int x) &#123;return fa[x]=(fa[x]==x?x:findfa(fa[x]));&#125; void join(int x,int y) &#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy; &#125; struct Data &#123; int d,p; friend bool operator &lt; (Data a,Data b) &#123;return a.d&lt;b.d;&#125; &#125;a[MAX_N*2]; int yz[MAX_N*2]; int op[MAX_N]; int n; bool check() &#123; for(int i=1;i&lt;=n;i++) if(!op[i]) &#123; int fx=findfa(yz[2*i-1]),fy=findfa(yz[2*i]); if(fx==fy) return 0; &#125; return 1; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d%d",&amp;x,&amp;y,&amp;op[i]); a[2*i-1].d=x;a[2*i-1].p=2*i-1; a[2*i].d=y;a[2*i].p=2*i;//debug &#125; sort(a+1,a+2*n+1); int rx=1;yz[a[1].p]=rx; for(int i=2;i&lt;=2*n;i++) rx+=(a[i-1].d!=a[i].d),yz[a[i].p]=rx; for(int i=1;i&lt;=rx;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) if(op[i]) join(yz[2*i-1],yz[2*i]); if(check()) puts("YES"); else puts("NO"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 2 POJ1456 Supermarket9.18 难度1请先思考后再展开 我的做法和网上的都不一样lyd1：在前i天，尽量卖出合法的前i个值lyd2：从大到小处理，然后找过期前面的空位，可以用并查集加速我的做法：从大到小枚举天数，每次把这一天的所有新商品放到堆里面，然后卖出其中最大的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=11000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hou[MAX_N]; struct Edge&#123;int y,g;&#125;e[MAX_N]; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; struct Nod &#123; int a,b; friend bool operator &lt; (Nod x,Nod y) &#123;return x.a&lt;y.a;&#125; &#125;p[MAX_N]; priority_queue&lt;Nod&gt; q; void main() &#123; int n; while(scanf("%d",&amp;n)!=EOF) &#123; ln=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].a,&amp;p[i].b),ins(p[i].b,i); int ans=0;while(!q.empty()) q.pop(); for(int now=MAX_N-1;now&gt;=1;now--) &#123; for(int k=hou[now];k&gt;0;k=e[k].g) q.push(p[e[k].y]); if(q.empty()) continue; Nod t=q.top();q.pop(); ans+=t.a; &#125; printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 3 POJ1733 Parity game9.18 难度1请先思考后再展开 lyd边带权做法：奇1偶0，路径压缩时异或同集合判断合法性，不同集合就合并 lyd拓展域做法：拆成奇数域和偶数域，同集合表示一种能互相推导的关系判断非法的话，是根据此前是否有和当前操作相反的信息 我的做法是乱yy的，和拓展域做法类似区别： 在我的理解里面，拆点表示和我不一样（因为只有两个情况） 判断非法时，我是看是否会导致我和我的对立点相同12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=11000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int fa[MAX_N]; int findfa(int x) &#123;return fa[x]=(x==fa[x]?x:findfa(fa[x]));&#125; void merg(int x,int y) &#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy; &#125; bool one(int x,int y) &#123;int fx=findfa(x),fy=findfa(y);return fx==fy;&#125; struct Nod &#123; int d,p; friend bool operator &lt; (Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; &#125;a[MAX_N]; int yz[MAX_N]; bool v[MAX_N]; char s[10]; int solve() &#123; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=q;i++) &#123; int l,r;scanf("%d%d%s",&amp;l,&amp;r,s+1); if(l&gt;r or r&gt;n) return i-1; v[i]=(s[1]=='o'); a[2*i-1]=(Nod)&#123;l-1,2*i-1&#125;;//debug 不能离散化l a[2*i]=(Nod)&#123;r,2*i&#125;; &#125; sort(a+1,a+2*q+1); int rx=1;yz[a[1].p]=rx; for(int i=2;i&lt;=2*q;i++) rx+=(a[i-1].d!=a[i].d),yz[a[i].p]=rx; for(int i=1;i&lt;=2*rx;i++) fa[i]=i; for(int i=1;i&lt;=q;i++) &#123; int l1=yz[2*i-1],r=yz[2*i]; if(v[i]) merg(l1,rx+r),merg(rx+l1,r); else merg(l1,r),merg(rx+l1,rx+r); if(one(l1,rx+l1) or one(r,rx+r)) return i-1; &#125; return q; &#125; void main() &#123; printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125; 4 POJ2182 Lost Cows9.18 难度1请先思考后再展开 如果前面有k个比我大的，那么显然我就是当前可选里面第k+1名从后往前，那么我们需要一个数据结构维护当前第k大，支持删除splay和树状数组都可以，就看值域了，显然这道题选择树状数组适合 5 4302 Interval GCD9.18 难度2请先思考后再展开 太巧妙了原串的GCD和差分的GCD相同 6 Violet 蒲公英9.19 难度2请先思考后再展开 区间众数！而且因为强制在线，把莫队卡掉了 显然数字先离散化设每个块的长度为T设询问和N相同量级 方法一：暴力处理每次询问，时间复杂度$O(n^2)$ 方法二：以块编号为端点，得出 $(n/T)^2$ 个区间，每个区间存储当前众数具体计算可以确定左端点，然后向右暴力 再以块编号为端点，前缀和存储每个颜色出现个数（可以在刚才的步骤中顺便算好）对于每次询问，A为整区间[L,R]的众数，在前缀和数组的基础上，遍历两边的零散区域，B=A，动态更新维护B，得出答案后再还原时间复杂度$O(n^2/T+nT)$取$T=n……{1/2}$，得出最小值$O(n^{3/2})$，本题=11000000（可以强行把两边相等，一般都是最小……我也不知道为什么） 方法三：以块编号为端点，得出 $(n/T)^2$ 个区间，每个区间存储当前众数具体计算可以确定左端点，然后向右暴力 然后我们还需要维护一个vector，以数值为索引，保存该数字所有出现位置对于每次询问，A为整区间[L,R]的众数，再遍历两边的零散区域，B=A，对于每个数字，在vector中二分得出l到r出现次数，维护B时间复杂度$O((n/T)n+nTlogn)=O(n^2/T+Tnlogn)$（同样可以强行相等），取$T=\sqrt \frac{n}{logn}$时间复杂度$O(n \sqrt {nlogn})$，本题=45000000 7 CH#46 磁力块9.19 难度1请先思考后再展开 一开始没思路，看了看第一句话居然就有想法了因为有两个条件，不妨用其中一个排序，然后在当前的序列中分块，大小为T然后在每个块，相互之间完全独立，然后内部保持另一个条件的有序性 然后我们用类似bfs的思想去维护（这就是我看的那句话，好菜……）那么每次询问，可以二分一个k，保证k前面都是小于，k后面都是大于那么k前面的部分，枚举每个块，然后从左往右扫描，直到不满足条件，此时把满足的删除，放入队列中对于第k个块，暴力处理，维护好l到r的连续性，整体不连续没有关系，因为已经相对独立 分析一下复杂度，当时考虑的时候我是考虑尺取法的思想，就是指针的单调性（整体不单调，局部单调）对于这道题，出去了就不会进来，每个被指针扫描过的点，都不会再次经过所以复杂度是$O(nT+n^2/T)$，T取根号为最优12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=310000; typedef long long ll; ll mysqr(ll x) &#123;return x*x;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; ll dis,bj; int m,cl; &#125;p[MAX_N],tmp[MAX_N]; //p以块的形式，相对独立在 int left[MAX_N],right[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.dis&lt;b.dis;&#125; ll ds[MAX_N];//仅用来找，哪些块一定满足 bool cmp2(Nod a,Nod b) &#123;return a.m&lt;b.m;&#125; int n; queue&lt;Nod&gt; q; int solve() &#123; int T=sqrt(n); sort(p+1,p+n+1,cmp); for(int i=1;i&lt;=n;i++) ds[i]=p[i].dis; for(int i=1;i&lt;=(n-1)/T+1;i++) &#123; left[i]=(i-1)*T+1;right[i]=mymin(n,i*T); int fl=left[i],fr=right[i]; sort(p+fl,p+fr+1,cmp2); &#125; q.push(p[0]);int tot=0; while(!q.empty()) &#123; Nod now=q.front();q.pop(); int rr=upper_bound(ds+1,ds+n+1,now.bj)-ds-1;//&lt;=半径 int ed=(rr-1)/T+1; for(int i=1;i&lt;=ed-1;i++)//完整块 &#123; int r=left[i]-1;while(p[r+1].m&lt;=now.cl and r+1&lt;=right[i]) r++,q.push(p[r]),tot++; left[i]=r+1; &#125; int tt=0; for(int i=left[ed];i&lt;=right[ed];i++) if(p[i].dis&lt;=now.bj and p[i].m&lt;=now.cl) q.push(p[i]),tot++; else tmp[++tt]=p[i]; right[ed]=left[ed]+tt-1; for(int i=left[ed];i&lt;=right[ed];i++) p[i]=tmp[i-left[ed]+1]; &#125; return tot; &#125; void main() &#123; int x0,y0;scanf("%d%d%d%lld%d",&amp;x0,&amp;y0,&amp;p[0].cl,&amp;p[0].bj,&amp;n); p[0].dis=0;p[0].bj=mysqr(p[0].bj); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d%d%d%lld",&amp;x,&amp;y,&amp;p[i].m,&amp;p[i].cl,&amp;p[i].bj); p[i].bj=mysqr(p[i].bj);//规避double p[i].dis=mysqr(x-x0)+mysqr(y-y0); &#125; printf("%d",solve()); &#125;&#125;;int main()&#123; mine::main();&#125; 0x49 数据结构练习部分题目 8 IOI1998 Picture9.19 难度2请先思考后再展开 问题转化为，通过一个数据结构，只有区间+1和-1两种操作，然后保证运算过程中始终不是负数求整个区间的0的数量（通过变化量得出周长） 然后这东西昨天中午想过，想出来了，然后听说是练习的题目，所以就想着到时再说结果今天忘记昨天曾经想过了……而且还不会做其实只要维护区间最小值以及其次数即可，关键是【始终没有负数】的性质123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=5100; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; struct Seg &#123; int mi,num; int lz; &#125;p[21000*5]; #define lc (2*x) #define rc (2*x+1) void update(int x) &#123; p[lc].mi+=p[x].lz;p[lc].lz+=p[x].lz; p[rc].mi+=p[x].lz;p[rc].lz+=p[x].lz; p[x].lz=0; &#125; void pre(int x,int l,int r) &#123; p[x].mi=p[x].lz=0; if(l==r) p[x].num=1; else &#123; int mid=(l+r)&gt;&gt;1; pre(lc,l,mid);pre(rc,mid+1,r); p[x].num=p[lc].num+p[rc].num; &#125; &#125; void change(int x,int l,int r,int fl,int fr,int cc) &#123; if(l==fl and r==fr) &#123; p[x].mi+=cc; p[x].lz+=cc; return; &#125; update(x); int mid=(l+r)&gt;&gt;1; if(fr&lt;=mid) change(lc,l,mid,fl,fr,cc); else if(fl&gt;mid) change(rc,mid+1,r,fl,fr,cc); else change(lc,l,mid,fl,mid,cc),change(rc,mid+1,r,mid+1,fr,cc); p[x].mi=mymin(p[lc].mi,p[rc].mi); if(p[lc].mi==p[rc].mi) p[x].num=p[lc].num+p[rc].num; else if(p[lc].mi&lt;p[rc].mi) p[x].num=p[lc].num; else p[x].num=p[rc].num; &#125; int getid(int x) &#123;return 10000+x;&#125;//化点为区间后，最小为-9999 int getzero() &#123;return (p[1].mi==0)?p[1].num:0;&#125; struct Nod&#123;int x,y0,y1,cc;&#125;s[MAX_N*2]; bool cmp(Nod a,Nod b) &#123;return a.x&lt;b.x or (a.x==b.x and a.cc&gt;b.cc);&#125; //先增后减，防止不同矩形的重边 int n,pos[MAX_N][2][2]; int solve(int op) &#123; for(int i=1;i&lt;=n;i++) &#123; s[2*i-1]=(Nod)&#123;pos[i][op][0],pos[i][op^1][0],pos[i][op^1][1],1&#125;; s[2*i]=(Nod)&#123;pos[i][op][1],pos[i][op^1][0],pos[i][op^1][1],-1&#125;; &#125; sort(s+1,s+2*n+1,cmp); pre(1,getid(-9999),getid(10000)); int ans=0,lst=getzero(); for(int i=1;i&lt;=2*n;i++) &#123; //忘记化点为区间了 change(1,getid(-9999),getid(10000),getid(s[i].y0+1),getid(s[i].y1),s[i].cc); int t=getzero();ans+=myabs(lst-t);lst=t; &#125; return ans; &#125; void main() &#123; while(scanf("%d",&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) scanf("%d%d%d%d",&amp;pos[i][0][0],&amp;pos[i][1][0],&amp;pos[i][0][1],&amp;pos[i][1][1]); printf("%d\n",solve(0)+solve(1)); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#509 比赛总结]]></title>
    <url>%2Fposts%2Fbeed.html</url>
    <content type="text"><![CDATA[CF#509 比赛总结题目即1041F，1041E，1041D，1041C，1041B，1041A 比赛经历t1原本超快做完，然后submit没按到+交错语言，ggt2一开始忘记gcd了，还好良心样例t3感觉可以贪心，对set不太熟悉，因为要找upper-1的位置，然后感觉写不了就感觉只能splay（虽然我知道一定不是正解，毕竟是cf）先去看t4，发现可以尺取法，写完发现tkj也是先t4，感觉可能t3码农，不过同学都切完是什么鬼耐下性子，老老实实写splay，感觉思路特清晰，写的很快（毕竟至少5个月没写过了……）过了以后只剩10min了，发现自己是最慢的（大众四题，毫无竞争力）……手速弱鸡表示怀念oi赛制然后就是真的要认真了解一下stl+结构题的各种语法了 T1_Analysis请先思考后再展开 没什么好说的mx-mi+1-n T1_Code_old请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; ll MOD; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; void main() &#123; int n;scanf("%d",&amp;n); int mi=0x3f3f3f3f,mx=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t&lt;mi) mi=t; if(t&gt;mx) mx=t; &#125; printf("%d",mx-mi+1-n); &#125;&#125;;int main()&#123; mine::main();&#125; T2_Analysis请先思考后再展开 gcd+向下取整 T2_Code_old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; ll MOD; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll gcd(ll a,ll b) &#123;return b==0?a:gcd(b,a%b);&#125; void main() &#123; ll a,b,x,y;scanf("%I64d%I64d%I64d%I64d",&amp;a,&amp;b,&amp;x,&amp;y); ll d=gcd(x,y);x/=d;y/=d; ll t=floor((double)a/x); ll t2=floor((double)b/y); printf("%I64d",t&lt;t2?t:t2); &#125;&#125;;int main()&#123; mine::main();&#125; T3_Analysis请先思考后再展开 我的做法是贪心地去找 $a&lt;a2-d$ 中最大的，时间复杂度nlognset的新内容已经在oi之路的stl处更新然后看rk1发现可以 $O(n)$ 贪心得更加彻底：同样是排序后，维护k为“当天合法最远距离”，可以用尺取法实现，那么中间的一定是其他天数的然后就1 2 3 4 …… k 1 2 3 …… k 这样分配，不难发现这样一定是合法的，最小性同样可以证明，因为如果用更大的，例如r+1和l在同一天，那么答案不会变小 T3_Code_old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; struct Nod &#123; int son[2],f; int d,pos; Nod() &#123;son[0]=son[1]=f=d=pos=0;&#125; &#125;p[MAX_N*2]; void rotate(int x,int w) &#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].f=f; p[x].son[w]=f; p[f].f=x; &#125; int root; void splay(int x,int rt) &#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x; &#125; int findip(int d) &#123; int x=root; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; //printf("x=%d lc=%d rc=%d\n",x,lc,rc); if(d&lt;p[x].d) &#123; if(!lc) break; x=lc; &#125; else &#123; if(!rc) break; x=rc; &#125; &#125; return x; &#125; int id=0; void insert(int d,int pos) &#123; //printf("d=%d\n",d); if(root==0) &#123; root=++id; p[id].d=d; p[id].pos=pos; return; &#125; int t=findip(d); //printf("d=%d t=%d\n",d,t); p[++id].f=t;if(d&lt;p[t].d) p[t].son[0]=id; else p[t].son[1]=id; p[id].d=d;p[id].pos=pos; splay(id,0); &#125; void del(int d) &#123; int x=findip(d); if(p[x].d!=d) return; splay(x,0); int lc=p[x].son[0],rc=p[x].son[1]; if(lc==0 and rc==0) &#123; root=0; &#125; else if(lc&gt;0 and rc==0) &#123; root=lc;p[lc].f=0; &#125; else if(lc==0) &#123; root=rc;p[rc].f=0; &#125; else &#123; int t=lc; while(p[t].son[1]&gt;0) t=p[t].son[1]; splay(t,x); root=t;p[t].f=0; p[t].son[1]=rc;p[rc].f=t; &#125; &#125; int findQ(int d) &#123; int x=findip(d);splay(x,0); if(p[x].d&gt;=d and p[x].son[0]&gt;0) &#123; x=p[x].son[0]; while(p[x].son[1]&gt;0) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return x; return -1; &#125; struct dat &#123; int d,p; &#125;a[210000]; bool cmp(dat a,dat b) &#123;return a.d&lt;b.d;&#125; int ans[210000]; void main() &#123; root=0; int n,m,d;scanf("%d%d%d",&amp;n,&amp;m,&amp;d); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].d),a[i].p=i; sort(a+1,a+n+1,cmp); ans[a[1].p]=1; insert(a[1].d,a[1].p); int id=1; for(int i=2;i&lt;=n;i++) &#123; int t2=findQ(a[i].d-d);//&lt;a[i].d-d if(t2&lt;0) &#123; ans[a[i].p]=++id; insert(a[i].d,a[i].p); &#125; else &#123; ans[a[i].p]=ans[p[t2].pos]; del(p[t2].d); insert(a[i].d,a[i].p); &#125; &#125; printf("%d\n",id); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; T3_Code_用set请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; struct Nod &#123; int d,p; friend bool operator &lt; (Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; &#125;a[210000]; set&lt;Nod&gt; q; Nod findQ(int d)//&lt;d &#123; set&lt;Nod&gt;::iterator it=q.lower_bound( (Nod)&#123;d,0&#125; ); if(it==q.begin()) return (Nod)&#123;-1,0&#125;;//debug Nod t=*(--it); if(t.d&lt;d) return t; return (Nod)&#123;-1,0&#125;; &#125; int ans[210000]; void main() &#123; int n,m,d;scanf("%d%d%d",&amp;n,&amp;m,&amp;d); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].d),a[i].p=i; sort(a+1,a+n+1); ans[a[1].p]=1; q.insert( (Nod)&#123;a[1].d,a[1].p&#125; ); int id=1; for(int i=2;i&lt;=n;i++) &#123; Nod t=findQ(a[i].d-d);//&lt;a[i].d-d if(t.d&lt;0) &#123; ans[a[i].p]=++id; &#125; else &#123; ans[a[i].p]=ans[t.p]; q.erase(t); &#125; q.insert( (Nod)&#123;a[i].d,a[i].p&#125; ); &#125; printf("%d\n",id); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; T3_Code_完美贪心请先思考后再展开 自行看众ak爷代码…… T4_Analysis请先思考后再展开 尺取法一下即可 T4_Code_old请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=510000; typedef long long ll; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hei[MAX_N],dis[MAX_N]; void main() &#123; int n,h;scanf("%d%d",&amp;n,&amp;h); int lstr=-1e9; for(int i=1;i&lt;=n;i++) &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); hei[2*i-1]=l-lstr;dis[2*i-1]=l-lstr; hei[2*i]=0;dis[2*i]=r-l; lstr=r; &#125; hei[2*n+1]=INF;dis[2*n+1]=INF; int r=0,sum=0,dd=0; int ans=0; for(int l=0;l&lt;=2*n;l++) &#123; while(sum&lt;h) &#123; sum+=hei[r+1]; dd+=dis[r+1]; if(sum&gt;h) &#123;sum-=hei[r+1],dd-=dis[r+1];break;&#125; r++; &#125; //printf("l=%d r=%d sum=%d dd=%d\n",l,r,sum,dd); ans=mymax(ans,dd+h-sum); dd-=dis[l+1]; sum-=hei[l+1]; &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷18年7月月赛比赛总结]]></title>
    <url>%2Fposts%2Fb37c.html</url>
    <content type="text"><![CDATA[洛谷18年9月月赛比赛总结题目 比赛经历哇这次是oi赛制耶感觉心理压力会小很多…… 第一题一开始很自信，觉得可以暴力，因为位数可能不会太大……当时电脑上没有g++，于是就应验了师兄们对在线ide的推测，没来得及装的时候比赛就开始了……主要是没检查到（原电脑在竞赛室不想拿回来）随便出组数据就tle了但仔细看看题目，就是没有说无解的情况，我也不会证明有解后来认真想想，推推式子，发现原来是bsgs，时间复杂度nlogn然后如果无解，我会输出-1打了个对拍，暴力会出负数，也就是无解情况为了方便对拍，统一输出-1拍了30min的rand数据，范围不会太大（感觉rand的最大值是刚好的），避免暴力太慢，感觉应该没问题了……（30min伏笔） 然后是t2，感觉是约束一下，但没有太明确的思路，先跳t3是一棵树，除以2以后，化一下式子，发现就是 $min \sum C-&gt;A_i$然后感觉可以参考一下“中位数的应用”，就是考虑移动的贡献那么不难发现，从根向下移动，相当于非该子树的A要多走w，子树内则少走w这样就是每条边走过去的贡献那么我们不妨先把初始的C设在根节点，然后往下重新计算dis，如果最小的dis小于0，那么移动到那里会更优仔细检查一下变量类型，感觉没问题，然后思考一下也应该是正解，时间复杂度n 此时只剩一个半小时，稍微有点慢了看看t4，标题写着分块是什么鬼感觉能拿30分后来忽然发现，统计1的数量需要乘以15，凉凉 看t2，发现只需要转移成第二行的情况，然后维护一下确定的区间具体而言，就是把每个约束条件转化为a~b的形式，而且满足 $2 \leq num \leq 2m$如果宽度小于m多解，大于m无解，否则定位一下就好了一直coding到最后3min，虚的一匹还好最后成功写完，交了上去到比赛首页，居然发现比赛延迟30min！赶快回去细细检查，发现细节稍微有点多，挖掘了一下样例后真发现几个bug，应该问题也不大了 检查一波，然后看t4，发现我制杖了，预处理一下1的数量就好了，值域很小那么又骗了30分目前最高分330时间刚好结束 好像比赛首页因为太多人刷新炸了？出去陪弟弟玩了波大富翁，好颓废啊回来发现145是什么鬼？怎么可能还有rk23，这么sb的分数……woc，80+60+0+5太困了先睡了…… T1_Analysis请先思考后再展开 因为 $n \leq MOD$所以答案是超过int的，没发现这点交上去还是80再仔细想想，因为刚刚发现的这一点，两个MOD相乘会爆ll，所以要快速乘tle!因为现在复杂度变成了log方，真是连锁反应……主要是因为我之前的写法一直都是 $A^b=ed \times inv(A^{at})$ ，n=at+b那么改改就好了，避免以后吃亏$A^b=A^{at} \times inv(ed)$ , n=at-b 所以说，还是考虑不够周全，造成连锁反应感觉这种事情很危险啊，特别是noip之前不久前还跟别人说自己很少fail题，因为大部分题都不会做……立刻就来教训了 T1_Code_std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; ll MOD; ll qmul(ll x,ll e) &#123; ll ans=0; while(e&gt;0) &#123; if(e&amp;1) ans=(ans+x)%MOD; x=(x+x)%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=qmul(ans,x); x=qmul(x,x);e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125;//MOD is prime ll ed; map&lt;ll,int&gt; mp; ll bsgs() &#123; int t=ceil(sqrt((double)MOD)); ll now=1; for(int i=0;i&lt;=t;i++) &#123; mp[now]=i; now=now*10%MOD; &#125; ed=inv(ed); ll dec=qpower(10,t); now=1; for(int a=1;a&lt;=t;a++) &#123; now=qmul(now,dec); ll wt=qmul(now,ed); if(mp.count(wt)) return (ll)a*t-mp[wt]; &#125; return -1; &#125; void main() &#123; scanf("%lld%lld",&amp;ed,&amp;MOD); if(ed==0) &#123;puts("0");return;&#125; ed=ed*9+1;ed%=MOD; printf("%lld",bsgs()); &#125;&#125;;int main()&#123; mine::main();&#125; T2_Analysis请先思考后再展开 发现这种做法是错误的因为我不能确定它实际在第二行还是第三行……所以换个思路，考虑直接约束1的位置然而我完全不会怎么解带模的不等式：$(A+k-2) \% m \leq m+A-B-1$总之，如果能解出来，可能是同时多个区间，需要找到被覆盖s次的区间这个的话，可以补集转化一下，维护其补集的交，这样无论解有多少个区间都能解决，非常巧妙 T3_Analysis请先思考后再展开 哇哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈……woc看错题了使得他送货所需的最长距离最小而不是使得他送货所需的距离总长最小我就说怎么会爆零大概是第一次彻头彻尾看错题？可能真的没细看那时候如果要找个理由的话，哪有人会关心最长那个啊还有就是样例恰好只有一个商品…… 不过然后就不会做了……好像二分也没有什么卵用 膜出题人嗯决策和刚才一样，都是具有单调性的，而且最优方向一定是由局部最优组成的然后我自己也能猜到一个性质：题目中的距离，一定是 $2 \times c到ab路径的距离+ab路径长度$那么关键是最小化左边的部分考虑从任意一个点开始，用刚才的思路，考虑跳过去的贡献每一次，暴力计算出所有总答案最大的点对考虑每条边，如果有任何点对跨越该边（可以用dfs序和siz判断），意味着当前是最优位置如果那边有点对，另一边也有点对，跳过去没有意义，当前也是最优位置否则，单纯地往那边跳即可 当前的时间复杂度是 $O(深度 \times n)$套一个点分治即可（因为这是枚举类的解法，但距离等要在原本结构上求） T4_Analysis请先思考后再展开 原来是空间挂了……正解是神仙的莫队改版以后做……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4882】lty loves 96]]></title>
    <url>%2Fposts%2F9a30.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4882 Record2h Analysis请先思考后再展开 非常有趣的一次经历（把本题当做是本比赛回忆吧……）如果能ac，就能和rose、xgc平分3块……当时的第一感觉是，从来没做过这么复杂的数位dp预处理非常麻烦，反正不会写然后这时候红太阳xgc出现了，他说不需要预处理，要相信记忆化的力量……其实也没错，数位dp的特性就在于，和具体数字的关系不会太大，一般都是部分 所以就听他的，瞎jb设了个状态开码中途到了5:40，必须要走了，当时xgc有50分在车上，仔细反思，觉得我的思路没有问题，可能超时或者爆long long但应该不会这么少分发现可能是转移的01写错了，匆忙回到家发现没写错……（学校的时候根本没细想） 补充说明一下，比赛7点结束 吃饭的时候一声不吭，觉得应该是边界的地方，忘记判断69数量了匆忙改，成功过了样例……交上去却只有20（他曾经也是，不知道怎么改的，好像思路不太一样） 测一测时间，恩很快但是极限数据出现负数！！（之前学校的错误代码，出来个4000以为没事）当时还剩30min，很赖皮地从以前的高精度模板那里copy下来恩样例还是能过的，但极限数据非常慢不管了交一发吧mle！没时间计算空间了优化一下发现还是不行，那应该意思就是写压位了ps 后来发现，原来是gb出题人把空间改到了64mb…… 当时还剩5min学校的时候和xgc就py过，他的50分代码已经发给了我，作为压箱手段（因为我乐多赛罚分最少）匆忙改了改格式，怕被识别作弊看rk，13是什么鬼？最后这么多人上去了（前10有3块，学校rk9） 当时真的好绝望，本来以为稳了，只是不太想用忽然想起来应该发邮箱给rose，发现有新邮件！标题为“kuai”，来自xgc！发现他打了压位高精度，然后才发现自己又傻了没有提醒他……交上去，ac看着那个rk8忽然觉得人生好神奇hh 方法一先给出一份long long的清纯版谁会想到现在还有这么毒瘤的出题人（所以说以后还是不想做洛谷的非月赛了）因为本来也以“条件很强，不会太多的”来安抚自己 好了说正事，数位dp现在觉得一点也不难大概也就是位数乘以10的复杂度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long fuk; fuk zero,one; fuk jia(fuk a,fuk b) &#123; fuk c; c=a+b; return c; &#125; void output(fuk a) &#123; printf("%lld",a); &#125; fuk f[55][55][2][10][10]; bool v[55][55][2][10][10]; bool is(int x) &#123;return x==6 or x==9;&#125; fuk dp(int n,int ct,int ok,int b,int c) &#123; if(ct&lt;0) return zero; if(n==2 and ok) return zero; if(n==1) &#123; if(ct==is(c) and b==0 and ok==0 and c!=0) return one; else return zero; &#125; if(v[n][ct][ok][b][c]) return f[n][ct][ok][b][c]; v[n][ct][ok][b][c]=1; fuk ans=zero; for(int a=0;a&lt;=9;a++) &#123; if(ok) &#123; int fc=(a*a+b*b); if(c==0) fc=-1; else fc%=c; if(is(a+b+c) or is(fc)) ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); else ans=jia(ans,dp( n-1,ct-is(c),1,a,b )); &#125; else ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); &#125; return f[n][ct][ok][b][c]=ans; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); //n=50;m=1; zero=0; one=1; fuk ans=zero; for(int ct=m;ct&lt;=n;ct++) for(int b=0;b&lt;=9;b++) for(int c=0;c&lt;=9;c++) ans=jia(ans,dp(n,ct,1,b,c)); output(ans); &#125;&#125;;int main()&#123; mine::main();&#125; 方法二压位高精度，第一是能解决空间问题但还有个也非常重要的，就是速度快很多空间的计算：$\frac{64 \times 1024^2 /4}{50^2 \times 2 \times 10^2}=30$所以结构体最多30位考虑一下速度，决定压5位 其实压位也不难写，改动一点点而已，但当时时间真的太紧了，又有责任在身，再加上没写过，所以就放弃了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; struct fuk &#123; int num[15],ln; fuk() &#123;memset(num,0,sizeof num);&#125; &#125;; fuk zero,one; fuk jia(fuk a,fuk b) &#123; fuk c;c.ln=mymax(a.ln,b.ln); for(int i=1;i&lt;=c.ln;i++) &#123; c.num[i]+=a.num[i]+b.num[i]; if(c.num[i]&gt;99999) &#123; c.num[i+1]++; c.num[i]-=100000; if(i==c.ln) c.ln++; &#125; &#125; while(c.num[c.ln]==0 and c.ln&gt;1) c.ln--; return c; &#125; void output(fuk a) &#123; for(int i=a.ln;i&gt;=1;i--) &#123; if(i!=a.ln and a.num[i]&lt;10) printf("0000%d",a.num[i]); else if(i!=a.ln and a.num[i]&lt;100) printf("000%d",a.num[i]); else if(i!=a.ln and a.num[i]&lt;1000) printf("00%d",a.num[i]); else if(i!=a.ln and a.num[i]&lt;10000) printf("0%d",a.num[i]); else printf("%d",a.num[i]); &#125; &#125; fuk f[55][55][2][10][10]; bool v[55][55][2][10][10]; bool is(int x) &#123;return x==6 or x==9;&#125; fuk dp(int n,int ct,int ok,int b,int c) &#123; if(ct&lt;0) return zero; if(n==2 and ok) return zero; if(n==1) &#123; if(ct==is(c) and b==0 and ok==0 and c!=0) return one; else return zero; &#125; if(v[n][ct][ok][b][c]) return f[n][ct][ok][b][c]; v[n][ct][ok][b][c]=1; fuk ans=zero; for(int a=0;a&lt;=9;a++) &#123; if(ok) &#123; int fc=(a*a+b*b); if(c==0) fc=-1; else fc%=c; if(is(a+b+c) or is(fc)) ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); else ans=jia(ans,dp( n-1,ct-is(c),1,a,b )); &#125; else ans=jia(ans,dp( n-1,ct-is(c),0,a,b )); &#125; return f[n][ct][ok][b][c]=ans; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); zero.ln=1;zero.num[1]=0; one.ln=1;one.num[1]=1; fuk ans=zero; for(int ct=m;ct&lt;=n;ct++) for(int b=0;b&lt;=9;b++) for(int c=0;c&lt;=9;c++) ans=jia(ans,dp(n,ct,1,b,c)); output(ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu4881】hby与tkw的基情]]></title>
    <url>%2Fposts%2F3729.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu4881 Record30min Analysis请先思考后再展开 非常好推式子$\sum_{i=0}^{ \lfloor \frac{n-1}{2} \rfloor } (2i+1)26^{i+1}$ 方法一n非常大显然要用快速幂和矩阵乘法那么矩阵的设计可以参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll MOD=1e9+7; struct mm &#123; ll a[4][4]; mm() &#123;memset(a,0,sizeof a);&#125; &#125;; mm pre() &#123; mm t; for(int i=1;i&lt;=3;i++) t.a[i][i]=1; return t; &#125; mm cheng(mm a,mm b) &#123; mm c; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) for(int k=1;k&lt;=3;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j]%MOD; return c; &#125; mm qpower(mm x,int e) &#123; mm c=pre(); while(e&gt;0) &#123; if(e&amp;1) c=cheng(c,x); x=cheng(x,x);e&gt;&gt;=1; &#125; return c; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); n=(n-1)/2; mm op;op.a[1][1]=op.a[2][1]=op.a[2][2]=26;op.a[3][1]=1;op.a[3][2]=2;op.a[3][3]=1; op=qpower(op,n+1); mm st;st.a[1][1]=26; st=cheng(op,st); printf("%lld\n",st.a[3][1]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 方法二然鹅上面的方法很慢，因为矩阵乘法的常数达到了30其实有高中数学常识的很容易看出是一个差比数列（看题解后学的……）不了解的可以去定理杂烩一章]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
        <tag>差比数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TJOI2013】循环格]]></title>
    <url>%2Fposts%2Fccfc.html</url>
    <content type="text"><![CDATA[Source and JudgeTJOI2013bzoj3171luogu3965 Record1h Analysis请先思考后再展开 首先，显然需要一些决策但好像不是很好贪心于是自然鹅言想到了网络流（或者费用流） 然后就不会了，主要是不太熟悉其实很容易发现题目要求的就是，每个点都要在至少一个环中 可以把题目再转化一下：给每个节点一滴水如果每个点都能有水过来，并且消耗掉，那么显然能满足题目的条件 按照这样建图以后，为了追求最小权值，跑费用流，把额外的边设费用1所谓费用流，前提是最大流，所以一定会把每个点都满足 不过有个小问题，就是可能自己立刻就出去了所以要拆一下点，分为入x和出y123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAX_N=50; struct Nod &#123; int hou; int fm; bool v; Nod() &#123;hou=0;v=0;&#125; &#125;p[MAX_N*MAX_N*2]; struct Edge &#123; int y,g; int c,w; &#125;e[MAX_N*MAX_N*2*10]; int oth(int x) &#123;return (x&amp;1)?(x+1):(x-1);&#125; int ln=0; void ins(int x,int y,int c,int w) &#123; e[++ln]=(Edge)&#123;y,p[x].hou,c,w&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,0,-w&#125;;p[y].hou=ln; &#125; int ans=0; int st,ed; queue&lt;int&gt; q; int dis[MAX_N*MAX_N*2]; int flow[MAX_N*MAX_N*2];//最短路径到此流量 bool solve() &#123; memset(dis,63,sizeof dis); memset(flow,63,sizeof flow); dis[st]=0;p[st].v=1;q.push(st); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&gt;dis[x]+e[k].w and e[k].c&gt;0) &#123; dis[y]=dis[x]+e[k].w; p[y].fm=k; flow[y]=mymin(flow[x],e[k].c); //debug 不能用全局变量flow，因为路径的选择会改变 if(!p[y].v) p[y].v=1,q.push(y); &#125; &#125; p[x].v=0; &#125; if(dis[ed]==INF) return 0; ans+=flow[ed]*dis[ed]; for(int x=ed;x!=st;) &#123; int rd=p[x].fm; e[rd].c-=flow[ed];e[oth(rd)].c+=flow[ed]; x=e[oth(rd)].y; &#125; return 1; &#125; int r,c; int calc(int x,int y,int t) &#123; if(x==0) x=r; if(x==r+1) x=1; if(y==0) y=c; if(y==c+1) y=1; return (x-1)*c+y+(t?(r*c):0); &#125; //0右 1左 2上 3下 const int tx[4]=&#123;0,0,-1,1&#125;; const int ty[4]=&#123;1,-1,0,0&#125;; char mp[MAX_N][MAX_N]; void main() &#123; scanf("%d%d",&amp;r,&amp;c); for(int i=1;i&lt;=r;i++) scanf("%s",mp[i]+1); st=0;ed=2*r*c+1; for(int i=1;i&lt;=r;i++) for(int j=1;j&lt;=c;j++) &#123; ins(st,calc(i,j,1),1,0);//st=&gt;y ins(calc(i,j,0),ed,1,0);//x=&gt;ed int now; if(mp[i][j]=='R') now=0; if(mp[i][j]=='L') now=1; if(mp[i][j]=='U') now=2; if(mp[i][j]=='D') now=3; for(int t=0;t&lt;=3;t++) ins(calc(i,j,1),calc(i+tx[t],j+ty[t],0),1,now!=t); &#125; while(solve()) ; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【国家集训队】跳跳棋]]></title>
    <url>%2Fposts%2F4147.html</url>
    <content type="text"><![CDATA[Source and Judgebzoj2144luogu1852 Record2h Analysis请先思考后再展开 很好的题目不妨设a&lt;b&lt;c 考虑我能怎么跳因为题目要求，每次只能跳过一个棋子发现在任意时刻，只有三种移动方法$dis1=b-a,dis2=c-b$ $a-dis1,a,c$ $a,c,c+dis2$ $b,b+dis1,c$ 或者 $a,b-dis2,b$ （如果都不行，则没有）度大部分都是3，你想到了什么？一棵二叉树！把第一种和第二种，看作是孩子，第三种看作是父亲不过，树的深度无限，因为你总是能不停向外跳的 那么我们来证明一下这为什么是一棵二叉树（网上的漏点） 对于没有父亲的节点，本身就是根节点，所以严格来说这是一个二叉树森林 我们必须要证明x的祖先不可能会出现在x的子树中如果我们定义一个值：最接近两点间的距离不难发现，向上时必定变小，向下时必定变大（不能够重叠棋子） 操作可逆，所以是无向图 那么，现在要求的就是两个节点间的lca此时已经有40分了，如何避免暴力存图呢？ 考虑每次向上跳（再也不用考虑向下了，我向下就是等它上来）如果方向是相同的（缩左边或者缩右边），那么间距不变，可以直接通过一个除法来计算出来，然后距离取模那么复杂度基本上就是log（参考gcd的复杂度）如果要限制长度，可以判断一下，确保不超过（当覆盖时） 那么找lca的时候，先到相同高度，然后二分向上距离即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int a,b,c; Nod(int x=0,int y=0,int z=0) &#123;a=x,b=y,c=z;&#125; &#125;; int dep; Nod jump(Nod now,int mx)//限制步数 &#123; int a=now.a,b=now.b,c=now.c; dep=0; while(1) &#123; int stp=0; int dis1=b-a,dis2=c-b; if(dis1&lt;dis2) &#123; stp=mymin(mx-dep,(dis2-1)/dis1); a+=stp*dis1,b+=stp*dis1; &#125; else if(dis2&lt;dis1) &#123; stp=mymin(mx-dep,(dis1-1)/dis2); b-=stp*dis2,c-=stp*dis2; &#125; dep+=stp; if(stp==0) return Nod(a,b,c); &#125; &#125; bool check(Nod x,Nod y,int mx) &#123; x=jump(x,mx);y=jump(y,mx); return x.a==y.a and x.b==y.b and x.c==y.c; &#125; Nod ss(Nod now) &#123; if(now.a&gt;now.b) swap(now.a,now.b); if(now.a&gt;now.c) swap(now.a,now.c); if(now.b&gt;now.c) swap(now.b,now.c); return now; &#125; void main() &#123; Nod x,y;scanf("%d%d%d%d%d%d",&amp;x.a,&amp;x.b,&amp;x.c,&amp;y.a,&amp;y.b,&amp;y.c); x=ss(x);y=ss(y);//debug 漏了 jump(x,2*INF);int xdep=dep; jump(y,2*INF);int ydep=dep; if(xdep&lt;ydep) swap(xdep,ydep),swap(x,y); x=jump(x,xdep-ydep); int l=0,r=ydep,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(x,y,mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) puts("NO"); else printf("YES\n%d",2*ans+xdep-ydep); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-6图论 32题]]></title>
    <url>%2Fposts%2F6259.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x60 图论部分题目 1 POJ3662 Telephone Lines8.29 难度2请先思考后再展开 找出一条从1到n的路径，上面第k+1大的那条边，权值最小好弱啊第一题就不会做，天天看题解…… 最小化除了前面k个以外的最大值，二分答案把所有长度在mid以内的边看做0，否则1跑一次最短路，如果花费在k以内，意味着可行代码略 2 noip2009 最优贸易8.29 难度2请先思考后再展开 曾经做过 3 Usaco2011 Jan Gold 道路和航线8.29 难度2请先思考后再展开 这道题挺有意思的，本来以为是裸题想跳的，看到lyd说spfa会tle，就不想以身试法了（网上说加上slf就好了……不过本着锻炼思维的理念，学习一下正解）因为题目保证航线没有环，本来以为这仅仅是保证没有负环，没想到这还是一个突破口（还有就是道路都是双向的这个性质） 如果只加入双向边，那么就会形成多个连通块如果缩点后再加入单向航线，图会形成一个有向无环图，是可以通过拓扑得到最短路的不过具体而言，不能真的缩点，因为需要具体得出每个点的最短路大致上就是沿着负权边找到各个连通块，以拓扑为框架跳来跳去 具体的话有个细节：就是有可能st所在的连通块，入度不为0或者可能出了st连通块外，还有其他入度不为0的连通块所以还是要按照平常拓扑那样，把所有入度为0的加入栈不过为了防止，单源最短路被扰乱，应该先把st连通块的dis置0，这样无论如何也没法更新掉了然后其他连通块的inf也应该设置大一点，这样即使被更新，也是一个很大的值然后输出no path的时候，不能只是和inf比较，因为可能曾经被更新，要看它是否明显超过理论正常最大距离( $T \times 10000=250000000$ )，设为0x3f3f3f3f就够了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=31000,MAX_M=160000; const ll INF=(1ll&lt;&lt;60); int n; struct Nod &#123; int hou; ll dis; int uni; Nod() &#123; uni=hou=0; dis=INF; &#125; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_M]; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; int deg[MAX_N]; vector&lt;int&gt; vt[MAX_N]; void dfs(int x,int now) &#123; p[x].uni=now;vt[now].push_back(x); for(int k=p[x].hou;k&gt;0;k=e[k].g) if(p[e[k].y].uni==0) dfs(e[k].y,now); &#125; struct Que &#123; ll d; int x; friend bool operator &lt; (Que a,Que b) &#123;return a.d&gt;b.d;&#125; &#125;; int sta[MAX_N],top=0; priority_queue&lt;Que&gt; q; void solve(int st) &#123; for(int i=0;i&lt;vt[p[st].uni].size();i++) p[vt[p[st].uni][i]].dis=0;//确保不会被，st无法到达的块更新 for(int i=1;i&lt;=n;i++) if(vt[i].size()&gt;0 and deg[i]==0) sta[++top]=i; while(top&gt;0)//topsort &#123; int t=sta[top--]; for(int i=0;i&lt;vt[t].size();i++) &#123; int x=vt[t][i]; if(t==p[st].uni and x!=st) p[x].dis=INF;//debug 漏了 q.push((Que)&#123;p[x].dis,x&#125;); &#125; while(!q.empty())//dijkstra &#123; Que now=q.top();q.pop(); int x=now.x;if(now.d!=p[x].dis) continue;//delete for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; if(p[y].uni==p[x].uni) q.push((Que)&#123;p[y].dis,y&#125;); &#125; if(p[y].uni!=p[x].uni) &#123; deg[p[y].uni]--; if(deg[p[y].uni]==0) sta[++top]=p[y].uni; &#125; &#125; &#125; &#125; &#125; void main() &#123; int ma,mb,st;scanf("%d%d%d%d",&amp;n,&amp;ma,&amp;mb,&amp;st); while(ma--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; for(int i=1;i&lt;=n;i++) if(p[i].uni==0) dfs(i,i); while(mb--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);if(p[x].uni!=p[y].uni) deg[p[y].uni]++; &#125; solve(st); for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;0x3f3f3f3f) puts("NO PATH"); else printf("%lld\n",p[i].dis); &#125;&#125;;int main()&#123; mine::main();&#125; 4 POJ1734 Sightseeing trip8.29 难度2请先思考后再展开 floyd找最小环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; const int INF=0x3f3f3f3f; int ans[MAX_N],ln; int fm[MAX_N][MAX_N]; int dis[MAX_N][MAX_N],a[MAX_N][MAX_N]; void getans(int x,int y) &#123; if(fm[x][y]&lt;0) &#123;ans[++ln]=x;return;&#125; int k=fm[x][y]; getans(x,k);getans(k,y); &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); memset(a,63,sizeof a); memset(fm,0,sizeof fm); for(int i=1;i&lt;=n;i++) a[i][i]=0; while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(c&lt;a[x][y]) a[x][y]=a[y][x]=c,fm[x][y]=fm[y][x]=-1; &#125; memcpy(dis,a,sizeof a); int mi=INF; for(int k=1;k&lt;=n;k++) &#123; for(int i=1;i&lt;k;i++) for(int j=i+1;j&lt;k;j++) &#123; ll tmp=(ll)dis[i][j]+a[j][k]+a[k][i];//debug 爆int if(mi&gt;tmp) &#123; mi=tmp; ln=0;getans(i,j);ans[++ln]=j;ans[++ln]=k; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i!=j) if(dis[i][j]&gt;dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j],fm[i][j]=k; &#125; if(mi==INF) puts("No solution.");//神tm漏了一个点…… else for(int i=1;i&lt;=ln;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; 5 6201 走廊泼水节8.29 难度2请先思考后再展开 这道题设计得很好个人很喜欢这种，对看似简单、经典的算法，推陈出新地挖掘细节、原理的题目结果就不会做了…… 这道题从边的角度思考会简单一些想到边，以及最小生成树，会想到kruskal把所有边排序，然后关键就是“完全图中的边，是否跨树”对于这一点我只能出个数据把自己的乱搞做法卡掉，但不知道怎么去解决 其实这条边什么时候会跨树呢？盗lyd好图：是不是豁然开朗了？模拟kruskal的过程，连接两个树之间的边，只会在这一次跨树此时，他们的取值都应为z+1，个数则是 $Sx \times Sy-1$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=6100; const int INF=0x3f3f3f3f; struct Edge &#123; int x,y,c; &#125;e[MAX_N]; bool cmp(Edge a,Edge b) &#123;return a.c&lt;b.c;&#125; int fa[MAX_N],siz[MAX_N]; int findfa(int x) &#123;return fa[x]=(x==fa[x]?x:findfa(fa[x]));&#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) fa[i]=i,siz[i]=1; for(int i=1;i&lt;=n-1;i++) scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].c); sort(e+1,e+n-1+1,cmp); ll ans=0; for(int i=1;i&lt;=n-1;i++) &#123; int x=e[i].x,y=e[i].y; int fx=findfa(x),fy=findfa(y); ans+=ll(e[i].c+1)*( (ll)siz[fx]*siz[fy]-1 ); if(fx!=fy) fa[fx]=fy,siz[fy]+=siz[fx];//merg &#125; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 6 POJ1639 Picnic Planning8.30 难度2请先思考后再展开 就是限制了根节点度数的最小生成树先去除1节点，跑出每个节点的最小生成树，然后找最小的一条边连接上去然后有可能可以对某个点x，去掉某条1到x的一条边，并连接x和1 7 POJ2728 Desert King8.30 难度1请先思考后再展开 01分数规划+最小生成树不过不知道为什么跑得很慢log的大小，无论如何都是在100以内的，那么正常来说这道题就一亿，时限3s个人觉得它非要卡二分我也没办法，Dinkelbach大概只是恰好快而已（毕竟那东西的复杂度很玄学）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=1100; const int INF=0x3f3f3f3f; double myabs(double x) &#123;return x&gt;0?x:-x;&#125; const double eps=1e-8; struct Nod &#123; int x,y; int h; &#125;p[MAX_N]; double dis(double x1,double y1,double x2,double y2) &#123;return sqrt( (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) );&#125; int n; double L; double d[MAX_N],a[MAX_N][MAX_N],cst[MAX_N][MAX_N],ln[MAX_N][MAX_N]; bool v[MAX_N]; bool check()//prim&lt;=0 &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=cst[i][j]-L*ln[i][j]; d[0]=INF;d[1]=0;for(int i=2;i&lt;=n;i++) d[i]=a[1][i]; memset(v,0,sizeof v);v[1]=1; double sum=0; for(int cnt=1;cnt&lt;=n-1;cnt++) &#123; int t=0;for(int i=1;i&lt;=n;i++) if(!v[i] and d[i]&lt;d[t]) t=i; sum+=d[t];v[t]=1; for(int i=1;i&lt;=n;i++) if(!v[i] and a[t][i]&lt;d[i]) d[i]=a[t][i]; &#125; return sum&lt;=eps; &#125; /* int m; struct Edge &#123; int x,y; double cst,ln; &#125;e[MAX_N*MAX_N]; bool cmp(Edge a,Edge b) &#123;return a.cst-L*a.ln&lt;b.cst-L*b.ln;&#125; int fa[MAX_N]; int findfa(int x) &#123;return fa[x]=(x==fa[x]?x:findfa(fa[x]));&#125; bool check()//kruskal&lt;=0 沙茶了，完全图用kruskal…… &#123; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=n;i++) fa[i]=i;//debug double sum=0; for(int i=1;i&lt;=m;i++) &#123; int x=e[i].x,y=e[i].y; int fx=findfa(x),fy=findfa(y); if(fx!=fy) &#123; sum+=e[i].cst-L*e[i].ln; fa[fx]=fy; &#125; &#125; return sum&lt;=0; &#125;*/ void main() &#123; while(1) &#123; scanf("%d",&amp;n); if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d%d%d",&amp;p[i].x,&amp;p[i].y,&amp;p[i].h); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cst[i][j]=myabs(p[i].h-p[j].h),ln[i][j]=dis(p[i].x,p[i].y,p[j].x,p[j].y); double l=0,r=INF,ans=-1; while(l&lt;=r+eps) &#123; L=(l+r)/2; if(check()) ans=L,r=L-eps; else l=L+eps; &#125; printf("%.3lf\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 8 APIO2010 巡逻8.30 难度2请先思考后再展开 这道题的k=1、2，先从k=0入手不难发现，每条边一定要经过两次（因为是树，一定会递归一次回溯一次），所以就是$2(n-1)$对于k=1，加入一条新的边以后，一定出现了环，就不一定是两次了同时，在这个环上，其他边都从经过两次变成了经过一次（例如题目中的a）不难发现，此时答案为$2(n-1)-(直径长度-1)$ 对于k=2的情况，稍微复杂了一些如果产生的新的环，没有和原本的环重叠，那么同样是不用经过一次（例如题目中的b）但是，如果重叠了（例如题目中的c），那么由于“新的边必须经过一次”这个限制，公共部分又变成了要经过两次 总上所述，第一次找直径L1，把边权变为-1第二次找到直径L2，答案即$2(n-1)-(L1-1)-(L2-1)$ 有木有觉得apio的图片非常良心 9 CH#56C 异象石8.30 难度2请先思考后再展开 先从每个节点上都有石头的情况开始考虑如果从边的角度，那就是边总长但因为这道题，主要从点的情况考虑，所以转化为，按照dfs搜索顺序，经过的相邻两点间距离/2而对于不满的情况也是类似，把存在的所有点，按照dfs序收尾相接，相邻间距离和即为答案那么具体实现的时候，可以搞一个set，用upper_bound等找相邻并动态维护当前总和即可 10 BJWC2010 严格次小生成树8.30 难度2请先思考后再展开 按照惯例，对于这种在树上有非树边的问题，可以考虑一下，由非树边产生的环例如本题，对于这个环，我们断掉任何一个，整个图依然是树（本来就是挂起来的无向无环图）所以说，对于每条边，其贡献就是，把它替换掉原本树上路径中最大那一条产生的差然后因为求的是严格次小，所以有种特殊情况，就是最大那个和当前边相同长 引理：在最小生成树原本的路径中，一定不会有比当前非树边大的边 证明：否则应该被当前非树边替换掉（替换掉一定不会有其他副作用之类，还是那句话，树本来就是挂起来的无向无环图） 那么也就是我们还需要且只需要再考虑次大值具体实现的话，用一个倍增st表维护一下就好了（以倍增lca为框架） 11 IOI2008 Island8.30 难度1请先思考后再展开 题意为，给出一个基环树森林，每个节点只能去一次，起点任意跨基环树的时候，不能回到曾经去过的基环树求最大化的【经过的基环树边的总和】显然答案就是每个基环树内直径之和然后基环树直径这种东西，写个dfs找环，dfs向下找最大深度，然后套个单调队列就好了 12 6401 创世纪8.30 难度2请先思考后再展开 在lxj的提醒下才想到正解……其实一点都不难 图显然是一个内向树森林，要求选自己，则至少一个孩子不被选考虑dp，$f(x,0/1)$表示当前子树满足条件时，x选择0/1的最大选择节点数先搞定树上的部分，如果枚举固定一个孩子不选，然后其他乱搞，但给个菊花图就会炸不难想到取补，把任意情况减去所有孩子都选了的情况（套路之记录次小值） 对于环上的怎么搞呢？看一眼这里就知道了 13 POI2008 BLO-Blockade8.31 难度2请先思考后再展开 教程然后还是不会做…… 在搜索树上考虑对于每个节点，假如它不是割点，那么只有它和其他人是连通块，贡献为$2(n-1)$而如果是割点，我们需要知道产生了多少个连通块，以及他们的大小 但怎么找？$low_y \leq dfn_x$这等价于割点的判定条件主要考虑是可以相等，因为每次我们会断掉所有的边 连通块有三种： x自己，大小1 共有t个满足上面的条件，大小为在搜索树上的子树大小 剩下的所有点（假如大小不为0，则一定存在） 第三点非常容易想漏，所以说建议多构造几组数据，当然对拍也是可以如果求稳的话 时间复杂度$O(n+m)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000,MAX_M=510000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int siz; int dfn,low; ll ans; Nod() &#123;hou=dfn=siz=0;ans=0;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_M*2]; int ln=0; void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int oth(int t) &#123;return (t&amp;1)?t+1:t-1;&#125; int id=0; int n; void tarjan(int x,int from) &#123; p[x].siz=1; p[x].dfn=p[x].low=++id; int sum=0,cnt=0;bool cut=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) &#123; tarjan(y,k); p[x].siz+=p[y].siz; p[x].low=mymin(p[x].low,p[y].low); if(p[y].low&gt;=p[x].dfn) &#123; cnt++; p[x].ans+=(ll)p[y].siz*(n-p[y].siz); sum+=p[y].siz; if(x!=1 or cnt&gt;1) cut=1; &#125; &#125; else if(k!=oth(from)) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(cut) p[x].ans+=ll(n-sum-1)*(sum+1)+(n-1); else p[x].ans=2*(n-1);//注意要直接赋值 &#125; void main() &#123; int m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123;int x,y;scanf("%d%d",&amp;x,&amp;y);ins(x,y);ins(y,x);&#125;//无重边 tarjan(1,-1); for(int i=1;i&lt;=n;i++) printf("%lld\n",p[i].ans); &#125;&#125;;int main()&#123; mine::main();&#125; 14 POJ3694 Network8.31 难度1请先思考后再展开 教程考虑合并每个e-DCC，形成一棵树然后倍增预处理一下lca 然后对于操作，其实就是合并x到y树上路径上的所有点，这个可以考虑用并查集维护由于单个的小合并操作，只会发生n次，即使并查集log，也只有nlogn而这个复杂度是超脱于询问这个循环之外的总复杂度 其实细节挺多的，大致流程： tarjan找到e-DCC，确定代表元素，初始化其并查集（最后别漏了根节点） 建立新的边目录，预处理倍增lca 回答询问的时候，一个个向上跳，维护割边数量cnt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000,MAX_M=410000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int dfn,low; int fa;//块父亲 &#125;p[MAX_N]; struct Edge &#123; int x,y,g; &#125;e[MAX_M*2]; int ln; void ins(int x,int y) &#123; ln++; e[ln].x=x;e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln; &#125; int oth(int t) &#123;return (t&amp;1)?(t+1):(t-1);&#125; int id[MAX_N];//并查集维护，所在的块 int findfa(int x) &#123;return id[x]=(x==id[x]?x:findfa(id[x]));&#125; void dfs(int x,int fa,int now) &#123; id[x]=now; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=fa and id[e[k].y]==0) dfs(e[k].y,x,now); &#125; int ct,cnt; void tarjan(int x,int from) &#123; p[x].dfn=p[x].low=++ct; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) &#123; tarjan(y,k); p[x].low=mymin(p[x].low,p[y].low); if(p[y].low&gt;p[x].dfn)//割边 &#123; cnt++;//割边数 p[y].fa=x; dfs(y,x,y); &#125; &#125; else if(k!=oth(from)) p[x].low=mymin(p[x].low,p[y].dfn); &#125; &#125; int hou[MAX_N],dep[MAX_N]; Edge e2[MAX_M*2]; int ln2; void ins2(int x,int y) &#123; ln2++; e2[ln2].y=y;e2[ln2].g=hou[x]; hou[x]=ln2; &#125; int f[MAX_N][20]; void pre(int x,int fa) &#123; dep[x]=dep[fa]+1; f[x][0]=fa;for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=hou[x];k&gt;0;k=e2[k].g) &#123; int y=e2[k].y;if(y==fa) continue; pre(y,x); &#125; &#125; int n,m; void make_graph() &#123; ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=p[i].dfn=0; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x);//无自环 &#125; cnt=0;ct=0;memset(id,0,sizeof id); tarjan(1,-1);dfs(1,0,1); ln2=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=2*m;i+=2) &#123; int fx=findfa(e[i].x),fy=findfa(e[i].y); if(fx!=fy) ins2(fx,fy),ins2(fy,fx); &#125; pre(1,0); &#125; int bin[20]; int getlca(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int solve() &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); int fx=findfa(x),fy=findfa(y),lca=findfa(getlca(fx,fy));//debug getlca(x,y) while(fx!=lca) cnt--,id[fx]=lca,fx=findfa(p[fx].fa); while(fy!=lca) cnt--,id[fy]=lca,fy=findfa(p[fy].fa); //因为每次findfa找最上面的代表元素，所以p[fx].fa一定是另一个节点 return cnt; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int cas=0; while(1) &#123; scanf("%d%d",&amp;n,&amp;m); if(n==0) break; printf("Case %d:\n",++cas); make_graph(); int q;scanf("%d",&amp;q); while(q--) printf("%d\n",solve()); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 15 POJ2942 Knights of the Round Table9.1 难度2请先思考后再展开 题意：找出有多少个骑士，无法出席任何会议会议的要求是有奇数个人，成环形后相邻的人没有憎恨关系 因为是环形，考虑连成一个环，不难想到建立一个补图，用【无憎恨关系】来建边那么就转化成，有多少个点，不在任何奇环（奇数个点的简单环）中 然后判断奇环可以染色，但怎么标记呢？暴力搞我自己都能出个数据卡成nm百思不得其姐，又去膜题解题解给出的又是两个结论……还好这一次，这两个结论的证明都很简单 结论1：奇环不会垮v-DCC存在证明：显然两个v-DCC能合并成一个v-DCC，与v-DCC的“极大”矛盾 结论2：如果某个v-DCC中有奇环，则整个v-DCC的每个节点，至少被一个奇环所包含假设有奇环外节点x，总是能和奇环上任意两个节点vi和vj形成奇环，因为无论【x到vi+x到vj】的奇偶性如何，奇环上两个点间距离总是能取奇数或者偶数……因为奇=奇+偶，亘古不变…… 怎么说呢？这两个结论都不是太好猜，但偏偏缺一不可 16 POJ1236 Network of Schools9.1 难度2请先思考后再展开 开始想法：设强连通分量缩点后，a=【入度=0】，b=【出度=0】那么第一问求a，第二问求b 其实已经和正解接近了，但还是错误的第二问求的其实是max(a,b)重新思考，对于入度为0的scc，如果起点不在这里就凉了，要消除掉对于出度为0的scc，如果起点在这里就凉了，要消除掉因为一次可以同时消除两种各一个，得证 17 POJ2226 Muddy Fields9.7 难度2请先思考后再展开 不会做的经典模型将连续的泥地分为行泥泞块和列泥泞块，形成了二分图那么，对于每个小泥地，至少要被其中一种覆盖那么把每个小泥地作为边，恰好连接两个元求最小覆盖即可 18 6902 Vani和Cl2捉迷藏9.9 难度2请先思考后再展开 神仙结论题，结论不好猜，证明不好想，但出得挺好因为不能有路径相连，可以联想到传递闭包（居然没有想到），转移为边的相连（构造新图，边就是用闭包得出来的结果）那么现在类似于要找最大独立集 具体做法：oi之路-图论-其他-Dilworth定理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=210; int n,m; int match1[MAX_N],match2[MAX_N]; int ask[MAX_N],ti;//时间戳 bool mp[MAX_N][MAX_N]; bool fd(int x) &#123; for(int y=1;y&lt;=n;y++) &#123; if(!mp[x][y] or ask[y]==ti) continue; ask[y]=ti; if(match2[y]==0 or fd(match2[y])) &#123; match1[x]=y; match2[y]=x; return 1; &#125; &#125; return 0; &#125; bool A[MAX_N],Anx[MAX_N]; int up(int x) &#123;return match2[x];&#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); mp[x][y]=1; &#125; //传递闭包 for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) mp[i][j]|=mp[i][k]&amp;mp[k][j]; //二分图匹配 int ans=0;for(ti=1;ti&lt;=n;ti++) ans+=fd(ti); printf("%d\n",n-ans); for(int i=1;i&lt;=n;i++) if(match1[i]==0) A[i]=1; bool modif=1; while(modif) &#123; modif=0; memset(Anx,0,sizeof Anx); for(int i=1;i&lt;=n;i++) if(A[i]) for(int j=1;j&lt;=n;j++) if(mp[i][j]) Anx[j]=1; for(int i=1;i&lt;=n;i++) if(A[i] and Anx[i]) &#123; modif=1; int t=up(i);while(Anx[t]) t=up(t); A[i]=0;A[t]=1; break; &#125; &#125; for(int i=1;i&lt;=n;i++) if(A[i]) printf("%d ",i); &#125;&#125;;int main()&#123; mine::main();&#125; 19 CH#17 舞动的夜晚9.10 难度2请先思考后再展开 详见oi之路的二分图一章123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=11000,MAX_M=110000; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; bool v; Nod() &#123;hou=0;v=0;&#125; &#125;p[MAX_N*2]; struct Edge &#123; int y,g,c; &#125;e[(MAX_N*2+MAX_M)*2]; int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,0&#125;;p[y].hou=ln; &#125; int st,ed; int h[MAX_N*2]; queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,sizeof h); q.push(st);h[st]=1; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int flow) &#123; if(x==ed) return flow; int out=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y,fine=mymin(flow-out,e[k].c); if(h[y]==h[x]+1 and fine&gt;0)//注意e[k].c，可能改变了 &#123; int t=dfs(y,fine); out+=t;e[k].c-=t;e[oth(k)].c+=t; &#125; &#125; if(out==0) h[x]=0;//剪枝 return out; &#125; int dfn[MAX_N*2],low[MAX_N*2],id=0; int sta[MAX_N*2],top=0; bool insta[MAX_N*2]; int belg[MAX_N*2],cnt=0; void tarjan(int x) &#123; dfn[x]=low[x]=++id; sta[++top]=x;insta[x]=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(e[k].c==0) continue; if(dfn[y]==0) tarjan(y),low[x]=mymin(low[x],low[y]); else if(insta[y]) low[x]=mymin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; ++cnt; int now; do &#123; now=sta[top--]; belg[now]=cnt; insta[now]=0; &#125;while(now!=x); &#125; &#125; int xx[MAX_M],yy[MAX_M]; void main() &#123; int n,m,ct;scanf("%d%d%d",&amp;n,&amp;m,&amp;ct); st=0,ed=n+m+1; for(int i=1;i&lt;=n;i++) ins(st,i,1); for(int i=1;i&lt;=m;i++) ins(n+i,ed,1); for(int i=1;i&lt;=ct;i++) &#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); ins(xx[i],n+yy[i],1); &#125; while(bfs()) dfs(st,0x3f3f3f3f); for(int i=st;i&lt;=ed;i++) if(dfn[i]==0) tarjan(i); int tot=0; for(int i=1;i&lt;=ct;i++) tot+=(e[2*(n+m+i-1)+1].c==0 or belg[xx[i]]==belg[n+yy[i]]); printf("%d\n",ct-tot); for(int i=1;i&lt;=ct;i++) if(e[2*(n+m+i-1)+1].c==0 or belg[xx[i]]==belg[n+yy[i]]) ; else printf("%d ",i); &#125;&#125;;int main()&#123; mine::main();&#125; 20 Poj3422 Kaka’s Matrix Travels9.10 难度1请先思考后再展开 考虑用流量表示路径的移动然后因为每个格子只能取一次，拆一下点$st=&gt;(1,1,0),flow=k,cost=0$$(i,j,0)=&gt;(i,j,1),flow=1,cost=num(i,j)$$(i,j,0)=&gt;(i,j,1),flow=\infty,cost=0$$(i,j,1)=&gt;(i+tx[t],j+ty[t],0),flow=\infty,cost=0$$(n,n,1)=&gt;ed,flow=\infty,cost=0$跑最大费用最大流即可 0x6B 图论练习部分题目 21 6B02 升降梯上9.11 难度1请先思考后再展开 把每个点拆成m个操作后的状态，最短路即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=21000; const int INF=0x3f3f3f3f; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; struct Nod &#123; int hou; int dis; Nod() &#123;hou=0;dis=INF;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*30]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln;&#125; int st,ed; struct Data &#123; int dis,id; friend bool operator &gt; (Data a,Data b) &#123;return a.dis&gt;b.dis;&#125; &#125;; priority_queue&lt; Data,vector&lt;Data&gt;,greater&lt;Data&gt; &gt; q; void dijkstra() &#123; p[st].dis=0;q.push((Data)&#123;p[st].dis,st&#125;); while(!q.empty()) &#123; Data t=q.top();q.pop(); int x=t.id;if(p[x].dis&lt;t.dis) continue; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; q.push((Data)&#123;p[y].dis,y&#125;); &#125; &#125; &#125; &#125; int n,m; int c[30]; int calc(int x,int y) &#123;return (x-1)*m+y;&#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); st=0;ed=n*m+1; for(int j=1;j&lt;=m;j++) &#123; scanf("%d",&amp;c[j]); if(c[j]==0) ins(st,calc(1,j),0); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=m;k++) if(1&lt;=i+c[k] and i+c[k]&lt;=n) ins(calc(i,j),calc(i+c[k],k),myabs(j-k)+2*myabs(c[k])); for(int j=1;j&lt;=m;j++) ins(calc(n,j),ed,0); dijkstra(); printf("%d",p[ed].dis==INF?-1:p[ed].dis); &#125;&#125;;int main()&#123; mine::main();&#125; 22 NOI2007 社交网络9.11 难度2请先思考后再展开 原来最短路路径数是可以用floyd统计的然后记住一定要去除编号相同的情况（以前总是偷懒）还有就是，一开始总是想不通怎么处理一条链的情况，为什么不会重复统计呢？但其实，由于其dp性质，一条路径只会在k为最大编号时才被统计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110; typedef long long ll; int mp[MAX_N][MAX_N]; ll cnt[MAX_N][MAX_N]; void main() &#123; memset(mp,0x3f,sizeof mp); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) mp[i][i]=0,cnt[i][i]=1; while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); mp[x][y]=mp[y][x]=c; cnt[x][y]=cnt[y][x]=1; &#125; //因为floyd的dp性质，左右两边只经过小于当前编号的节点，所以不会计算重复 for(int k=1;k&lt;=n;k++) for(int x=1;x&lt;=n;x++) if(x!=k)//避免重复情况 for(int y=1;y&lt;=n;y++) if(y!=k and y!=x) &#123; if(mp[x][y]&gt;mp[x][k]+mp[k][y]) &#123; mp[x][y]=mp[x][k]+mp[k][y]; cnt[x][y]=cnt[x][k]*cnt[k][y]; &#125; else if(mp[x][y]==mp[x][k]+mp[k][y]) cnt[x][y]+=cnt[x][k]*cnt[k][y]; &#125; for(int x=1;x&lt;=n;x++) &#123; double ans=0; for(int st=1;st&lt;=n;st++) if(st!=x) for(int ed=1;ed&lt;=n;ed++) if(ed!=x) if(mp[st][x]+mp[x][ed]==mp[st][ed]) ans+=(double)cnt[st][x]*cnt[x][ed]/cnt[st][ed]; printf("%.3lf\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 23 NOI2003 逃学的小孩9.12 难度2请先思考后再展开 算法一：最小化答案：min(c-&gt;a,c-&gt;b)+a-&gt;b结论：可以取直径作为a-&gt;b神仙证明 算法二：最小化答案：min(c-&gt;a,c-&gt;b)+a-&gt;b可能这个稍微常规一点?不妨设最小的是a，题目变成求出 a-&gt;c+a-&gt;b这是两条点不重复的路径，并且要求对于a而言c比b近如果枚举这两条路径的分叉点，巧妙地转化成求不同三个子树的最大深度这个可以用二次扫描+换根法实现还有个小细节，分岔点可能就是a 24 AHOI2008 紧急集合9.12 难度2请先思考后再展开 又感到很惭愧了……想了些数据，发现一定是跑到其中一个lca然后又yy几个情况，发现都是应该找深度最小那两个，然后到他们的lca，就不用枚举三次了然后就秒wa了然后就被rose秒出hack数据了，就是深度大那个点在它们到lca之间的路径上……所以最后还是枚举，发现有点慢，最大0.93s……所以正解应该是用离线lca算法，不过太复杂就不改了，大概yy了一下算法权当复习 下面就只给出朴素代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=510000; struct Nod &#123; int hou; int dep; Nod() &#123;hou=dep=0;&#125; &#125;p[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N*2]; int ln=0;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125; int bin[21]; int f[MAX_N][21]; void pre(int x,int fa) &#123; p[x].dep=p[fa].dep+1; f[x][0]=fa;for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; pre(y,x); &#125; &#125; int LCA(int x,int y) &#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=20;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int dis(int x,int y) &#123;return p[x].dep+p[y].dep-2*p[LCA(x,y)].dep;&#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n-1;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); ins(a,b);ins(b,a); &#125; pre(1,0); while(q--) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int lca1=LCA(a,b),lca2=LCA(b,c),lca3=LCA(a,c); int c1=(p[a].dep-p[lca1].dep)+(p[b].dep-p[lca1].dep)+dis(lca1,c); int c2=(p[b].dep-p[lca2].dep)+(p[c].dep-p[lca2].dep)+dis(lca2,a); int c3=(p[a].dep-p[lca3].dep)+(p[c].dep-p[lca3].dep)+dis(lca3,b); if(c1&lt;=c2 and c1&lt;=c3) printf("%d %d\n",lca1,c1); else if(c2&lt;=c1 and c2&lt;=c3) printf("%d %d\n",lca2,c2); else printf("%d %d\n",lca3,c3); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 25 POJ1275 Cashier Employment9.13 难度2请先思考后再展开 本来想着如果在费用流统计答案的时候不把费用乘以流量，就能让边权只表示使用这条边的费用那么就可以构图，从st到每个人，流量8费用1，然后时间连向ed，流量就是需求量然后发现这样的修改没有用，因为我可能流量在下一条增广路采用，然后费用就被多次统计了……看了眼tag居然是差分约束…… 不难想到可以前缀和一下，构造不等式组不过不知道怎么处理环形的情况，好像涉及了三个元$s[i] \geq s[i-1]$$当i leq 7,s[i]+tot-s[i+15] \geq c[i]$$otherwise,s[i]-s[i-8] \geq c[i]$ 膜lxj后发现，显然的单调性，二分即可 26 6B12 最优高铁环9.13 难度2请先思考后再展开 连01规划的sb题都不会做了有点担忧……现在才相同专题都这样，感觉后面要更多地做综合题对于有思考环节深度的题目，经常比别人走得浅当别人在关心判正环太慢的时候，我还毫无思路甚至别人以为我没去做例题…… 总之这道题为了判断负环的速度，写的是栈spfa如果在初始值为0的情况下，只要存在最长路的松弛，就是产生了正环然后不知为何本机ac提交wa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=1100; typedef long long ll; int hou[5*MAX_N]; struct Edge &#123; int y,g,c; &#125;e[51000]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln;&#125; double dis[5*MAX_N]; bool v[5*MAX_N]; bool dfs(int x,double mid) &#123; v[x]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&lt;dis[x]+e[k].c-mid) &#123; if(v[y]) return 1; dis[y]=dis[x]+e[k].c-mid; if(dfs(y,mid)) return 1; &#125; &#125; v[x]=0; return 0; &#125; bool check(double mid) &#123; memset(v,0,sizeof v); memset(dis,0,sizeof dis); for(int i=1;i&lt;=5000;i++) if(dfs(i,mid)) return 1; return 0; &#125; int sum;bool bk; int getid() &#123; char c=getchar(); char c2=getchar();int t=0; while('0'&lt;=c2 and c2&lt;='9') t=t*10+c2-'0',c2=getchar(); bk=(c2=='-'); if(c=='S') &#123;sum+=1000;return t;&#125; if(c=='G') &#123;sum+=500;return 1000+t;&#125; if(c=='D') &#123;sum+=300;return 2000+t;&#125; if(c=='T') &#123;sum+=200;return 3000+t;&#125; sum+=150;return 4000+t; &#125; void main() &#123; int m;scanf("%d",&amp;m);getchar(); for(int i=1;i&lt;=m;i++) &#123; sum=0; int st=getid(); int ed=getid(); while(bk) ed=getid(); ins(st,ed,sum); &#125; ll l=0,r=(ll)1000*20*50000*10,ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check((double)mid/10)) ans=mid,l=mid+1; else r=mid-1; &#125; if(ans&lt;0) puts("-1"); else printf("%d",(int)round( (double)ans/10 )); &#125;&#125;;int main()&#123; mine::main();&#125; 27 HNOI2012 矿场搭建9.14 难度2请先思考后再展开 显然先求一下割点，求出每个块的组成分析每个块，如果内部没有割点，那么需要两个出口，位置任意，但不重复如果只有一个割点，那么堵掉就凉了，所以要添加出口，而且不能在割点处如果有两个或以上，那么就无需担心，总能够出去综上说述，乘法原理统计一下即可 然后我以为根节点那个特判会影响vdcc的判断，其实只是影响割点……没有好好思考还有就是完全没考虑孤立点，还好这道题不需要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hou[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N]; int oth(int x) &#123;return x&amp;1?x+1:x-1;&#125; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int cnt;vector&lt;int&gt; vdcc[MAX_N]; bool gd[MAX_N]; int id,dfn[MAX_N],low[MAX_N]; int sta[MAX_N],top;bool insta[MAX_N]; void tarjan(int x,int fm) &#123; sta[++top]=x;insta[x]=1; dfn[x]=low[x]=++id; int son=0;//debug 这个不能影响vdcc的判定条件，只是和是否割点有关 for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(k==oth(fm)) continue; if(dfn[y]==0) &#123; tarjan(y,k);low[x]=mymin(low[x],low[y]); if(low[y]&gt;=dfn[x] or (fm==0 and son&gt;=2))//块 &#123; son++;vdcc[++cnt].clear(); if(fm!=0 or son&gt;=2) gd[x]=1; while(1) &#123; int now=sta[top--]; vdcc[cnt].push_back(now); if(now==y) break; &#125; vdcc[cnt].push_back(x); &#125; &#125; else if(insta[y]) low[x]=mymin(low[x],dfn[y]); &#125; //debug 注意我忘记考虑孤立点的情况了 //但因为这道题没有自环，也确实不用考虑 &#125; void main() &#123; int ct=0; while(1) &#123; int n;scanf("%d",&amp;n); if(n==0) break; ln=0;memset(hou,0,sizeof hou); int mx=0; for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); mx=mymax(mx,mymax(x,y)); &#125; id=top=cnt=0; memset(insta,0,sizeof insta); memset(gd,0,sizeof gd); memset(dfn,0,sizeof dfn); for(int i=1;i&lt;=mx;i++) if(dfn[i]==0) tarjan(i,0); ll tot=0,ans=1; for(int i=1;i&lt;=cnt;i++) &#123; int siz=vdcc[i].size(); int dg=0;for(int j=0;j&lt;siz;j++) if(gd[vdcc[i][j]]) dg++; if(dg==0) tot+=2,ans*=(ll)siz*(siz-1)/2; if(dg==1) tot++,ans*=siz-1; &#125; printf("Case %d: %lld %lld\n",++ct,tot,ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 28 bzoj3033 太鼓达人9.15 难度2请先思考后再展开 非常好的一道题，如果lxj不说是欧拉图我肯定不会做……先考虑长度，显然不会超过 $2^k$ ，否则一定会出现重复那么如果我们能构造出一种方案，保证长度为 $2^k$ ，那么答案就是 $2^k$ 假设该结论成立，那么我们需要覆盖 0~ $2^k-1$ 的每个值有一个不那么好像的方法，但因为自己受到提示，不难想到把每个值作为边然后为了确保出现的独一无二，分割为前面k-1个和后面k-1个，转移的边为了字典序优先选最小的那么因为出度为2，入度为2，一定是一个欧拉图，那么一定能得出 $2^k$ 的长度0 如果讲得不清楚，这位女选手的图片不错 29 中山市选 杀人游戏9.15 难度1请先思考后再展开 这道题的题意不太清晰其实就是尽量少去交给命运决定……（少尝试）答案就是 $\frac{n-尝试数量}{n}$ ，也就是都不是杀手那么缩点后找入度为0即可不过如果本来是一个点，那么可以用排除法得出结果，稍微判断一下即可 30 POJ3648 Wedding9.15 难度1请先思考后再展开 2-sat比较显然假设新娘在右边，然后左边不能有通奸，直接scc判断即可那么因为有可能新郎也通奸，导致新娘去左边了，为了防止这种情况，从新娘到新郎连一条边表示非法性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; const int MAX_N=110000; typedef long long ll; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int hou[MAX_N]; struct Edge &#123; int y,g; &#125;e[MAX_N]; int ln;void ins(int x,int y) &#123;e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln;&#125; int id,dfn[MAX_N],low[MAX_N]; int cnt,belg[MAX_N]; int sta[MAX_N],top;bool insta[MAX_N]; void tarjan(int x) &#123; sta[++top]=x;insta[x]=1; dfn[x]=low[x]=++id; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dfn[y]==0) tarjan(y),low[x]=mymin(low[x],low[y]); else if(insta[y]) low[x]=mymin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; cnt++; while(1) &#123; int now=sta[top--]; belg[now]=cnt; insta[now]=0; if(now==x) break; &#125; &#125; &#125; int getid() &#123; int t;char c;scanf("%d%c",&amp;t,&amp;c); return 2*t+(c=='h');//0~2n-1 &#125; void output(int x) &#123;printf("%d%c ",x/2,x&amp;1?'h':'w');&#125; bool v[MAX_N];//块的选择状态 void main() &#123; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; ln=0;memset(hou,0,sizeof hou); ins(0,1);//确保选新郎，否则非法 for(int i=1;i&lt;=m;i++) &#123; int a=getid(),b=getid(); ins(a,b^1);ins(b,a^1); &#125; cnt=0;top=0;id=0; memset(dfn,0,sizeof dfn); for(int i=0;i&lt;=2*(n-1)+1;i++) if(dfn[i]==0) tarjan(i); memset(v,0,sizeof v); //反图拓扑序小=&gt;正图拓扑序大=&gt;正图scc编号小 bool bk=0; for(int i=0;i&lt;=n-1;i++) &#123; int fx=belg[i*2],fy=belg[i*2+1]; if(fx==fy) bk=1; v[mymin(fx,fy)]=1; &#125; if(bk) &#123;puts("bad luck");continue;&#125; for(int i=1;i&lt;=n-1;i++) output(v[belg[2*i]]?2*i+1:2*i);//得出新郎，输出新娘 puts(""); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 31 POJ1112 Team Them Up!9.18 难度2请先思考后再展开 题目关键：直接认识 在本题中，单一的单向边是没有意义的，应转化为双向边因为这个直接到达有点麻烦，如果取补图，边的意义就是【不能在相同的组中】此时成功产生了互斥关系，可以二分图染色，如果不是二分图，直接无解 当然我们染色出来的只是其中一种解对于每个连通块，都是可以取反的那么现在相当于一个有序二元组，目标就是让人数差最小01背包dp一下，转移很快，滚不滚没关系 32 zoj1654/HEOI2016/TJOI2016 游戏9.18 难度2请先思考后再展开 又没看出来……先想了想网络流，肯定不对因为是双向边，想了想二分图，感觉不对，因为我选，下一个不选，并不代表再下一个会选然后想想2-sat，有点像，但不知道怎么满足最大…… 看了看tag，我去，最大独立集好像有道理，但不应该是一般图吗？再想想……哦因为排斥关系是行或列的，所以没有奇环…… 然后就连样例都过不去了……随便考虑一行多个点，然后就会有奇环凉了 lxj提示说和草地排水很像一下得到启发，分行块和列块，把点化作边那么每个点最多连一条边，那么就是一个二分图匹配]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟赛2总结]]></title>
    <url>%2Fposts%2F80fa.html</url>
    <content type="text"><![CDATA[题目 比赛经历开局听说是看谁破百请吃饭的毒瘤题集不愧是tkj出得题（后来听栋老师说，都是煞笔题） 先看t1，fff是什么东西？狗狗协会？因为有spj，尝试找突破口手推不出-1的情况，尝试用rand帮我，所以码了个暴力，结果n到25也搞不出-1的点看来可能根本就没有-1的情况了那感觉就没什么突破口了看下一题 天啊看到这种题面和排序有关的题目就虚因为以前遇到过几次，感觉都和”冒泡排序”有关果不其然，我这种不会冒泡排序的人虚死了看下一题 金坷垃？没有任何思路感觉可能要计算几何，或者扫描线之类的东西反正不会…… 难道这把就要挂机了？好像很多人都是这样……各个都说不想交了，直接讲题什么的，毫无耐心现在想想好像只有第二题可以搏一搏了 这种快排好奇特啊能不能直接先把do while的那个跑一跑，然后枚举每个点，看看后面有多少个比它小的（逆序对贡献），然后如果有再+1？这个加入离散化后，可以用树状数组维护 发现过不了大样例啊，对拍一下试试吧2h过去了……发现暴力超级难打不过也不是虚度，因为通过模拟分段的无数细节，对分段性质理解加深了 然后我发现空间炸的一匹，vector也没有用（因为大数据非常良心，是一个dfs链状结构）所以就放弃出大数据的希望了，用来对拍吧 果然逆序对是错误的主要是两个原因：循环先执行再判断、执行复杂度直接算是当前区间长度 怎么办呢想着交个暴力算了 然后，突然灵光一现，发现可以改良因为每一次的复杂度贡献是按照长度来的，然后每个分段，其实就是由【在该数后面的数中比当前小，而且最远那个】和当前，包围起来的此时因为查错，我右边的备用小数据中已经有差不多10个了发现每一个都满足这个性质（一定要先跑一次，单循环冒泡，这样子分段才是明确的） 然后发现这是一个平方级别的做法，不知道能拿多少分先打了先把，很好改试试大样例 ？？居然过了？？当时就激动得一匹因为至少做法正确性没有问题主要还是速度太慢 想办法优化数据结构中好像只有具备结构体能力的splay能搞但当时只有20min了！以我的码力，这是不可能的 咦考虑一个数组（早就离散化了），存下最后那个？那询问还要按值找哦不对是可以用线段树维护最大值的，如果保存距离的话 当时还剩15min火速开始码他们已经打算交了 那几分钟，我的心跳的好快好快手指尖在键盘间笨拙地跳舞熟悉的单点修改区间询问线段树啊，如果码出来，就有ac的希望了那段时间好漫长，但没想到还是打完了途中还差点被没看懂的编译错误卡住，现在想想真的好险 最后还是打完了，顺利过了大样例然后就去吃饭了心里虚的一匹主要是时间太紧了，要不然能对拍一下就好了现在回想起来，还是在暴力上花费太长时间了，虽然那可能是想出正解的基础 这些东西现在回想起来，感觉也很难说清楚吧其实运气成分还是很大比例的而且我这速度，后面的发展也很虚啊三道题，用全部时间，只能做出一道题 吃饭途中得喜报还是顺利ac了感谢上帝……上一次拿rk1已经是省选前了……只是，没有人和我一样兴奋都对自己很失望吗不过这种东西，风水轮流转吧大概像我上次cf，被吊锤，晚上也是难受的很 ————在断网的中午，胡思乱想 T1-Analysis请先思考后再展开 这是一个非常奇妙的做法首先把情侣之间用无向边连接，然后把2i-1和2i连接这样，所有环因为必定是情侣边和相邻边交替的，而且出发边和结束边一定不一样（度只有2）所以只有偶环，也就是说是个二分图所以就可以愉快地染色了 windows本地栈，63000左右如果不是linux，可以考虑手动模拟 T1-Code-Std请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=110000; int hou[MAXN*2]; struct Edge &#123; int y,g; &#125;e[MAXN*4]; int ln=0; void ins(int x,int y) &#123; ln++; e[ln].y=y;e[ln].g=hou[x]; hou[x]=ln; &#125; int col[MAXN*2]; void dfs(int x,int now) &#123; col[x]=now; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(!col[y]) dfs(y,3-now); &#125; &#125; int a[MAXN],b[MAXN]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;a[i],&amp;b[i]); ins(a[i],b[i]);ins(b[i],a[i]); &#125; for(int i=1;i&lt;=n;i++) ins(2*i-1,2*i),ins(2*i,2*i-1); for(int i=1;i&lt;=2*n;i++) if(!col[i]) dfs(i,1); for(int i=1;i&lt;=n;i++) printf("%d %d\n",col[a[i]],col[b[i]]); &#125;&#125;;int main()&#123; mine::main();&#125; T2-Analysis请先思考后再展开 原题 Usaco2018 Open Out of SortsLuogu4372Bzoj5277 现在冷静想一想，发现我傻了，根本没有必要用线段树这种这么长的东西因为已经离散化了，直接用数组，维护最后位置，然后搞一个【前缀最大值】就好了这要是因为我们要维护的是位置，而这种东西可以通过比较直接确定在不在后面然后前缀最大值这种东西，当时太紧张，再加上原本的做法是需要动态维护的，所以就没跳出来当然复杂度没有变化 师兄的做法没看懂，不管了反正不一样 UP：讲课的时候被d飞了86 1 3 2 4 5 2 4答案是19虽然答案一样，但画出来的线段完全不对应（据akc研究后说，它的总数值，代表了某种总贡献，只是神仙地把操作后移了） 去膜了发官方题解发现可以这样考虑：对于所谓的快排下去递归冒泡，其实和对整个序列冒泡是等效的那么考虑每个元素的贡献，就是它左右两边的分隔符都出现之前的时间长度注意： 如果在最开始的时候，它就是单个元素，那么也会被统计一次 枚举元素的时候，是按照排序后的位置来找左右两边的 那么现在问题转化为计算n-1个分隔符出现的时间对于在i和i+1之间那个分隔符，它出现时，序列前i个元素已经在其前面了那么现在的关键就是第i大（稳定排序下）那个元素的位置r，要多久才能到i显然现在位于i的那个元素，一定比位于r的那个要大，否则前面已经足够了因为更大，那么每次冒泡，这个泡i一定会把r给换过来，也就是说每次冒泡往前一位所以说从r到i的时间恰恰是r-i T2-Code-Old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; int qread() &#123; int sum=0; char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') sum=sum*10+c-'0',c=getchar(); return sum; &#125; const int MAXN=110000; int n; int a[MAXN]; struct Nod &#123; int d,p; &#125;s[MAXN]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; int rx=0; void lsh() &#123; sort(s+1,s+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; if(i==1 or s[i-1].d!=s[i].d) rx++; a[s[i].p]=rx; &#125; &#125; struct Meg &#123; int lc,rc; int mx; &#125;p[MAXN*2]; int id=0; int build(int l,int r) &#123; int t=++id; p[t].mx=0; if(l==r) p[t].lc=p[t].rc=0; else &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; return t; &#125; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; void change(int x,int l,int r,int pos,int d) &#123; if(x==0) return; if(l==r) &#123; p[x].mx=mymax(d,p[x].mx); return; &#125; int mid=(l+r)/2; if(pos&lt;=mid) change(p[x].lc,l,mid,pos,d); else change(p[x].rc,mid+1,r,pos,d); p[x].mx=mymax(p[p[x].lc].mx,p[p[x].rc].mx); &#125; int ask(int x,int l,int r,int fl,int fr) &#123; if(x==0) return 0; if(l==fl and r==fr) return p[x].mx; int mid=(l+r)/2; if(fr&lt;=mid) return ask(p[x].lc,l,mid,fl,fr); else if(fl&gt;mid) return ask(p[x].rc,mid+1,r,fl,fr); else return mymax(ask(p[x].lc,l,mid,fl,mid),ask(p[x].rc,mid+1,r,mid+1,fr)); &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) s[i].d=a[i]=qread(),s[i].p=i; lsh(); if(n==1) &#123;putchar('0');return;&#125; ll ans=n; for(int i=1;i&lt;=n-1;i++) if(a[i]&gt;a[i+1]) swap(a[i],a[i+1]); build(1,rx); for(int i=n;i&gt;=1;i--) &#123; int j=ask(1,1,rx,1,a[i]-1); if(j&gt;0) ans+=j-i+1; change(1,1,rx,a[i],i); &#125; printf("%lld\n",ans); &#125;&#125;;int main()&#123; mine::main();&#125; T2-Code-Std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; const int MAXN=110000; struct Nod &#123; int d,p; &#125;p[MAXN]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d or (a.d==b.d and a.p&lt;b.p);&#125; int tot[MAXN]; void main() &#123; int n;scanf("%d",&amp;n); if(n==1) &#123;putchar('0');return;&#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].d),p[i].p=i; sort(p+1,p+n+1,cmp); int r=0;//前i小 for(int i=1;i&lt;=n-1;i++) &#123; r=mymax(r,p[i].p); tot[i]=r-i; &#125; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; int l=tot[i-1],r=tot[i]; if(l==0 and r==0) ans+=1;//do while else ans+=mymax(l,r); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; T3-Analysis请先思考后再展开 原题 Usaco2018 Jan SprinklersLuogu4184Bzoj5187 首先，最后的可行多边形一定是一个外凸边形那么有一个重要的性质，就是对于这种形状（大概是两个阶梯围成的）然后这种图形的可行解非常好处理，因为对于每个点，它的另一个端点的可行区域就在其左下侧区域中如果要直接暴力的话，现在就可以得到50分了 考虑处理出每一列的up和low表示上下界这个东西的维护，可以考虑先记录一个转折点，然后最后再线性推一推就好了（因为有单调性） 接下来推式子$$\sum_{i=0}^{n-1}{ \sum_{j=low[i]+1}^{up[i]} 【 \sum_{k=low[i]}^{j-1} i-left[k] 】}$$ $$\sum_{i=0}^{n-1}{ \sum_{j=low[i]+1}^{up[i]} 【 i \times (j-low[i]) - \sum_{k=low[i]}^{j-1} left[k] 】}$$ $$\sum_{i=0}^{n-1}{ i \times \sum_{j=low[i]+1}^{up[i]} 【 (j-low[i]) - \sum_{k=low[i]}^{j-1} left[k] 】}$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - \sum_{j=low[i]+1}^{up[i]} \sum_{k=low[i]}^{j-1} left[k]】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - \sum_{t=low[i]}^{up[i]-1} left[t] \times (up[i]-t)】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - up[i] \times \sum_{t=low[i]}^{up[i]-1} left[t] + \sum_{t=low[i]}^{up[i]-1} left[t] \times t】$$ $$\sum_{i=0}^{n-1}【 \frac{ i (up[i]-low[i]) (up[i]-low[i]+1) }{2} - up[i] \times \sum_{t=low[i]}^{up[i]-1} left[t] + \sum_{t=low[i]}^{up[i]-1} left[t] \times t】$$ 所以维护一个前缀和就好了 T3-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//use-v4//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=110000; const int INF=0x3f3f3f3f; const int MOD=1e9+7; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int up[MAXN],low[MAXN],left[MAXN]; ll slf1[MAXN],slf2[MAXN]; void main() &#123; int n;scanf("%d",&amp;n); memset(up,-1,sizeof up); memset(low,63,sizeof low); memset(left,63,sizeof left); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); up[x]=mymax(up[x],y); low[x]=mymin(low[x],y); left[y]=mymin(left[y],x); &#125; int lw=INF; for(int i=0;i&lt;=n-1;i++)//下阶梯 &#123; if(low[i]!=INF) lw=mymin(lw,low[i]); if(lw!=INF) low[i]=lw; &#125; int upp=0; for(int i=n-1;i&gt;=0;i--)//上阶梯 &#123; if(up[i]!=-1) upp=mymax(upp,up[i]); if(upp!=0) up[i]=upp; &#125; int lf=INF; for(int i=0;i&lt;=n-1;i++)//左阶梯 &#123; if(left[i]!=INF) lf=mymin(lf,left[i]); if(lf!=INF) left[i]=lf; &#125; slf1[0]=left[0];slf2[0]=0; for(int t=1;t&lt;=n-1;t++) &#123; slf1[t]=(slf1[t-1]+left[t])%MOD; slf2[t]=(slf2[t-1]+(ll)left[t]*t%MOD)%MOD; &#125; ll ans=0; for(int i=0;i&lt;=n-1;i++) &#123; if(up[i]&gt;=low[i]) ans+=ll(up[i]-low[i])*(up[i]-low[i]+1)/2 %MOD *i; ans%=MOD; if(low[i]&gt;0) ans-=(ll)up[i]*(slf1[up[i]-1]-slf1[low[i]-1]) %MOD; else ans-=(ll)up[i]*slf1[up[i]-1] %MOD; if(low[i]&gt;0) ans+=slf2[up[i]-1]-slf2[low[i]-1]; else if(up[i]&gt;0) ans+=slf2[up[i]-1]; ans=(ans%MOD+MOD)%MOD; &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-5动态规划 24题]]></title>
    <url>%2Fposts%2F18f8.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 另外，由于追进度，对于coding部分比较有自信的题目，不再具体实现 0x50 动态规划部分题目 1 5101 LCIS8.22 难度2请先思考后再展开 精妙的做法设 $f(i,j)$ 表示以b[j]结尾，匹配到i的最长LCIS$a_i \neq b_j,f(i,j)=f(i-1,j)$$a_i=b_j,f(i,j)=max_{0&lt;k&lt;j,b_k&lt;b_j} f(i-1,k)+1$$a_i=b_j,f(i,j)=max_{0&lt;k&lt;j,b_k&lt;a_i} f(i-1,k)+1$乍一看是$n^3$级别的，但其实k的位置是可以动态维护的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=3100; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int a[MAXN],b[MAXN]; int f[MAXN][MAXN]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123; int k=0;//0&lt;k&lt;j for(int j=1;j&lt;=n;j++) &#123; if(a[i]!=b[j]) f[i][j]=f[i-1][j]; else f[i][j]=f[i-1][k]+1; if(b[j]&lt;a[i] and f[i-1][j]&gt;f[i-1][k]) k=j; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans=mymax(ans,f[n][i]); printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 2 5105 Cookies8.22 难度2请先思考后再展开 好题对于决策的分配，可以从等效状态直接转移抓住【排序后分配额递减】和【饼干至少1】的特性同时怒气值是根据相对大小产生的，所以可以整体少1设 $f(i,j)$ 表示给前i个人j块饼干的花费 决策1，所有人减少1块（当$j-i \geq i$）$$f(i,j)=f(i,j-i)$$决策2，后k个人（包括i）都是1块$$f(i,j)=min_{k=1}^{i-1} { f(i-k,j-k) + (i-k) \times \sum_{t=i-k+1}^i g[t] }$$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=40,MAX_M=5100; int g[MAX_N]; ll s[MAX_N];//前缀和 int pos[MAX_N]; bool cmp(int x,int y) &#123;return g[x]&gt;g[y];&#125; ll f[MAX_N][MAX_M]; int fm[MAX_N][MAX_M]; int n,m; int ans[MAX_N]; void output(int a,int b) &#123; if(a==0 and b==0) return; int k=fm[a][b]; if(k==0) &#123; output(a,b-a); for(int i=1;i&lt;=n;i++) ans[pos[i]]++; &#125; else &#123; output(a-k,b-k); for(int i=a-k+1;i&lt;=a;i++) ans[pos[i]]=1; &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;g[i]),pos[i]=i; sort(pos+1,pos+n+1,cmp); memset(f,0x3f,sizeof f); f[0][0]=0; for(int i=1;i&lt;=n;i++) &#123; s[i]=s[i-1]+g[pos[i]]; for(int j=i;j&lt;=m;j++) &#123; if(j-i&gt;=i) f[i][j]=f[i][j-i],fm[i][j]=0; for(int k=1;k&lt;=i;k++) &#123; ll nx=f[i-k][j-k]+ll(i-k)*(s[i]-s[i-k+1-1]); if(f[i][j]&gt;nx) f[i][j]=nx,fm[i][j]=k; &#125; &#125; &#125; printf("%lld\n",f[n][m]); output(n,m); for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; 3 POJ1015 Jury Compromise8.22 难度2请先思考后再展开 把差值作为体积，和作为权值，跑背包难点在于回溯刚开始在外层跑第几个物品，然后发现会出现一种情况，即使倒着枚举已选数量：现在使用过的物品，可能把当前依赖的那个位置给更新掉，不符合01背包所以改成在里面枚举，这样每次强行判断一下就好了如果要稍微降低代码复杂度，同时剪剪枝（其实也就是20），可以考虑刷表法 话说跟风akc，第一次用宏对于这道题是真的爽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=210,MAX_M=30; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; #define f(i,j) F[i][550+(j)] #define fm(i,j) Fm[i][550+(j)] int F[MAX_M][1100]; int Fm[MAX_M][1100]; int h[MAX_N],w[MAX_N]; int person[MAX_M]; void main() &#123; int ct=0; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; printf("Jury #%d\n",++ct); for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); h[i]=x-y;w[i]=x+y; &#125; memset(F,-1,sizeof F); f(0,0)=0; for(int i=0;i&lt;=m-1;i++) for(int val=-500;val&lt;=500;val++) if(f(i,val)&gt;=0)//刷表法更方便 for(int k=1;k&lt;=n;k++) if(f(i+1,val+h[k])&lt;f(i,val)+w[k])//剪枝 &#123; bool bk=0; int a=i,b=val; while(a!=0) &#123; int t=fm(a,b); if(t==k) &#123;bk=1;break;&#125; a--;b-=h[t]; &#125; if(bk) continue;//判重 f(i+1,val+h[k])=f(i,val)+w[k]; fm(i+1,val+h[k])=k; &#125; int v; for(int val=0;val&lt;=500;val++) &#123; if(f(m,-val)&gt;=f(m,val) and f(m,-val)&gt;=0) &#123;v=-val;break;&#125; if(f(m,val)&gt;=f(m,-val) and f(m,val)&gt;=0) &#123;v=val;break;&#125; &#125; int p=0,d=0; int now=m; while(now&gt;0) &#123; int k=fm(now,v); person[now]=k; p+=(h[k]+w[k])/2;d+=(w[k]-h[k])/2; now--;v-=h[k]; &#125; sort(person+1,person+m+1); printf("Best jury has value %d for prosecution and value %d for defence:\n",p,d); for(int i=1;i&lt;=m;i++) printf(" %d",person[i]); printf("\n\n");//debug 空行 &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 4 POJ1742 Coins8.22 难度2请先思考后再展开 楼教主的题耶二进制拆分法解决多重背包问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110,MAX_M=110000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int bin[20]; int a[MAX_N],b[MAX_N]; int w[MAX_N*20]; bool f[MAX_M]; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); int tot=0; for(int i=1;i&lt;=n;i++) &#123; int p=0;while(bin[p+1]-1&lt;b[i]) p++; int r=b[i]-(bin[p]-1);p--; for(int j=0;j&lt;=p;j++) w[++tot]=bin[j]*a[i]; w[++tot]=r*a[i]; &#125; memset(f,0,sizeof f); f[0]=1; for(int i=1;i&lt;=tot;i++) for(int j=m;j&gt;=w[i];j--) f[j]|=f[j-w[i]]; int ans=0; for(int i=1;i&lt;=m;i++) ans+=f[i]; printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 5 USACO2005 Jan Gold Naptime8.23 难度2请先思考后再展开 环形的dp，并且不能使用克隆法（会重复使用）对于这种决策能自动补全的题目，可以用一种巧妙的做法————二次扫描 设 $f(i,j,0/1)$ 表示处理到第i个小时，已经休息了j个小时，当前醒/睡状态下，最大的休息值先不考虑从昨晚就开始睡觉的情况 初始值为负无限（剔除非法状态，例如休息0正在睡）$f(1,0,0)=f(1,1,1)=0$$f(i,j,0)=f(i-1,j,0)$$f(i,j,1)=max{ f(i-1,j-1,0),f(i-1,j-1,1)+w_i }$$ans1=max{ f(n,m,0),f(n,m,1) }$那么昨晚就开始睡觉怎么办？$f(1,0,0)=0,f(1,1,1)=w_1$强行重新跑一次，自动拼接$ans2=f(n,m,1)$ $ANS=max{ ans1,ans2 }$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=4000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int n,m; int w[MAX_N]; int f[2][MAX_N][2];//滚动 void dp() &#123; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;=mymin(i,m);j++) &#123; f[i&amp;1][j][0]=mymax(f[(i-1)&amp;1][j][0],f[(i-1)&amp;1][j][1]); if(j&gt;0) f[i&amp;1][j][1]=mymax( f[(i-1)&amp;1][j-1][0],f[(i-1)&amp;1][j-1][1]+w[i] ); &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); memset(f,-63,sizeof f);//debug 剔除非法状态 f[1][0][0]=f[1][1][1]=0; dp(); int ans1=mymax(f[n&amp;1][m][0],f[n&amp;1][m][1]); memset(f,-63,sizeof f); f[1][0][0]=0;f[1][1][1]=w[1]; dp(); printf("%d",mymax(ans1,f[n&amp;1][m][1])); &#125;&#125;;int main()&#123; mine::main();&#125; 6 CF24D Broken robot8.23 难度2请先思考后再展开 注意题意细节，一开始看题看错了： 不能向上 可以到最后一行任意位置 停在原地的选择也算是一种行动，要计算步数 如果向左是非法选择，那么随机的时候不会考虑那边非常有趣的思路：用高斯消元解决局部依赖性的dp 分n个阶段去dp同样用倒推解决期望问题$f(i,j)=f(i,j)/4+f(i,j-1)/4+f(i,j+1)/4+f(i+1,j)/4+1$其中 $f(i+1,j)$ 是定值$\frac{3}{4}f(i,j)-\frac{1}{4}f(i,j-1)-\frac{1}{4}f(i,j+1)=f(i+1,j)/4+1$每个阶段列出一个 m个m元方程组，浮点高斯消元求解即可 就这么水？呵呵复杂度是$n^3$ ，不tle才怪主要是高斯消元太慢了考虑通过题目性质改良123456@@@@@ @@@ @@@ @@@ @@ 形状一定是这样的然后可以这样搞：第一遍，顺着，第i行消第i+1的第i元，变成这样123456@@ @@ @@ @@ @@ @ 第二遍，倒着，第i行消第i-1行的第i个 然后就完美了虽然大部分是自己想的，但还是有akc的一点提示，以及lxj的一点题意解释（懒得看）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=1100; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; double f[MAX_N][MAX_N]; int m; double a[MAX_N][MAX_N],b[MAX_N]; void guass2()//针对此题的形状 &#123; for(int i=1;i&lt;=m-1;i++) &#123; double t=a[i+1][i]/a[i][i]; a[i+1][i]=0; a[i+1][i+1]-=a[i][i+1]*t; b[i+1]-=b[i]*t; &#125; for(int i=m;i&gt;=2;i--) &#123; double t=a[i-1][i]/a[i][i]; a[i-1][i]=0; b[i-1]-=b[i]*t; &#125; &#125; void main() &#123; int n,stx,sty;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;stx,&amp;sty); if(m==1) &#123; printf("%d",(n-stx)*2); return;//f(i,j)/2=f(i+1,j)/2+1 &#125; for(int i=n-1;i&gt;=stx;i--) &#123; for(int j=1;j&lt;=m;j++) &#123; if(1==j or j==m) &#123; a[j][j]=2; if(j&gt;1) a[j][j-1]=-1; if(j&lt;m) a[j][j+1]=-1; b[j]=f[i+1][j]+3; &#125; else &#123; a[j][j]=3; if(j&gt;1) a[j][j-1]=-1; if(j&lt;m) a[j][j+1]=-1; b[j]=f[i+1][j]+4; &#125; &#125; guass2(); for(int j=1;j&lt;=m;j++) if(a[j][j]!=0) f[i][j]=b[j]/a[j][j],a[j][j]=0; &#125; printf("%.10lf",f[stx][sty]); &#125;&#125;;int main()&#123; mine::main();&#125; 7 noi2001 炮兵阵地8.26 难度2请先思考后再展开 关键是状态怎么精妙地表示一开始想着用6进制数，炸得很主要是没有考虑到十字的影响很小计算第i+1行，只要考虑第i-1和第i行，确保它们分别与运算都是0（反映列的上下影响两个）同时可以预处理出每个行内合法的状态，也就是没有两个相邻的距离小于3（反映行）这个状态量非常小，极限88个，可以放心搞时间复杂度$O(n |S|^3)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; int bin[20]; int n,m; int tot,S[100],siz[100];//状态，1的数量，极限88个 void pre() &#123; bin[0]=1;for(int i=1;i&lt;=m;i++) bin[i]=bin[i-1]*2; tot=0; for(int s=0;s&lt;=bin[m]-1;s++) &#123; int lst=-5,tmp=0; bool bk=1; for(int j=0;j&lt;=m-1;j++) if(s&amp;bin[j]) &#123; tmp++; if(j-lst&lt;=2) bk=0; else lst=j; &#125; if(bk) S[++tot]=s,siz[tot]=tmp; &#125; &#125; int mp[110]; bool okay(int i,int k) &#123; return (mp[i]|S[k])==mp[i]; &#125; int f[110][100][100]; int dp() &#123; memset(f,-1,sizeof f); for(int i=1;i&lt;=tot;i++) for(int j=1;j&lt;=tot;j++) if((S[i]&amp;S[j])==0 and okay(1,i) and okay(2,j)) f[2][i][j]=siz[i]+siz[j]; for(int now=2;now&lt;=n-1;now++)//刷表法 for(int i=1;i&lt;=tot;i++) for(int j=1;j&lt;=tot;j++) if(f[now][i][j]&gt;=0) for(int k=1;k&lt;=tot;k++) if(okay(now+1,k) and (S[i]&amp;S[k])==0 and (S[j]&amp;S[k])==0) f[now+1][j][k]=mymax(f[now+1][j][k],f[now][i][j]+siz[k]); int ans=0; for(int i=1;i&lt;=tot;i++) for(int j=1;j&lt;=tot;j++) if((S[i]&amp;S[j])==0 and okay(n-1,i) and okay(n,j)) ans=mymax(ans,f[n][i][j]); return ans; &#125; char str[20]; void main() &#123; scanf("%d%d",&amp;n,&amp;m); pre(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str); for(int j=0;j&lt;=m-1;j++) if(str[j]=='P') mp[i]|=bin[j]; &#125; if(n==1) &#123; int mx=0; for(int i=1;i&lt;=tot;i++) if(okay(1,i)) mx=mymax(mx,siz[i]); printf("%d",mx); &#125; else printf("%d",dp()); &#125;&#125;;int main()&#123; mine::main();&#125; 8 5702 Count The Repetitions8.27 难度2请先思考后再展开 神仙好题看到字符串的“生成”就虚的要死但其实字符串长度很短，可以暴力搞具体等会讲 问题可以转化成，用 $s(s_1,n_1)$ 能生成的 $s(s_2,m’)$ 使m’最大答案即最大的 $n_2 \times m \leq m’$ 因为m’是能拆分二进制的，那么考虑能否用s1来拼出只要有解，那么从某个位置开始的连续一段，花费一些字符长度，总是能拼出来的那么记录具体花费（考虑到题目中的生成是不能跳跃的，那么花费代价是很明确的，也没有任何决策可言）$f(x,p)$ 表示在s1的x开始，需要花费多少个字符，才能生成$s(s_2,2^p)$对于p=0的起始状态，可以直接暴力尝试s2的每个字符，然后如果为了找一个字符连续找了一圈，那么无解，这个地方的复杂度是$100^3$ 倍增的转移就非常简单了（为了方便，字符串从0开始）这时候先假设s1是无限长的，后面拆分的时候再考虑最终长度限制，因为现在还不明确$f(x,p)=f(x,p-1)+f( x+f(x,p-1) \% |s_1|,p-1 )$ 对于每次拆分，设x为当前用到什么地方，限制$x \leq n_1 \times |s_1|$然后x从0开始，lyd不知道干嘛居然还枚举x的起点，这样显然是没意义的……然后就没有然后了 本题ch上数据有错，多了个大括号在输入文件中，用cin可以规避简易前往leetcode4661234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; const int INF=0x3f3f3f3f; ll f[MAX_N][40]; int n1,n2; char s2[MAX_N],s1[MAX_N]; void solve() &#123; int len2=strlen(s2),len1=strlen(s1); memset(f,0,sizeof f); //暴力计算f(st,0) for(int st=0;st&lt;=len1-1;st++) &#123; int now=st; for(int i=0;i&lt;=len2-1;i++)//s2 &#123; int tot=0;//s1 while(s1[now]!=s2[i]) &#123; now=(now+1)%len1; if(++tot&gt;=len1) &#123;puts("0");return;&#125;//debug &#125; now=(now+1)%len1;f[st][0]+=tot+1; &#125; &#125; //预处理转移 for(int p=1;p&lt;=30;p++) for(int x=0;x&lt;=len1-1;x++) f[x][p]=f[x][p-1]+f[(f[x][p-1]+x)%len1][p-1]; //二进制拆分 ll now=0,ans=0; for(int p=30;p&gt;=0;p--) if(now+f[now%len1][p]&lt;=n1*len1) now+=f[now%len1][p],ans+=1&lt;&lt;p; printf("%lld\n",ans/n2); &#125; void main() &#123; while(scanf("%s%d%s%d",s2,&amp;n2,s1,&amp;n1)!=EOF) solve(); &#125;&#125;;int main()&#123; mine::main();&#125; 9 POJ3017 Cut the Sequence8.27 难度2请先思考后再展开 $f(i)=min{ f(j)+mx(j+1,i) },sum(j+1,i) \leq M,0 \leq j&lt;i$这个式子的可以用队列维护，但难以维护单调性 但是有一个结论：对于一个 $j$ ，若 $j$ 可能是最优决策，则不仅要满足$sum(j+1,i) \leq M$还要满足下列其中一个条件： $a_j=max(j,i)$ （单调递减性） $sum(j,i)&gt;M$ （也就是说 $j+1$ 是满足条件中最小的 ）证明：首先如果意会一下，就是在满足条件下，以max结果分割，每段最左边的那个原因是，如果存在一个满足条件的 $j-1$ ，并且和 $j$ 在同一段中，那么再考虑f的单调性（显然多一个数字不会更小），显然 $j-1$ 不会比 $j$ 差 上面两种情况可以分开考虑和继承对于情况2，可以尺取法线性维护（每个 $i$ 只有一个）对于情况1，维护一个 $a$ 单调递减的队列不难发现，对于单调队列中的每个元素，其 $mx(j+1,i)$ 就是下一个元素的a然后，由于条件1，在每次插入 $a_i$ 并维护单调性后，每个决策的大小是不会变的（除了单调队列最后一个元素，因为此时它还没有下一个元素）等维护完以后，再把倒数第二个决策插入到二叉堆里面，取最大更新即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000; const int INF=0x3f3f3f3f; int bin[20]; ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125; int n; int a[MAX_N]; int p[MAX_N];//单调队列对应位置 multiset&lt;ll&gt; q; ll f[MAX_N]; void main() &#123; ll m;scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); if(a[i]&gt;m) &#123;puts("-1");return;&#125; &#125; int l=1,r=1; p[1]=1;f[1]=a[1]; ll sum=a[1];int low=1; for(int i=2;i&lt;=n;i++) &#123; //update sum+=a[i]; while(sum&gt;m) sum-=a[low++]; while(l&lt;=r and p[l]&lt;low) &#123; if(l&lt;r) q.erase(q.find( f[p[l]]+a[p[l+1]] )); l++; &#125; //push while(l&lt;=r and a[p[r]]&lt;=a[i]) &#123; if(l&lt;r) q.erase(q.find( f[p[r-1]]+a[p[r]] )); r--; &#125; p[++r]=i;if(l&lt;r) q.insert(f[p[r-1]]+a[p[r]]); //dp f[i]=f[low-1]+a[p[l]]; if(l&lt;r) f[i]=mymin(f[i],*q.begin()); &#125; printf("%lld",f[n]); &#125;&#125;;int main()&#123; mine::main();&#125; 10 5A01 任务安排18.27 难度2请先思考后再展开 最初的想法，基本上是$O(750000^2 n)$$f(i,ed)=min{ f(j,\leq ed-s-sumT[i]+sumT[j])+ed \times (sumC[i]-sumC[j]) }$其实可以把第二维转化为分段数量，简化状态，时间$O(n^3)$$f(i,t)=min{ f(j,t-1)+(S \times t+sumT[i]) \times (sumC[i]-sumC[j]) }$ 然后有一个神奇的经典思想，叫做“费用提前计算”，就是把当前决策产生的后效性现在就计算，这样子，如果某次决策比不过别人，没有后效性之后是不用任何担心的，再也不会更优$f(i)=min{ f(j)+sumT[i] \times (sumC[i]-sumC[j])+S \times (sumC[n]-sumC[j]) }$时间$O(n^2)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=5100; const int INF=0x3f3f3f3f; ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125; ll sumT[MAX_N],sumC[MAX_N]; ll f[MAX_N]; void main() &#123; int n,S;scanf("%d%d",&amp;n,&amp;S); for(int i=1;i&lt;=n;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); sumT[i]=sumT[i-1]+a;sumC[i]=sumC[i-1]+b; &#125; memset(f,63,sizeof f); f[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) f[i]=mymin(f[i], f[j]+sumT[i]*(sumC[i]-sumC[j])+(sumC[n]-sumC[j])*S ); printf("%lld",f[n]); &#125;&#125;;int main()&#123; mine::main();&#125; 11 CF559C Gerald and Giant Chess8.28 难度2请先思考后再展开 看到黑色棋子这么少，一定是用总方案数-非法情况得到答案然后就想着，如果统计每个黑色格子经过的数量，用容斥原理统计的话，怎么计算出多个黑色的情况？显然是无法暴力枚举的，然后就懵逼了 其实，这是因为状态的设计有问题，导致同一条路径被多次计算重新设计状态，设$f(x)$表示以黑格子x作为某条【经过黑格子的路径】的第一个黑格子，这样，每条路径只会被它第一个黑格子统计，这样就能不重不漏了至于任意走的时候的方案数，可以参考前面讲到的多重集全排列 $$f(i)=C_{x_i+y_i-2}^{x_i-1} - \sum_{{ j|x_j \leq x_i 且 y_j \leq y_i }} f(j) \times C_{x_i-x_j+y_i-y_j}^{x_i-x_j} $$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=2100; const ll MOD=1e9+7; ll qpower(ll a,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*a%MOD; a=a*a%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll fac[210000],invfac[210000];//debug 开太小了，因为x+y ll C(int n,int m) &#123; return fac[n]*invfac[m]%MOD*invfac[n-m]%MOD; &#125; struct Nod &#123; int x,y; &#125;p[MAX_N]; bool cmp(Nod a,Nod b) &#123; return a.x&lt;b.x or (a.x==b.x and a.y&lt;b.y); &#125; ll f[MAX_N]; void main() &#123; fac[0]=1;invfac[0]=1; for(int i=1;i&lt;=200000;i++) fac[i]=fac[i-1]*i%MOD,invfac[i]=qpower(fac[i],MOD-2); int h,w,n;scanf("%d%d%d",&amp;h,&amp;w,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+n+1,cmp); p[n+1].x=h;p[n+1].y=w;//等价 for(int i=1;i&lt;=n+1;i++) &#123; f[i]=C(p[i].x+p[i].y-2,p[i].x-1); for(int j=1;j&lt;=i-1;j++) if(p[j].x&lt;=p[i].x and p[j].y&lt;=p[i].y) &#123; f[i]-=f[j]*C(p[i].x-p[j].x+p[i].y-p[j].y,p[i].x-p[j].x)%MOD; f[i]=(f[i]%MOD+MOD)%MOD; &#125; &#125; printf("%I64d",(f[n+1]%MOD+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125; 12 POJ1737 Connected Graph8.28 难度2请先思考后再展开 通常而言，计数类dp需要划分结构来继承，但现在处理的“连通无向图”很难划分所以现在考虑能否算出【任意无向图数量-不连通的无向图数量】任意无向图数量显然为$2^{n(n-1)/2}$对于不连通的无向图数量，可以划分出多个连通块又是运用某个不知名的经典思想，只分割出单一的一个来避免重复计数，剩下的内部还是任意（不能和分割出来的连通） 设 $f(i)$ 表示一个大小为n的连通无向图数量$f(i)=2^{i(i-1)/2}-\sum_{j=1}^{i-1} f(j) \times C_{i-1}^{j-1} \times 2^{(i-j)(i-j-1)/2}$代码略 13 CEOI2002 A decorative fence8.28 难度3请先思考后再展开 整体思路：因为要找第k大，依次枚举每个位置，枚举在这上面放什么，然后计算如果这样放，后面的方案数T如果$k \leq T$，那么证明这是正确的，继续往下找，否则$k-=T$这个思想在【树状数组、各种平衡树中找第k大】等应用中都有体现，不过本题没法也没必要分治 具体而言，设当前位置为i，并假设现在放了一块长度为h的木板作为0低位1高位高低位在第一个确定以后，就是轮流的了，所以说第一个要特判那么怎么计算方案数呢？设 $f(i,j,0/1)$ 表示用i个木板，其中最左边那个在其中是第i小且作为0低位1高位，的方案数那么此时就是$f[n-i+1][h在剩下中的排名][递推出的当前高低位]$ 注意到我们用排名而不是具体的值来表示这样子就不用考虑左边用剩下什么，而只要考虑高低位所需要的相对大小关系就好了（类似离散化）而且因为和具体的值没有关系，放在外面预处理也是可以的 这个dp方程也不是太好想可以从放入后的结果考虑，然后思考什么状态能转移过来：在插入后，最左边那个的排名是j如果是低位，那么插入后的排名，可以在它右边的就是 j+1~i ，还原到i-1时就是 j~i-1$f(i,j,0)=\sum_{p=j}^{i-1} f(i-1,p,1)$如果是低位，那么插入后的排名，可以在它右边的就是 1~j-1 ，还原到i-1时依旧是 1~j-1$f(i,j,1)=\sum_{p=1}^{j-1} f(i-1,p,0)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; ll f[MAX_N][MAX_N][2]; void predp() &#123; f[1][1][0]=f[1][1][1]=1; for(int i=2;i&lt;=20;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; for(int p=j;p&lt;=i-1;p++) f[i][j][0]+=f[i-1][p][1]; for(int p=1;p&lt;=j-1;p++) f[i][j][1]+=f[i-1][p][0]; &#125; &#125; &#125; void main() &#123; predp(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;ll k;scanf("%d%lld",&amp;n,&amp;k); int last,now; for(last=1;last&lt;=n;last++)//第一个（要从小到大） &#123; now=1; if(k&gt;f[n][last][1])//由于第一位已经确定，字典序由第二位决定，先下降 &#123; k-=f[n][last][1],now=0; if(k&gt;f[n][last][0]) &#123;k-=f[n][last][0];continue;&#125; &#125; break; &#125; printf("%d",last); bool v[30];memset(v,0,sizeof v);v[last]=1; for(int i=2;i&lt;=n;i++)//填第i位,n^3 &#123; now^=1; for(int len=1;len&lt;=n;len++)//要从小到大 &#123; if(v[len]) continue; if(now and last&gt;len) continue; if(!now and last&lt;len) continue; int tot=0;for(int j=1;j&lt;=len-1;j++) if(!v[j]) tot++; if(k&lt;=f[n-i+1][tot+1][now]) &#123;v[len]=1;last=len;printf(" %d",len);break;&#125; else k-=f[n-i+1][tot+1][now]; &#125; &#125; puts(""); &#125; return; &#125;&#125;;int main()&#123; mine::main();&#125; 14 POJ3208 Apocalypse Someday8.28 难度2请先思考后再展开 运用和上一道题类似的思想考虑每一个位置，枚举其数字，将后面能够让当前数字变成魔鬼数有多少种方案 而要称为魔鬼数，需要考虑三点： 前面部分最后连续的6的数量（也可能已经是魔鬼数，此时后面可以任意填） 这一位是否是6（衔接、延长） 后面的方案 这里后面的方案同样是预处理，但又要考虑到其前面6的个数以下内容包含前导0设 $f(i)$ 表示i位魔鬼数的数量$g(i,0/1/2)$ 表示最后有连续 $0/1/2$ 个6，但不是魔鬼数的数量（避免重复） 显然有如下式子$f(i)=g(i-1,2)+10\times f(i-1)$$g(i,0)=g(i-1,0)+g(i-1,1)+g(i-1,2)$$g(i,1)=g(i-1,0)$$g(i,2)=g(i-1,1)$ 但要注意边界$g(0,0)=1$本来直接写出了i=1的情况错了，好想是因为后面要用到，而不仅预处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int f[20],g[20][3]; void predp() &#123; g[0][0]=1;//debug 不止预处理，拆分的时候也要用到 for(int i=1;i&lt;=10;i++) &#123; g[i][0]=9*(g[i-1][0]+g[i-1][1]+g[i-1][2]); g[i][1]=g[i-1][0]; g[i][2]=g[i-1][1]; f[i]=g[i-1][2]+10*f[i-1]; &#125; &#125; void main() &#123; predp(); int T;scanf("%d",&amp;T); while(T--) &#123; int k;scanf("%d",&amp;k); int ln=3;while(k&gt;f[ln]) ln++;//确保第一个不会选出0 int lst=0;//3表示已经是 for(int now=ln;now&gt;=1;now--) &#123; for(int i=0;i&lt;=9;i++) &#123; int num=f[now-1];//有多少种填法能让整个数是魔鬼数 if(lst==3) num+=g[now-1][0]+g[now-1][1]+g[now-1][2]; else if(i==6) &#123; if(lst&gt;=0) num+=g[now-1][2]; if(lst&gt;=1) num+=g[now-1][1]; if(lst&gt;=2) num+=g[now-1][0]; &#125; if(k&gt;num) &#123;k-=num;continue;&#125; if(lst&lt;3) &#123; if(i==6) lst++; else lst=0; &#125; printf("%d",i); break; &#125; &#125; puts(""); &#125; return; &#125;&#125;;int main()&#123; mine::main();&#125; 15 Ahoi2009 同类分布8.28 难度2请先思考后再展开 本来觉得是一道神题学完数位dp后，就觉得是一道水题了（主要是太套路，太常规）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; ll f[20][170][170]; bool v[20][170][170]; int ed; int num[20]; ll dec[20];//%ed下 ll calc(int ln,int sum,int r,bool mask)//长度，剩下和，余数，顶位 &#123; if(sum&lt;0) return 0; if(ln&lt;=0) return sum==0 and r==0; if(!mask and v[ln][sum][r]) return f[ln][sum][r]; ll tot=0; int mx=mask?num[ln]:9; for(int now=0;now&lt;=mx;now++) tot+=calc(ln-1,sum-now,(( r-now*dec[ln-1] )%ed+ed)%ed,mask and now==mx); if(!mask) v[ln][sum][r]=1,f[ln][sum][r]=tot; return tot; &#125; ll solve(ll x) &#123; int n=0;while(x&gt;0) num[++n]=x%10,x/=10; ll ans=0; for(ed=1;ed&lt;=9*n;ed++) &#123; dec[0]=1;for(int i=1;i&lt;20;i++) dec[i]=dec[i-1]*10%ed; memset(v,0,sizeof v); ans+=calc(n,ed,0,1); &#125; return ans; &#125; void main() &#123; ll a,b;scanf("%lld%lld",&amp;a,&amp;b); printf("%lld",solve(b)-solve(a-1)); &#125;&#125;;int main()&#123; mine::main();&#125; 0x5E 动态规划练习部分题目 16 USACO2002 Feb BUY LOW, BUY LOWER8.24 难度2请先思考后再展开 难点在于统计和去重很不好想的做法：先处理出f，接着重新枚举一次，根据刚才的转移路径来统计答案为了避免重复，碰到相同的数就break，因为前面的部分是无法直接更新自己的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=5100; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int a[MAX_N]; int f[MAX_N],c[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); a[0]=0x3f3f3f3f; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=i-1;j++) if(a[j]&gt;a[i]) f[i]=mymax(f[i],f[j]+1); c[0]=1; for(int i=1;i&lt;=n;i++) for(int j=i-1;j&gt;=0;j--) &#123; if(a[j]==a[i]) break;//前面部分交给j if(a[j]&gt;a[i] and f[j]+1==f[i]) c[i]+=c[j];//转移 &#125; int ans=0;for(int i=1;i&lt;=n;i++) ans=mymax(ans,f[i]); int count=0;for(int i=1;i&lt;=n;i++) if(f[i]==ans) count+=c[i]; printf("%d %d",ans,count); &#125;&#125;;int main()&#123; mine::main();&#125; 17 POJ1722 SUBTRACT8.24 难度3请先思考后再展开 非常好的一道题，思考难度略大 （就是说我太菜不会做） 转化题目：把两个数做差后合并，就是打负号后再打括号那么相当于把整个数列，在空位写符号，问能否得到目标数T 题目特性：由于值域很小（-10000~10000），考虑一个可加可减的背包$f(i,ed)$ 表示考虑到第i位，能否得到d，-1表示不行，0表示在$i-1和i$ 之间用+，1表示-因为有spj，能找到解就好还原路径也非常简单 求解：合并的做法也很巧妙每次把连续的一段+，打上括号，也就变成了-然后随便地把第一位连续输出长度个即可这样把所有+处理完，只剩-，那么同样直接把第一个位置连续地输出就好了 对了，注意第一个符号不能是+，否则没法变成-1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int a[MAX_N]; #define f(i,j) F[i][10000+j] int F[MAX_N][21000]; int sign[MAX_N];//0=+,1=- void main() &#123; int n,ed;scanf("%d%d",&amp;n,&amp;ed); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); memset(F,-1,sizeof F); f(1,a[1])=2;//任意的可行 for(int i=1;i&lt;=n-1;i++)//刷表法更方便 for(int d=-10000;d&lt;=10000;d++) if(f(i,d)&gt;=0) &#123; if(i&gt;1) f(i+1,d+a[i+1])=0;//debug 第一个不能是+ f(i+1,d-a[i+1])=1; &#125; for(int i=n;i&gt;=2;i--) &#123; sign[i-1]=f(i,ed); if(sign[i-1]) ed+=a[i]; else ed-=a[i]; &#125; int nown=n-1,ln=0; for(int i=n-1;i&gt;=1;i--) &#123; if(!sign[i]) ln++;//+ else &#123; nown-=ln; while(ln--) printf("%d\n",i+1); ln=0; &#125; &#125; nown-=ln; while(ln&gt;0) printf("%d\n",ln),ln--; while(nown&gt;0) printf("1\n"),nown--; &#125;&#125;;int main()&#123; mine::main();&#125; 18 noi2001 陨石的秘密8.24 难度2请先思考后再展开 非常巧妙地dp设计之前听嘎爷讲过类似的题目，就是通过一个小小的容斥表示状态这样具体转移的时候只要关心一个上或下限就好了以本题为例，设$f(d,a,b,c)$ 表示$深度 \leq d$ ，同时各个括号分别用a、b、c对时，其可行方案数这样答案就是$f(D,A,B,C)-f(D-1,A,B,C)$ 转移的时候，可以通过简单的乘法原理，分成两边后，考虑右边那个的外层是什么，然后累加起来这样子就能够保证右边那个一定是一个块，而不是多个块，避免了重复这一点之前也见过，把一个多子树的问题，每次只抽出一个子树，其他递归下去考虑，一样的道理$$f(d,a,b,c)= \\f(d,a,b,c-k-1) \times f(d-1,0,0,k) + \\f(d,a,b-j-1,c-k) \times f(d-1,0,j,k) + \\f(d,a-i-1,b-j,c-k) \times f(d-1,i,j,k)$$时间复杂度$O(A^6 \times D)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MOD=11380; int f[40][20][20][20]; void dp(int d,int a,int b,int c)//美观 &#123; if(a==0 and b==0 and c==0) &#123;f[d][a][b][c]=1;return;&#125; int tmp=0; for(int k=0;k&lt;=c-1;k++)//() tmp=(tmp+f[d][a][b][c-k-1]*f[d-1][0][0][k])%MOD; for(int j=0;j&lt;=b-1;j++)//[] for(int k=0;k&lt;=c;k++)//() tmp=(tmp+f[d][a][b-j-1][c-k]*f[d-1][0][j][k])%MOD; for(int i=0;i&lt;=a-1;i++)//&#123;&#125; for(int j=0;j&lt;=b;j++)//[] for(int k=0;k&lt;=c;k++)//() tmp=(tmp+f[d][a-i-1][b-j][c-k]*f[d-1][i][j][k])%MOD; f[d][a][b][c]=tmp; &#125; void main() &#123; int A,B,C,D;scanf("%d%d%d%d",&amp;A,&amp;B,&amp;C,&amp;D); f[0][0][0][0]=1; for(int d=1;d&lt;=D;d++) for(int a=0;a&lt;=A;a++) for(int b=0;b&lt;=B;b++) for(int c=0;c&lt;=C;c++) dp(d,a,b,c); //debug 又被三目运算符坑了 int ans=f[D][A][B][C]-(D&gt;0?f[D-1][A][B][C]:0); printf("%d",(ans%MOD+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125; 19 noi1999 棋盘分割8.25 难度2请先思考后再展开 一开始看错题目了，好像是因为以前见过那样的题目：每次切都是产生切剩下的部分的代销（像合并果子？）那样的话，平均值不固定会非常难处理，于是就跑去膜题解了才发现自己沙茶了（这也可能是没有样例解释的锅）其实是指切n-1刀，最后是n个块，那么其实拼起来就是原本的块，所以平均值是固定的 稍微化简一下式子（挺意外还有化简这回事……以后题目中见到式子都要试一试）$ans^2$$=\frac{1}{n}( \sum (xi-\overline x)^2 )$$=\frac{1}{n}( \sum (xi^2-2 x_i \overline x+\overline x^2) )$$=\frac{1}{n}( \sum xi^2 - 2sum\overline x + \sum \overline x^2)$$=\sum xi^2/n - \overline x^2$ 代码实现就非常简单了，先二维前缀和预处理，设$f(n,a,b,c,d)$ 表示当前还有多少次，以及当前区间记忆化搜索，转移的时候枚举端点比较即可 20 POJ1390 Blocks8.26 难度2请先思考后再展开 显然先缩点 一开始想了一个贪心的做法，每次选择一个地方消除，分治，并顺便暴力地合并左右两边来更新答案然后发现连样例都过不去，以后应该先对着样例模拟一次的……所以现在的主要问题还是新块合并的处理 一个非常难想的延后处理法：设$f(l,r,k)$ 表示处理l到r的区间，同时存在一个本来不连续的长度为k的块和r相连且颜色相同 直接合并，$f(l,r,k)=f(l,r-1,0)+(k+len_r)^2$ 把k交给前面的某个t（$col_t=col_r$）处理，$f(l,r,k)=f(l,t,k+len_r)+f(t+1,r-1,0)$ 很巧妙地通过增加维，解决了新区间合并的问题其中也含有部分贪心的思想（例如直接把r也交给t处理） 时间复杂度方面不好估计，可能比赛的话，会感觉自己打了一个部分分？然后出来就ac了主要是因为颜色方面的限制，不会跑满（颜色块的不相同和转移时颜色的相同互斥）极限数据如121212121，可以自己造来跑一跑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=210; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; int a[MAX_N]; int col[MAX_N],len[MAX_N]; int f[MAX_N][MAX_N][MAX_N];bool v[MAX_N][MAX_N][MAX_N]; int dp(int l,int r,int k) &#123; if(l&gt;r) return 0; if(l==r) return mysqr(len[r]+k); if(v[l][r][k]) return f[l][r][k]; v[l][r][k]=1; int ans=0; ans=mymax(ans,dp(l,r-1,0)+mysqr(k+len[r])); for(int t=l;t&lt;=r-1;t++) if(col[t]==col[r]) ans=mymax(ans,dp(l,t,k+len[r])+dp(t+1,r-1,0)); return f[l][r][k]=ans; &#125; void main() &#123; int T;scanf("%d",&amp;T); int ct=0; while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int cnt=1;col[1]=a[1];len[1]=1; for(int i=2;i&lt;=n;i++) if(a[i-1]!=a[i]) col[++cnt]=a[i],len[cnt]=1; else len[cnt]++; memset(v,0,sizeof v); printf("Case %d: %d\n",++ct,dp(1,cnt,0)); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 21 HDU2196 Computer8.26 难度2请先思考后再展开 二次剩余，时间复杂度n为了求出，一个数列中除了某个数以外，其他数的最大值，维护一下次大值即可大概算是小技巧 总之第一次求出子树内距离，第二次从父亲处继承信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=11000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; struct Nod &#123; int hou; int mx; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*2]; int ln; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; void dfs1(int x,int fa) &#123; p[x].mx=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs1(y,x); p[x].mx=mymax(p[x].mx,p[y].mx+e[k].c); &#125; &#125; void dfs2(int x,int fa,int mx) &#123; int mx1=0,mx2=0;//最大和次大值 for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; if(p[y].mx+e[k].c&gt;mx1) mx2=mx1,mx1=p[y].mx+e[k].c; else if(p[y].mx+e[k].c&gt;mx2) mx2=p[y].mx+e[k].c; //忘记判断，与mx2的关系 &#125; p[x].mx=mymax(p[x].mx,mx); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; int t=mx1;if(p[y].mx+e[k].c==t) t=mx2; dfs2(y,x,mymax(t,mx)+e[k].c); &#125; &#125; void main() &#123; int n; while(scanf("%d",&amp;n)!=EOF) &#123; ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=2;i&lt;=n;i++) &#123; int fa,c;scanf("%d%d",&amp;fa,&amp;c); ins(fa,i,c);ins(i,fa,c); &#125; dfs1(1,0); dfs2(1,0,0); for(int i=1;i&lt;=n;i++) printf("%d\n",p[i].mx); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 直径结论，时间复杂度nlogn这东西的证明等，自行搜索本博客“直径”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAX_N=11000; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; struct Nod &#123; int hou; int dis,dep; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*2]; int ln; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; void dfs(int x,int fa) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; dfs(y,x); &#125; &#125; int bin[20]; int f[MAX_N][20]; void pre(int x,int fa) &#123; f[x][0]=fa;for(int i=1;i&lt;20;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; p[y].dep=p[x].dep+1; pre(y,x); &#125; &#125; int LCA(int x,int y) &#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=19;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;i--) if(p[x].dep&gt;=bin[i] and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; &#125; int getdis(int x,int y) &#123; return p[x].dis+p[y].dis-2*p[LCA(x,y)].dis; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n; while(scanf("%d",&amp;n)!=EOF) &#123; memset(f,0,sizeof f); ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=2;i&lt;=n;i++) &#123; int fa,c;scanf("%d%d",&amp;fa,&amp;c); ins(fa,i,c);ins(i,fa,c); &#125; int a=1;p[1].dis=0;dfs(1,0); for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[a].dis) a=i; int b=a;p[a].dis=0;dfs(a,0); for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[b].dis) b=i; p[1].dis=0;p[1].dep=1;pre(1,0); for(int i=1;i&lt;=n;i++) printf("%d\n", mymax(getdis(i,a),getdis(i,b)) ); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 22 HNOI2011 XOR和路径8.26 难度2请先思考后再展开 xor是对整数的运算，所以无法求出期望递推式如果把每个位置拆分（还是那个套路，二进制运算，不同数位间互不影响）那么只要考虑每个数位位置是1的概率，就能求出期望（权值确定，为1） 依旧是倒推，设$f(x)$ 表示当前x到n，异或和这一位是1的概率当$w_i=0$，$f(x)+=f(y)/tot$当$w_i=1$，$f(x)+=(1-f(y))/tot=1/tot-f(y)/tot$然后高斯消元即可 这道题卡精度，eps简易设置为1e-8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mysqr(int x) &#123;return x*x;&#125; const double eps=1e-8; bool iszero(double x) &#123;return x&gt;=-eps and x&lt;=eps;&#125; int tot[MAX_N]; int hou[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[21000]; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,hou[x]&#125;; hou[x]=ln; tot[x]++; &#125; int bin[40]; double a[MAX_N][MAX_N],b[MAX_N]; void gauss(int n,int m) &#123; for(int i=1;i&lt;=m;i++) &#123; int nx=0;for(int j=i;j&lt;=n;j++) if(!iszero(a[j][i])) &#123;nx=j;break;&#125; swap(b[nx],b[i]);for(int k=1;k&lt;=m;k++) swap(a[nx][k],a[i][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j or iszero(a[j][i])) continue; double t=a[j][i]/a[i][i]; b[j]-=b[i]*t;for(int k=1;k&lt;=m;k++) a[j][k]-=a[i][k]*t; &#125; &#125; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);if(x!=y) ins(y,x,c);//debug 自环不能建双向边 &#125; double ans=0; for(int now=0;now&lt;=30;now++) &#123; memset(a,0,sizeof a); memset(b,0,sizeof b); //f(n)=0 for(int x=1;x&lt;=n-1;x++) &#123; a[x][x]=tot[x]; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(e[k].c&amp;bin[now]) &#123; b[x]+=1; if(y!=n) a[x][y]+=1; &#125; else if(y!=n) a[x][y]-=1; &#125; &#125; gauss(n-1,n-1); ans+=b[1]/a[1][1]*bin[now]; &#125; printf("%.3Lf",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 23 SCOI2010 股票交易8.29 难度2请先思考后再展开 设 $f(i,k)$ 表示在第i天，拥有k个股票的最大现金答案即 $max f(T,1…maxp)$可能从 $f(j \leq i-w-1,k2 \leq maxp)$ 转移注意到第二维、决策都和第一维没有关系可以考虑一个经典的做法：把最优值后置，减少转移时间也就是说，直接取值 $f(i-w-1,k2 \leq maxp)$ 或者 $f(i-1,k)$时间复杂度为$O(n^3)$ 在这种连log都不能要，必须省掉一个n的时候，不妨考虑一下单调性①买入$f(i,k)=max { f(i-w-1,k2 \geq k-As_i)+k2 \times Ap_i }-k \times Ap_i$②卖出$f(i,k)=max { f(i-w-1,k2 \geq k+Bs_i)+k2 \times Bp_i }-k \times Bp_i$ 编号越大，贡献范围越大，维护一个编号递增，贡献递减的单调队列即可无脑开2n个单调队列，继承于i-w-1，维护i，时空都是完全没毛病的代码略 24 USACO2006 Nov Silver Round Numbers8.29 难度1请先思考后再展开 按照套路来就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=40; const int INF=0x3f3f3f3f; int num[MAX_N]; int f[MAX_N][MAX_N][MAX_N]; bool v[MAX_N][MAX_N][MAX_N]; int calc(int ln,int now0,int now1,bool iszero,bool top) &#123; if(ln==0) return now0&gt;=now1; if(!iszero and !top and v[ln][now0][now1]) return f[ln][now0][now1]; int mx=top?num[ln]:1; int cnt=0; for(int now=0;now&lt;=mx;now++) cnt+=calc(ln-1,now0+( iszero?0:(now==0) ),now1+(now==1),iszero and (now==0),top and (now==mx)); if(!iszero and !top) v[ln][now0][now1]=1,f[ln][now0][now1]=cnt; return cnt; &#125; int solve(int t) &#123; int ln=0;while(t&gt;0) num[++ln]=t%2,t/=2; return calc(ln,0,0,1,1); &#125; void main() &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); printf("%d",solve(r)-solve(l-1)); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1025C】Plasticine zebra]]></title>
    <url>%2Fposts%2Ff525.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1025C Record1h Analysis请先思考后再展开 要不是因为比赛的时候被第二题卡，还是能做出来的……说多都是泪 然后我的做法和机房其他人都不一样就是从操作的实际意义入手，发现等于没有翻转例如形如 ab|cd 这样的字符串，得到所谓的ba|dc但其实本质上，就是把后面那个放到前面，cd|ab，然后再整体倒过来然后不难发现，整体倒过来没有任何意义所以每次操作其实就是把后面的一段放到前面去，相当于跑一个环状的东西 所以说，只需要枚举一个起点，然后向后延伸就好了比赛还剩五分钟的时候，感觉需要平方级别回去的路上立刻就想到，其实维护一个双指针就好了 总而言之这道题真的很好想从操作入手，思考本质就是了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; char s[210000]; bool check(int i,int j) &#123; return ((j-i)%2==0 and s[i]==s[j]) or ((j-i)%2==1 and s[i]!=s[j]); &#125; void main() &#123; scanf("%s",s+1); int n=strlen(s+1); for(int i=n+1;i&lt;=n+n;i++) s[i]=s[i-n]; int ans=1,r=1; for(int l=1;l&lt;=n;l++) &#123; if(r&lt;l) r=l; while(r&lt;=l+n-1 and check(l,r)) r++; r--; //printf("%d %d\n",l,r); ans=mymax(ans,r-l+1); &#125; printf("%d",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2007】降雨量]]></title>
    <url>%2Fposts%2F20bf.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2007luogu2471bzoj1067POJ2637 Record1h Analysis请先思考后再展开 裸题就是情况有点多 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=51000,MAXM=11000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int bin[20]; int lg[MAXN+MAXM+MAXM]; struct LSH &#123; int d,p; &#125;ls[MAXN+MAXM+MAXM]; bool cmp(LSH a,LSH b) &#123;return a.d&lt;b.d;&#125; int rx; int n,m; int val[MAXN+MAXM+MAXM];//离散化结果 int yz[MAXN+MAXM+MAXM];//原值 void lsh() &#123; for(int i=1;i&lt;=n+m+m;i++) ls[i].p=i; sort(ls+1,ls+n+m+m+1,cmp);rx=0; for(int i=1;i&lt;=n+m+m;i++) &#123; if(i==1 or ls[i-1].d!=ls[i].d) yz[++rx]=ls[i].d; val[ls[i].p]=rx; &#125; &#125; int rain[MAXN]; int know[MAXN+MAXM+MAXM]; int mx[20][MAXN+MAXM+MAXM]; void pre() &#123; memset(know,0,sizeof know); for(int i=1;i&lt;=rx;i++) mx[0][i]=-INF; for(int i=1;i&lt;=n;i++) know[val[i]]=1,mx[0][val[i]]=rain[i]; for(int i=1;i&lt;=rx;i++) know[i]+=know[i-1]; for(int k=1;k&lt;20;k++) for(int i=1;i&lt;=rx-bin[k]+1;i++) mx[k][i]=mymax(mx[k-1][i],mx[k-1][i+bin[k-1]]); &#125; int get(int l,int r) &#123; if(l&gt;r) return -INF-1; int k=lg[r-l+1]; return mymax(mx[k][l],mx[k][r-bin[k]+1]); &#125; int solve(int y,int x) &#123; if(y&gt;x) return 2; if(y==x) return 1; int fy=get(y,y),fx=get(x,x); int have=know[x]-know[y-1],ln=yz[x]-yz[y]+1; if(fy==-INF and fx==-INF) return 0; else if(fy==-INF) &#123; if(ln==2 or get(y+1,x-1)&lt;fx) return 0; else return 2; &#125; else if(fx==-INF) &#123; if(ln==2 or get(y+1,x-1)&lt;fy) return 0; else return 2; &#125; else &#123; if(fy&gt;=fx and get(y+1,x-1)&lt;fx) &#123; if(have==ln) return 1; else return 0; &#125; else return 2; &#125; return -1; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;20;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAXN+MAXM+MAXM;i++) lg[i]=lg[i&gt;&gt;1]+1; while(1) &#123; scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;ls[i].d,&amp;rain[i]); scanf("%d",&amp;m);for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;ls[n+i].d,&amp;ls[n+m+i].d); lsh(); pre(); for(int i=1;i&lt;=m;i++) &#123; int ans=solve(val[n+i],val[n+m+i]); if(ans==0) puts("maybe"); else if(ans==1) puts("true"); else if(ans==2) puts("false"); else puts("ERROR"); &#125; puts(""); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度1</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟赛1总结]]></title>
    <url>%2Fposts%2F4f83.html</url>
    <content type="text"><![CDATA[题目 T1-Analysis请先思考后再展开 这是一道当时感觉很神，后来感觉很签到的好题关键在于，判断是否是n的倍数把加0看做乘以10，加1看做乘以10再加1这里运用到了一个技巧————用余数表示再通过记忆化，能够把原本【2的次幂】的复杂度，降低到n具体的实现可以用bfs路径的记录，可以以余数为索引，记录从哪个余数继承过来当然无脑string也行，毕竟就是一个等差数列的复杂度 T1-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=1100000; int MOD; int from[MAXN]; int ans[MAXN],tot; void add(int x) &#123; int nx=from[x]; ans[++tot]=!( (nx*10%MOD)==x ); &#125; queue&lt;int&gt; q; void bfs() &#123; q.push(1); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int i=0;i&lt;=1;i++) &#123; int nx=(x*10+i)%MOD; if(from[nx]&lt;0) &#123; from[nx]=x; q.push(nx); &#125; &#125; &#125; if(from[0]&lt;0) puts("-1"); else &#123; tot=0;add(0); int now=from[0]; while(now&gt;1) add(now),now=from[now]; ans[++tot]=1;//debug 漏了 &#125; &#125; void main() &#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); memset(from,-1,sizeof from); scanf("%d",&amp;MOD); bfs(); for(int i=tot;i&gt;=1;i--) putchar('0'+ans[i]); &#125;&#125;;int main()&#123; mine::main();&#125; T2-Analysis请先思考后再展开 考虑用dp来预处理神仙转化问题：【把原本的串取反，允许修改k的配额，能得到多少个目标串】设$f(S,i,k)$为，当前状态为S，处理到第i位，剩下可分配额为k，后面能够得到多少个目标串计数类dp，显然是倒推的$f(S,i,k)=f(S,i+1,k)+【k&gt;=w_i】f(S^bin[i],i+1,k-w_i)$ T2-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=16,MAXM=510000; int n; int w[MAXN]; int ct[1&lt;&lt;MAXN]; int f[1&lt;&lt;MAXN][MAXN][40]; int bin[MAXN]; char s[MAXN]; int read() &#123; scanf("%s",s); int now=0; for(int j=0;j&lt;=n-1;j++) if(s[n-j-1]=='1') now+=bin[j]; return now; &#125; void main() &#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); bin[0]=1;for(int i=1;i&lt;MAXN;i++) bin[i]=bin[i-1]&lt;&lt;1; int m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=m;i++) ct[bin[n]-1-read()]++;//取反 for(int i=n+1;i&gt;=1;i--) for(int s=0;s&lt;=bin[n]-1;s++) for(int k=0;k&lt;=30;k++) &#123; if(i==n+1) f[s][i][k]=ct[s]; else &#123; f[s][i][k]=f[s][i+1][k]; if(k&gt;=w[i]) f[s][i][k]+=f[s^bin[n-i]][i+1][k-w[i]]; &#125; &#125; while(q--) &#123; int now=read(),k;scanf("%d",&amp;k); printf("%d\n",f[now][1][k]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; T3-Analysis请先思考后再展开 原题：cf_R495_div_d然后我的代码其实如果加上快读就卡过去了，大概0.5s的速度……毕竟我的快速check函数，还是下了一番功夫的，从【面积】下降到【最大编号】 先说说我的想法：1.设计一个check函数表示在n乘m的矩阵中，数字i出现了几次（假设(1,1)=1）然后这个东西很多人是暴力【面积】做的其实可以通过找规律，分类讨论一下，降到【最大编号】 2.确认一个最大的完美正方形，每次调用check函数计算数字的需求量，然后判合法性 3.经过上一步，已经保证这个正方形会贴边了，这样我们就能直接把它在那条边上移动（注意交换n和m）最后还是分4个块，然后调用check判合法性 讲讲正解和我不同的部分：1.通过一层层向外枚举，得到第一个不能完美菱形的数字，这个数字就是0的x坐标可以这样考虑：x在外面，则高度为x-1~0，也就是x个然后做法的话，其实可以直接每层数字，数量+4，而我硬生生调用一个函数来计算……当然因为这个在外面，所以速度可以很随便，只是不那么优美 2.在枚举出矩阵的形状后，可以直接把最大那个数字mx放在(n,m)的位置，因为即使它在其他的角落，矩阵也能翻转过来这样的好处在于，最大曼哈顿距离确定为$mx=n-x+m-y$移项后得到$y=n+m-x-mx$，也就是说能够直接得出y这样就省去了枚举y的时间了 现在复杂度就是$O(\sqrt n \times check复杂度)$而check复杂度就是$\sum_{i=1 \to \sqrt n} i+n/i$根据等差数列和调和级数$n/2+nlog_2 \sqrt n$ 当然你要是暴力，问题不大，因为实际上外面的循环不会到满的根号，毕竟约数个数不会太大根据我打的表，一千万内最多的也只有448个 T3-Code-Old请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; const int MAXN=1000001; int c[MAXN]; int need[MAXN]; inline int check(int n,int m,int i) &#123; if(n&gt;m) swap(n,m); if(i&lt;=n) return i; if(i&lt;=m) return n; if(i&lt;=m+n-1) return (n+m-1)-i+1; return 0; &#125; int k=2; bool okay() &#123; for(int i=1;i&lt;=k+k;i++) if(check(k/2+1,k/2,i)*4&gt;c[i]) return 0; return 1; &#125; int ansx,ansy; bool trying(int n,int m) &#123; int need; int midx=k/2+1; for(int tx=1;tx&lt;=m-k+1;tx++) &#123; int midy=tx+k/2+1-1; //printf("%d %d %d %d\n",n,m,midx,midy); int mxx=mymax(n-midx,midx-1)+mymax(m-midy,midy-1)+5; bool bk=0; for(int i=1;i&lt;=mxx;i++) &#123; need=check(midx,midy,i+1)+check(n-midx,midy,i)+check(midx,m-midy,i)+check(n-midx,m-midy,i-1); if(need!=c[i]) &#123;bk=1;break;&#125; if(need==0) break; &#125; if(bk==0) &#123; ansx=midx,ansy=midy; return 1; &#125; &#125; return 0; &#125; int read() &#123; int x=0; char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') x=x*10+c-'0',c=getchar(); return x; &#125; void main() &#123; freopen("c.in","r",stdin); freopen("c.out","w",stdout); int mx;scanf("%d",&amp;mx); for(int i=1;i&lt;=mx;i++) &#123; int x;scanf("%d",&amp;x); c[x]++; &#125; while(k*k&lt;=mx) &#123; if(!okay()) break; k++; &#125; k--; for(int n=1;n*n&lt;=mx;n++) &#123; if(mx%n!=0) continue; int m=mx/n; if(trying(n,m)) &#123;printf("%d %d\n%d %d",n,m,ansx,ansy);return;&#125; if(trying(m,n)) &#123;printf("%d %d\n%d %d",m,n,ansx,ansy);return;&#125; &#125; puts("-1"); &#125;&#125;;int main()&#123; mine::main();&#125; T3-Code-Std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; const int MAXN=1000001; int c[MAXN]; int check(int n,int m,int i) &#123; if(n&gt;m) swap(n,m); if(i&lt;=n) return i; if(i&lt;=m) return n; if(i&lt;=m+n-1) return (n+m-1)-i+1; return 0; &#125; int mxnum=0; int ansx,ansy; bool trying(int n,int m) &#123; ansy=n+m-mxnum-ansx; int mxx=mymax(n-ansx,ansx-1)+mymax(m-ansy,ansy-1)+5; bool bk=1; for(int i=1;i&lt;=mxx;i++) &#123; int need; need=check(ansx,ansy,i+1)+check(n-ansx,ansy,i)+ check(ansx,m-ansy,i)+check(n-ansx,m-ansy,i-1); if(need!=c[i]) &#123;bk=0;break;&#125; if(need==0) break; &#125; if(bk) printf("%d %d\n%d %d",n,m,ansx,ansy); return bk; &#125; int read() &#123; int x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') x=x*10+c-'0',c=getchar(); return x; &#125; void main() &#123; int mx;scanf("%d",&amp;mx); for(int i=1;i&lt;=mx;i++) &#123; int t=read(); mxnum=mymax(mxnum,t); c[t]++; &#125; if(c[0]!=1) &#123;puts("-1");return;&#125;//debug 0很烦人 ansx=1; int need=4; while(c[ansx]&gt;=need) need+=4,ansx++; for(int n=1;n*n&lt;=mx;n++) &#123; if(mx%n!=0) continue; int m=mx/n; if(trying(n,m) or trying(m,n)) return; &#125; puts("-1"); &#125;&#125;;int main()&#123; mine::main();&#125; T4-Analysis请先思考后再展开 又是一道很好的脑力题$a_i \&amp; a_j =0$其实就是没有同时对应存在的1 依然是巧妙地转化题目：用个数组记录合法性【取反后a】存在合法解a并且因为【有合法解性】是可以传递的所以倒着递推（像背包？），枚举每个数字，每个【有合法解性】的数字，把某个1去掉后，都能从a得到合法解 T4-Code-Std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=1100000; int bin[30]; int a[MAXN]; bool b[MAXN]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); int mx=bin[20]-1; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),b[a[i]^mx]=1; for(int s=mx;s&gt;=1;s--) &#123; if(!b[s]) continue; for(int i=0;i&lt;=19;i++) if(s&amp;bin[i]) b[s^bin[i]]=1; &#125; for(int i=1;i&lt;=n;i++) printf("%d ",b[a[i]]); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【国家集训队】礼物]]></title>
    <url>%2Fposts%2F1774.html</url>
    <content type="text"><![CDATA[Source and Judge国家集训队bzoj2142 Record5h Analysis请先思考后再展开 拓展lucas裸题直接算$\prod C_n^{wi} \% p$，但每次要减少n时间复杂度$O(\sqrt N + p^c)$ 调试了一天……好多细节 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll qpower(ll a,ll e,ll MOD) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*a%MOD; a=a*a%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; ll inv(ll a,ll MOD) &#123; ll x,y;exgcd(a,MOD,x,y); x=(x%MOD+MOD)%MOD; return x; &#125; ll fac(int n,ll p,ll MOD) &#123; if(n&lt;=0) return 1; ll ans=1; ll t=n/MOD; for(int i=1;i&lt;=MOD-1;i++) if((i%p)!=0) ans=ans*i%MOD; //debug 这里不要调用一次fac，会导致重复计算剩下的 ans=qpower(ans,t,MOD); for(int i=t*MOD+1;i&lt;=n;i++) if((i%p)!=0) ans=ans*i%MOD; return ans*fac(n/p,p,MOD)%MOD;//debug 忘记去除p后，还会有东西剩下来 &#125; ll smallC(ll m,ll n,ll p,ll MOD) &#123; ll num=0; for(ll pk=p;pk&lt;=n;pk*=p) num+=n/pk; for(ll pk=p;pk&lt;=m;pk*=p) num-=m/pk; for(ll pk=p;pk&lt;=(n-m);pk*=p) num-=(n-m)/pk; ll ans=qpower(p,num,MOD);//不互质的烦恼 ans=ans*fac(n,p,MOD)%MOD; ans=ans*inv(fac(m,p,MOD),MOD)%MOD; ans=ans*inv(fac(n-m,p,MOD),MOD)%MOD; return ans; &#125; ll C(ll m,ll n,ll MOD)//exLucas &#123; ll ans=0;ll tmp=MOD; for(int p=2;p*p&lt;=tmp;p++) &#123; int pk=1; while(tmp%p==0) tmp/=p,pk*=p; if(pk&gt;1) (ans+=smallC(m,n,p,pk) *(MOD/pk)%MOD *inv(MOD/pk,pk) %MOD)%=MOD;//CRT &#125; if(tmp&gt;1) (ans+=smallC(m,n,tmp,tmp) *(MOD/tmp)%MOD *inv(MOD/tmp,tmp) %MOD)%=MOD; return ans; &#125; int w[10]; void main() &#123; int MOD;scanf("%d",&amp;MOD); int n,m;scanf("%d%d",&amp;n,&amp;m); ll tot=0; for(int i=1;i&lt;=m;i++) scanf("%d",&amp;w[i]),tot+=w[i]; if(tot&gt;n) puts("Impossible"); else &#123; ll ans=1; for(int i=1;i&lt;=m;i++) ans=ans*C(w[i],n,MOD)%MOD,n-=w[i]; printf("%lld",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1019A】Elections]]></title>
    <url>%2Fposts%2F1dd8.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1019A Record2h Analysis请先思考后再展开 比赛的时候乱想了一个贪心，没有足够的码力实现，而且应该是错误的 曾经想到枚举出最后的数量ed，然后不知道怎么利用其实这样以后，一下就能判断出，比ed高或相同的部分都要去掉，而且一定是选小的。而且，这样以后如果还没达到ed，选择什么地方都和决策没有关系了，直接选最小的即可时间复杂度O(n^2) 其实现在回想起来，又是【把最重要的一点想到后懵逼】系列 还有就是akc说满足三分性，不过反正题目没卡这个，就不管了反正时间优秀的一匹 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; struct Nod &#123; int c; int a,b; &#125;p[3100]; int all; bool cmp(Nod a,Nod b) &#123;return a.c&lt;b.c;&#125; int n,m; ll s[3100][3100];int sz[3100]; ll f(int ed) &#123; ll ans=0; int now=sz[1]; for(int i=2;i&lt;=m;i++) if(sz[i]&gt;=ed) &#123; int t=sz[i]-ed+(ed!=0);//debug 当ed=0，数组越界 ans+=s[i][t],now+=t; &#125; for(int i=1;i&lt;=all;i++) &#123; if(now&gt;=ed) break;//debug 前面可能已经达到ed,不能用== if(p[i].b&lt;=sz[p[i].a]-ed+1) continue; ans+=p[i].c;now++; &#125; return ans; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int p,c;scanf("%d%d",&amp;p,&amp;c); s[p][++sz[p]]=c; &#125; all=0; for(int i=2;i&lt;=m;i++) &#123; sort(s[i]+1,s[i]+sz[i]+1); for(int j=1;j&lt;=sz[i];j++) &#123; p[++all].c=s[i][j],p[all].a=i,p[all].b=j; s[i][j]+=s[i][j-1]; &#125; &#125; sort(p+1,p+all+1,cmp); ll mi=(1ll&lt;&lt;60); for(int ed=sz[1];ed&lt;=n;ed++) &#123; ll t=f(ed); if(t&lt;mi) mi=t; &#125; printf("%I64d",mi); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIAC9】小h的树]]></title>
    <url>%2Fposts%2Ff894.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIAC9 Record1h Analysis请先思考后再展开 这也是一道好题把dp和树结构的性质等结合在了一起 找点性质：因为要遍历每一个点，而且还是个树结构不难发现每条边最多遍历2次 先考虑特殊情况，k=n那么每条边都要遍历，而且“有点难发现”最后只被遍历一次的会是一条链答案就是$2 \times 边总长-链长度$所以为了答案最小，取直径…… 然后推广一下，有些边可以不经过了发现其实就是选取一个子树结构，让【上面说的值】最小然后我们维护的东西是满足可加性的，只要保证一条链 接下来对于我来说有些难度，但可能对大佬来说是一个套路就是搞一个树形dp，考虑直径的出现情况因为满足可加性，设 $f(x,k,0/1/2)$ 表示在x的子树中选k个（根节点必选）最后的下标，表示直径端点出现情况然后在dp的过程中，枚举y，根据直径端点出现情况考虑x到y这条边的贡献情况 感觉这个dp状态的设计还是灰常关键的 最后要证明这个复杂度方法灰常奇特啊就是把枚举siz看做是枚举其子树内每个节点那么对于每个点对，只会在其lca处被枚举到 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;int bin[40],lg[1&lt;&lt;21];namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=3e3+10; const int MOD=1e9+7; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; vector&lt;pr&gt; son[MAX_N];int siz[MAX_N],K,ans=INF; int f[2][MAX_N][MAX_N][3],g[2][MAX_N];//子树内有多少个端点 void solve(int x,int fa) &#123; memset(g,0x3f,sizeof g); siz[x]=1;f[0][x][1][0]=f[0][x][1][1]=f[0][x][1][2]=g[0][1]=0; int now=0; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t].FR,c=son[x][t].SE;if(y==fa) continue; now^=1;memcpy(f[now][x],f[now^1][x],sizeof f[now][x]);memcpy(g[now],g[now^1],sizeof g[now]); solve(y,x); for(int a=1;a&lt;=siz[x] and a&lt;=K;a++) for(int b=1;b&lt;=siz[y] and a+b&lt;=K;b++) &#123; chmin(f[now][x][a+b][0],f[now^1][x][a][0]+f[0][y][b][0]+c*2); chmin(f[now][x][a+b][1],f[now^1][x][a][0]+f[0][y][b][1]+c); chmin(f[now][x][a+b][1],f[now^1][x][a][1]+f[0][y][b][0]+c*2); chmin(f[now][x][a+b][2],min(f[now^1][x][a][0]+f[0][y][b][2],f[now^1][x][a][2]+f[0][y][b][0])+2*c ); chmin(f[now][x][a+b][2],f[now^1][x][a][1]+f[0][y][b][1]+c ); &#125; siz[x]+=siz[y]; &#125; if(now!=0) memcpy(f[0][x],f[1][x],sizeof f[1][x]); chmin(ans,min(min(f[0][x][K][0],f[0][x][K][1]),f[0][x][K][2]) ); &#125; void main() &#123; int n=qread();K=qread(); for(int i=1;i&lt;=n-1;i++) &#123; int x=qread(),y=qread(),c=qread(); son[x].PB(MP(y,c));son[y].PB(MP(x,c)); &#125; memset(f,0x3f,sizeof f); solve(1,0);write(ans); &#125;&#125;;int main()&#123; srand(time(0)); bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;(1&lt;&lt;21);i++) lg[i]=lg[i&gt;&gt;1]+1; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF1025D】Recovering BST]]></title>
    <url>%2Fposts%2F7565.html</url>
    <content type="text"><![CDATA[Source and JudgeCF1025D Record1h Analysis请先思考后再展开 这道题出得灰常好再次%一发rose大爷首先，所谓BST就是吓唬人的联想一下splay，其中序遍历不变这道题同样如此甚至都帮你排好序了然后就不知道怎么解决了…… 其实可以继续在中序遍历中做文章因为这是一个一维的序列然后在一颗子树中，其实是连续的一段（完全忘记的我……） 考虑一下区间dp然后有个小性质：我的父亲一定在当前区间的旁边，毕竟当初就是这样分开的而且，这棵树的根节点是可以随便取的 具体实现的话，枚举出当前子树的根节点x，与rt判断是否合法，然后向下用记忆化会灰常方便设f(l,r,op)表示可行性，然后op表示rt在那一侧就好了 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int gcd(int a,int b) &#123;return b==0?a:gcd(b,a%b);&#125; int a[710]; bool f[710][710][2]; bool v[710][710][2]; bool dp(int l,int r,int op) &#123; if(l&gt;r) return 1; if(v[l][r][op]) return f[l][r][op]; v[l][r][op]=1; int rt=op?r+1:l-1; for(int x=l;x&lt;=r;x++) if(gcd(a[x],a[rt])!=1 and dp(l,x-1,1) and dp(x+1,r,0)) return f[l][r][op]=1; return f[l][r][op]=0; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); if(dp(2,n,0)) puts("Yes"); else puts("No"); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D2T3】列队]]></title>
    <url>%2Fposts%2F1613.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D2T3Loj2319Luogu3960 Problem【Description】Sylvia 是一个热爱学习的女♂孩子。前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。Sylvia 所在的方阵中有n×m名学生，方阵的行数为 n，列数为 m。为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 1 到 n×m 编上了号码（参见后面的样例）。即：初始时，第 i 行第 j 列 的学生的编号是(i−1)×m+j。然鹅在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 q件这样的离队事件。每一次离队事件可以用数对(x,y)(1≤x≤n,1≤y≤m)描述，表示第 x 行第 y 列的学生离队。在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令： 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 x 行第 m 列。 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 n 行第 m 列。教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 n 行 第 m 列一个空位，这时这个学生会自然地填补到这个位置。因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学 的编号是多少。注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。【Input】输入共 q+1 行。第 1 行包含 3 个用空格分隔的正整数 n,m,q，表示方阵大小是 n 行 m 列，一共发 生了 q 次事件。接下来 q 行按照事件发生顺序描述了 q 件事件。每一行是两个整数 x,y，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 x 行第 y 列。【Output】按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学 生的编号。【Limited conditions】数据保证每一个事件满足 1≤x≤n,1≤y≤m【Sample input】2 2 31 12 21 2【Sample output】114【Sample explanation】列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 1 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 2 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 4 的同学向上一步，这时空位移动到第二行第二列。最后编号 为 1 的同学返回填补到空位中。 Record2h Analysis请先思考后再展开 如果把每次排队，抽象成操作【删除】和【寻找某一行或者一列的第k个】那么显然就是要用数据结构维护了可以说这是一道我见过最不裸的数据结构题反正我是没有独立看出来的能力的 但这个二维的矩阵要怎么维护呢？如果说每行都开一个，那么每次向前看起的时候，最后一列向前移动了一位也就是说我们需要插入、删除n次？显然是不可能的 其实向前的列只有最后一列，所以我们可以把行上的操作类比到最后一列上也就是说，把最后一列单独维护，前面的n行，每行只维护m-1个元素就好了 接下来把操作具体化一下，设出队的人坐标为(x,y)：①y=m【把最后一列的第x个删除并获得id】，【将id插入到最后一列的最后】②y&lt;m【把第x行的第y个删除并获得id】，【将id插入到最后一列的最后】【把最后一列的第x个删除并获得id】，【将id插入到第x行的最后】 还有一点就是，由于矩阵很大，不能直接存储，需要用一些手段动态利用空间 基于以上考虑，决定使用的数据结构思路一：平衡树，我只会splay思路二：线段树【%rose_max大爷，想到了这么神的做法】 平衡树很好理解，操作很常规，主要是怎么压缩空间然后我自己想了个做法，结果tm到处都是这样做的……就是把连续的节点用二元组(st,tot)表示，需要的时候分裂开就好了找第k大就用siz来找就好了 至于线段树的做法，借鉴主席树的思想，动态开点，只产生链对于找第k大，还是用siz，但这一次是用【线段树下标差-被删除数量】来搞然后删除数量，就用一个sum维护即可因为后面还要插入，所以预先每个线段树开n+q的范围这样的空间复杂度是nlogn，比splay多个log，但是时间理论上会小常数 不过实际情况是，我写的splay总时间和线段树一样，约10000ms，但单点最大1500ms，而线段树是1000ms在极限时间相同的情况下，xgc和rose的线段树总时间只有6000ms对比了一下，也没发现什么不同…… Code1请先思考后再展开 splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=310000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int f,son[2]; ll siz; ll id,tot;//起始编号、连续长度 Nod() &#123; f=son[0]=son[1]=0; &#125;&#125;p[MAXN*(2+4)];int ln=0;struct Splay&#123; void update(int x) &#123; p[x].siz=p[x].tot; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].siz+=p[lc].siz;//debug tot if(rc&gt;0) p[x].siz+=p[rc].siz;//debug tot &#125; void rotate(int x,int w) &#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int son=p[x].son[w]; p[f].son[1-w]=son; if(son&gt;0) p[son].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x); &#125; int root; void splay(int x,int rt) &#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x; &#125; void add(int fa,int w,ll id,int tot) &#123; int now=++ln; p[now].f=fa;p[fa].son[w]=now; p[now].id=id;p[now].tot=tot; update(now); &#125; void insert_wei(ll id,ll tot) &#123; if(root==0) &#123; root=++ln; p[root].id=id;p[root].tot=tot; update(root);//debug &#125; else &#123; int now=root;while(p[now].son[1]&gt;0) now=p[now].son[1]; add(now,1,id,tot); splay(ln,0); &#125; &#125; int findk(ll &amp;k)//返回编号 &#123; int now=root; while(1) &#123; int lc=p[now].son[0]; ll lcc=(lc&gt;0)?p[lc].siz:0; if(k&lt;=lcc) now=lc; else if(k&gt;lcc+p[now].tot) k-=lcc+p[now].tot,now=p[now].son[1]; else &#123;k-=lcc;return now;&#125; &#125; &#125; void del(int now) &#123; splay(now,0); int lc=p[now].son[0],rc=p[now].son[1]; if(lc==0 and rc==0) &#123; //debug ln=0不能用！ root=0; &#125; else if(lc&gt;0 and rc==0) &#123; root=lc; p[root].f=0; &#125; else if(lc==0 and rc&gt;0) &#123; root=rc; p[root].f=0; &#125; else &#123; int nx=lc;while(p[nx].son[1]&gt;0) nx=p[nx].son[1]; splay(nx,now); root=nx;p[root].f=0; p[rc].f=root;p[root].son[1]=rc; update(root); &#125; &#125; ll delk_getid(ll k) &#123; int now=findk(k); //printf("%lld %lld\n",p[now].id,k); k=p[now].id+k-1; if(p[now].tot==1) del(now); else if(k==p[now].id) &#123; p[now].id++; p[now].tot--;//debug 漏了这句话，导致推移 splay(now,0); &#125; else if(k==p[now].id+p[now].tot-1) &#123; p[now].tot--; splay(now,0); &#125; else &#123; ll backup=p[now].tot; p[now].tot=k-1-p[now].id+1; int rc=p[now].son[1]; p[now].son[1]=0; add(now,1,k+1,backup-p[now].tot-1); p[ln].son[1]=rc;p[rc].f=ln; splay(ln,0); &#125; return k; &#125;&#125;s[MAXN];int main()&#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) &#123; s[i].insert_wei( ll(i-1)*m+1 ,m-1); s[0].insert_wei( (ll)i*m,1);//最后一列 &#125; while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(y==m) &#123; ll id=s[0].delk_getid(x); printf("%lld\n",id); s[0].insert_wei(id,1); &#125; else &#123; ll id=s[x].delk_getid(y); printf("%lld\n",id); s[0].insert_wei(id,1); id=s[0].delk_getid(x); s[x].insert_wei(id,1); &#125; &#125;&#125; Code2请先思考后再展开 线段树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=610000;//totconst int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int lc,rc; int sum;//删除数量 ll id; Nod() &#123; lc=rc=sum=0; id=0; &#125;&#125;p[2*MAXN*17];//2*tot+2*tot*log(tot)int ln=0;int rt[MAXN],ed[MAXN];void change(int &amp;now,int l,int r,int pos,int c,ll id)&#123; if(now==0) now=++ln; p[now].sum+=c; if(l==r) &#123; p[now].id=id;return; &#125; int mid=(l+r)/2; if(pos&lt;=mid) change(p[now].lc,l,mid,pos,c,id); else change(p[now].rc,mid+1,r,pos,c,id);&#125;int tmp;//局部编号，外面还原ll findk(int now,int l,int r,int k,int &amp;pos)//返回编号，pos为下标&#123; if(now==0) &#123;tmp=pos=l+k-1;return 0;&#125; if(l==r) &#123;pos=l;tmp=l+k-1;return p[now].id;&#125; int mid=(l+r)/2; int left=mid-l+1-p[p[now].lc].sum;//debug 不能对0节点特判（习惯……） if(k&lt;=left) return findk(p[now].lc,l,mid,k,pos); else return findk(p[now].rc,mid+1,r,k-left,pos);&#125;int main()&#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); int tot1=m+q,tot2=n+q;//debug 原本用了动态的，然后还忘记分开来 ed[0]=n;for(int i=1;i&lt;=n;i++) ed[i]=m-1;//长度 while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(y==m) &#123; int pos; ll id=findk(rt[0],1,tot2,x,pos); change(rt[0],1,tot2,pos,1,0);//delete if(id==0) id=(ll)tmp*m; printf("%lld\n",id); change(rt[0],1,tot2,++ed[0],0,id); &#125; else &#123; int pos; ll id=findk(rt[x],1,tot1,y,pos); change(rt[x],1,tot1,pos,1,0);//delete if(id==0) id=ll(x-1)*m+tmp; printf("%lld\n",id); change(rt[0],1,tot2,++ed[0],0,id); id=findk(rt[0],1,tot2,x,pos); change(rt[0],1,tot2,pos,1,0);//delete if(id==0) id=(ll)tmp*m; change(rt[x],1,tot1,++ed[x],0,id); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>splay</tag>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D2T2】宝藏]]></title>
    <url>%2Fposts%2F301d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D2T2Loj2318Luogu3959 Problem【Description】参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 n 个深埋在地下的宝藏屋， 也给出了这 n 个宝藏屋之间可供开发的 m 条道路和它们的长度。小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。新开发一条道路的代价是：L×KL代表这条道路的长度，K代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代 价最小，并输出这个最小值。【Input】第一行两个用空格分离的正整数 n,m ，代表宝藏屋的个数和道路数。接下来 m 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 1−n ），和这条道路的长度 v 。【Output】一个正整数，表示最小的总代价。【Limited conditions】1≤n≤12， 0≤m≤1000， v≤500000【Sample input 1】4 51 2 11 3 31 4 12 3 43 4 1【Sample output 1】4【Sample input 2】4 51 2 11 3 31 4 12 3 43 4 2【Sample output 2】5【Sample explanation】无 Record3h去年比赛的时候想了半天，没想出什么数据能卡贪心地最小生成树然后就被卡到了45分 Analysis请先思考后再展开 rose曾经提出的做法:用$f[S][now][dep]$表示当点的状态为S，现在在now且深度为dep时的最优结果那么把不同种起点方式塞进去之后，就可以转移复杂度为$2^n \times n \times n \times n$ 看起来没有任何问题，对吧？我一开始也是这样认为的，就是一直心里有种别扭的感觉后来想半天终于发现，因为把其他点的信息舍去了，再也不能从别的点出发转移了 正解是状压dp这次的状压灰常独特呢反正我是没见过…… 设$f[dep][S]$表示当前的状态是S，最大深度是dep时的最小代价然后枚举每个状态进行转移的时候，每次直接添加一个点集，直接全部作为新的一层至于代价，考虑到题目的特殊性，树的结构具体如何无关紧要，只和每个节点的深度有关既然如此，只要预处理出每个节点添加到一个点集中的代价，再预处理成点集即可 然后让我们分析一下复杂度大致上=dp时枚举dep的时间 × 所有状态转移时枚举【补集的子集】的时间花费那么其实枚举【补集的子集】就是枚举子集 如果直接从循环量看，一定是比$O(2^n \times 2^n)=2亿$少的当然按照akc在省选后的教训，这个也可能跑出灰常多的分数但这个时间到底是多少呢？ 因为这东西是和rose一起xjb想出来的，不一定严谨而且好像和别的大佬看起来不一样？考虑按照【含0数量】分类$2^12 \times C_12^0$$2^11 \times C_12^1$……$2^6 \times C_12^6$……$2^1 \times C_12^11$$2^0 \times C_12^12$ 那么最大的显然是$2^6 \times C_12^6&lt;=60000$那么它们的总和$&lt; 60000*12=720000$所以总复杂度就是8640000 UP 晚上：问了问师兄，得出了和网上大佬相同的结论对于这种连续的枚举子集问题，复杂度其实是$O(3^n)$对于每个数位，只有3种情况，原本是0，原本是1枚举子集成0，原本是1枚举子集成1当然这种复杂度的前提是精准找到那个位置 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ull mymin(ull x,ull y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int bin[15];const int MAXS=1&lt;&lt;12;int n,maxs;int dis[15][15];int v[15];//原本位置ull value[15][MAXS];//点=&gt;集int cost[MAXS][MAXS];//集=&gt;集void pre()//3^n*n&#123; memset(value,63,sizeof value); for(int s=0;s&lt;=maxs;s++) &#123; for(int i=0;i&lt;=n-1;i++) if(s&amp;bin[i]) for(int j=0;j&lt;=n-1;j++) if( (s&amp;bin[j])==0 ) value[j][s]=mymin(value[j][s],dis[i][j]); for(int s2=(maxs-s);s2&gt;0;s2=(s2-1)&amp;(maxs-s))//枚举补集的子集 for(int i=0;i&lt;=n-1;i++) if(s2&amp;bin[i]) cost[s2][s]+=value[i][s]; &#125;&#125;ull f[15][MAXS];void dp()//n*3^n&#123; memset(f,63,sizeof f); for(int i=0;i&lt;=n-1;i++) f[1][bin[i]]=0; for(int dep=1;dep&lt;=n;dep++) for(int s=1;s&lt;=maxs;s++)//debug 不能是0 for(int s2=(maxs-s);s2&gt;0;s2=(s2-1)&amp;(maxs-s))//枚举补集的子集 f[dep+1][s|s2]=mymin(f[dep+1][s|s2],f[dep][s]+(ull)cost[s2][s]*dep);&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;15;i++) bin[i]=bin[i-1]&lt;&lt;1; int m;scanf("%d%d",&amp;n,&amp;m); memset(dis,63,sizeof dis); for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); x--;y--; if(dis[x][y]&gt;c) dis[x][y]=dis[y][x]=c; &#125; maxs=bin[n]-1; pre(); dp(); ull ans=INF; for(int dep=1;dep&lt;=n;dep++) ans=mymin(ans,f[dep][maxs]); printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SDOI2013】随机数生成器]]></title>
    <url>%2Fposts%2F41a1.html</url>
    <content type="text"><![CDATA[Source and JudgeSDOI2013Luogu3306Bzoj3122 Record2h Analysis请先思考后再展开 随便推推式子，发现有通项公式$x_i=a^{i-1}x_1 + b(1+a+a^2…+a^{i-2}) (\mod p)$$x_i=a^{i-1}x_1 + b \times (a^{i-1}-1) \times inv(a-1) (\mod p)$注意0没有逆元，所以要特判a=1的情况，即一个带模等差数列，解一个同余方程即可而对于普遍情况，可以BSGS，而且不用拓展，因为已经保证p是素数，而且a小于p Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; typedef unsigned long long ull; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; const int MAXN=610000; ll Mod; ll gcd(ll a,ll b) &#123;return (b==0)?a:gcd(b,a%b);&#125; ll qpower(ll a,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=(ans*a)%Mod; a=(a*a)%Mod;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,Mod-2);&#125; map&lt;ll,int&gt; hash; int BSGS(ll a,ll b) &#123; hash.clear();//debug ll m=ceil(sqrt( (double)Mod )); ll t=a,now=1; for(int j=0;j&lt;=m;j++) hash[ b*now%Mod ]=j,now=now*t%Mod; t=qpower(a,m),now=t; for(int i=1;i&lt;=m;i++) &#123; if(hash.count(now)) return (i*m-hash[now])+1; now=now*t%Mod; &#125; return -1; &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; ll a,b,st,ed;scanf("%lld%lld%lld%lld%lld",&amp;Mod,&amp;a,&amp;b,&amp;st,&amp;ed); if(st==ed) &#123;puts("1");continue;&#125;//debug 式子要求天数&gt;1 if(a==0) &#123;puts( (b==ed)?"2":"-1" );continue;&#125;//debug if(a==1)//debug 相当于除以0 &#123; if(b==0) puts("-1"); else &#123; //st+b*x=ed (mod Mod) ll ans=((ed-st)%Mod+Mod)%Mod; printf("%lld\n",ans*inv(b)%Mod+1); &#125; continue; &#125; //if( gcd(st+b*inv(a-1),Mod)!=1 ) &#123;puts("-1");continue;&#125; //debug st+b*inv(a-1)这个式子，本来想着要丢到逆元里面，所以不能% //但其实，一是应该在除过去之前就被%，二是它可能比Mod大 int ans=BSGS(a,(ed+b*inv(a-1)%Mod)*inv(st+b*inv(a-1)%Mod)%Mod); printf("%d\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Abc104-D】We Love ABC]]></title>
    <url>%2Fposts%2Ff88a.html</url>
    <content type="text"><![CDATA[Source and JudgeAbc104-D Problem【Description】给出一个字符串，只有A,B,C和通配符?答案为：枚举出各种情况，每种情况，不同位置三元组满足(A,B,C)，其数量之和【Input】字符串s【Output】输出和，模1e9+7【Limited conditions】|s|&lt;=10^5【Sample input 1】A??C【Sample output 1】8【Sample input 2】ABCBC【Sample output 2】3【Sample input 3】????C?????B??????A???????【Sample output 3】979596887【Sample explanation】无 Record30min刚长途旅游完只有abc Analysis请先思考后再展开 第一次想出D因为同样的三元组，可能会多次统计直接枚举每个b和?，考虑其贡献即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const ll MOD=1e9+7;char s[MAXN];ll a[MAXN],c[MAXN],wen[MAXN];ll three[MAXN];int main()&#123; three[0]=1;for(int i=1;i&lt;MAXN;i++) three[i]=(three[i-1]*3)%MOD; scanf("%s",s+1); int len=strlen(s+1); for(int i=1;i&lt;=len;i++) &#123; a[i]=a[i-1]+(s[i]=='A'); c[i]=c[i-1]+(s[i]=='C'); wen[i]=wen[i-1]+(s[i]=='?'); &#125; ll ans=0; for(int i=1;i&lt;=len;i++) if(s[i]=='B') &#123; ans+=a[i-1]*(c[len]-c[i])%MOD*three[wen[len]]%MOD;ans%=MOD;//(a,b,c) ans+=wen[i-1]*(c[len]-c[i])%MOD*three[wen[len]-1]%MOD;ans%=MOD;//(?,b,c) ans+=a[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-1]%MOD;ans%=MOD;//(a,b,?) ans+=wen[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-2]%MOD;ans%=MOD;//(?,b,?) &#125; else if(s[i]=='?') &#123; ans+=a[i-1]*(c[len]-c[i])%MOD*three[wen[len]-1]%MOD;ans%=MOD;//(a,?,c) ans+=wen[i-1]*(c[len]-c[i])%MOD*three[wen[len]-2]%MOD;ans%=MOD;//(?,?,c) ans+=a[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-2]%MOD;ans%=MOD;//(a,?,?) ans+=wen[i-1]*(wen[len]-wen[i])%MOD*three[wen[len]-3]%MOD;ans%=MOD;//(?,?,?) &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-3数学30题]]></title>
    <url>%2Fposts%2F82f7.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x30 数学题目 1 POJ2689 Prime Distance7.19 难度2请先思考后再展开 有一个很妙的做法：采用类似埃筛的方法筛素数所以只要线性预处理出前面$\sqrt R$内的素数p，然后在后面搞一搞就好了 复杂度计算：$$O(\sum_{质数p \leq \sqrt R} \frac{R-L}{p})$$然后根据什么调和级数之类的东西，$1+1/2+1/3+1/4….1/n ≈ log_2 n$所以说复杂度就大概是$O((R-L) \times log_2 \sqrt R)$ 最后提醒各位特判一下1并且数组的下标是相对位置，错了好多次123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=310;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=100000;int pr=0,prime[MAXNUM];bool v[MAXNUM];void pre()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;bool bk[1100000];int main()&#123; pre(); int l,r; while(scanf("%d%d",&amp;l,&amp;r)!=EOF) &#123; memset(bk,1,sizeof bk); if(l==1) bk[0]=0;//debug for(int i=1;i&lt;=pr;i++) for(int j=l/prime[i];j&lt;=r/prime[i];j++) if(l&lt;=j*prime[i] and j&gt;1) bk[j*prime[i]-l]=0;//debug bool two=0; int mix=0,miy=INF,mxx=0,mxy=0,lst=0; for(int i=0;i&lt;=r-l;i++) &#123; if(!bk[i]) continue; int tmp=l+i; if(lst&gt;0 and tmp-lst&lt;miy-mix) mix=lst,miy=tmp,two=1; if(lst&gt;0 and tmp-lst&gt;mxy-mxx) mxx=lst,mxy=tmp,two=1; lst=tmp; &#125; if(two) printf("%d,%d are closest, %d,%d are most distant.\n",mix,miy,mxx,mxy); else puts("There are no adjacent primes."); &#125;&#125; 2 3101 阶乘分解7.19 难度1请先思考后再展开 枚举素数p，考虑贡献，对于次幂为1，有$\frac{n}{p}$个对于次幂为t，有$\frac{n}{p^t}$个，新贡献恰好为$\frac{n}{p^t}$所以，枚举每个素数，然后以log的时间计算贡献即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=1000000;int pr=0,prime[MAXNUM];bool v[MAXNUM];void pre()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int main()&#123; pre(); int n;scanf("%d",&amp;n); for(int k=1;k&lt;=pr;k++) &#123; int tot=0; for(ll kn=prime[k];kn&lt;=n;kn*=prime[k]) tot+=n/kn; if(tot&gt;0) printf("%d %d\n",prime[k],tot); &#125;&#125; 3 HAOI2007 反素数8.6 难度2请先思考后再展开 找找反素数共有的性质吧 性质1：如果约数个数相同，根据性质，应该取最小的 性质2：素因子只有2,3,5,7,11,13,17,19,23证明：回忆约数个数公式，只与每个素数的次幂有关。如果使用更大的素因子，前面这9个中至少有一个空缺（否则超出题目范围）如果用这个空缺替换，次幂不变，会得到更小的数字，违背性质1 性质3：若将反素数表示为$2^{k_2} \times3^{k_3} \times5^{k_5} \times7^{k_7} \times11^{k_{11}} \times13^{k_{13}} \times17^{k_{17}} \times19^{k_{19}} \times23^{k_{23}}$则$k_2 \geqk_3 \geqk_5 \geqk_7 \geqk_{11} \geqk_{13} \geqk_{17} \geqk_{19} \geqk_{23} \geq0$证明：如果不递减，把某个逆序对交换后，可以得到相同约数下更小的数字，违背性质1 最后用dfs枚举一下就好了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int mxn;int mxg=1,ans=1;//最小const int p[10]=&#123;0,2,3,5,7,11,13,17,19,23&#125;;int k[10];void dfs(int now,int nowg,int num)&#123; if(num&gt;mxn) return; if(now==10) &#123; if(nowg&gt;mxg) mxg=nowg,ans=num; else if(nowg==mxg and num&lt;ans) ans=num;//debug，不能保证数字递增 return; &#125; int tmp=1; for(int i=0;i&lt;=k[now-1] and tmp&lt;=mxn and ll(num)*tmp&lt;=mxn;i++)//debug num写成now &#123; k[now]=i; dfs(now+1,nowg*(i+1),num*tmp); tmp*=p[now]; &#125;&#125;int main()&#123; scanf("%d",&amp;mxn); k[0]=30; dfs(1,1,1); printf("%d",ans);&#125; 4 CQOI2007 余数求和8.6 难度1请先思考后再展开 先化简式子$ans=\sum_{i=1}^n k-\lfloor \frac{k}{i} \rfloor \times i=nk - \sum_{i=1}^k \lfloor \frac{k}{i} \rfloor \times i$这是因为当i&gt;k时，结果就是k 然后这东西初看时线性的，还是会超时如果有经验的话，可以一眼看出用一个技巧解决详见套路集锦中枚举方法3本来不知道怎么算复杂度，反正比k小，曾经听说期望根号现在已经把书上的证明补充上去了，其实也不复杂 总之就这样枚举过去，等差数列推推式子就好了12345678910111213141516171819202122232425262728293031323334#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); ll ans=ll(n)*k; for(int i=1;i&lt;=k and i&lt;=n;)//debug 也要判n &#123; int lst=k/(k/i); if(lst&gt;n) lst=n;//debug ans-=ll(k/i)*(i+lst)*(lst-i+1)/2;//debug long long i=lst+1; &#125; printf("%lld",ans);&#125; 5 POJ3090 Visible Lattice Points8.7 难度2请先思考后再展开 先分析题目，不难发现要求的是gcd(1~n,1~n)=1的数量 那么可以直接用莫比乌斯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=1001;int prime[MAXNUM],pr=0;bool v[MAXNUM];int mu[MAXNUM];void pre()&#123; mu[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break;//mu=0 else mu[i*prime[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;MAXNUM;i++) mu[i]+=mu[i-1];&#125;int main()&#123; pre(); int T;scanf("%d",&amp;T);int ct=0; while(T--) &#123; int n;scanf("%d",&amp;n); int f1=0; for(int i=1;i&lt;=n;) &#123; int lst=n/(n/i); int F=(n/i)*(n/i); f1+=(mu[lst]-mu[i-1])*F; i=lst+1; &#125; printf("%d %d %d\n",++ct,n,2+f1); &#125;&#125; 那么我们尝试用欧拉搞一搞其实就是因为长宽相同，那么对于每一列，累加一下欧拉就好了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=1001;int prime[MAXNUM],pr=0;bool v[MAXNUM];int phi[MAXNUM];void pre()&#123; phi[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,phi[i]=i-1; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125;int main()&#123; pre(); int T;scanf("%d",&amp;T);int ct=0; while(T--) &#123; int n;scanf("%d",&amp;n); int ans=0; for(int i=2;i&lt;=n;i++) ans+=phi[i]; printf("%d %d %d\n",++ct,n,3+ans*2); &#125;&#125; 6 POJ3696 The Luckiest number8.7 难度3请先思考后再展开 x个8连在一起的数字，可以用$\frac{8}{9} (10^x-1)$表示那么题目要求$L | \frac{8}{9} (10^x-1)$等效于$9L | 8(10^x-1)$设$d=gcd(L,8)$假设条件满足，那么L中的偶因子是8的约数两边同时除以d后，左边不再有偶因子，则右边剩下的偶因子没有意义$\frac{9L}{d} | 10^x-1$转化成$10^x=1 (\mod \frac{9L}{d})$ 当$gcd(10,\frac{9L}{d})=1$时，根据中欧拉函数与欧拉定理的定理8，可枚举其约数，快速幂判断即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;ll gcd(ll x,ll y) &#123;return (y==0)?x:gcd(y,x%y);&#125;ll qmul(ll a,ll e,ll Mod)&#123; ll ans=0; while(e&gt;0) &#123; if(e&amp;1) ans=(ans+a)%Mod; e&gt;&gt;=1;a=(a+a)%Mod; &#125; return ans;&#125;ll qpower(ll a,ll e,ll Mod)&#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=qmul(ans,a,Mod); e&gt;&gt;=1;a=qmul(a,a,Mod); &#125; return ans;&#125;ll getphi(ll tmp)&#123; ll phi=tmp; for(ll i=2;i*i&lt;=tmp;i++) if(tmp%i==0) &#123; while(tmp%i==0) tmp/=i; phi=phi/i*(i-1);//debug phi*(i-1)/i 这里可能爆 &#125; if(tmp&gt;1) phi=phi/tmp*(tmp-1);//debug return phi;&#125;int main()&#123; int ct=0; while(1) &#123; int L;scanf("%d",&amp;L); if(L==0) break; printf("Case %d: ",++ct); ll tmp=(ll)L*9/gcd(L,8); if(gcd(10,tmp)==1) &#123; ll phi=getphi(tmp); ll ans=phi; for(ll i=1;i*i&lt;=phi;i++) if(phi%i==0) &#123; if(i&lt;ans and qpower(10,i,tmp)==1) ans=i; if(i*i!=phi and phi/i&lt;ans and qpower(10,phi/i,tmp)==1) ans=phi/i; &#125; printf("%lld\n",ans); &#125; else puts("0"); &#125;&#125; 7 bzoj2973 1801 石头游戏8.10 难度1请先思考后再展开 脑残题但是题目居然不说清楚：如果操作违法，要把它丢掉还有就是一些sb错误，耽误了一个早上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; typedef unsigned long long ull; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int n,m; struct Matrix &#123; ll a[100][100]; Matrix() &#123; memset(a,0,sizeof a); &#125; &#125;; Matrix pre() &#123; Matrix ans; for(int i=1;i&lt;=90;i++) ans.a[i][i]=1; return ans; &#125; Matrix cheng(Matrix a,Matrix b) &#123; Matrix c; for(int i=1;i&lt;=90;i++) for(int j=1;j&lt;=90;j++) for(int k=1;k&lt;=90;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j]; return c; &#125; Matrix qpower(Matrix a,int e) &#123; Matrix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans; &#125; int gcd(int a,int b) &#123;return (b==0)?a:gcd(b,a%b);&#125; int lcm(int a,int b) &#123;return a/gcd(a,b)*b;&#125; Matrix op[100]; int calc(int x,int y) &#123;return (x-1)*m+y;&#125; void main() &#123; int ti,act;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;ti,&amp;act); char mp[10][10]; for(int i=1;i&lt;=n;i++) scanf("%s",mp[i]+1); int tlen=1; char oper[10][10];int oplen[10]; for(int i=0;i&lt;=act-1;i++) &#123; scanf("%s",oper[i]+1); oplen[i]=strlen(oper[i]+1); tlen=lcm(tlen,oplen[i]); &#125; int now[10];for(int i=0;i&lt;=act-1;i++) now[i]=1;//debug 忘记初始化 Matrix all=pre(); for(int s=1;s&lt;=tlen;s++) &#123; op[s]=pre(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; int id=mp[i][j]-'0',t=now[id]; if(isdigit(oper[id][t])) op[s].a[calc(i,j)][n*m+1]=oper[id][t]-'0'; else if(oper[id][t]=='D') op[s].a[calc(i,j)][calc(i,j)]=0; else//推 &#123; op[s].a[calc(i,j)][calc(i,j)]=0; int nx=i,ny=j; if(oper[id][t]=='N') nx--;if(oper[id][t]=='S') nx++; if(oper[id][t]=='W') ny--;if(oper[id][t]=='E') ny++; if(1&lt;=nx and nx&lt;=n and 1&lt;=ny and ny&lt;=m) op[s].a[calc(nx,ny)][calc(i,j)]=1; &#125; &#125; all=cheng(op[s],all); for(int i=0;i&lt;=act-1;i++) if( (++now[i])==oplen[i]+1) now[i]=1;//debug 本来写(++now[i])==oplen[i] &#125; Matrix st;st.a[n*m+1][1]=1; Matrix tmp=pre();for(int s=ti%tlen;s&gt;=1;s--) tmp=cheng(tmp,op[s]); st=cheng( cheng(tmp,qpower(all,ti/tlen)) ,st); ll ans=0; for(int i=1;i&lt;=n*m;i++) if(st.a[i][1]&gt;ans) ans=st.a[i][1]; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 8 JSOI2008 球形空间产生器8.10 难度2请先思考后再展开 先推推式子如果把n+1个点，与球心的距离表示出来，会得出一个多元二次方程组为了变成一次，考虑把相邻的相减$\sum (a_{i,j}-x_j)^2-(a_{i+1,j}-x_j)^2=0$$\sum 2(a_{i+1,j}-a_{i,j})x_j=\sum a_{i+1,j}^2-a_{i,j}^2$然后高斯消元就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; double myabs(double x) &#123;return x&gt;0?x:-x;&#125; const double eps=1e-8; const int MAXN=20; double p[MAXN][MAXN]; double a[MAXN][MAXN],b[MAXN];//系数、常数 void gauss(int n) &#123; for(int i=1;i&lt;=n;i++)//目标为xi &#123; int nx=-1; for(int j=i;j&lt;=n;j++) if(myabs(a[j][i])&gt;eps) &#123;nx=j;break;&#125; if(nx&lt;0) continue; swap(b[i],b[nx]);for(int k=1;k&lt;=n;k++) swap(a[i][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j) continue; double t=a[j][i]/a[i][i];//确保分母不为0 b[j]-=b[i]*t;for(int k=i;k&lt;=n;k++) a[j][k]-=a[i][k]*t; &#125; &#125; &#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++) scanf("%lf",&amp;p[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; a[i][j]=2*(p[i+1][j]-p[i][j]); b[i]+=p[i+1][j]*p[i+1][j]-p[i][j]*p[i][j]; &#125; gauss(n); for(int i=1;i&lt;=n;i++) printf("%.3lf ",b[i]/a[i][i]); &#125;&#125;;int main()&#123; mine::main();&#125; 9 POJ1830 开关问题8.10 难度2请先思考后再展开 如果把异或看做是不进位的加法，那么就很好理解了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=40; int n; int p[MAXN][MAXN]; int a[MAXN][MAXN],b[MAXN];//系数、常数 bool iszero(int i) &#123; for(int j=1;j&lt;=n;j++) if(a[i][j]&gt;0) return 0; return 1; &#125; int gauss() &#123; for(int i=1;i&lt;=n;i++) &#123; int nx=-1; for(int j=i;j&lt;=n;j++) if(a[j][i]&gt;0) &#123;nx=j;break;&#125; if(nx&lt;0) continue; swap(b[i],b[nx]);for(int k=1;k&lt;=n;k++) swap(a[i][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(i==j or !a[j][i]) continue; b[j]^=b[i];for(int k=i;k&lt;=n;k++) a[j][k]^=a[i][k]; &#125; &#125; int tot=0;//主元 for(int i=1;i&lt;=n;i++) if(!iszero(i)) tot++; else if(b[i]!=0) return -1; return 1&lt;&lt;(n-tot); &#125; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(a,0,sizeof a); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i][i]=1,scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123;int t;scanf("%d",&amp;t);b[i]^=t;&#125; while(1) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(x==0 and y==0) break; a[y][x]=1;//debug 要反过来 &#125; int ans=gauss(); if(ans&gt;0) printf("%d\n",ans); else puts("Oh,it's impossible~!!"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 10 JLOI2015 装备购买8.11 难度2请先思考后再展开 卡精度，要开long double所以决定以后无脑long double了hh 为了做第二问，贪心地每次找最小的作为主元证明不会，但是我构造不出反例本来以为找到一个：3 23 04 45 02 1 3但其实，经过消元，第一行不会是0如果非要是0，那么第二行一定是第一行的倍数，则也能反过来……（感觉我表述得乱七八糟，意会一下吧）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; #define double long double double myabs(double x) &#123;return x&gt;0?x:-x;&#125; const double eps=1e-8; int n,m; double a[510][510],c[510]; int tot=0;double sum=0; void gauss() &#123; for(int i=1;i&lt;=m;i++) &#123; int nx=-1; for(int j=tot+1;j&lt;=n;j++) if(myabs(a[j][i])&gt;eps) if(nx&lt;0 or c[nx]&gt;c[j]) nx=j; if(nx&lt;0) continue; tot++;sum+=c[nx]; for(int k=1;k&lt;=m;k++) swap(a[tot][k],a[nx][k]); swap(c[tot],c[nx]);//debug 漏了 for(int j=1;j&lt;=n;j++) &#123; if(tot==j or myabs(a[j][i])&lt;=eps) continue; double t=a[j][i]/a[tot][i]; for(int k=i;k&lt;=m;k++) a[j][k]-=a[tot][k]*t; &#125; &#125; &#125; void main() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%Lf",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) scanf("%Lf",&amp;c[i]); gauss(); printf("%d %.0Lf",tot,sum); &#125;&#125;;int main()&#123; mine::main();&#125; 11 Hdu3949 XOR8.11 难度2请先思考后再展开 key：高斯消元后，得到的简化阶梯形矩阵，具有一个重要的性质————对于主元i，该列上唯一的1在这上面所以说，在其他相同的情况下，选i一定比不选要大所以说，可以把k按二进制拆分，按位，对应于要不要选择第i行 细节：注意0，线性基可以通过【自己异或自己】得出，但本题不行所以说特判一下最后的矩阵，就好了，具体自己分析 最后补充一下【异或线性基组合出来的数（即span张成）互不相同】的证明：假设有一个式子，左右两边都是异或出来的数字，把左边留下某一个，其他移项到右边，那么出现，那个数字能被其他数字表示出，则违反线性基定义 顺便说说异或能移项的证明：把两边同时异或那个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll bin[70]; int n; bool zero; ll a[11000]; int tot;//线性基长度 void gauss() &#123; zero=0;tot=0; for(int i=60;i&gt;=0;i--) &#123; int nx=tot+1; while( !(a[nx]&amp;bin[i]) and nx&lt;=n ) nx++; if(nx&gt;n) continue; tot++;swap(a[tot],a[nx]); for(int k=1;k&lt;=n;k++) if(k!=tot and a[k]&amp;bin[i]) a[k]^=a[tot]; &#125; if(tot&lt;n) zero=1; &#125; ll solve() &#123; ll k;scanf("%lld",&amp;k); if(zero) k--;//能产生0时，k=1得0，k=2得最小 if(k&gt;bin[tot]-1) return -1;//去除【什么都不选的情况】 ll ans=0; for(int i=0;i&lt;=tot-1;i++) if(k&amp;bin[i]) ans^=a[tot-i]; return ans; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=60;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); for(int ct=1;ct&lt;=T;ct++) &#123; printf("Case #%d:\n",ct); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); gauss(); int q;scanf("%d",&amp;q); while(q--) printf("%lld\n",solve()); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 12 3602 Counting Swaps8.13 难度3请先思考后再展开 多重集组合数 假如写出前面的几个数（谁会这样啊……都退出式子了，也好像化简不出什么）：1,1,3,16,125会发现$s[n]=n^{n-2}$ 对于k个长度分别为l1,l2,…,lk的环$ans=\prod s[l_1]*s[l_2]*…*s[l_k]*\frac{(n-k)!}{(l_1-1)!(l_2-1)!…(l_k-1)!}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=110000; const int MOD=1e9+9; ll fac[MAXN]; ll qpower(ll a,int e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*a%MOD; a=a*a%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123; x=1;y=0; return a; &#125; ll tx,ty; ll d=exgcd(b,a%b,tx,ty); x=ty; y=tx-(a/b)*ty; return d; &#125; ll inv(ll a) &#123; ll x,y; exgcd(a,MOD,x,y); return (x%MOD+MOD)%MOD; &#125; int p[MAXN]; bool v[MAXN]; int getsiz(int x) &#123; int now=p[x],tot=1; v[x]=1; while(now!=x) &#123; v[now]=1; tot++; now=p[now]; &#125; return tot; &#125; void main() &#123; fac[0]=1;for(int i=1;i&lt;MAXN;i++) fac[i]=fac[i-1]*i%MOD; int T;scanf("%d",&amp;T); while(T--) &#123; memset(v,0,sizeof v); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i]); ll ans=1;int tot=0; for(int i=1;i&lt;=n;i++) if(!v[i]) &#123; int l=getsiz(i);tot++; ans=ans*qpower(l,l-2)%MOD; ans=ans*inv(fac[l-1])%MOD; &#125; printf("%lld\n",ans*fac[n-tot]%MOD); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 13 CF451E Devu and Flowers8.16 难度2请先思考后再展开 多重集组合数裸题，讲解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll MOD=1e9+7; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; ll C(ll m,ll n)//O(m) &#123; if(m&lt;0 or n&lt;0 or m&gt;n) return 0; ll ans=1; for(ll t=n;t&gt;=n-m+1;t--) ans=ans*(t%MOD)%MOD; ll s=1;for(ll t=2;t&lt;=m;t++) s=s*t%MOD; return ans*inv(s)%MOD; &#125; ll a[30]; int bin[30]; void main() &#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;ll m;scanf("%d%I64d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%I64d",&amp;a[i]); ll ans=0; for(int s=0;s&lt;=bin[n]-1;s++) &#123; int num=0; ll M=n-1,N=(ll)n-1+m;//debug n转longlong for(int i=0;i&lt;=n-1;i++) if(s&amp;bin[i]) N-=a[i+1]+1,num++;//debug a[i] if(num&amp;1) ans-=C(M,N); else ans+=C(M,N); ans%=MOD; &#125; printf("%I64d",(ans+MOD)%MOD); &#125;&#125;;int main()&#123; mine::main();&#125; 14 POI2007 ZAP-Queries8.16 难度1请先思考后再展开 莫比乌斯裸题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXNUM=51000; bool v[MAXNUM]; int pr=0,prime[MAXNUM]; int mu[MAXNUM]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; for(int i=2;i&lt;MAXNUM;i++) mu[i]+=mu[i-1]; &#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; void main() &#123; pre(); int q;scanf("%d",&amp;q); while(q--) &#123; int a,b,d;scanf("%d%d%d",&amp;a,&amp;b,&amp;d); int n=a/d,m=b/d;if(n&gt;m) swap(n,m); ll ans=0; for(ll d=1;d&lt;=n;) &#123; int lst=mymin(n/(n/d),m/(m/d)); ans+=ll(mu[lst]-mu[d-1])*(n/d)*(m/d); d=lst+1; &#125; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 15 3801 Rainbow的信号8.16 难度2请先思考后再展开 求期望位运算的特性在于，不同的二进制位之间没有影响所以为了方便统计，先枚举每一个位，然后分类讨论 线性枚举r①and如果出现了0，就是0那么最后一个0把前面l的取值范围分成两半，其中只有后面的部分有贡献所以记录一下lst0②or如果出现1，就是1和and同理，记录lst1③xor这个稍微麻烦一些，因为取值涉及到1出现个数的奇偶性那么把按照1的出现次数，分奇偶，形成交替的区间那么只有贡献为奇数的区间是有用的用c0、c1分别记录偶数区间和奇数区间的总长度即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; #define double long double int bin[40]; int a[110000]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); double xor1=0,and1=0,or1=0; for(int k=0;k&lt;=29;k++) &#123; int lst0=0,lst1=0;//上一个 int c1=0,c0=0;//奇偶区间 for(int r=1;r&lt;=n;r++) &#123; int now=a[r]&amp;bin[k]; //l=r if(now) xor1+=bin[k],and1+=bin[k],or1+=bin[k]; //l&lt;r if(now) &#123; xor1+=2.0*c0*bin[k]; and1+=2.0*(r-lst0-1)*bin[k];//lst0+1~r or1+=2.0*(r-1)*bin[k];//1~lst1 &#125; else &#123; xor1+=2.0*c1*bin[k]; or1+=2.0*lst1*bin[k];//1~lst1 &#125; //update if(now) lst1=r; else lst0=r; if(now) swap(c1,c0),c1++; else c0++; &#125; &#125; printf("%.3Lf %.3Lf %.3Lf",xor1/n/n,and1/n/n,or1/n/n); &#125;&#125;;int main()&#123; mine::main();&#125; 16 3802 绿豆蛙的归宿8.16 难度2请先思考后再展开 期望的线性性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; const int MAXN=110000,MAXM=210000; struct Nod &#123; int hou; int ru; int backup; Nod() &#123; hou=ru=0; &#125; &#125;p[MAXN]; struct Edge &#123; int y,c,g; &#125;e[MAXM]; int ln=0; void ins(int x,int y,int c) &#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; p[y].ru++; &#125; double E[MAXM]; int sta[MAXN]; void topsort(int st) &#123; int top=0;sta[++top]=st; while(top&gt;0) &#123; int x=sta[top--]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; p[y].ru--; E[y]+=(E[x]+e[k].c)/p[y].backup; if(!p[y].ru) sta[++top]=y; &#125; &#125; &#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(b,a,c); &#125; for(int i=1;i&lt;=n;i++) p[i].backup=p[i].ru; topsort(n); printf("%.2lf",E[1]); &#125;&#125;;int main()&#123; mine::main();&#125; 17 3803 扑克牌8.16 难度2请先思考后再展开 本来写的是倒着dp，好像被卡边界了结果tm改成记忆化搜索就过了？？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125; int A,B,C,D; double f[20][20][20][20][5][5]; bool v[20][20][20][20][5][5]; double dp(int a,int b,int c,int d,int x,int y) &#123; if(v[a][b][c][d][x][y]) return f[a][b][c][d][x][y]; v[a][b][c][d][x][y]=1; double &amp;ans=f[a][b][c][d][x][y]; int aa=a+(x==1)+(y==1),bb=b+(x==2)+(y==2),cc=c+(x==3)+(y==3),dd=d+(x==4)+(y==4); if(aa&gt;=A and bb&gt;=B and cc&gt;=C and dd&gt;=D) return ans=0; int left=54-aa-bb-cc-dd; if(a&lt;13) ans+=(dp(a+1,b,c,d,x,y)+1)*(13-a)/left; if(b&lt;13) ans+=(dp(a,b+1,c,d,x,y)+1)*(13-b)/left; if(c&lt;13) ans+=(dp(a,b,c+1,d,x,y)+1)*(13-c)/left; if(d&lt;13) ans+=(dp(a,b,c,d+1,x,y)+1)*(13-d)/left; if(x==0) &#123;double mi=1000;for(int i=1;i&lt;=4;i++) &#123;mi=mymin(mi,dp(a,b,c,d,i,y));&#125;ans+=(mi+1)/left;&#125; if(y==0) &#123;double mi=1000;for(int i=1;i&lt;=4;i++) &#123;mi=mymin(mi,dp(a,b,c,d,x,i));&#125;ans+=(mi+1)/left;&#125; return ans; &#125; void main() &#123; scanf("%d%d%d%d",&amp;A,&amp;B,&amp;C,&amp;D); int p1=(A&gt;13)?A-13:0,p2=(B&gt;13)?B-13:0,p3=(C&gt;13)?C-13:0,p4=(D&gt;13)?D-13:0; if(p1+p2+p3+p4&gt;2) puts("-1.000"); else printf("%.3lf",dp(0,0,0,0,0,0)); &#125;&#125;;int main()&#123; mine::main();&#125; 18 POJ2311 Cutting Game8.17 难度2请先思考后再展开 博弈不过，如果出现(1,1)，并定义为必败态，本身没有问题但考虑只有一行或一列的情况，会把两个有向图游戏异或起来，然后对方就会“努力翻盘”，导致本来游戏早就结束，却被“莫名其妙翻盘了”所以要跳过这些状态，并早点判断出必败态：(2,2)和(2,3)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int sg[210][210]; bool v[210][210]; bool b[410];//每次产生不同，最多只有400个 int SG(int n,int m) &#123; if(n&gt;m) swap(n,m); if(v[n][m]) return sg[n][m]; v[n][m]=1; if(n==1 and m==1) return sg[n][m]=0; //if(n==2 and m==2) return sg[n][m]=0; //if(n==2 and m==3) return sg[n][m]=0; memset(b,0,sizeof b); for(int k=2;k&lt;=n-2;k++) b[ SG(k,m)^SG(n-k,m) ]=1; for(int k=2;k&lt;=m-2;k++) b[ SG(n,k)^SG(n,m-k) ]=1; int now=0;while(b[now]) now++; return sg[n][m]=now; &#125; void main() &#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; if(SG(n,m)&gt;0) puts("WIN"); else puts("LOSE"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 0x3B 数学练习题目 19 SDOI2012 Longge的问题8.17 难度2请先思考后再展开 按照反素数的思路，只考虑前面几个素数，按照约数个数公式dfs最终得出，在int范围内约数最多约1500个 那么，如果枚举约数s，把它作为gcd的结果$\sum s \times 【gcd(1 \to n,n)=s的个数】$$\sum s \times 【gcd(1 \to n/s)=1的个数】$$\sum s \times \varphi (n/s)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll phi(ll x) &#123; ll ans=x; for(ll t=2;t*t&lt;=x;t++) &#123; if(x%t!=0) continue; while(x%t==0) x/=t; ans=ans/t*(t-1); &#125; if(x&gt;1) ans=ans/x*(x-1); return ans; &#125; void main() &#123; ll n;scanf("%lld",&amp;n); ll ans=0; for(ll k=1;k*k&lt;=n;k++) &#123; if(n%k!=0) continue; ans+=k*phi(n/k); if(k*k!=n) ans+=n/k*phi(k); &#125; printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 20 bzoj1477 POJ1061 青蛙的约会8.17 难度1请先思考后再展开 同余方程组裸题t(n-m)+kL=x-y1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; void main() &#123; ll x,y,m,n,L;scanf("%lld%lld%lld%lld%lld",&amp;x,&amp;y,&amp;m,&amp;n,&amp;L); ll A=n-m,B=L,K=x-y; ll tx,ty; ll d=exgcd(A,B,tx,ty);//t(n-m)+kL=x-y if(K%d!=0) puts("Impossible"); else &#123; tx=tx*(K/d); ll t=B/d; printf("%lld",(tx%t+t)%t); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 21 3B04 Xiao 9*大战朱最学8.17 难度1请先思考后再展开 同余方程组裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; void main() &#123; int n;scanf("%d",&amp;n); ll a1,b1;scanf("%lld%lld",&amp;a1,&amp;b1); for(int i=2;i&lt;=n;i++) &#123; ll a2,b2;scanf("%lld%lld",&amp;a2,&amp;b2); ll A=a1,B=a2,K=b2-b1; ll k1,k2;ll d=exgcd(A,B,k1,k2); k1=k1*(K/d); ll t=B/d;k1=(k1%t+t)%t; b1=k1*a1+b1; a1=a1*a2; &#125; printf("%lld",b1); &#125;&#125;;int main()&#123; mine::main();&#125; 22 SDOI2011 计算器8.17 难度2请先思考后再展开 裸题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll qpower(ll x,ll e,ll MOD) &#123; ll ans=1;x%=MOD; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123;x=1,y=0;return a;&#125; ll tx,ty;ll d=exgcd(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d; &#125; void solve2(ll A,ll B,ll K) &#123; ll x,y;ll d=exgcd(A,B,x,y); if(K%d!=0) puts("Orz, I cannot find x!"); else &#123; x*=(K/d); ll t=B/d; printf("%lld\n",(x%t+t)%t); &#125; &#125; map&lt;ll,ll&gt; hash; void solve3(ll A,ll z,ll MOD) &#123; if(A%MOD==0) &#123;puts("Orz, I cannot find x!");return;&#125;//debug A%=MOD;z%=MOD; hash.clear(); ll t=ceil(sqrt( (double)MOD )); ll now=z;for(ll b=0;b&lt;=t;b++) hash[now]=b,now=now*A%MOD; ll tmp=qpower(A,t,MOD); now=tmp; for(ll a=1;a&lt;=t;a++) &#123; if(hash.count(now)) &#123;printf("%lld\n",a*t-hash[now]);return;&#125; now=now*tmp%MOD; &#125; puts("Orz, I cannot find x!"); &#125; void main() &#123; int T,k;scanf("%d%d",&amp;T,&amp;k); while(T--) &#123; ll y,z,p;scanf("%lld%lld%lld",&amp;y,&amp;z,&amp;p); if(k==1) printf("%lld\n",qpower(y,z,p)); else if(k==2) solve2(y,p,z); else solve3(y,z,p); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 23 HDU5015 233 Matrix8.17 难度1请先思考后再展开 矩阵乘法裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const ll MOD=10000007; struct Matrix &#123; ll a[30][30]; Matrix() &#123;memset(a,0,sizeof a);&#125; &#125;; const int N=20; Matrix pre() &#123; Matrix ans; for(int i=0;i&lt;=N;i++) ans.a[i][i]=1; return ans; &#125; Matrix cheng(Matrix a,Matrix b) &#123; Matrix ans; for(int i=0;i&lt;=N;i++) for(int j=0;j&lt;=N;j++) for(int k=0;k&lt;=N;k++) ans.a[i][j]=(ans.a[i][j]+a.a[i][k]*b.a[k][j]%MOD)%MOD; return ans; &#125; Matrix qpower(Matrix x,int e) &#123; Matrix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,x); x=cheng(x,x);e&gt;&gt;=1; &#125; return ans; &#125; void main() &#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; Matrix st;st.a[0][0]=0; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;st.a[i][0]); st.a[++n][0]=233;st.a[++n][0]=1; Matrix op; for(int i=0;i&lt;=n-2;i++) &#123; for(int j=1;j&lt;=i;j++) op.a[i][j]=1; op.a[i][n-1]=1; &#125; op.a[n-1][n-1]=10;op.a[n-1][n]=3;//233=&gt;2333 op.a[n][n]=1;//1=&gt;1 st=cheng(qpower(op,m),st); printf("%lld\n",st.a[n-2][0]); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 24 POJ2947 Widget Factory8.18 难度1请先思考后再展开 带模数的高斯消元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int qpower(int x,int e,int MOD) &#123; int ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; int inv(int x,int MOD) &#123;return qpower(x,MOD-2,MOD);&#125; int a[310][310],b[310],MOD=7; bool iszero(int x,int m) &#123; for(int i=1;i&lt;=m;i++) if(a[x][i]) return 0; return 1; &#125; void gauss(int n,int m) &#123; int tot=0; for(int i=1;i&lt;=m;i++)//目标 &#123; int nx=-1; for(int j=tot+1;j&lt;=n;j++) if(a[j][i]) &#123;nx=j;break;&#125; if(nx&lt;0) continue; tot++;swap(b[tot],b[nx]);for(int k=1;k&lt;=m;k++) swap(a[tot][k],a[nx][k]); for(int j=1;j&lt;=n;j++) &#123; if(tot==j or !a[j][i]) continue; int x=a[j][i],y=a[tot][i]; for(int k=1;k&lt;=m;k++) &#123; a[tot][k]=a[tot][k]*x%MOD; a[j][k]=a[j][k]*y-a[tot][k]; a[j][k]=(a[j][k]%MOD+MOD)%MOD; &#125; b[tot]=b[tot]*x%MOD; b[j]=b[j]*y%MOD-b[tot]; b[j]=(b[j]%MOD+MOD)%MOD; &#125; &#125; for(int i=1;i&lt;=n;i++) if(iszero(i,m) and b[i]!=0) &#123;puts("Inconsistent data.");return;&#125; if(tot!=m) &#123;puts("Multiple solutions.");return;&#125; for(int i=1;i&lt;=m-1;i++) &#123;int t=b[i]*inv(a[i][i],MOD)%MOD;printf("%d ",t&gt;=3?t:t+7);&#125; int t=b[m]*inv(a[m][m],MOD)%MOD;printf("%d\n",t&gt;=3?t:t+7);//debug 题目条件，3~9 &#125; char s[20]; int getday() &#123; scanf("%s",s+1); if(s[1]=='M') return 1;//MON if(s[3]=='E') return 2;//TUE if(s[1]=='W') return 3;//WED if(s[2]=='H') return 4;//THU if(s[1]=='F') return 5;//FRI if(s[2]=='A') return 6;//SAT return 7; &#125; void main() &#123; while(1) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==0 and m==0) break; memset(a,0,sizeof a);//debug for(int i=1;i&lt;=m;i++) &#123; int k;scanf("%d",&amp;k); int t1=getday(),t2=getday(); b[i]=((t2-t1+1)%MOD+MOD)%MOD; while(k--) &#123; int t;scanf("%d",&amp;t); a[i][t]=(a[i][t]+1)%MOD; &#125; &#125; gauss(m,n); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 25 WC2011 最大XOR和路径8.18 难度2请先思考后再展开 这道神题的关键在于 利用异或的抵消性质当然交换、结合律也稍微要用到 对于一个路径，其实就是由链和在上面重叠的环组成这样以后，你会发现，能对最终答案产生影响的就是一条链和几个环因为对于重叠的部分或者为了到达环而经过的边（如果原路返回）被自己抵消了因为这是一个无向图，如果有多条可选的链，而最优的不是这一条，那当前这一条和它组成了一个环，所以说枚举环的时候异或一下，自己就又被抵消了，变成了那条链 所以说，随便找一个链，找一些环放上去，让异或和最大想到异或和会想到线性基那怎么找环呢？dfs去找不难想到，但枚举起点复杂度过高其实直接从1开始就好了，对于一个结束的环，可以把当前值异或从起点到这里的代价这样又抵消掉了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=51000; ll bin[61]; ll bs[61]; void insert(ll now) &#123; for(int i=60;i&gt;=0;i--) if(now&amp;bin[i]) &#123; if(bs[i]&lt;0) &#123; bs[i]=now; for(int j=60;j&gt;i;j--) if(bs[j]&amp;bin[i]) bs[j]^=now;//回代 break; &#125; else now^=bs[i]; &#125; &#125; struct Nod &#123; int hou; bool v; ll sum; Nod() &#123; hou=0; sum=0; v=0; &#125; &#125;p[MAXN]; struct Edge &#123; int y,g; ll c; &#125;e[MAXN*4]; int ln=0; void ins(int x,int y,ll c) &#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; &#125; void dfs(int x,ll now) &#123; p[x].v=1;p[x].sum=now; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].v) insert(now^e[k].c^p[y].sum); else dfs(y,now^e[k].c); &#125; &#125; ll solve(ll now) &#123; for(int i=60;i&gt;=0;i--) if(bs[i]&gt;=0 and (now^bs[i])&gt;now) now=now^bs[i]; return now; &#125; void main() &#123; bin[0]=1;for(int i=1;i&lt;=60;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;ll c;scanf("%d%d%lld",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; memset(bs,-1,sizeof bs); dfs(1,0); printf("%lld",solve(p[n].sum)); &#125;&#125;;int main()&#123; mine::main();&#125; 26 CQOI2013 新Nim游戏8.19 难度2请先思考后再展开 根据博弈的基本知识，普通nim游戏在异或和=0的时候必败，否则必胜那么只要能确保后手无法在第二回合把异或和变成0，那么就胜利 异或和基本上就和线性基有关了，主要是因为，对于异或线性基，其异或空间除了0，其他的表示方法中每个元素最多用一次 什么情况下，能够把异或和变成0？就是在某一次插入x中，发现无法插入因为这意味着，里面的东西能够表示出x这个时候，当前线性基 xor x=0，后手只要把后面取走就好了我们的应对策略是把x取走（因为线性基内部，无法表示出0，否则违背定义） 那怎么求第一问，让取走的东西总数最小呢？有一个精妙的贪心：按照从大到小考虑这个可以用微扰证明，如果某个位置能用小也能用大，我们用了大，不会让答案更差，因为线性基能否插入和其他位置无关1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; int bin[40]; int bs[40]; bool insert(int now) &#123; for(int i=40;i&gt;=0;i--) if(now&amp;bin[i]) &#123; if(bs[i]&lt;0) &#123;bs[i]=now;return 1;&#125; now^=bs[i]; &#125; return 0; &#125; int a[110]; void main() &#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; memset(bs,-1,sizeof bs); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); ll ans=0,sum=0; for(int i=n;i&gt;=1;i--) &#123; sum+=a[i]; if(!insert(a[i])) ans+=a[i]; &#125; if(ans==sum) puts("-1"); else printf("%lld",ans); &#125;&#125;;int main()&#123; mine::main();&#125; Sdoi2016 排列计数8.29 难度2请先思考后再展开 同学提醒这道题漏掉了……所以就没有编号了 把其中m个固定后，剩下的就是错排发现题目要求的是$C_n^m \times D_{n-m}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=1100000; const ll INF=0x3f3f3f3f; const ll MOD=1e9+7; ll fac[MAX_N]; ll D[MAX_N]; ll qpower(ll x,ll e) &#123; ll ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x) &#123;return qpower(x,MOD-2);&#125; ll C(int n,int m) &#123;return fac[n]*inv(fac[m])%MOD*inv(fac[n-m])%MOD;&#125; void main() &#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; D[0]=1;D[1]=0;D[2]=1;for(int i=3;i&lt;MAX_N;i++) D[i]=(D[i-1]+D[i-2])%MOD*(i-1)%MOD; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",C(n,m)*D[n-m]%MOD); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 27 POJ3904 Sky Code8.20 难度1请先思考后再展开 莫反裸题一开始没想到F(d)那么好求……复杂度$O(n \sqrt n)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; ll C(ll n)//C(4,n) &#123; return n*(n-1)*(n-2)*(n-3)/24; &#125; const int MAXNUM=11000; bool v[MAXNUM]; int pr=0,prime[MAXNUM]; int mu[MAXNUM]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and (ll)i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; &#125; int fd[MAXNUM]; void main() &#123; pre(); int n; while(scanf("%d",&amp;n)!=EOF) &#123; memset(fd,0,sizeof fd); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); for(int j=1;j*j&lt;=t;j++) &#123; if(t%j!=0) continue; fd[j]++; if(j*j!=t) fd[t/j]++; &#125; &#125; ll ans=0; for(int i=1;i&lt;=10000;i++) ans+=mu[i]*C(fd[i]); printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 28 3B13/CF167B/bzoj4636 守卫者的挑战8.20 难度1请先思考后再展开 概率dp裸题但是有很多细节，中文题目不是很清楚 必须n个都尝试过，最后再离开 某一时刻可以装不下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; double f[210][210][410]; //f(i,vec,k)=【i次开始之前，赢了vec次，当前背包剩余空间为k-200】的概率 int p[210],a[210]; void main() &#123; int n,L,K;scanf("%d%d%d",&amp;n,&amp;L,&amp;K); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); if(K&gt;200) K=200;//debug f[1][0][200+K]=1; for(int i=1;i&lt;=n;i++) for(int vec=0;vec&lt;=i-1;vec++) for(int bg=-200;bg&lt;=200;bg++) &#123; f[i+1][vec+1][200+mymin(bg+a[i],200)]+=f[i][vec][200+bg]*p[i]/100; f[i+1][vec][200+bg]+=f[i][vec][200+bg]*(100-p[i])/100;//fail &#125; double ans=0; for(int i=L;i&lt;=n;i++) for(int j=0;j&lt;=200;j++) ans+=f[n+1][i][200+j]; printf("%.6lf",ans); &#125;&#125;;int main()&#123; mine::main();&#125; 29 POJ2976 Dropping tests8.20 难度2请先思考后再展开 01分数规划裸题浮点二分果然练得还是太少了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; const int MAXN=1100; const double eps=1e-4; int n,k; ll a[MAXN],b[MAXN]; double tmp[MAXN]; bool check(double L) &#123; for(int i=1;i&lt;=n;i++) tmp[i]=(double)a[i]-L*b[i]; sort(tmp+1,tmp+n+1); double sum=0; for(int i=k+1;i&lt;=n;i++) sum+=tmp[i]; return sum&gt;=0; &#125; void main() &#123; while(1) &#123; scanf("%d%d",&amp;n,&amp;k);if(n==0 and k==0) break; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]),a[i]*=100; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;b[i]); double l=0,r=100,ans=-1; while(l&lt;=r+eps)//l&lt;r &#123; double mid=(l+r)/2; if(check(mid)) ans=mid,l=mid+eps; else r=mid-eps; &#125; printf("%d\n",int(round(ans))); &#125; &#125;&#125;;int main()&#123; mine::main();&#125; 30 POJ1704 Georgia and Bob8.20 难度2请先思考后再展开 这是一道传说中的阶梯博弈其实就是转化为nim游戏 首先，把两堆石子两两捆绑（奇数堆的时候，把第1堆和边界0捆绑）然后如果每组石子内部，后面的向前移，最多移动就是空格数量所以如果不考虑前面那个的移动情况，就是一个nim游戏 所以对于先手，如果他是赢家，一定按照nim来这个时候如果后手突然移动前面，那么先手把后面那个等距离向前移动，就能还原出相同局面，而且一定能实现而如果先手是输家，那么和上面同理无法改变结局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; int sg[11000]; bool v[11000]; bool b[11000]; int SG(int x) &#123; if(v[x]) return sg[x]; v[x]=1; memset(b,0,sizeof b); for(int y=0;y&lt;=x-1;y++) b[SG(y)]=1; int now=0;while(b[now]) now++; return sg[x]=now; &#125; int a[1100]; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); int now=0; if(n%2==1) &#123; for(int i=1;i&lt;=n;i+=2) now^=SG(a[i]-a[i-1]-1); &#125; else &#123; for(int i=2;i&lt;=n;i+=2) now^=SG(a[i]-a[i-1]-1); &#125; if(now&gt;0) puts("Georgia will win"); else puts("Bob will win"); &#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷18年7月月赛比赛总结]]></title>
    <url>%2Fposts%2Fb37c.html</url>
    <content type="text"><![CDATA[洛谷18年7月月赛比赛总结题目 比赛经历先把第一题做了然后第二题wa了几次，蹲坑的时候忽然灵光一现想到了漏洞……然后就挂机了……和以前没什么区别 T1_Analysis请先思考后再展开 先离散化一下，统计每个数出现个数如果剩下一个的时候，判断素数即可 看了题解发现原来我的代码是有漏洞的没有考虑，最后没有数字的情况（没有把t初始化为1），然后居然ac了 T1_Code_原请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;bool isprime(ll x)&#123; if(x&lt;=1) return 0; if(x==2) return 1; for(ll i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1;&#125;struct Nod&#123; ll d; int p;&#125;a[MAXN*2],b[MAXN*2];bool cmp(Nod x,Nod y) &#123;return x.d&lt;y.d;&#125;ll yz[MAXN*2];//oldint mx;int n,m;void lsh()&#123; memcpy(b,a,sizeof a); sort(b+1,b+n+m+1,cmp); mx=1;yz[mx]=b[1].d;a[b[1].p].d=mx; for(int i=2;i&lt;=n+m;i++) &#123; if(b[i-1].d!=b[i].d) mx++; yz[mx]=b[i].d;a[b[i].p].d=mx; &#125;&#125;int c[MAXN*2];bool check()&#123; bool bk=0; ll t;//这里应该改成1 for(int i=1;i&lt;=mx;i++) &#123; if(c[i]&gt;0) &#123; if(bk==0) &#123; if(c[i]&gt;1) return 0; bk=1,t=yz[i]; &#125; else if(bk) return 0; &#125; &#125; //printf("mx=%d\n",mx); return isprime(t);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i].d),a[i].p=i; for(int i=1;i&lt;=m;i++) scanf("%lld",&amp;a[n+i].d),a[n+i].p=n+i; lsh(); memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) if(yz[a[i].d]&gt;1) c[a[i].d]++; for(int i=n+1;i&lt;=n+m;i++) if(yz[a[i].d]&gt;1) c[a[i].d]--; if(check()) puts("YES"); else puts("NO"); &#125;&#125; T2_Analysis请先思考后再展开 一眼贪心模拟显然碰到连续两个跳过的点，就失败但是一开始写成了【连续两个小段失败】，其实可能只是跳过中间那个点就行还有一个细节漏了，就是不能跳过m-1 T2_Code_原请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n,m,s;int w[MAXN];bool v[MAXN];int ans[MAXN],tot=0;bool check()&#123; int now=0; bool fail=0; int nx=1; while(now&lt;m+1) &#123; int dis=w[nx]-w[now]; if(dis&lt;s) &#123; if(nx==m+1 or fail) return 0; fail=1; nx++; &#125; else &#123; now=nx; nx++; v[now]=1; ans[++tot]=now; fail=0; &#125; &#125; while(now&gt;0) &#123; int nx=now-1;while(nx&gt;0 and v[nx]) nx--; int dis=w[now]-w[nx]; if(dis&lt;s) return 0; v[nx]=1; now=nx; ans[++tot]=now; &#125; for(int i=0;i&lt;=m+1;i++) if(!v[i]) return 0; puts("YES"); for(int i=1;i&lt;=tot;i++) printf("%d ",ans[i]); return 1;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;w[i]); w[0]=0;w[m+1]=n; if(!check()) puts("NO");&#125; T3_Analysis请先思考后再展开 当时想了1h都没有思路只是想到通过差分和贪心，面对一个局面时可以线性地判断然后就在想方设法【线性扫时间，通过利用残留信息logn判断】然后就实在想不到什么残留信息可以用…… 强行伏笔：一直奇怪那个r给出来有什么用（可能是用来迷惑人的？）然后题目下面一大堆限制条件，以为只是用来手算范围的其实有一个隐藏的特性：$R_i&gt;=i$所以说一次成功后，后面的都能成功，也就是满足二分性（不一定是一个完美的函数，但最后一定都是成功）（让我联想到化学反应的结束图像） 实话说我经常会这样害怕毒瘤题面 T3_Code_std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=510000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m,k,mx;int a[MAXN],c[MAXN];struct Nod&#123; int w,x,v;&#125;b[MAXN];int check(int mid)&#123; memcpy(c,a,sizeof a); for(int i=1;i&lt;=mid;i++) c[b[i].x]-=b[i].v,c[b[i].x+1]+=b[i].v; int ans=0,tot=0; for(int i=1;i&lt;=n;i++) &#123; tot+=c[i]; if(tot&lt;1) &#123; ans+=(1-tot); c[i]+=(1-tot); if(i+k&lt;=n) c[i+k]-=(1-tot);//debug 2分的小细节！ tot+=(1-tot); &#125; &#125; return ans;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;mx); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=n;i&gt;=1;i--) a[i]-=a[i-1];//差分 for(int i=1;i&lt;=mx;i++) &#123;int t;scanf("%d",&amp;t);&#125; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;b[i].w,&amp;b[i].x,&amp;b[i].v); b[m+1].w=INF; int ans; int l=0,r=m; while(l&lt;=r) &#123; int mid=(l+r)/2; int tot=check(mid); if(tot&gt;=b[mid+1].w) l=mid+1; else ans=tot,r=mid-1; &#125; printf("%d",ans);&#125; T4_Analysis请先思考后再展开 有关区间最小值，有这样一个套路:先用一个递减的单调栈，分别从前往后和从后往前，求出l[i]和r[i]表示第一个比a[i]大的位置，则l[i]+1~r[i]-1中间，用到的最大值都是a[i] 考虑枚举这个最大值位置，然后枚举左右中数量少的那一边的端点这样另一个端点的取值范围就确定了，静态主席树即可，当然树状数组+离散化+二分查找也行。这样做的话读者可能认为复杂度是$O(n^2 log_2 n)$的，无异于【预处理st表+暴力枚举端点】的复杂度 然鹅，这种做法的复杂度其实是$O(n log_2^2 n)$的证明：对于每个i，它能够把l[i]~r[i]分成两半，分出来后，下一层级的j不能跨越出去所以说每次选取少的那一边，$枚举量 \leq log_2 n$换句话说，这些查询区间的总量是nlogn个，可以用set查重 至于空间，如果用树状数组或者线段树，不离散化的话，复杂度是m至于主席树，因为是静态的，前缀和形式，动态开点则变成nlogm，大大降低 debug:有一个漏洞，就是相同的数会多次作为最大值我的想法灰常暴力：set判重，不影响复杂度，由于区间不多，空间也不大而优秀的rose就有更劲的方法：全覆盖时强行保证只用最左边的具体而言，左边延伸到比x大或相等的，右边延伸到比x大的这样它们右端点相通，但左端点不会重复覆盖 T4_Code_std请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int dd[MAXN],top;//存储位置int n;int a[MAXN],l[MAXN],r[MAXN];//debug l和r定义不同，确保最大值中只用最左边那个！void pre_lr()&#123; //debug l[i]-1是&gt;=a[i]的 top=1;dd[top]=1;l[1]=1; for(int i=2;i&lt;=n;i++) &#123; while(top&gt;0 and a[dd[top]]&lt;a[i]) top--; l[i]=(top&gt;0)?dd[top]+1:1;//debug 可能空 dd[++top]=i; &#125; //debug r[i]+1是&gt;a[i]的 top=1;dd[top]=n;r[n]=n; for(int i=n-1;i&gt;=1;i--) &#123; while(top&gt;0 and a[dd[top]]&lt;=a[i]) top--; r[i]=(top&gt;0)?dd[top]-1:n;//debug 可能空 dd[++top]=i; &#125;&#125;struct Nod&#123; int lc,rc; int c; Nod() &#123; lc=rc=0; c=0; &#125;&#125;p[MAXN*40];int rt[MAXN];int id=0;void add(int &amp;x,int l,int r,int d,int o)&#123; if(l&gt;r) return; if(!x) x=++id; p[x].c+=o; if(l==r) return; int mid=(l+r)/2; if(d&lt;=mid) add(p[x].lc,l,mid,d,o); else add(p[x].rc,mid+1,r,d,o);&#125;void merg(int x,int &amp;y)&#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; merg(p[x].lc,p[y].lc); merg(p[x].rc,p[y].rc);&#125;int calc(int x,int l,int r,int d)//&lt;=d&#123; if(l&gt;r or x==0) return 0; if(l==r and l==d) return p[x].c; int lc=p[x].lc,rc=p[x].rc,mid=(l+r)/2; if(d&lt;=mid) return calc(lc,l,mid,d); else return p[lc].c+calc(rc,mid+1,r,d);&#125;const int MAXNUM=1000000000;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; add(rt[i],1,MAXNUM,a[i],1); merg(rt[i-1],rt[i]); &#125; pre_lr(); ll ans=0; for(int mid=1;mid&lt;=n;mid++) &#123; int fl=l[mid],fr=r[mid]; if(mid-fl&lt;fr-mid)//left &#123; for(int i=fl;i&lt;=mid;i++) &#123; int d=a[mid]/a[i]; ans+=calc(rt[fr],1,MAXNUM,d)-calc(rt[mid-1],1,MAXNUM,d); &#125; &#125; else//right &#123; for(int j=mid;j&lt;=fr;j++) &#123; int d=a[mid]/a[j]; ans+=calc(rt[mid],1,MAXNUM,d)-calc(rt[fl-1],1,MAXNUM,d); &#125; &#125; &#125; printf("%lld",ans);&#125; T5_Analysis请先思考后再展开 看到“凸包”两个字就想跑……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【USACO2009 NOV Gold】灯]]></title>
    <url>%2Fposts%2F3fa9.html</url>
    <content type="text"><![CDATA[Source and JudgeUSACO2009 NOV GoldBzoj1770Luogu2962 Problem【Description】贝希和她的闺密们在她们的牛棚中玩游戏。但是天不从人愿，突然，牛棚的电源跳闸了，所有的灯都被关闭了。贝希是一个很胆小的女生，在伸手不见拇指的无尽的黑暗中，她感到惊恐，痛苦与绝望。她希望您能够帮帮她，把所有的灯都给重新开起来！她才能继续快乐地跟她的闺密们继续玩游戏！牛棚中一共有N盏灯，编号为1到N。这些灯被置于一个灰常複杂的网络之中。有M条很神奇的无向边，每条边连接两盏灯。每盏灯上面都带有一个开关。当按下某一盏灯的开关的时候，这盏灯本身，还有所有有边连向这盏灯的灯的状态都会被改变。状态改变指的是：当一盏灯是开著的时候，这盏灯被关掉；当一盏灯是关著的时候，这盏灯被打开。问最少要按下多少个开关，才能把所有的灯都给重新打开。数据保证至少有一种按开关的方案，使得所有的灯都被重新打开。【Input】第一行：兩個空格隔開的整數：N和M。第二到第M+1行：每一行有兩個由空格隔開的整數，表示兩盞燈被一條無向邊連接在一起。 沒有一條邊會出現兩次。【Output】一個單獨的整數，表示要把所有的燈都打開時，最少需要按下的開關的數目。【Limited conditions】1 &lt;= N &lt;= 351 &lt;= M &lt;= 595【Sample input】5 61 21 34 23 42 55 3【Sample output】3【Sample explanation】一共有五盞燈。燈1、燈4和燈5都連接著燈2和燈3。按下在燈1、燈4和燈5上面的開關。 Record1h细节很多…… Analysis请先思考后再展开 高斯消元的做法以后再补吧现在讲讲怎么用折半搜索艹过去 其实其核心思想就是把指数暴力地拆开，低消耗地合并起来得到答案左边从起点过来，而右边则从终点过来，找到一个重叠状态（有时是对应状态，例如这道题是相反数）用其中一边去找另外一边记录下来的答案（小就用数组，大就存下来二分查找） 以这道题为例，随便分成两边，右边记录答案（用数组，存储从终点过来需要多少步）左边暴力后，找右边的相反数答案，相加即可 最后再反思点拨一下：虽然产生的状态是2^35量级的，但其不同状态数量只有2^17个人认为这也是折半搜索的精髓之体现 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=40;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m;ll f[MAXN];ll ed;ll bin[MAXN];map&lt;ll,int&gt; mp;//leftint ans=INF;void dfs(int x,int step,ll now,bool right)&#123; if(now==ed) ans=mymin(ans,step);//debug else if(!right and x&gt;n/2) &#123; ll tmp=mp[now]; if(tmp==0 or tmp&gt;step) mp[now]=step; //if(!mp.count(now)) mp[now]=step; //else if(step&lt;mp[now]) mp[now]=step; &#125; else if(right and x&gt;n-1) &#123; if(mp.count(ed-now)) ans=mymin(ans,step+mp[ed-now]); &#125; else &#123; dfs(x+1,step,now,right); dfs(x+1,step+1,now^f[x],right); &#125;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=35;i++) bin[i]=bin[i-1]*2; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n-1;i++) f[i]=bin[i]; while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); x--;y--;//debug f[x]+=bin[y];f[y]+=bin[x]; &#125; ed=bin[n]-1; dfs(0, 0,0,0); dfs(n/2+1,0,0,1); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>高斯消元</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佛山2015市选2比赛总结]]></title>
    <url>%2Fposts%2F88c1.html</url>
    <content type="text"><![CDATA[佛山2015市选2比赛总结题目 比赛经历看一遍题目发现是做过的题，但当时没有讲，做了和没做一样然后感觉当时多少分现在可能也差不多了【flag】一年过去sa依然不会，因为这不是noip的范围，然后省选计划还没到哪里……这就是所谓知识盲区吧，虽然知道但也没办法，手头上还有不少任务于是就安心爆零吧…… 评测经历T2的stl怎么fail了?少了40暴力分然后T3居然忘记删除输出调试了，少了20暴力分其实当时也想过要不要检查，但是今天本来就没多少分，不想检查了最后[0/100]+[10/100]+[0/100]+[0/100]=10/400两天差距甚大啊，直接加上了“倒数”两个字，变成了倒数rk2……%xgc今天翻盘遥遥领先 T1_Analysis请先思考后再展开 据说这是一道很套路的sg题目主要就是学会sg有个核心公式（以后补教程）$$sg(i)=mex { sg(i-j)|gcd(i,j)=1 }$$然后这个$gcd(i,i-j)=1$然后取值的话不太好想，但证明其正确性灰常简单如果是质数，sg=质数序数+1如果是合数，sg=sg(最小质因数)+1 然后按照套路（异或）起来就好了 T1_Code_std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXNUM=1000001;int pr=0,prime[100000];int sg[MAXNUM];bool v[MAXNUM];void pre()&#123; memset(v,1,sizeof v); sg[1]=1;//定义 for(int i=2;i&lt;MAXNUM;i++) &#123; if(v[i]) prime[++pr]=i,sg[i]=pr+1; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=0; sg[i*prime[j]]=sg[prime[j]];//最小的【与其互质】 if(i%prime[j]==0) break; &#125; &#125;&#125;int main()&#123; freopen("stone.in","r",stdin); freopen("stone.out","w",stdout); pre(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); ans^=sg[t]; &#125; if(ans==0) puts("Bob"); else puts("Alice"); &#125;&#125; T2_Analysis请先思考后再展开 sam和sa都不会……hash好像也没什么必要吧反正弃了 T3_Analysis请先思考后再展开 主要思路是，进行了前面的第一轮后，就变成一个子问题找规律神题，细节很多，不想写 T4_Analysis请先思考后再展开 没人会的神题……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[佛山2015市选1比赛总结]]></title>
    <url>%2Fposts%2F4bc4.html</url>
    <content type="text"><![CDATA[佛山2015市选1比赛总结题目 比赛经历先切了T3、T4，回头发现T1很简单，最后杠T2%akc，100分钟想完所有题然后码完巨大心理压力有木有然后rose和我一起杠T2，没什么想法，只能打个暴力 评测经历wocT4的MLE是什么鬼，一度心态爆炸，明明算过的原来是师兄空间只开了64mb最后[100/100]+[0/98]+[63/99]+[98/98]=261/395最后混了个初三rk2%ch文件名打错，实际比我高20,屈居rk3%lhp做过原题虐场，306全场最高 T1_Analysis请先思考后再展开 对于后面的点，没有人覆盖它，只能自己解决问题的从这些点入手，倒推即可 T1_Code_原请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int mp[MAXN][MAXN];char s[MAXN];int main()&#123; freopen("change.in","r",stdin); freopen("change.out","w",stdout); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) mp[i][j]=s[j]-'0'; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=m;j&gt;=1;j--) &#123; if(mp[i][j]) &#123; ans++; for(int a=1;a&lt;=i;a++) for(int b=1;b&lt;=j;b++) mp[a][b]=1-mp[a][b]; &#125; &#125; printf("%d",ans);&#125; T2_Analysis请先思考后再展开 这道题考的时候写了个暴力搜索+hash判重，然后成功炸空间其实这题的正解违背【数据范围自适应】定律：把矩阵的元素加起来…… 其实不是很会证明，但大概可以猜个结论？比如说因为总是偶数个，所以最优解不会有浪费？反正没分 然后一个价值30分的细节：有种情况是，点虽然独立，但没有边和它相连，这种情况的话是不算非法的……很难想到啊 T2_Code_原请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;struct Nod&#123; int mp[MAXN][MAXN]; int now,p;&#125;;set&lt;ull&gt; has;const ull base=131;bool bk;ull gethas(Nod x)&#123; ull ans=x.now; bk=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; ans=ans*base+x.mp[i][j]; if(x.mp[i][j]!=0 and x.mp[i][j]&lt;=9) bk=0; &#125; return ans;&#125;queue&lt;Nod&gt; q;int bfs()&#123; while(!q.empty()) &#123; Nod now=q.front();q.pop(); int x=now.now; for(int y=1;y&lt;=n;y++) if(x!=y and now.mp[x][y]&lt;=9) &#123; Nod nx=now;nx.p=now.p+1;nx.now=y; if(nx.mp[x][y]&gt;0) nx.mp[x][y]--; ull hs=gethas(nx); if(bk) return nx.p; if(has.count(hs)) continue; has.insert(hs);q.push(nx); &#125; &#125; return -1;&#125;char str[MAXN];int main()&#123; freopen("snow.in","r",stdin); freopen("snow.out","w",stdout); int T;scanf("%d",&amp;T); while(T--) &#123; Nod st;st.p=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=n;j++) &#123; st.mp[i][j]=str[j]-'0'; if(st.mp[i][j]==0) st.mp[i][j]=10; &#125; &#125; has.clear(); while(!q.empty()) q.pop(); q.push(st);has.insert( gethas(st) ); printf("%d\n",bfs()); &#125;&#125; T2_Code_std请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int fa[MAXN];int findfa(int x)&#123; if(fa[x]!=x) fa[x]=findfa(fa[x]); return fa[x];&#125;void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;int n;char str[MAXN];int main()&#123; freopen("snow.in","r",stdin); freopen("snow.out","w",stdout); int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); int ans=0; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); bool bk2=0; for(int j=1;j&lt;=n;j++) &#123; int t=str[j]-'0'; if(t&gt;0) ans+=t,join(i,j),bk2=1; &#125; if(!bk2) fa[i]=0;//debug 特判独立点 &#125; bool ok=1; int rt=findfa(1); for(int i=2;i&lt;=n;i++) if(findfa(i)!=rt and fa[i]&gt;0) ok=0; if(!ok) puts("-1"); else printf("%d\n",ans); &#125;&#125; T3_Analysis请先思考后再展开 一眼查分约束然后就被一个关键句卡了：“栋栋给的分数都是0到10000的正整数” 真的不知道怎么做了这道题其实题意也很不清晰呀弃了 T3_Code_原请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=11000,MAXM=410000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;struct Nod&#123; int hou; int dis; int ru; bool v; Nod() &#123; hou=v=0; ru=0; //dis=INF; dis=-INF; &#125;&#125;p[MAXN];struct Edge&#123; int y,g,c;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;queue&lt;int&gt; q;int spfa()&#123; q.push(1);p[1].dis=0;p[1].v=1;p[1].ru++; while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&lt;p[x].dis+e[k].c) //if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; if(!p[y].v) &#123; p[y].v=1; q.push(y); p[y].ru++; if(p[y].ru&gt;n) return -1; &#125; &#125; &#125; p[x].v=0; &#125; return 1;&#125;int main()&#123; freopen("grade.in","r",stdin); freopen("grade.out","w",stdout); int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int a,b,x;scanf("%d%d%d",&amp;a,&amp;b,&amp;x); //ins(a,b,-x); ins(b,a,x); &#125; if(spfa()&lt;0) printf("impossible"); else printf("%d",p[n].dis);&#125; T4_Analysis请先思考后再展开 网络流即可记得要拆点！akc和hanks_o都忘记了 T4_Code_原请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=40;const int INF=0x3f3f3f3f;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int getid(int x,int y) &#123;return (x-1)*30+y;&#125;queue&lt;int&gt; q;int hou[5000];struct Edge&#123; int y,g,c; int oth;&#125;e[8000000];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=hou[x];hou[x]=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=hou[y];hou[y]=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int h[5000];bool bfs()&#123; memset(h,0,sizeof h);h[st]=1; q.push(st); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(e[k].c&gt;0 and h[y]==0) &#123; h[y]=h[x]+1; q.push(y); &#125; &#125; &#125; return h[ed]&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int out=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(e[k].c&gt;0 and h[y]==h[x]+1 and out&lt;f) &#123; int tmp=dfs(y,mymin(f-out,e[k].c)); out+=tmp;e[k].c-=tmp;e[e[k].oth].c+=tmp; &#125; &#125; if(out==0) h[x]=0; return out;&#125;int n,m,k;int mp[MAXN][MAXN];struct Node&#123; int x,y,p; Node(int a=0,int b=0,int c=0) &#123;x=a,y=b,p=c;&#125;&#125;;queue&lt;Node&gt; q2;const int tx[4]=&#123;0,0,-1,1&#125;;const int ty[4]=&#123;-1,1,0,0&#125;;bool v[MAXN][MAXN];void make(int stx,int sty)&#123; memset(v,0,sizeof v); q2.push( Node(stx,sty,0) ); while(!q2.empty()) &#123; Node now=q2.front();q2.pop(); if(now.p&gt;=k) continue; int x=now.x,y=now.y; for(int t=0;t&lt;=3;t++) &#123; int nx=x+tx[t],ny=y+ty[t]; if(1&lt;=nx and nx&lt;=n and 1&lt;=ny and ny&lt;=m and !v[nx][ny]) &#123; if(mp[nx][ny]==1) q2.push( Node(nx,ny,now.p+1) ); if(mp[nx][ny]==3) ins(2000+getid(stx,sty),3000+getid(nx,ny),1); if(mp[nx][ny]==4) ins(getid(nx,ny),1000+getid(stx,sty),1); v[nx][ny]=1; &#125; &#125; &#125;&#125;char str[MAXN];int main()&#123; freopen("jobs.in","r",stdin); freopen("jobs.out","w",stdout); int T;scanf("%d",&amp;T); while(T--) &#123; ln=0;memset(hou,0,sizeof hou); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=m;j++) &#123; if(str[j]=='X') mp[i][j]=0; if(str[j]=='.') mp[i][j]=1; if(str[j]=='W') mp[i][j]=2; if(str[j]=='G') mp[i][j]=3; if(str[j]=='S') mp[i][j]=4; &#125; &#125; st=0;ed=4000; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(mp[i][j]==2) &#123; make(i,j); ins(1000+getid(i,j),2000+getid(i,j),1); &#125; if(mp[i][j]==3) ins(3000+getid(i,j),ed,1); if(mp[i][j]==4) ins(st,getid(i,j),1); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【置顶】电脑操作知识备忘]]></title>
    <url>%2Fposts%2F7de4.html</url>
    <content type="text"><![CDATA[电脑操作知识备忘网站推介：搜索算法名称与国际接轨 编译-Wall开启提示 -std=c++11等 -O2一定要大写…… -m3232位程序，配合gdb32 -Wl,–stack=SIZE扩栈 gdb查看调用参数info args 查看局部变量info locals 查看函数栈bt 每步操作都显示变量值display frame xxx配合bt，跳转 linux下对拍while true; do … if diff a.out a.ans; then printf AC else exit 0 fidone 卡常123#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#pragma GCC target ("avx2") SPJ板子12345678910111213141516171819202122232425262728293031323334353637383940414243FILE *in, *stand, *out, *score, *report;template&lt;typename T&gt;string tostr(const T&amp; v)&#123; stringstream ss; ss &lt;&lt; v; return ss.str();&#125;/** argv[1]：输入* argv[2]：选手输出* argv[3]：标准输出* argv[4]：单个测试点分值* argv[5]：输出最终得分* argv[6]：输出错误报告*/int main(int argc,char*argv[])&#123; in = fopen(argv[1],"r"); out = fopen(argv[2],"r"); stand = fopen(argv[3],"r"); score = fopen(argv[5], "w"); report = fopen(argv[6], "w"); int n;fscanf(in,"%d",&amp;n); int cnt=0;bool bk=0; for(int i=1;i&lt;=n;i++) &#123; double a,b; fscanf(stand,"%lf\n",&amp;a); fscanf(out,"%lf\n",&amp;b); if(a*2&lt;b or b*2&lt;a) &#123; cnt++; if(cnt==11) &#123; fprintf(score,"0"); fprintf(report, ("expected: "+tostr(a)+", found: "+tostr(b)+", line: "+tostr(i)+" (11th error)").c_str() ); bk=1;break; &#125; &#125; &#125; if(!bk) fprintf(score,"%s",argv[4]),fprintf(report,"Good job");&#125; 数据改名器板子1234567891011121314151617181920template&lt;typename T&gt;string tostr(const T&amp; v)&#123; stringstream ss; ss &lt;&lt; v; return ss.str();&#125;int main(int argc,char*argv[])&#123; for(int i=1;i&lt;=55;i++) &#123; string now; if(i&lt;=9) now="0"+tostr(i); else now=tostr(i); string cmd="ren "+now+".a"+" "+now+".out"; system(cmd.c_str()); //cout&lt;&lt;cmd&lt;&lt;endl; &#125;&#125; O(1)快速乘12345ll MUL(ll x,ll y)&#123; ll tmp=(long double)x/MOD*y+0.5;tmp=a*b-tmp*MOD; return tmp&lt;0?tmp+MOD:tmp;//利用LIMIT这个模数相同，做差得精确值&#125; 出题造数据器123456789101112131415161718192021222324ll rd(ll l,ll r)&#123; if(l&gt;r) puts("error"); if(l==r) return l; return l+(RAND_MAX*rand()+rand())%(r-l+1);&#125;char num[2];void main()&#123; int mxn=qread(),mxk=qread(),mik=qread(); for(int i=1;i&lt;=9;i++) &#123; string file="data\\vp";num[0]='0'+i; string in=(file+num+".in"),out=(file+num+".out"); string cmd="vp.exe &lt;"+in+" &gt;"+out; freopen(in.c_str(),"w",stdout); fclose(stdout); system(cmd.c_str()); // freopen(out.c_str(),"r",stdin);int num=qread();fclose(stdin); // if(num==0) i--; &#125;&#125; 循环展开的高妙技巧猫锟的代码 123456#define A if((--j)&amp;=s2)ans+=f[j+low]*g[s2-j];else break;for(int j=s2;;)&#123; A A A A A A A A A A A A A A A A ans%=D;&#125; 超级IO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768namespace fastIO&#123; #define BUF_SIZE 100000 #define OUT_SIZE 100000 #define ll long long bool IOerror=0; inline char nc() &#123; static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if(p1==pend) &#123; p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if(pend==p1)&#123;IOerror=1;return -1;&#125; &#125; return *p1++; &#125; inline bool blank(char ch)&#123;return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';&#125; inline void read(int &amp;x) &#123; bool sign=0; char ch=nc(); x=0; for(;blank(ch);ch=nc()); if(IOerror)return; if(ch=='-')sign=1,ch=nc(); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if(sign)x=-x; &#125; inline void read(ll &amp;x) &#123; bool sign=0; char ch=nc(); x=0; for(;blank(ch);ch=nc()); if(IOerror)return; if(ch=='-')sign=1,ch=nc(); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if(sign)x=-x; &#125; char ss[1000000*15],tt[20]; int ssl,ttl; inline int Flush() &#123; fwrite(ss+1,sizeof(char),ssl,stdout); ssl=0; return 0; &#125; inline int print(int x) &#123; if(!x)ss[++ssl]='0'; if(x&lt;0)ss[++ssl]='-',x=-x; for(ttl=0;x;x/=10)tt[++ttl]=char(x%10+'0'); for(;ttl;ttl--)ss[++ssl]=tt[ttl]; return ss[++ssl]='\n'; &#125; inline int print(ll x) &#123; if(!x)ss[++ssl]='0'; if(x&lt;0)ss[++ssl]='-',x=-x; for(ttl=0;x;x/=10)tt[++ttl]=char(x%10+'0'); for(;ttl;ttl--)ss[++ssl]=tt[ttl]; return ss[++ssl]='\n'; &#125; #undef OUT_SIZE #undef BUF_SIZE&#125;;using namespace fastIO;]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-2搜索13题]]></title>
    <url>%2Fposts%2F9d2f.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x20 搜索题目 1 2101 可达性统计7.9 难度2请先思考后再展开 一开始以为是统计 siz 的sb题原来是我sb了，因为会有重复，那么只能把每个点能到达的统计下来了而且因为是有向的，必须要按照拓扑序（建反边）来统计用bitset统计，查询1的个数即可 复杂度的话，时间是$O(n^2/32)$，空间是128MB12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=31000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int hou; int ru; Nod() &#123; hou=ru=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y;e[ln].g=p[x].hou; p[x].hou=ln; p[y].ru++;&#125;int lst[MAXN],top=0;bitset&lt;MAXN&gt; f[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(y,x); &#125; for(int i=1;i&lt;=n;i++) &#123; f[i][i]=1; if(p[i].ru==0) lst[++top]=i; &#125; while(top&gt;0) &#123; int x=lst[top--]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; f[y]=f[y]|f[x]; p[y].ru--; if(p[y].ru==0) lst[++top]=y; &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%d\n",f[i].count());&#125; 2 2201 小猫爬山7.10 难度2请先思考后再展开 这道题引发了我对暴搜方式的思考：如果用车来找猫，就有次序性；而反过来，新车选择就会减少，次序也固定123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=20;int n,w;int ans=MAXN;int use[MAXN];int c[MAXN];void dfs(int now,int cnt)&#123; if(cnt&gt;=ans) return;//最优化剪枝 if(now&gt;n) &#123;ans=cnt;return;&#125; for(int i=1;i&lt;=cnt;i++) if(use[i]+c[now]&lt;=w) &#123; use[i]+=c[now]; dfs(now+1,cnt); use[i]-=c[now]; &#125; use[cnt+1]=c[now]; dfs(now+1,cnt+1);&#125;bool cmp(int x,int y) &#123;return x&gt;y;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;w); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); sort(c+1,c+n+1,cmp);//减少选择 dfs(1,0); printf("%d",ans);&#125; 3 POJ2676 POJ3074 Sudoku7.10 难度2请先思考后再展开 POJ2676 0msPOJ3074 tle，精A12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=20;const int INF=0x3f3f3f3f;int mp[MAXN][MAXN];bitset&lt;10&gt; hang[MAXN],lie[MAXN],block[MAXN];int getid(int x,int y) &#123; return ((x-1)/3)*3+(y-1)/3+1; &#125;int tot;int fx,fy;void getnxt()&#123; int ans=INF; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) if(mp[i][j]==0) &#123; int t=(hang[i]&amp;lie[j]&amp;block[getid(i,j)]).count(); if(ans&gt;t) ans=t,fx=i,fy=j; &#125;&#125;bool bk;void dfs(int now)&#123; if(bk) return; if(now&gt;tot) &#123; for(int i=1;i&lt;=9;i++) &#123; for(int j=1;j&lt;=9;j++) printf("%d",mp[i][j]); putchar('\n'); &#125; //putchar('\n'); bk=1; return; &#125; getnxt();//debug 原本直接用fx、fy，后果严重，查错很久！ int x=fx,y=fy,id=getid(x,y); for(int t=1;t&lt;=9;t++) if(hang[x][t] and lie[y][t] and block[id][t]) &#123; hang[x][t]=lie[y][t]=block[id][t]=0; mp[x][y]=t; dfs(now+1); mp[x][y]=0; hang[x][t]=lie[y][t]=block[id][t]=1; &#125;&#125;char str[MAXN*MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) //while(1) &#123; tot=0; for(int i=1;i&lt;=9;i++) hang[i].set(),lie[i].set(),block[i].set(); //scanf("%s",str+1); if(str[1]=='e') break; for(int i=1;i&lt;=9;i++) &#123; scanf("%s",str+1); for(int j=1;j&lt;=9;j++) &#123; int now=str[j]-'0'; //int now=(str[(i-1)*9+j]=='.')?0:str[(i-1)*9+j]-'0'; mp[i][j]=now; if(now&gt;0) hang[i][now]=lie[j][now]=block[getid(i,j)][now]=0; else tot++; &#125; &#125; bk=0;dfs(1); &#125;&#125; 4 POJ1011 luogu1120 Sticks7.11 难度3请先思考后再展开 去掉次序性的套路：强行限制大小关系，例如我选择了递减 由于值的数量比个数少，可以把值映射一下，方便查找，至于可用性可以直接更改数量然后这个方法包含了一个剪枝——同值不再考虑 书上的一个剪枝一直没有理解，就是当空的时候，检验前面决策具体而言是尝试每一个木棒，任何一个失败都意味着前面决策错误然后我的策略是毫不犹豫地选择最大的本来是一直坚信其优越性的，直到惊觉我的做法，发现决策的错误要在以后的层，多出了很多无用枝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int sum,mx,k;int n;int c[MAXN];//映射bool okay;void dfs(int done,int now,int lst)//强制递减&#123; if(done==sum/k) okay=1; if(okay) return; int t=mymin(lst,k-now);//debug 原本 k-lst if(lst==INF) t=mx; for(;t&gt;0;t--) &#123; if(c[t]==0) continue; c[t]--; if(now+t==k) dfs(done+1,0,INF); else dfs(done,now+t,t); c[t]++; if(!okay and (now==0 or now+t==k)) return;//现在失败，前面有问题 //大剪枝，因为耗时大部分都是失败的结果，否则已经结束了 //now==0：空的，塞东西后失败，迟早会用到 //now+t==k：大的块一定不会比【小的拼起来一样长】的更有用，因为不能拆开 &#125;&#125;int main()&#123; while(1) &#123; scanf("%d",&amp;n); if(n==0) break; memset(c,0,sizeof c); mx=sum=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t&lt;=50) &#123; sum+=t; mx=mymax(mx,t); c[t]++; &#125; &#125; int ans=INF; for(int t=1;t&lt;=sqrt(sum);t++) if(sum%t==0) &#123; k=t; if(k&gt;=mx) &#123; okay=0;dfs(0,0,INF); if(okay) ans=mymin(ans,k); &#125; k=sum/t; if(k!=t and k&gt;=mx) &#123; okay=0;dfs(0,0,INF); if(okay) ans=mymin(ans,k); &#125; &#125; printf("%d\n",ans); &#125;&#125; 5 POJ1190 生日蛋糕7.12 难度2请先思考后再展开 剪枝 最优化剪枝nows&gt;=ans 可行性剪枝Ri&gt;=1+2*(m-i)Hi&gt;=1+2*(m-i) 最小化可行性剪枝nown+getmin()&gt;n 最大化可行性剪枝nown+getmax()&lt;n 最后一个剪枝特tm难想到首先，如果要剪枝，肯定要把上面部分的东西表示出来N表示去掉$\pi$的体积，S表示去掉$\pi$的表面积 $$N_后=\sum_{i=now}^m R_i^2 H_i$$ $$S_后=2 \times \sum_{i=now}^m R_i H_i$$ 所谓剪枝，可以考虑不等式【据说接下来的是高中数学灰常恶心的东西：不等式的缩放】 加入元$R_{now-1}$（很难想）$$S_后=\frac{2}{R_{now-1}}\times\sum_{i=now}^m R_i H_i R_{now-1}$$ 把右边部分缩放一下由于$R_{now-1} &gt; R_i$ $$S_后 \frac{2}{R_{now-1}}\times\sum_{i=now}^m R_i^2 H_i$$ 联系一下体积$$S_后&gt; \frac{2}{R_{now-1}} \times N_剩$$ 因为前面几个剪枝，只有一个是关于【有关答案的表面积】的那么可以说$S_后$一定比某个值大可以最优化剪枝一波，条件：$$S_现+\frac{2}{R_{now-1}} \times N_剩&gt;=ans$$ 最后就是碰到搜索要无脑倒序循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=20;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m;int r[MAXN],h[MAXN];int mi[MAXN];ll getmx(int x)&#123; ll sum=0,rr=r[x-1],hh=h[x-1]; for(int i=x;i&lt;=m;i++) sum+=(rr+i)*(rr+i)*(hh+i); return sum;&#125;int ans=INF;void dfs(int nows,int nown,int x)&#123; if(nows+r[1]*r[1]&gt;=ans) return; if(x==m+1) &#123; if(nown==n) ans=nows+r[1]*r[1]; return; &#125; //if(nown+mi[m-x+1]&gt;n) return; //if(getmx(x)+nown&lt;n) return; 会拖慢 if(r[1]*r[1]+nows+2*(n-nown)/r[x-1]&gt;=ans) return; for(int ri=mymin(sqrt(n-mi[m-x]-nown),r[x-1]-1);ri&gt;=1+(m-x);ri--)//debug，sqrt部分没想到 &#123; int hmx=(n-mi[m-x]-nown)/(ri*ri);//最小化可行性剪枝的变形 if(x==m) &#123; r[x]=ri;h[x]=hmx; if(hmx&lt;=h[x-1]-1) dfs(nows+2*ri*hmx,nown+ri*ri*hmx,x+1); continue; &#125; for(int hi=mymin(hmx,h[x-1]-1);hi&gt;=1+(m-x);hi--) &#123; r[x]=ri;h[x]=hi; dfs(nows+2*ri*hi,nown+ri*ri*hi,x+1); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) mi[i]=i*i*i; r[0]=100+1;h[0]=20000+1; dfs(0,0,1); if(ans==INF) ans=0; printf("%d",ans);&#125; 6 POJ2248 Addition Chains7.12 难度1请先思考后再展开 迭代加深这个东西第一次看到感觉它虽然比bfs慢一些，但其优势在于便于还原状态、不用大量空间来存储状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int ed;int ln;int a[MAXN];bool v[MAXN];bool dfs(int now)&#123; if(a[now-1]==ed) &#123; for(int i=1;i&lt;=now-1;i++) printf("%d ",a[i]); return 1; &#125; if(now&gt;ln) return 0; memset(v,0,sizeof v); for(int i=now-1;i&gt;=1;i--) for(int j=now-1;j&gt;=i;j--) &#123; a[now]=a[i]+a[j]; if(v[a[now]] or a[now]&gt;ed or a[now]&lt;=a[now-1]) continue; v[a[now]]=1; if(dfs(now+1)) return 1; &#125; return 0;&#125;int main()&#123; a[1]=1; while(1) &#123; scanf("%d",&amp;ed); if(ed==0) break; for(ln=1;ln&lt;=100;ln++) if(dfs(2)) break; printf("\n"); &#125;&#125; 7 2401 送礼物7.13 难度2请先思考后再展开 其实通常面对一个决策与顺序无关，而且不卡log的题目，排序一下都不亏其实看不出这个正解和折半搜索有什么关系但是灰常鬼畜啊hh主要思路来自【指数级爆搜】把问题分成两边（已排序），搜索左右两边，然后通过枚举左边的结果，二分查找右边的这样子复杂度就被硬生生变成了$O(2^{n/2} log_2 2^{n/2})$ 折半搜索还有道体现得更明显的题目：灯然后我们通过折半，把取值的数量从2^45变成最坏2^22，其实还不少，所以要剪枝 可恶啊卡我的set……1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=50;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int w,n;int a[MAXN];int ans=0;//set&lt;int&gt; f;//leftint f[1&lt;&lt;25],cnt=0;//leftvoid dfs(int x,int now,bool right)&#123; if(!right and x&gt;n/2) f[++cnt]=now;//f.insert(now); else if(right and x&gt;n) &#123; //int t=*( --upper_bound(f.begin(),f.end(),w-now) );//&lt;=w-now int t=f[upper_bound(f+1,f+cnt+1,w-now)-f-1]; ans=mymax(ans,t+now); &#125; else &#123; dfs(x+1,now,right); if(ll(now)+a[x]&lt;=w) dfs(x+1,now+a[x],right); &#125;&#125;int main()&#123; scanf("%d%d",&amp;w,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1);reverse(a+1,a+n+1); dfs(1,0,0); sort(f+1,f+cnt+1); cnt=unique(f+1,f+cnt+1)-f-1; dfs(n/2+1,0,1); printf("%d",ans);&#125; 8 2601 电路维修7.14 难度2请先思考后再展开 最巧妙的地方：把决策转化为边，边权为代价于是就变成了最短路问题 spfa一直tle……试一试书上的新做法，以为多特别所以没有打p[x].v=0，一直wa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=510;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n,m;int calc(int x,int y) &#123;return (x-1)*MAXN+y;&#125;struct Nod&#123; int hou; int dis; bool v;&#125;p[MAXN*MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*MAXN*2*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].g=p[y].hou;p[y].hou=ln;&#125;deque&lt;int&gt; q;int bfs(int st,int ed)&#123; p[st].v=1;q.push_back(st);p[st].dis=0; while(!q.empty()) &#123; int x=q.front();q.pop_front(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].c) &#123; p[y].dis=p[x].dis+e[k].c; if(!p[y].v) &#123; p[y].v=1; if(e[k].c) q.push_back(y); else q.push_front(y); &#125; &#125; &#125; p[x].v=0;//debug &#125; return p[ed].dis;&#125;char s[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; ln=0; for(int i=1;i&lt;MAXN*MAXN;i++) &#123; p[i].v=0; p[i].hou=0; p[i].dis=INF; &#125; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) &#123; ins( calc(i,j),calc(i+1,j+1),(s[j]=='/') ); ins( calc(i+1,j),calc(i,j+1),(s[j]!='/') ); &#125; &#125; int ans=bfs(calc(1,1),calc(n+1,m+1)); if(ans==INF) puts("NO SOLUTION"); else printf("%d\n",ans); &#125;&#125; 9 POJ3635 Full Tank?7.17 难度1请先思考后再展开 本来以为可以dfs去记忆化然鹅这样是错的，因为不能保证第一次就是最优解……话说bfs的复杂度其实灰常悬，可能数据水？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1100,MAXM=21000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int a[MAXN];int hou[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=hou[x];hou[x]=ln;&#125;int full,st,ed;struct Nod&#123; int x,oil; int cost; Nod(int a=0,int b=0,int c=0) &#123;x=a,oil=b,cost=c;&#125; friend bool operator &gt; (Nod a,Nod b) &#123;return a.cost&gt;b.cost;&#125;&#125;;bool v[MAXN][110];priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int bfs()&#123; memset(v,0,sizeof v); while(!q.empty()) q.pop(); q.push( Nod(st,0,0) );//题目中说是空箱 while(!q.empty()) &#123; Nod now=q.top();q.pop(); int x=now.x,oil=now.oil,cost=now.cost; if(x==ed) return cost; if(v[x][oil]) continue; v[x][oil]=1; if(oil&lt;full) q.push( Nod(x,oil+1,cost+a[x]) ); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(oil&gt;=e[k].c) q.push( Nod(y,oil-e[k].c,cost) ); &#125; &#125; return -1;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); x++;y++; ins(x,y,c);ins(y,x,c); &#125; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;full,&amp;st,&amp;ed); st++;ed++; int ans=bfs(); if(ans&lt;0) puts("impossible"); else printf("%d\n",ans); &#125;&#125; 10 POJ2449 Remmarguts’ Date7.17 难度2请先思考后再展开 key：第k次出堆，得到第k小的解akc眼中的模版题 不过最后奇奇怪怪mle先放着吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1100,MAXM=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int st,ed,K;int hou[MAXN];bool v[MAXN];int f[MAXN];//估价函数struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=hou[x];hou[x]=ln;&#125;queue&lt;int&gt; lst;void spfa()&#123; memset(f,63,sizeof f);//debug 忘记了…… lst.push(ed);v[ed]=1;f[ed]=0; while(!lst.empty()) &#123; int x=lst.front();lst.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(f[y]&gt;f[x]+e[k].c) &#123; f[y]=f[x]+e[k].c; if(!v[y]) v[y]=1,lst.push(y); &#125; &#125; v[x]=0; &#125;&#125;int tot[MAXN];//次数struct Nod&#123; int x,dis; Nod(int a=0,int b=0) &#123;x=a,dis=b;&#125; friend bool operator &gt; (Nod a,Nod b) &#123;return a.dis+f[a.x]&gt;b.dis+f[b.x];&#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int solve()&#123; q.push( Nod(st,0) ); while(!q.empty()) &#123; Nod now=q.top();q.pop(); int x=now.x; tot[x]++; if(tot[x]&gt;K) continue; if(x==ed and tot[x]==K) return now.dis; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(tot[y]&lt;K) q.push( Nod(y,now.dis+e[k].c) ); &#125; &#125; return -1;&#125;int xx[MAXM],yy[MAXM],cc[MAXM];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;xx[i],&amp;yy[i],&amp;cc[i]); ins(yy[i],xx[i],cc[i]); &#125; scanf("%d%d%d",&amp;st,&amp;ed,&amp;K); if(st==ed) K++;//好像是必须要走??? spfa(); ln=0;memset(hou,0,sizeof hou); for(int i=1;i&lt;=m;i++) ins(xx[i],yy[i],cc[i]); printf("%d",solve());&#125; 11 POJ3460 Booksort7.17 难度3请先思考后再展开 A*=堆+bfs+估价IDA*=迭代dfs+估价 最难的就是怎么估价了目标是有序，但我们不能用【逆序对数量】，因为每次消除量是不确定的观察题目性质，每次操作都是对连续的一段进行的再有序的情况下，每个数都有一个正确的后继而每次操作最多消除3个错误后继数不过要向上取整 顺便再介绍一下折半搜索怎么做：先考虑每次决策的分支量如果选a本，有n-a+1种，可以插n-a处同时对于前移，必定有一种后移方案与其等效，所以只后移分支数$ \sum_{a=1}^{n-1} (n-a+1) \times (n-a) /2 = 560 $普通dfs是4次方，折半一下，就变成了平方级别可以用hash+map存储结果，第二次的时候对应找到，然后累计即可总而言之复杂度$O(560^2 log_2 560^2)$ wa了一次，忘记判断完美情况了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=20;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;int mxdep;bool bk;void dfs(int now[MAXN],int step)&#123; if(bk) return; int f=0; for(int i=1;i&lt;n;i++) if(now[i+1]!=now[i]+1) f++; f=int( ceil(double( f+(now[n]!=n) )/3.0) ); if(f==0) &#123;bk=1;return;&#125; if(step+f&gt;mxdep) return; for(int a=1;a&lt;=n-1;a++) &#123; for(int st=1;st&lt;=n-a+1;st++) &#123; int ed=st+a-1; for(int nw=ed+1;nw&lt;=n;nw++) &#123; //第一段 1~st-1 //第二段 ed+1~nw //第三段 st~ed //第四段 nw+1~n int nx[MAXN],cnt=0; for(int i=1;i&lt;=st-1;i++) nx[++cnt]=now[i]; for(int i=ed+1;i&lt;=nw;i++) nx[++cnt]=now[i]; for(int i=st;i&lt;=ed;i++) nx[++cnt]=now[i]; for(int i=nw+1;i&lt;=n;i++) nx[++cnt]=now[i]; dfs(nx,step+1); &#125; &#125; &#125;&#125;int a[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); bk=0; for(mxdep=0;mxdep&lt;=4;mxdep++)//debug 完美情况 &#123; dfs(a,0); if(bk) break; &#125; if(bk) printf("%d\n",mxdep); else puts("5 or more"); &#125;&#125; 0x29 搜索练习题目 12 POJ3700 Missile Defence System7.18 难度2请先思考后再展开 先给出一份比较显然的做法，一组组找尽力加上了两个剪枝： 仅当没东西选的时候再结束 当前能被now到nx中间的覆盖时，延迟搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int n;int a[MAXN];bool v[MAXN];bool bk;int mxdep;void dfs(int cnt,int tot,int now,int up)&#123; if(bk) return; if(cnt&gt;mxdep) return; if(tot==n) &#123;bk=1;return;&#125; bool b=0; int mi=INF,mx=0; for(int nx=now+1;nx&lt;=n;nx++) &#123; if(v[nx]) continue; if(up==0 and (a[now]&lt;a[nx] or a[nx]&lt;mx)) continue; if(up==1 and (a[now]&gt;a[nx] or a[nx]&gt;mi)) continue; b=1;mi=mymin(mi,a[nx]);mx=mymax(mx,a[nx]); v[nx]=1; if(up&lt;0) dfs(cnt,tot+1,nx,0),dfs(cnt,tot+1,nx,1); else dfs(cnt,tot+1,nx,up); v[nx]=0; &#125; if(!b) &#123; for(int nx=1;nx&lt;=n;nx++) if(!v[nx]) &#123; v[nx]=1; dfs(cnt+1,tot+1,nx,-1); v[nx]=0; break; &#125; &#125;&#125;int main()&#123; while(1) &#123; scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); bk=0; for(mxdep=1;mxdep&lt;=n;mxdep++) &#123; memset(v,0,sizeof v); v[1]=1;dfs(1,1,1,-1); if(bk) break; &#125; printf("%d\n",mxdep); &#125;&#125; 然鹅这样依然会tle原因大概是叉太多了?其实想到这么多剪枝，但方向大概都是错误的 正解是考虑元素，分配组（这大概也是一个套路）这样的话只要贪心地找最不优秀但符合条件的即可顺利变成二叉，然后迭代加深也没意义了，最优性剪枝即可代码就不写了 13 POJ1945 Power Hungry Cows7.18 难度2请先思考后再展开 网上到处都是打表和玄学（其实错误）剪枝来一股IDA*清流吧因为感性地感觉次数不会太多，迭代一下重点是这个估价函数不难猜出最优解一定先倍增上去再微调的那么如果只考虑倍增，实现容易又能满足$f(s) \leq g(s)$的定义 不过有一个应该是正确的剪枝，不太会证明如果P的约数中没有【x和y的最大公约数】，则返回大概原因是，无论怎么操作，得到的数一定是包含这个【x和y的最大公约数】吧想想，好像无论加减都是如此。这个还是挺妙的 官方数据：19997 1815151 1711111 1710007 165123 145111 151234 131024 101023 111010 1231 6然后在这些数据中，没有卡掉一种错误做法：假设较小值不会超过50反例：18673，答案应该是17然后打表发现其实是6160？听别人说的 顺便吐槽一句lyd的代码是打特判过的，根本错误的做法 反正我是没卡过去所有数据都是正确的 IDA*12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int gcd(int x,int y)&#123; return (y==0)?x:gcd(y,x%y);&#125;int P;int f(int x,int y)&#123; if(y==P) return 0; int ans=0; while(x&lt;P) x*=2,ans++; return ans;&#125;bool bk=0;int mxdep;void dfs(int x,int y,int step)&#123; if(bk) return; if(x&lt;y) swap(x,y); if(x&gt;=2*P) return; if(x==0) return; if(P%gcd(x,y)!=0) return; if(step+f(x,y)&gt;mxdep) return; if(x==P or y==P) &#123;bk=1;return;&#125; //x+y dfs(x+y,x,step+1);dfs(x+y,y,step+1); //x-y dfs(x-y,x,step+1),dfs(x-y,y,step+1); //x+x dfs(x+x,x,step+1);dfs(x+x,y,step+1); //y+y dfs(y+y,x,step+1);dfs(y+y,y,step+1);&#125;int main()&#123; scanf("%d",&amp;P); for(mxdep=0;mxdep&lt;=P;mxdep++) &#123; dfs(1,0,0); if(bk) break; &#125; printf("%d",mxdep);&#125; A*，稍微快一点点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=60;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int gcd(int x,int y)&#123; return (y==0)?x:gcd(y,x%y);&#125;int P;int f(int x,int y)&#123; if(y==P) return 0; int ans=0; while(x&lt;P) x*=2,ans++; return ans;&#125;set&lt;ull&gt; has;ull gethas(ull x,ull y)&#123; return x*13331+y;&#125;struct Nod&#123; int x,y; int step,cost; Nod(int a=0,int b=0,int c=0,int d=0) &#123;x=a,y=b,step=c,cost=d;&#125; friend bool operator &gt; (Nod a,Nod b) &#123;return a.step+a.cost&gt;b.step+b.cost;&#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;void push(int x,int y,int step)&#123; if(x&lt;y) swap(x,y); if(x&gt;=2*P) return; if(x==0) return; if(P%gcd(x,y)!=0) return; ull hs=gethas(x,y); if(has.count(hs)) return; has.insert(hs); q.push( Nod(x,y,step,f(x,y)) );&#125;int bfs()&#123; q.push( Nod(1,0,0,f(1,0)) ); has.insert( gethas(1,0) ); while(!q.empty()) &#123; Nod now=q.top();q.pop(); int x=now.x,y=now.y,step=now.step; if(x==P or y==P) return step; push(x+y,x,step+1);push(x+y,y,step+1);//x+y push(x-y,x,step+1),push(x-y,y,step+1);//x-y push(x+x,x,step+1);push(x+x,y,step+1);//x+x push(y+y,x,step+1);push(y+y,y,step+1);//y+y &#125; return -1;&#125;int main()&#123; scanf("%d",&amp;P); printf("%d",bfs());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-1基本数据结构21题]]></title>
    <url>%2Fposts%2F7248.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x10 基本数据结构题目 1 HDU4699 Editor7.3 难度1请先思考后再展开 要特判非法情况，这个是题目没有说明清楚的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100000;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int a[MAXN],sum[MAXN],mx[MAXN],top;void push(int d)&#123; a[++top]=d; sum[top]=sum[top-1]+d; mx[top]=mymax(mx[top-1],sum[top]);&#125;void pop()&#123; top--;&#125;int ign[MAXN],igntp;//ignore元素栈char s[10];int main()&#123; int Q; while(scanf("%d",&amp;Q)!=EOF) &#123; top=0;sum[0]=0; mx[0]=-0x3f3f3f3f;//debug igntp=0; while(Q--) &#123; scanf("%s",s); if(s[0]=='I') &#123; int d;scanf("%d",&amp;d); push(d); &#125; if(s[0]=='D') pop(); if(s[0]=='L') if(top&gt;0) ign[++igntp]=a[top--]; if(s[0]=='R') if(igntp&gt;0) push(ign[igntp--]); if(s[0]=='Q') &#123; int k;scanf("%d",&amp;k); printf("%d\n",mx[k]); &#125; &#125; &#125;&#125; 2 POJ2559 Largest Rectangle in a Histogram7.3 难度2请先思考后再展开 看到提示用单调栈，大概是想通了但发现我只会暴力地确定右端点后，枚举左端点来统计答案 看了发题解，发现大概思路差不多，主要就是统计答案的方法如果从右端点开始考虑，其左端点是不定的但如果稍微换个角度，利用一下单调性，可以发现：对于一个左端点，其最优的右端点只有一个，那就是在其存在时期内最后那个 所谓存在时期，就是它从进入到弹出期间我们可以考虑在它被弹出的时候再统计答案，而这时候，新矩形一定比它小所以从它到【第一个被当前新矩形弹出的矩形】之间，就是当前高度下的最优宽度所以边弹出，边累加宽度并统计答案即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;ll mymax(ll a,ll b) &#123;return a&gt;b?a:b;&#125;struct Nod&#123; int h,w;&#125;a[MAXN];//单调递增int h[MAXN];int main()&#123; while(1) &#123; int n;scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]); h[++n]=0; int top=0;ll ans=0; for(int i=1;i&lt;=n;i++) &#123; if(a[top].h&lt;=h[i]) &#123; a[++top].h=h[i];a[top].w=1; &#125; else &#123; int wid=0; while(top&gt;0 and a[top].h&gt;h[i]) &#123; wid+=a[top].w; ans=mymax(ans,ll(a[top].h)*wid); top--; &#125; a[++top].h=h[i];a[top].w=wid+1;//debug 漏了 &#125; &#125; printf("%lld\n",ans); &#125;&#125; 3 POJ2259 HDU1387 Team Queue7.3 难度2请先思考后再展开 偷懒，用了链表然后看题，一是会有0，完全没注意就用了0表示空二是多一个空行，读题时看到，写题时忘记回想起不久前中考时也有这个毛病或许应该写下这种注意点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100;int ps[MAXN];//位置struct Nod&#123; int a;//所属小组 int nxt;&#125;p[MAXN*MAXN];char s[20];int main()&#123; int cas=0; while(1) &#123; memset(ps,-1,sizeof ps); //debug 没注意到正常编号中有0，所以空应该用-1表示 int n;scanf("%d",&amp;n);if(n==0) break; for(int i=1;i&lt;=n;i++) &#123; int c;scanf("%d",&amp;c); while(c--) &#123; int t;scanf("%d",&amp;t); p[t].a=i;p[t].nxt=-1; &#125; &#125; int qst=-1,qed=-1;//队尾 printf("Scenario #%d\n",++cas); while(1) &#123; scanf("%s",s); if(s[0]=='E') &#123; int t;scanf("%d",&amp;t); int k=ps[p[t].a]; if(k&gt;-1) &#123; p[t].nxt=p[k].nxt; p[k].nxt=t; if(qed==k) qed=t; &#125; else &#123; if(qst==-1) qst=t; if(qed&gt;-1) p[qed].nxt=t; qed=t; &#125; ps[p[t].a]=t; &#125; if(s[0]=='D') &#123; printf("%d\n",qst); if(qst==qed) qed=-1; if(qst==ps[p[qst].a]) ps[p[qst].a]=-1; qst=p[qst].nxt; &#125; if(s[0]=='S') break; &#125; putchar('\n');//debug &#125;&#125; 4 bzoj2457 双端队列7.3 难度3请先思考后再展开 思考难度很大因为 要按照顺序处理数字，而又涉及大小关系，直接线性处理是不可能的考虑把数列排序一波（也可以从数据范围上观察得出）然后记录下标思考能够放在同一个双端队列里，需要满足的特性 结论：在同一个双端队列，对于编号最前的，比它大的要在它后面出现，比它小的也要在后面出现，而且与它的差越大，与它的距离差就应该越大如果用图像来表示，把排序后的数列，排名为x，原坐标为y，则必须是一个单谷图像 所以，大致上的流程就是：排序， 按从小到大处理数列，记录递增或递减趋势，记录有多少个图像但还有个细节：对于排名也就是大小一样的数，它们的原坐标顺序是可以任意排列的为了尽量减少单谷数量，对于大小相同的一段，内部在单调时最优。所以只要记录每一段的最大和最小值，任意变形来贪心地连接起来就好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;struct Nod&#123; int d,p;&#125;a[MAXN];bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d or (a.d==b.d and a.p&lt;b.p);&#125;int nx=0,mi[MAXN],mx[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].d),a[i].p=i; sort(a+1,a+n+1,cmp); mi[1]=1; for(int i=1;i&lt;=n;i++) if(i==1 or a[i-1].d!=a[i].d) &#123; mx[nx]=a[i-1].p; mi[++nx]=a[i].p; &#125; mx[nx]=n; bool up=1; int ans=0,ed=0x3f3f3f3f; for(int i=1;i&lt;=nx;i++) &#123; if(up) &#123; if(ed&lt;mi[i]) ed=mx[i]; else up=0,ans++,ed=mi[i]; &#125; else//down &#123; if(ed&gt;mx[i]) ed=mi[i]; else up=1,ed=mx[i]; &#125; &#125; printf("%d",ans);&#125; 5 1201 最大子序和7.3 难度1请先思考后再展开 这道题初看像是有限制条件的最大子段和，然鹅方法完全不一样首先，因为有长度限制，在枚举右端点的过程中，需要把左端点向右移那么因为和可以表示为sum[i]-sum[j-1],i-j+1&lt;=m因为我们的右端点是固定的，所以只要搞出一个符合条件中最小的sum[j-1]即可 稍微提醒一下，一定要明确是sum[j-1]而不是sum[j]，逻辑差别很大然后就wa了多次……12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=310000;const int INF=0x3f3f3f3f;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int sum[MAXN];struct Nod&#123; int d; int p;&#125;a[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;sum[i]); sum[i]+=sum[i-1]; &#125; int ans=0; int l=1,r=1; a[1].d=0,a[1].p=0; //debug,sum[i]-sum[j-1]，重点是【j-1】而不是【j】 for(int i=1;i&lt;=n;i++) &#123; while(l&lt;=r and i-a[l].p&gt;m) l++;//debug,i-j+1&lt;=m,i-(j-1)&lt;=m ans=mymax(ans,sum[i]-sum[a[l].p]); while(l&lt;=r and a[r].d&gt;=sum[i]) r--; a[++r].d=sum[i];a[r].p=i; &#125; printf("%d",ans);&#125; 6 POJ3349 Snowflake Snow Snowflakes7.4 难度2请先思考后再展开 这道题是真的毒瘤本来用hash判重，然后丢到set里面结果不是hash被卡wa就是stl被卡tle 总之，不得不用hash表，第一次写这玩意，以前只会理论各种tle，抄了很多书上的代码，改了改类型、模数，才卡了过去1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int now[6];const int Mod=100003;int gethash()&#123; int has=1; for(int i=0;i&lt;=5;i++) if(now[i]!=0) has=( ll(has)*now[i] )%Mod; //debug,爆int for(int i=0;i&lt;=5;i++) has=(has+now[i])%Mod; return has;&#125;struct HashTable&#123; int a[6]; int nxt; HashTable() &#123; nxt=0; &#125;&#125;a[MAXN];int head[Mod+10];int id=0;bool equal(int t,int op)&#123; for(int i=0;i&lt;=5;i++) for(int j=0;j&lt;=5;j++) &#123; int s; for(s=0;s&lt;=5;s++) if(a[t].a[(i+s+6)%6]!=now[(j+s*op+6)%6]) break; if(s==6) return 1; &#125; return 0;&#125;int main()&#123; int n;scanf("%d",&amp;n); while(n--) &#123; for(int i=0;i&lt;=5;i++) scanf("%d",&amp;now[i]); int has=gethash(); for(int t=head[has];t&gt;0;t=a[t].nxt) if(equal(t,1) or equal(t,-1)) &#123; printf("Twin snowflakes found."); return 0; &#125; a[++id].nxt=head[has]; memcpy(a[id].a,now,sizeof now); head[has]=id; &#125; printf("No two snowflakes are alike.");&#125; 7 1401 兔子与兔子7.4 难度1请先思考后再展开 裸题12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;ull has[MAXN];const ull Base=13331;ull bs[MAXN];ull gethash(int l,int r)&#123; return has[r]-has[l-1]*bs[r-l+1];&#125;char s[MAXN];int main()&#123; scanf("%s",s+1); int len=strlen(s+1); bs[0]=1; for(int i=1;i&lt;=len;i++) &#123; bs[i]=bs[i-1]*Base; has[i]=has[i-1]*Base+s[i]; &#125; int m;scanf("%d",&amp;m); while(m--) &#123; int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); if(gethash(a,b)==gethash(c,d)) printf("Yes\n"); else printf("No\n"); &#125;&#125; 8 POJ1961 Period7.4 难度1请先思考后再展开 经典题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;char s[MAXN];int nxt[MAXN];void prekmp(int len)&#123; int j=0;nxt[1]=0; for(int i=2;i&lt;=len;i++)//debug，从2开始，否则不符合定义 &#123; while(j&gt;0 and s[j+1]!=s[i]) j=nxt[j]; if(s[j+1]==s[i]) j++; nxt[i]=j; &#125;&#125;int main()&#123; int cas=0; while(1) &#123; int len;scanf("%d",&amp;len);if(len==0) break; scanf("%s",s+1); prekmp(len); printf("Test case #%d\n",++cas); for(int i=1;i&lt;=len;i++) if(i-nxt[i]&gt;0 and (i%(i-nxt[i]))==0 and nxt[i]&gt;0) printf("%d %d\n",i,i/(i-nxt[i])); putchar('\n');//debug &#125;&#125; 9 1602 The XOR Largest Pair7.4 难度1请先思考后再展开 居然对了！虽然不是1a，因为有个地方，得到的是int，就re了思路：把所有数转化成二进制，用类似字典树的结构存储对于i，先统计答案，i是其中一个，贪心地找另一个具体来说，贪心地从高位开始，尽量往反方向走，累计答案当然是在不行还是要走正方向统计完后，把这个串加入到字典树中供后人用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=4000000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int bin[40];struct Trie&#123; int son[2];&#125;p[MAXN];int id=0;void clear(int x)&#123; p[x].son[0]=p[x].son[1]=-1;&#125;int now[40];void add()&#123; int x=0; for(int i=30;i&gt;=0;i--) &#123; if(p[x].son[now[i]]&lt;0) &#123; p[x].son[now[i]]=++id; clear(id); &#125; x=p[x].son[now[i]]; &#125;&#125;int solve()&#123; int x=0,ans=0; for(int i=30;i&gt;=0;i--) &#123; int nx=p[x].son[ 1-now[i] ]; if(nx&gt;0) &#123; ans+=bin[i]; x=nx; &#125; else if(p[x].son[now[i]]&gt;0) x=p[x].son[now[i]]; else break; &#125; return ans;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]*2; int n;scanf("%d",&amp;n); clear(0); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); for(int j=0;j&lt;=30;j++) now[j]=( t&amp;bin[j] )&gt;0;//debug 原本是int if(i&gt;1) ans=mymax(ans,solve()); add(); &#125; printf("%d",ans);&#125; 10 POJ3764 The xor-longest Path7.4 难度2请先思考后再展开 想了一个小时，看到题解前半段的那一刻，难受的一匹原来和上一题是一样的！ x到y路径上xor和=x到根xor和 xor y到根xor和这基于同一个数xor自己，得到0，而0 xor 任何数=任何数 然鹅，自己在思考的时候，却想着还要xor lca(x,y)到根因为感觉那部分只出现了一次，神tm自己想再补上一次……感觉这给我的教训是要多动笔写下来，这样不容易错我才不会说这是因为笔被我整天乱扔，摔断墨了……自作自受吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int bin[40];struct Trie&#123; int son[2];&#125;tr[4000000];int id=0;void clear(int x)&#123; tr[x].son[0]=tr[x].son[1]=-1;&#125;int now[40];void add()&#123; int x=0; for(int i=30;i&gt;=0;i--) &#123; if(tr[x].son[now[i]]&lt;0) &#123; tr[x].son[now[i]]=++id; clear(id); &#125; x=tr[x].son[now[i]]; &#125;&#125;int solve()&#123; int x=0,ans=0; for(int i=30;i&gt;=0;i--) &#123; int nx=tr[x].son[ 1-now[i] ]; if(nx&gt;0) ans+=bin[i],x=nx; else if(tr[x].son[now[i]]&gt;0) x=tr[x].son[now[i]]; else break; &#125; return ans;&#125;struct Nod&#123; int hou; int dis;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;void dfs(int x,int fa)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis xor e[k].c; dfs(y,x); &#125;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]*2; int n; while(scanf("%d",&amp;n)!=EOF) &#123; p[1].dis=0;ln=0; for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); x++;y++; ins(x,y,c);ins(y,x,c); &#125; dfs(1,0); id=0;clear(0); int ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=30;j++) now[j]=( p[i].dis&amp;bin[j] )&gt;0; if(i&gt;1) ans=mymax(ans,solve()); add(); &#125; printf("%d\n",ans); &#125;&#125; 11 POJ1456 Supermarket7.4 难度3请先思考后再展开 一开始写了个错误的贪心：直接按照过期排序，第二关键字是价值但这样就考虑不了【过期冲突，价值极大】的情况 先明确：如果现在是第t天，则应卖出能卖出的前t大有一个套路，能够给限定数量的局部贪心后悔药：维护一个大小为t的堆，堆顶是最不优秀的元素，尝试替换来修正原方案12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=11000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int p,d; friend bool operator &gt; (Nod a,Nod b) &#123;return a.p&gt;b.p;&#125;&#125;a[MAXN];bool cmp(Nod a,Nod b) &#123; return a.d&lt;b.d; &#125;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int main()&#123; int n; while(scanf("%d",&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].p,&amp;a[i].d); sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; int siz=q.size(); if(siz&lt;a[i].d) q.push(a[i]); else if(a[i].p&gt;q.top().p) q.pop(),q.push(a[i]); &#125; int ans=0; while(!q.empty()) ans+=q.top().p,q.pop(); printf("%d\n",ans); &#125;&#125; 12 POJ2442 Sequence7.5 难度3请先思考后再展开 1.既然跟大小有关，先把每个序列排好序，确认了最小答案 2.因为直接枚举方案会超时这是因为产生了很多因为过大而无用的状态 这就用到了一个新套路（又被akc轻松想出）把所有最小值组成一个方案，放进堆里面通过堆进行决策的同时，基于堆的最优性进行拓展因为我们已经排好了序，拓展只是某个指针的前移此时复杂度是$O( n^2 \times log(nm) )$濒临超时 3.然鹅，上述方案有个致命的问题两个不同的状态可能拓展出相同的状态感觉强行hash判重也可以，不过没必要 4.有一个不那么好想的方法（或许利用了答案要求的数量和序列长度相同这个特性）先把两个序列合并，把得到的前n个作为一个新的序列然后像同余方程组那样逐个合并。而且，由于每次只处理两个数列，可以用bool判重解决上面的问题 复杂度$O( m \times n \times 2 \times log(n) )$，飞快 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=2100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n;int a0[MAXN],a1[MAXN];struct Nod&#123; int i,j; Nod(int x=0,int y=0) &#123;i=x,j=y;&#125; friend bool operator &gt; (Nod x,Nod y) &#123; return a0[x.i]+a1[x.j]&gt;a0[y.i]+a1[y.j]; &#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;bool v[MAXN][MAXN];void add(int i,int j)&#123; if(!v[i][j]) &#123; v[i][j]=1; q.push( Nod(i,j) ); &#125;&#125;int tmp[MAXN];void merg()&#123; memset(v,0,sizeof v);//debug 每次merg前，而不是每组数据 while(!q.empty()) q.pop(); add(1,1); for(int i=1;i&lt;=n;i++) &#123; Nod tp=q.top();q.pop(); tmp[i]=a0[tp.i]+a1[tp.j]; if(tp.i+1&lt;=n) add(tp.i+1,tp.j); if(tp.j+1&lt;=n) add(tp.i,tp.j+1); &#125; memcpy(a0,tmp,sizeof tmp);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int m;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a0[i]); sort(a0+1,a0+n+1); for(int t=2;t&lt;=m;t++) &#123; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a1[i]); sort(a1+1,a1+n+1); merg(); &#125; for(int i=1;i&lt;=n;i++) printf("%d ",a0[i]); putchar('\n'); &#125;&#125; 13 CTSC2007 数据备份 &amp; bzoj2151 种树7.5 难度2请先思考后再展开 这道题一年多以前做过，当时并没有blog然后我yy着就和远古时期的我产生了共鸣，回忆起了一个细节：在堆中进行可后悔决策然鹅完全没有思路虽然顺便又把一个关键性质想到了：不会有线路的重叠，故只会和旁边产生关系 如果想到这里，想必大佬们都能快速的想到怎么做然后我还是蒙逼状态，尽管我又把一个关键的图画了出来：四个点之间的连线x-1、x、x+1 是不是觉得我灰常无可救药？都已经把所有前提想到了，还是不会…… 事实上：有一种贪心策略：每次找最短的一条边，然后把它两边的删除但这样其实很容易举出反例，例如4,2,4,100000 怎么办？引入后悔机制，不要急着排除两边相反，在堆种放入一个c[x-1]+c[x+1]-c[x]也就是说，如果我再选择了一次，那么我就是花费两条边，把x-1和x+1建好了当然如果没有再被拿出，意味着没必要 细细思考，不难发现这样能同时满足互斥的两种状态决策总而言之，听起来灰常有道理，只不过不好想到【据说是一种模型，靠积累】 还有一些细节 如果我们放进去的被拿出来，意味着建两条边，那还是要找左右两侧的更远的边，在堆中去除因为要延长伸展，用链表比较方便 去除可以用可删堆，但还要确保编号相同；用set就灰常不方便了，毕竟是结构体；还有种方法是判断其是否和外界数据不同，表示其过时，直接弹出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int d,x; Nod(int a=0,int b=0) &#123; d=a,x=b; &#125; friend bool operator &gt; (Nod a,Nod b) &#123; return a.d&gt;b.d; &#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int s[MAXN];int l[MAXN],r[MAXN];int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); int lst=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); s[i]=t-lst;lst=t; if(i&gt;1) q.push( Nod(s[i],i) ); l[i]=i-1;r[i]=i+1; &#125; //边界哨兵节点 l[2]=1;s[1]=INF; r[n]=n+1;s[n+1]=INF; int ans=0; while(k--) &#123; while(q.top().d!=s[q.top().x]) q.pop();//old Nod now=q.top();q.pop(); int x=now.x,left=l[x],right=r[x]; //后悔药 s[x]=s[left]+s[right]-s[x];//debug 忘记更新s[x]，直接塞进去了 q.push( Nod(s[x],x) ); //删除左右 l[x]=l[left];r[l[left]]=x; r[x]=r[right];l[r[right]]=x; s[left]=INF;s[right]=INF; //统计答案 ans+=now.d; &#125; printf("%d",ans);&#125; 14 NOI2015 荷马史诗bzoj4198 luogu2168 uoj130 loj21327.5 难度2请先思考后再展开 入门好题，教程：【OI之路】09经典问题-3哈夫曼树 唯一不同的是第二问，要求最大深度最小构造哈夫曼树的时候，我们只是保证了带权路径长度和最小但当我们面对两个相同权值，但是一个下面的最大深度大的和小的这个时候，如果先合并下面的最大深度大的，答案会更大而先合并小的，就能把后面的机会留下了，从而减小了树的最大深度 具体做法很简单，重载堆的比较函数时，把下面的最大深度作为第二关键字，优先小的就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; ll w; int c;//最大深度 Nod(ll a=0,int b=0) &#123;w=a,c=b;&#125; friend bool operator &gt; (Nod a,Nod b) &#123; return a.w&gt;b.w or (a.w==b.w and a.c&gt;b.c); &#125;&#125;;priority_queue&lt; Nod,vector&lt;Nod&gt;,greater&lt;Nod&gt; &gt; q;int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) &#123; ll t;scanf("%lld",&amp;t); q.push( Nod(t,0) ); &#125; while( (int(q.size())-1)%(k-1)!=0 ) q.push( Nod(0,0) ); ll ans=0; while(1) &#123; ll tot=0; int mxdep=0; for(int i=1;i&lt;=k;i++) &#123; Nod now=q.top();q.pop(); mxdep=mymax(mxdep,now.c); tot+=now.w; &#125; ans+=tot; if(q.empty()) &#123; printf("%lld\n%d",ans,mxdep+1); break; &#125; q.push( Nod(tot,mxdep+1) ); &#125;&#125; 0x18 基本数据结构练习题目 15 1801 括号画家7.6 难度1请先思考后再展开 考细节……应自己构造数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;char s[MAXN];int sta[MAXN],top=0;int main()&#123; scanf("%s",s+1);int len=strlen(s+1); int ans=0; int lst=0; for(int i=1;i&lt;=len;i++) &#123; int now; if(s[i]=='&#123;') now=0; if(s[i]=='&#125;') now=5; if(s[i]=='[') now=1; if(s[i]==']') now=4; if(s[i]=='(') now=2; if(s[i]==')') now=3; if(now&lt;=2) sta[++top]=now; else &#123; if(top&gt;0 and sta[top]+now==5) lst+=2,top--; else ans=mymax(ans,lst),lst=0,sta[++top]=now; &#125; &#125; printf("%d",ans=mymax(ans,lst));&#125; 16 POJ1964 City Game7.6 难度2请先思考后再展开 骚操作预处理出每个点最大向上高度然后看作是二维的Largest Rectangle in a Histogram……1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int h,w; Nod(int a=0,int b=0) &#123;h=a,w=b;&#125;&#125;a[MAXN];int up[MAXN][MAXN];char c[10];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; scanf("%s",c); up[i][j]=(c[0]=='F')?1+up[i-1][j]:0; &#125; up[i][m+1]=0; int top=1;a[1]=Nod(up[i][1],1); for(int j=2;j&lt;=m+1;j++) &#123; int wid=0; while(top&gt;0 and a[top].h&gt;=up[i][j])//debug 判top&gt;0 &#123; wid+=a[top].w; ans=mymax(ans,a[top--].h*wid); &#125; a[++top]=Nod(up[i][j],wid+1); &#125; &#125; printf("%d\n",3*ans); &#125;&#125; 17 NOI1999 内存分配7.6 难度2请先思考后再展开 打了一大半很多细节问题先放着代码吧复杂度估计$O(n \sqrt n)$（如果块状链表）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=11000;const int INF=0x3f3f3f3f;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Lb&#123; int st,ed;//内存 //应该改成ln形式 Lb(int a=0,int b=0) &#123;st=a,ed=b;&#125;&#125;a[MAXN*20];int tou,ll[MAXN*20],rr[MAXN*20];int id=0;struct Task&#123; int st,ln;//内存 int tst,ti;//时间 friend bool operator &gt; (Task a,Task b) &#123;return a.tst+a.ti&gt;b.tst+b.ti;&#125;&#125;;priority_queue&lt; Task,vector&lt;Task&gt;,greater&lt;Task&gt; &gt; q;Task fail[MAXN];int fl=1,fr=0;int ans=0;void pop_update()&#123; Task now=q.top();q.pop(); int nowed=now.st+now.ln-1;//内存 ans=now.tst+now.ti-1; int x=tou; while(x&gt;0) &#123; int rx=rr[x],rrx=rr[rx]; int ma=0; if(x==tou) &#123; if(nowed+1==a[x].st)//debug 特判新的tou &#123; a[x].st=now.st; ma=x; &#125; else if(nowed&lt;a[x].st) &#123; tou=++id;//debug 原id++ rr[tou]=x;ll[x]=tou; a[tou].st=now.st;a[tou].ed=now.st+now.ln-1;//debug 漏了 ma=tou; &#125; &#125; else if(rx==0) &#123; if(a[x].ed+1==now.st) &#123; a[x].ed=nowed; ma=x; &#125; else &#123; a[++id].st=now.st;a[id].ed=nowed; rr[x]=id;ll[id]=x; ma=id; &#125; &#125; else &#123; if(a[x].ed+1==now.st and nowed+1==a[rx].st)//二合一 &#123; a[x].ed=a[rx].ed;ll[x]=rrx;ll[rrx]=x; ma=x; &#125; else if(a[x].ed+1==now.st) &#123; a[x].ed=nowed; ma=x; &#125; else if(nowed+1==a[rx].st) &#123; a[rx].st=now.st; ma=rx; &#125; else if(a[x].ed&lt;now.st and nowed&lt;a[rx].st) &#123; a[++id].st=now.st;a[id].ed=nowed; rr[x]=id;ll[id]=x;ll[rx]=id;rr[id]=rx; ma=id; &#125; &#125; if(ma&gt;0) &#123; while(fl&lt;=fr and a[ma].ed-a[ma].st+1&gt;=fail[fl].ln)//debug 写成&lt;= &#123; fail[fl].st=a[ma].st;fail[fl].tst=now.tst+now.ti-1+1;//debug q.push(fail[fl]);a[ma].st+=fail[fl++].ln; &#125; if(a[ma].st&gt;a[ma].ed)//空 &#123; if(ma==tou) &#123; &#125; rr[ll[ma]]=rr[ma];ll[rr[ma]]=ll[ma]; if(ma==tou and rr[tou]&gt;0) tou=rr[ma];//debug 特判tou，避免环 &#125; return; &#125; x=rx; &#125;&#125;void try_push(int tst,int ln,int ti)&#123; int x=tou; while( x&gt;0 ) &#123; int lx=ll[x],rx=rr[x]; if( a[x].ed-a[x].st+1&gt;=ln )//succeed &#123; Task tmp; tmp.st=a[x].st,tmp.ln=ln; tmp.tst=tst,tmp.ti=ti; q.push(tmp); a[x].st += ln; if(a[x].st&gt;a[x].ed and x!=tou)//空 &#123; rr[lx]=rx; ll[rx]=lx; &#125; return; &#125; x=rx; &#125; fail[++fr].ln=ln; fail[fr].ti=ti;&#125;int main()&#123; int n;scanf("%d",&amp;n); tou=++id; a[tou]=Lb(0,n-1); ll[tou]=0,rr[tou]=0; while(1) &#123; int tst,ln,ti;scanf("%d%d%d",&amp;tst,&amp;ln,&amp;ti); if(tst==0 and ln==0 and ti==0) break; while(!q.empty() and q.top().tst+q.top().ti-1&lt;tst) pop_update(); try_push(tst,ln,ti); &#125; while(!q.empty()) pop_update(); printf("%d\n%d",ans+1,fr);//debug 要求所有彻底结束 //printf("fl=%d fr=%d",fl,fr);&#125; 18 1806 Matrix7.7 难度2请先思考后再展开 第一次二维hash，所以学了下题目的特性在于a和b固定，所以可以直接预处理出每个矩阵的hash然后排个序，后面的询问就灰常快了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n,m,a,b;const ull Base1=131;const ull Base2=13331;int cnt=0;ull sum[MAXN*MAXN];char s[MAXN];ull h[MAXN][MAXN];int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b); ull b1a=1;for(int i=1;i&lt;=a;i++) b1a*=Base1;//Base1^a ull b2b=1;for(int i=1;i&lt;=b;i++) b2b*=Base2;//Base2^b for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) &#123; h[i][j]=h[i-1][j]*Base1+h[i][j-1]*Base2-h[i-1][j-1]*Base1*Base2+s[j]-'0'; if(i&gt;=a and j&gt;=b) sum[++cnt]=(h[i][j]-h[i-a][j]*b1a)-(h[i][j-b]-h[i-a][j-b]*b1a)*b2b; &#125; &#125; sort(sum+1,sum+cnt+1); int q;scanf("%d",&amp;q); while(q--) &#123; for(int i=1;i&lt;=a;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=b;j++) h[i][j]=h[i-1][j]*Base1+h[i][j-1]*Base2-h[i-1][j-1]*Base1*Base2+s[j]-'0'; &#125; int t=lower_bound(sum+1,sum+cnt+1,h[a][b])-sum; printf("%d\n",sum[t]==h[a][b]); &#125;&#125; 19 1807 Necklace7.7 难度1请先思考后再展开 最小表示法裸题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int len;char s[2][MAXN*2];int getmin(int w)&#123; int a=1,b=2; while(1) &#123; if(a==b) b++; if(a&gt;b) swap(a,b); if(b&gt;len) return a; bool bk=1;//相同 for(int k=0;k&lt;=len-1;k++) &#123; if(s[w][a+k]&lt;s[w][b+k]) &#123;b=b+k+1;bk=0;break;&#125; else if(s[w][a+k]&gt;s[w][b+k]) &#123;a=a+k+1;bk=0;break;&#125; &#125; if(bk) return 1; &#125;&#125;int main()&#123; scanf("%s%s",s[0]+1,s[1]+1);len=strlen(s[0]+1); for(int i=1;i&lt;=len;i++) s[0][len+i]=s[0][i],s[1][len+i]=s[1][i]; int k0=getmin(0),k1=getmin(1); for(int i=0;i&lt;=len-1;i++) if(s[0][k0+i]!=s[1][k1+i]) &#123; puts("No"); return 0; &#125; puts("Yes");for(int i=0;i&lt;=len-1;i++) printf("%c",s[0][k0+i]);&#125; 20 POJ2185 Milking Grid7.8 难度2请先思考后再展开 有关kmp与最小覆盖的前置知识，请搜索kmp查看教程 然后一开始猜一手结论，行取max，列同样，居然ac了其实后来我和mocha经过探讨发现，max是不正确的（例如6和9，除非问题改成陶陶的名字），应该取lcm UP 2018.7.11其实lcm也是错误的反例8 2AABBBBAAAAABBAAA 正确的方法应该是强行比较的kmp（hash也行，快一点）代码已更正123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=1100000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int n,m;char s[11000][110];int nxt[11000];bool cmp1(int col1,int col2)&#123; for(int row=1;row&lt;=n;row++) if(s[row][col1]!=s[row][col2]) return 0; return 1;&#125;int getnext1()&#123; nxt[1]=0; for(int i=2;i&lt;=m;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and !cmp1(j+1,i)) j=nxt[j]; nxt[i]=j+cmp1(j+1,i); &#125; return m-nxt[m];&#125;bool cmp2(int row1,int row2)&#123; for(int col=1;col&lt;=m;col++) if(s[row1][col]!=s[row2][col]) return 0; return 1;&#125;int getnext2()&#123; nxt[1]=0; for(int i=2;i&lt;=n;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and !cmp2(j+1,i)) j=nxt[j]; nxt[i]=j+cmp2(j+1,i); &#125; return n-nxt[n];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%s",s[i]+1); printf("%d",getnext1()*getnext2());&#125; 21 bzoj2288 生日礼物7.9 难度2请先思考后再展开 有一个灰常关键的步骤：由贪心知，连续的正数、负数一定是同时选取的所以可以直接合并起来考虑 把正数的段计数，我们的任务就是，在花费最少的前提下，把正数减少到m及以下减少的方法有两个，一是选取一个正数，然后把相邻的负数合并起来（因为必须要连续），代价为正数值二是选取一个负数，把相邻的正数合并，这样代价是负数绝对值综上所述，我们可以把所有数的绝对值放到小根堆里面，统计正数的数量，每次弹出直到数量在m以下即可 还有两个细节 三个数合并之后，正负性是没有意义的，我们前面是为了统计tot并确保算法正确性 对于边缘的负数，要予以忽略！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Num&#123; int d,pos; Num(int t,int p) &#123;d=t,pos=p;&#125; friend bool operator &gt; (Num a,Num b) &#123;return myabs(a.d)&gt;myabs(b.d);&#125;&#125;;int f[MAXN];//值int l[MAXN],r[MAXN];//链表priority_queue&lt; Num,vector&lt;Num&gt;,greater&lt;Num&gt; &gt; q;void del(int x)&#123; f[x]=INF; r[l[x]]=r[x]; l[r[x]]=l[x];&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int ans=0,tot=0,cnt=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if( i&gt;1 and (t&gt;0)==(f[cnt]&gt;0) ) f[cnt]+=t; else f[++cnt]=t; &#125; for(int i=1;i&lt;=cnt;i++) &#123; if(f[i]&gt;0) tot++,ans+=f[i]; q.push( Num(f[i],i) ); l[i]=i-1;r[i]=i+1; &#125; while(tot&gt;m) &#123; tot--;//debug 要在前面 while(!q.empty() and q.top().d!=f[q.top().pos]) q.pop();//old Num now=q.top();q.pop(); int x=now.pos,lx=l[x],rx=r[x]; if( (l[x]!=0 and r[x]!=cnt+1) or f[x]&gt;0 ) &#123; ans-=myabs(f[x]); f[x]=f[lx]+f[x]+f[rx]; q.push( Num(f[x],x) ); del(lx);del(rx);//删除 &#125; else tot++;//忽略边缘负数 &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【训练】算法竞赛进阶指南-0基本算法23题]]></title>
    <url>%2Fposts%2Fcfc5.html</url>
    <content type="text"><![CDATA[本处难度分档以个人实力为参照系难度1：半小时内想出，半小时内ac难度2：半小时想不出，看题解，服气难度3：半小时想不出，看题解，ac后依然觉得难度很大 0x00 基本算法题目 1 0103 最短Hamilton路径6.27 难度1请先思考后再展开 没难度，虽然一开始灰常尴尬地没注意到终点必须是n-11234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int MAXN=21;int f[MAXN][1&lt;&lt;MAXN];int mp[MAXN][MAXN];int bin[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;MAXN;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d",&amp;n); for(int i=0;i&lt;=n-1;i++) for(int j=0;j&lt;=n-1;j++) scanf("%d",&amp;mp[i][j]); int tot=bin[n]-1;//0~tot memset(f,0x3f,sizeof f); f[0][bin[0]]=0; for(int S=1;S&lt;tot;S++) &#123; for(int ed=0;ed&lt;=n-1;ed++)//内 &#123; if( !(S&amp;bin[ed]) ) continue; for(int x=0;x&lt;=n-1;x++)//外 &#123; if(S&amp;bin[x]) continue; f[x][ S+bin[x] ]=mymin(f[x][ S+bin[x] ],f[ed][S]+mp[x][ed]); &#125; &#125; &#125; printf("%d",f[n-1][tot]);&#125; 2 费解的开关6.28 难度2请先思考后再展开 关键性质：如果从某个格子的状态考虑，它的状态取决于它被覆盖了多少次的奇偶性1而与次序无关！所以说先点还是后点没有意义，只需要知道要点哪里就是了；同理，重复点也是没有用的。 那么第一行的点击方式就确定下来了，接下来一行行消除然后为了把第一行的1消除，只能按第二行的对应点，以此类推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mp[5][5];int now[5][5];void change(int x,int y)&#123; if(x&gt;=0 and x&lt;=4 and y&gt;=0 and y&lt;=4) now[x][y]^=1;&#125;void press(int x,int y)&#123; change(x-1,y); change(x,y-1);change(x,y);change(x,y+1); change(x+1,y);&#125;int bin[10];char s[10];int main()&#123; bin[0]=1;for(int i=1;i&lt;=5;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); while(T--) &#123; for(int i=0;i&lt;=4;i++) &#123; scanf("%s",s); for(int j=0;j&lt;=4;j++) mp[i][j]=s[j]-'0'; &#125; int mi=7; for(int l1=0;l1&lt;=bin[5]-1;l1++) &#123; memcpy(now,mp,sizeof now); int ans=0; for(int j=0;j&lt;=4;j++) if(l1&amp;bin[j]) press(0,j),ans++; for(int i=1;i&lt;=4;i++) for(int j=0;j&lt;=4;j++) if(now[i-1][j]==0) press(i,j),ans++; if(now[4][0]+now[4][1]+now[4][2]+now[4][3]+now[4][4]==5 and ans&lt;mi) mi=ans; &#125; if(mi!=7) printf("%d\n",mi); else printf("-1\n"); &#125;&#125; 3 [HNOI2003]激光炸弹6.28 难度1见这里激光炸弹 POJ3263 Tallest Cow6.28 难度2请先思考后再展开 开始想着查分约束，但是很慢而且没法确保最高点定值，建图也很麻烦实在没有思路看了发题解感觉这种贪心的方式很恶心，而且题意实在太不清晰了（理解分析能力？） 其实就是，假设所有人都是最高点然后因为相互看到必须中间都小于，所以不会交叉（括号序列）所以可以统计被覆盖次数，由于小于的传递性，这个削弱次数直接取-1然后必须要去重，否则无意义削弱1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=11000;struct Nod&#123; int l,r;&#125;s[MAXN];bool cmp(Nod a,Nod b) &#123;return a.l&lt;b.l or (a.l==b.l and a.r&lt;b.r);&#125;int cf[MAXN];int main()&#123; int n,mx,h,q;scanf("%d%d%d%d",&amp;n,&amp;mx,&amp;h,&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;s[i].l,&amp;s[i].r); if(s[i].l&gt;s[i].r) swap(s[i].l,s[i].r); &#125; sort(s+1,s+q+1,cmp); for(int i=1;i&lt;=q;i++) &#123; //去重 if(s[i].l==s[i-1].l and s[i].r==s[i-1].r) continue; cf[s[i].l+1]--;cf[s[i].r]++; &#125; int sum=0; for(int i=1;i&lt;=n;i++) &#123; sum+=cf[i]; printf("%d\n",h+sum); &#125;&#125; 4 POJ1845 Sumdiv6.28 难度2以前的原题这里 5 POJ3889 Fractal Streets6.28 难度2请先思考后再展开 看到这个分形图就有点慌主要难点就是怎么把编号换成坐标，而且这个编号还是连续的然后随便写了几个，找不到规律膜了膜题解 其实，正是因为这是分形，可以递归求解这个旋转，其实是可以对坐标操作一下的，具体自己推+找规律然后其实它总是从左上到右上到右下到左下的所以可以直接按照编号的大小确定属于哪个区域123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;double mysqr(double x) &#123;return x*x;&#125;int bin[30];struct Nod&#123; int x,y; Nod(int a=0,int b=0) &#123;x=a,y=b;&#125;&#125;;Nod calc(int n,int old)&#123; if(n==0) return Nod(1,1); int wid=bin[n-1],sq=wid*wid;//小 边长和面积 if(old&lt;=sq)//左上 &#123; Nod tmp=calc(n-1,sq-old+1);//找规律得new=sq-old+1 return Nod(tmp.y,wid-tmp.x+1); &#125; else if(old&lt;=2*sq)//右上 &#123; old-=sq; Nod tmp=calc(n-1,old); return Nod(tmp.x,wid+tmp.y); &#125; else if(old&lt;=3*sq)//右下 &#123; old-=2*sq; Nod tmp=calc(n-1,old); return Nod(wid+tmp.x,wid+tmp.y); &#125; else//左下 &#123; old-=3*sq; Nod tmp=calc(n-1,sq-old+1);//找规律得new=sq-old+1 return Nod(wid+(wid-tmp.y+1),tmp.x); &#125;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); while(T--) &#123; int n,st,ed;scanf("%d%d%d",&amp;n,&amp;st,&amp;ed); Nod a=calc(n,st),b=calc(n,ed); double d=sqrt(mysqr(a.x-b.x)*100+mysqr(a.y-b.y)*100); printf("%d\n",int(round(d))); &#125;&#125; 6 POJ2018 Best Cow Fences6.28 难度2请先思考后再展开 首先用二分，判定是否有满足条件的一段，平均值&gt;=mid然后最精妙的地方就是所有数-mid这样就从【与长度有关的平均值】变成了【与长度无关的和】直观点就是，如今$$sum=s[i]-s[j],0 \le j \le i-L$$如果sum&gt;=0，那么就满足条件 显然在s[j]最小时最优，二每新计算一个i，都带来一个新的j所以记录前面的最小值就好了 至于卡精度这种事……精A罢12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;int n,L;int a[MAXN];ll s[MAXN];bool check(int mid)&#123; for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i]-mid; int mi=s[0]; for(int i=L;i&lt;=n;i++)//new &#123; if(s[i-L]&lt;mi) mi=s[i-L];//new if(s[i]-mi&gt;=0) return 1; &#125; return 0;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;L); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),a[i]*=1000; int l=0,r=2000000,ans; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(mid)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d",ans);&#125; 7 cf670-C Cinema6.28 难度1请先思考后再展开 离散化裸题居然是c题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;struct Nod&#123; int d,p;&#125;ls[MAXN*3];bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125;int a[MAXN];int ct[MAXN*3];//统计struct Movie&#123; int q,w; int p;&#125;mv[MAXN];bool cmp2(Movie a,Movie b)&#123; return (ct[a.q]&gt;ct[b.q]) or (ct[a.q]==ct[b.q] and ct[a.w]&gt;ct[b.w]);&#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;ls[i].d),ls[i].p=i; int m;scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;ls[n+i].d),ls[n+i].p=n+i; for(int i=1;i&lt;=m;i++) scanf("%d",&amp;ls[n+m+i].d),ls[n+m+i].p=n+m+i; int tot=n+m+m;sort(ls+1,ls+tot+1,cmp); int nw=0; for(int i=1;i&lt;=tot;i++) &#123; if(ls[i-1].d!=ls[i].d) nw++; if(ls[i].p&lt;=n) a[ls[i].p]=nw; else if(ls[i].p&lt;=n+m) mv[ls[i].p-n].q=nw; else mv[ls[i].p-n-m].w=nw; &#125; for(int i=1;i&lt;=n;i++) ct[a[i]]++; for(int i=1;i&lt;=m;i++) mv[i].p=i; sort(mv+1,mv+m+1,cmp2); printf("%d",mv[1].p);&#125; 8 bzoj3032 七夕祭6.28 难度1请先思考后再展开 中位数这个东西前面已经讲过了，具体请搜索“中位数”典型特征就是能左能右或者类似的相反方向 把所有a-=平均数，这个操作还是掌握了点的看起来a[1]直接=0，其实这是因为总体和=0，没有直接用，这个问题和akc研究了挺久 然后由于等差数列，可能爆int12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll c1[MAXN],c2[MAXN];int main()&#123; int n,m,q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=q;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); c1[x]++;c2[y]++; &#125; bool ok1=(q%n==0),ok2=(q%m==0); if(ok1 and ok2) printf("both "); else if(ok1 and !ok2) printf("row "); else if(!ok1 and ok2) printf("column "); else printf("impossible"); if(ok1 or ok2) &#123; ll sum=0; if(ok1) &#123; for(int i=1;i&lt;=n;i++) c1[i]-=q/n; c1[1]=0;for(int i=2;i&lt;=n;i++) c1[i]=c1[i-1]-c1[i]; sort(c1+1,c1+n+1); ll tmp=c1[n/2+1]; for(int i=1;i&lt;=n;i++) sum+=myabs(-c1[i]+tmp); &#125; if(ok2) &#123; for(int i=1;i&lt;=m;i++) c2[i]-=q/m; c2[1]=0;for(int i=2;i&lt;=m;i++) c2[i]=c2[i-1]-c2[i]; sort(c2+1,c2+m+1); ll tmp=c2[m/2+1]; for(int i=1;i&lt;=m;i++) sum+=myabs(-c2[i]+tmp); &#125; printf("%lld",sum); &#125;&#125; 9 POJ3784 Running Median6.29 难度1请先思考后再展开 原来，1.5亿是能跑的……这个对顶堆的做法也是蛮有意思的，稍微比树状数组少log，比splay少常数12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;priority_queue&lt; int,vector&lt;int&gt;,less&lt;int&gt; &gt; q1;priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; while(!q1.empty()) q1.pop(); while(!q2.empty()) q2.pop(); int tmp,n;scanf("%d%d",&amp;tmp,&amp;n); printf("%d %d\n",tmp,(n+1)/2); int ct=0; for(int i=1;i&lt;=n;i++) &#123; int d;scanf("%d",&amp;d); if(q1.size()&gt;0 and d&lt;=q1.top()) q1.push(d); else q2.push(d); if(q1.size()&gt;=q2.size()+2) q2.push(q1.top()),q1.pop(); if(q1.size()+2&lt;=q2.size()) q1.push(q2.top()),q2.pop(); if(i%2==1) &#123; if(q1.size()&gt;q2.size()) printf("%d ",q1.top()); else printf("%d ",q2.top()); ct++;if(ct==10) ct=0,putchar('\n'); &#125; &#125; putchar('\n'); &#125;&#125; 第k大数这方法挺有意思的应该就是eth_element的原理吧就是无序数列中，O(2n)找其实就是n+n/2+n/4+…….1&lt;=2n原理就是类似二分排序，但是没必要两边都进入，而是只进入其中一边蛮好理解的 10 POJ2299 Ultra-QuickSort6.29 难度2请先思考后再展开 原来相邻比较和交换就是冒泡排序呀那么每次交换的时候，都消除了一个逆序对答案就是其个数了练习一下归并12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=510000;typedef long long ll;int a[MAXN],b[MAXN];ll mergsort(int l,int r)&#123; if(l&gt;=r) return 0; int mid=(l+r)&gt;&gt;1; ll ans=mergsort(l,mid)+mergsort(mid+1,r); int nw=l,q=l,w=mid+1; while(q&lt;=mid and w&lt;=r) &#123; if(a[q]&lt;=a[w]) b[nw]=a[q++]; else b[nw]=a[w++],ans+=mid-q+1; nw++; &#125; while(q&lt;=mid) b[nw++]=a[q++]; while(w&lt;=r) b[nw++]=a[w++]; for(int i=l;i&lt;=r;i++) a[i]=b[i]; return ans;&#125;int main()&#123; while(1) &#123; int n;scanf("%d",&amp;n); if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); printf("%lld\n",mergsort(1,n)); &#125;&#125; 11 hihocoder 1384 Genius ACM6.29 难度3请先思考后再展开 类似于满足二分性，不过用倍增会更快，特别是当k小的时候然后直接暴力地排序会tle，可以用归并来合并a数组=原本值b数组=排好序值c数组=合并后，用于尝试，成功则copy回b数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=510000;typedef long long ll;ll mysqr(ll x) &#123;return x*x;&#125;int m;int bin[40];int a[MAXN],b[MAXN],c[MAXN];void merge(int l,int mid,int r)//到c中&#123; int nw=l,q=l,w=mid+1; while(q&lt;=mid and w&lt;=r) &#123; if(b[q]&lt;=b[w]) c[nw]=b[q++]; else c[nw]=b[w++]; nw++; &#125; while(q&lt;=mid) c[nw++]=b[q++]; while(w&lt;=r) c[nw++]=b[w++];&#125;ll calc(int l,int r)&#123; ll sum=0; int num=0; while(num&lt;m and r-l+1&gt;=2) &#123; num++; sum+=mysqr(c[r]-c[l]); l++;r--; &#125; return sum;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]*2; int T;scanf("%d",&amp;T); while(T--) &#123; int n;ll k;scanf("%d%d%lld",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int L=1,ans=0; while(L&lt;=n)//新的一段 &#123; int R=L,len=1; b[L]=a[L];//debug while(len&gt;0 and R&lt;=n) &#123; //保证有序 for(int i=R+1;i&lt;=R+len;i++) b[i]=a[i]; //sort(b+L,b+R+len+1); TLE sort(b+R+1,b+R+len+1);merge(L,R,R+len); if(calc(L,R+len)&lt;=k) &#123; for(int i=L;i&lt;=R+len;i++) b[i]=c[i]; R+=len,len*=2;//succeed &#125; else len/=2; while(R+len&gt;n and len&gt;0) len/=2; &#125; ans++; L=R+1; &#125; printf("%d\n",ans); &#125;&#125; 12 POJ3614 Sunscreen6.29 难度2请先思考后再展开 不愧是我最虚的贪心 把牛用mx[x]递增排序，每次选最小的 归纳法证明：对于a=sp[t1]，b=sp[t2]已知mi[x]&lt;=a&lt;b&lt;=mx[x]&lt;=mx[y]则对于y，可能【ab可】、【a不可b可】、【ab不可】任何一种，选a 不会更差 同理，把mi[x]递减排序，每次选最大的也行123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=3100;struct Cow&#123; int mi,mx;&#125;p[3100];bool cmp(Cow a,Cow b) &#123;return a.mx&lt;b.mx;&#125;int ct[1100];//数量bool tryit(int l,int r)&#123; for(int i=l;i&lt;=r;i++) if(ct[i]&gt;0) &#123; ct[i]--; return 1; &#125; return 0;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].mi,&amp;p[i].mx); for(int i=1;i&lt;=m;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); ct[a]+=b; &#125; sort(p+1,p+n+1,cmp); int ans=0; for(int i=1;i&lt;=n;i++) ans+=tryit(p[i].mi,p[i].mx); printf("%d",ans);&#125; 13 POJ3190 Stall Reservations6.29 难度2请先思考后再展开 先按照开始时间把牛排序然后如果以房间为导向，二分查找可行牛，就要解决删除的问题，然后就懵了（其实这个也是错的） 如果以牛为导向去安排，随便放进一个能放的房间就行了证明：假如有两个房间a和b，ed[a]&lt;ed[b]由于后面的开始时间会更后，所以选择a，不会更优 不过这样是平方级别的既然是随便就好，搞个小根堆，这样选择的开销就很小了 回顾一下，关键还是以开始时间排序这个操作，并且要按照这个来安排而不是作为有序数列来二分查找12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=51000;struct Cow&#123; int l,r; int p;&#125;p[MAXN];bool cmp(Cow a,Cow b) &#123;return a.l&lt;b.l;&#125;struct Room&#123; int id,ed; Room(int a=0,int b=0) &#123;id=a,ed=b;&#125; friend bool operator &gt; (Room a,Room b) &#123;return a.ed&gt;b.ed;&#125;&#125;c[MAXN];priority_queue&lt; Room,vector&lt;Room&gt;,greater&lt;Room&gt; &gt; q;//小根堆int ans[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].l,&amp;p[i].r),p[i].p=i; sort(p+1,p+n+1,cmp); int tot=1;q.push(Room(1,0)); for(int i=1;i&lt;=n;i++) &#123; Room a=q.top();q.pop(); if(a.ed&lt;p[i].l) a.ed=p[i].r,ans[p[i].p]=a.id; else q.push(Room(++tot,p[i].r)),ans[p[i].p]=tot; q.push(a); &#125; printf("%d\n",tot); for(int i=1;i&lt;=n;i++) printf("%d\n",ans[i]);&#125; 14 POJ1328 Radar Installation6.30 难度2请先思考后再展开 计算出能覆盖每个岛的圆的圆点区间，用最少的点覆盖每个区间把区间按照左端点排序，然后如果无重叠，重新开始，否则可以把覆盖点“挪”到重叠区域 不过思考的时候漏了一种情况：就是重叠的话可能是包含关系 对于那些重叠但是不包含的，可能在后面还会和别人重叠但同样是因为贡献只有1，所以选择前面 不会更差12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100;const double eps=1e-7;double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125;struct Seg&#123; double l,r;&#125;p[MAXN];bool cmp(Seg a,Seg b) &#123;return a.l&lt;b.l-eps;&#125;int solve(int n,int R)&#123; bool error=0; for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(y&gt;R) error=1;//return -1; debug double t=sqrt(R*R-y*y);//底边 p[i].l=double(x)-t,p[i].r=double(x)+t; &#125; if(error) return -1; sort(p+1,p+n+1,cmp); int ans=1; double ed=p[1].r; for(int i=2;i&lt;=n;i++) &#123; if(ed&lt;p[i].l-eps) ans++,ed=p[i].r; else ed=mymin(ed,p[i].r);//debug 区间包含 &#125; return ans;&#125;int main()&#123; int T=0; while(1) &#123; int n,R;scanf("%d%d",&amp;n,&amp;R);if(n==0) break; printf("Case %d: %d\n",++T,solve(n,R)); &#125;&#125; 15 国王游戏6.30 难度2原题 16 POJ2054 Color a Tree6.30 难度3请先思考后再展开 先给出一个贪心：每次在能染色的点中找最大的然鹅这是错误的，举个简单的反例：在一个极小节点下有一个极大节点 反思一下，这是因为【必须先染父亲才能染儿子】这个条件但是我们依然可以推出一个结论：【对于非根的最大点，必定在父亲染完后立刻染色】所以说，其实可以把那两个节点看作一个节点不过这个节点的权值是多少才能不影响接下来的判断呢？ 结论2：【合并后的节点，权值为其平均值】证明：网上的证明普遍不堪入目，书上的也半斤八两后来终于在POJ的远古评论里看到，简单得令人感动 设有权值a节点和b1~bn的合并节点如果a在前，优势是na如果a在后，优势是b1~bn的和那么按照结论一的步骤，我们每次都要比较权值大小则比较：【公共部分+na】与【公共部分+b1~bn的和】由于我们不能把所有的a改成na，考虑算出一个通用的权值则比较：【a】与【b1~bn的和/n】也就是平均数了另外，如果感性地理解，其实就是把【晚一点染色的影响】均摊了 总之，合并后，它和一个普通的点是没有区别的，可以继续合并合并时，还要用指针存储顺序，最后按照决策计算答案即可 然后有一点是忘记了：最大点不一定是叶子节点（脑海中喜欢这样想，人性的懒惰？）所以要把fa改掉 然后我不会nlogn怎么写……可删堆怕是用不了的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=1100;struct Nod&#123; int fa; int sum;//权值和 int tot;//数量 int ed;//末端 friend bool operator &lt; (Nod a,Nod b) &#123; //return a.sum/a.tot&lt;b.sum/b.tot; return a.sum*b.tot&lt;b.sum*a.tot; &#125;&#125;p[MAXN];int nxt[MAXN];//指针int a[MAXN];int main()&#123; p[0].sum=0;p[0].tot=1;//mi while(1) &#123; int n,rt;scanf("%d%d",&amp;n,&amp;rt);if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n-1;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); p[y].fa=x; &#125; p[rt].fa=0; for(int i=1;i&lt;=n;i++) &#123; p[i].sum=a[i],p[i].tot=1; p[i].ed=i;//st其实就是自己编号，不用记录 &#125; for(int ok=0;ok&lt;n-1;ok++)//不会写nlogn &#123; int mx=0; for(int i=1;i&lt;=n;i++) if(i!=rt and p[mx]&lt;p[i]) mx=i; int f=p[mx].fa; p[f].sum+=p[mx].sum;p[f].tot+=p[mx].tot; nxt[p[f].ed]=mx;p[f].ed=p[mx].ed; //debug mx不一定是叶子节点 for(int i=1;i&lt;=n;i++) if(p[i].fa==mx) p[i].fa=f; p[mx].sum=0;p[mx].tot=1; &#125; int ans=0; for(int T=1,x=rt;T&lt;=n;T++,x=nxt[x]) ans+=T*a[x]; printf("%d\n",ans); &#125;&#125; 0x08「基本算法」练习题目 17 POJ2965 The Pilots Brothers’ refrigerator7.1 难度24乘4的矩阵，每个格子一个开关，+关-开每次操作改变第i行和第j列求所有开的最小操作数，并输出具体操作请先思考后再展开 又忘记这类问题的顺序无关性了……不过复杂度上bfs是可以的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=16,MAXS=71000;int bin[30];bool mp[5][5],mp2[5][5];bool ps[5][5],ansps[5][5];bool check()&#123; for(int i=1;i&lt;=4;i++) for(int j=1;j&lt;=4;j++) if(!mp2[i][j]) return 0; return 1;&#125;int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]*2; for(int i=1;i&lt;=4;i++) &#123; char s[10];scanf(&quot;%s&quot;,s+1); for(int j=1;j&lt;=4;j++) mp[i][j]=(s[j]==&apos;-&apos;); &#125; int tot=(1&lt;&lt;16)-1,ans=20; for(int i=0;i&lt;=tot;i++) &#123; memcpy(mp2,mp,sizeof mp); int step=0; for(int x=1;x&lt;=4;x++) for(int y=1;y&lt;=4;y++) &#123; ps[x][y]=i&amp;bin[ (x-1)*4+y-1 ]; if(ps[x][y]) &#123; step++; for(int i=1;i&lt;=4;i++) mp2[i][y]^=1; for(int j=1;j&lt;=4;j++) if(j!=y) mp2[x][j]^=1; &#125; &#125; if(check() and step&lt;ans) ans=step,memcpy(ansps,ps,sizeof ps); &#125; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=4;i++) for(int j=1;j&lt;=4;j++) if(ansps[i][j]) printf(&quot;%d %d\n&quot;,i,j);&#125; 18 POJ3714 Raid7.2 难度2请先思考后再展开 kd-tree裸题好久没打了，练练手，果然炸……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;const double INF=double(1ll&lt;&lt;60)*double(1ll&lt;&lt;60);void cmax(int &amp;a,int b) &#123;if(a&lt;b) a=b;&#125;void cmin(int &amp;a,int b) &#123;if(a&gt;b) a=b;&#125;double mymin(double a,double b) &#123;return a&lt;b?a:b;&#125;double mysqr(double x) &#123;return x*x;&#125;struct Nod&#123; int d[2];//坐标 int l[2],r[2];//范围 int son[2];&#125;p[MAXN];int D;bool cmp(Nod a,Nod b) &#123;return a.d[D]&lt;b.d[D];&#125;int build(int l,int r,int ds)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=ds;//debug 漏了 nth_element(p+l,p+mid,p+r+1,cmp); p[mid].l[0]=p[mid].r[0]=p[mid].d[0]; p[mid].l[1]=p[mid].r[1]=p[mid].d[1]; int lson=p[mid].son[0]=build(l,mid-1,1-ds); int rson=p[mid].son[1]=build(mid+1,r,1-ds); //debug 分治时要去掉mid if(lson) &#123; cmin(p[mid].l[0],p[lson].l[0]);cmin(p[mid].l[0],p[rson].l[0]); cmax(p[mid].r[0],p[lson].r[0]);cmax(p[mid].r[0],p[rson].r[0]); &#125; if(rson) &#123; cmin(p[mid].l[1],p[lson].l[1]);cmin(p[mid].l[1],p[rson].l[1]); cmax(p[mid].r[1],p[lson].r[1]);cmax(p[mid].r[1],p[rson].r[1]); &#125; return mid;&#125;double gg(double a,double b) &#123;return a*a+b*b;&#125;double calc(int x,int y,int now)&#123; double ans=0;//debug 用了int if(x&lt;p[now].l[0]) ans+=mysqr(p[now].l[0]-x); if(x&gt;p[now].r[0]) ans+=mysqr(x-p[now].r[0]); if(y&lt;p[now].l[1]) ans+=mysqr(p[now].l[1]-y); if(y&gt;p[now].r[1]) ans+=mysqr(y-p[now].r[1]); return ans;&#125;double ans;void findmin(int now,int x,int y)&#123; if(now==0) return; ans=mymin( ans,gg(x-p[now].d[0],y-p[now].d[1]) ); int lc=p[now].son[0],rc=p[now].son[1]; double lf=lc?calc(x,y,lc):INF; double rf=rc?calc(x,y,rc):INF; if(lf&gt;rf) swap(lc,rc),swap(lf,rf); if(lf&lt;ans) findmin(lc,x,y); if(rf&lt;ans) findmin(rc,x,y);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); int rt=build(1,n,0); ans=INF; for(int i=1;i&lt;=n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); findmin(rt,x,y); &#125; printf("%.3lf\n",sqrt(ans)); &#125;&#125; 19 bzoj1271 luogu4403 秦腾与教学评估7.2 难度2请先思考后再展开 真的没想到这个【具体位置个数】居然可以转化为【点个数前缀和的奇偶性】上来所以就可以二分了 然后就是在bzoj和luogu上的官方数据，疑似总人数爆int，没有满足题意12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=210000;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int st,ed,d;&#125;a[MAXN];int n;ll calc(ll mx)&#123; ll ans=0; for(int i=1;i&lt;=n;i++) if(a[i].st&lt;=mx) ans+=( mymin(a[i].ed,mx)-a[i].st )/a[i].d+1; return ans;&#125;int main()&#123; int T;scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;a[i].st,&amp;a[i].ed,&amp;a[i].d); ll l=1,r=(1ll&lt;&lt;31)-1,ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)/2; if(calc(mid)%2==1) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) printf(&quot;Poor QIN Teng:(\n&quot;); //if(ans&lt;0) printf(&quot;There&apos;s no weakness.\n&quot;); else printf(&quot;%lld %lld\n&quot;,ans,calc(ans)-calc(ans-1)); &#125;&#125; 20 POJ3179 Corral the Cows7.2 难度2请先思考后再展开 同样是无法存储的大坐标这一次的操作是离散化，因为没想到这个，就把前缀和否定掉了……然后就是常规的但其实我不熟练的双点法，虽然昨晚打比赛还用过咧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=510,MAXF=11000;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;struct Nod&#123; int x,y;&#125;p[MAXN];bool cmpx(Nod a,Nod b) &#123;return a.x&lt;b.x;&#125;bool cmpy(Nod a,Nod b) &#123;return a.y&lt;b.y;&#125;int sx,sy;//最大离散值int fx[MAXF],fy[MAXF];//原值int E,n;int sum[MAXN][MAXN];bool check(int now)&#123; int a=1,b=1;//x while(fx[b+1]-fx[a]+1&lt;=now and b+1&lt;=sx) b++; while(1) &#123; int c=1,d=1;//y while(fy[d+1]-fy[c]+1&lt;=now and d+1&lt;=sy) d++; while(1) &#123; int ans=sum[b][d]-sum[b][c-1]-sum[a-1][d]+sum[a-1][c-1]; if(ans&gt;=E) return 1; d++;if(d&gt;sy) break; while(fy[d]-fy[c]+1&gt;now and c+1&lt;=d) c++; &#125; b++;if(b&gt;sx) break; while(fx[b]-fx[a]+1&gt;now and a+1&lt;=b) a++; &#125; return 0;&#125;int c[MAXN][MAXN];//数量int main()&#123; scanf(&quot;%d%d&quot;,&amp;E,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); sort(p+1,p+n+1,cmpx); for(int i=1;i&lt;=n;i++) &#123; if(p[i-1].x!=p[i].x) fx[++sx]=p[i].x; p[i].x=sx; &#125; sort(p+1,p+n+1,cmpy); for(int i=1;i&lt;=n;i++) &#123; if(p[i-1].y!=p[i].y) fy[++sy]=p[i].y; c[p[i].x][p[i].y=sy]++; &#125; //debug 忽略1导致fx[1]没赋值 for(int i=1;i&lt;=sx;i++) for(int j=1;j&lt;=sy;j++) sum[i][j]=c[i][j]+sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]; int l=1,r=10000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf(&quot;%d&quot;,ans);&#125; 21 POJ1723 SOLDIERS7.2 难度2请先思考后再展开 一道很好地融合了贪心的题目至少好过七夕祭这种强行二维题 y直接中位数是没有问题的了主要是有个贪心没有想到：为了解决起点不确定问题，直接设一个起点然后把原数组贪心后a[i]对应st+i-1，并且是一一对应否则造成没有意义的花费这样达到最优解1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=11000;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;int a[MAXN],b[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i],&amp;b[i]); int ans=0; sort(a+1,a+n+1);for(int i=1;i&lt;=n;i++) a[i]-=i-1; sort(a+1,a+n+1);for(int i=1;i&lt;=n;i++) ans+=myabs(a[i]-a[n/2+1]); sort(b+1,b+n+1);for(int i=1;i&lt;=n;i++) ans+=myabs(b[i]-b[n/2+1]); printf("%d",ans);&#125; 22 POJ1050 To the Max7.2 难度2请先思考后再展开 裸题，枚举l、r，就能顺利转化了（又是想不到）可能因为是远古题吧而且如今这个数据规模暴力是很快过去的，没常数嘛，改成n=300就好很多1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110;int mp[MAXN][MAXN];int sum[MAXN][MAXN];//行前缀和int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; scanf("%d",&amp;mp[i][j]); sum[i][j]=sum[i][j-1]+mp[i][j]; &#125; int ans=0; for(int l=1;l&lt;=n;l++)//最大子矩阵和 for(int r=l;r&lt;=n;r++) &#123; int s=0; for(int i=1;i&lt;=n;i++)//最大子段和 &#123; s+=sum[i][r]-sum[i][l-1]; if(s&lt;0) s=0; if(ans&lt;s) ans=s; &#125; &#125; printf("%d",ans);&#125; 23 HDU4864 Task7.2 难度2请先思考后再展开 兼顾策略和实现的贪心好题 观察题目，发现重要性质 价值中，时间的优先级绝对大于等级 价值只和任务有关，和具体机器无关 结论 优先考虑时间 应该用任务去找机器 具体而言 把任务和机器按照时间从小到大排序，从大到小枚举任务（经典套路之尽量从小范围开始） 对于每个任务，可以确定一个区间满足时间的条件,区间左端点单调递减 由于性质2，这样我们就顺利地 消除了时间、等级对决策的直接影响 由于比现在耗时更大的任务已经解决，则选择时间最大的机器 不会使结果更差 至于机器的等级，直接使用满足条件但等级最小的，反正和价值无关，减少浪费 找的时候，两种方法，一是维护一个set这样不用打splay，二是统计某个等级的出现数量，因为等级比较少（之所以能这样又是用了性质2） 综上所述，时间复杂度约O(nlogn)对于结论2，可以再补充一个理由：如果用机器找任务，就不能消除时间对决策的直接影响就是说，当我们确定一个区间时，有两个参考量，毕竟会影响价值而我们现在就只用考虑等级，所以才能直接决定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=110000;typedef long long ll;struct Nod&#123; int x,y;&#125;ma[MAXN],ta[MAXN];bool cmp(Nod a,Nod b) &#123;return a.x&lt;b.x or (a.x==b.x and a.y&lt;b.y);&#125;int c[110];int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;ma[i].x,&amp;ma[i].y); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;ta[i].x,&amp;ta[i].y); sort(ma+1,ma+n+1,cmp);sort(ta+1,ta+m+1,cmp); int tot=0;ll ans=0; int l=n+1; for(int i=m;i&gt;=1;i--)//task &#123; while(ma[l-1].x&gt;=ta[i].x and l-1&gt;=1) c[ ma[--l].y ]++; for(int j=ta[i].y;j&lt;=100;j++) if(c[j]&gt;0) &#123; c[j]--; tot++; ans+=ta[i].x*500+ta[i].y*2; break; &#125; &#125; printf("%d %lld\n",tot,ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激光炸弹]]></title>
    <url>%2Fposts%2F2726.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2003Bzoj1218Luogu2280 Problem【Description】一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n个目标，用整数Xi,Yi( 其值在[0,5000] )表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。【Input】输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi【Output】输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标。【Limited conditions】N&lt;=10000结果不会超过32767【Sample input】2 10 0 11 1 1【Sample output】1【Sample explanation】无 Record30min Analysis请先思考后再展开 脑残题二维前缀和早知道不单独一篇文章了…… Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=5100;int mp[MAXN][MAXN];int main()&#123; int n,R;scanf("%d%d",&amp;n,&amp;R); while(n--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); mp[x+1][y+1]+=c; &#125; n=5001; for(int a=1;a&lt;=n;a++) for(int b=1;b&lt;=n;b++) mp[a][b]+=mp[a][b-1]+mp[a-1][b]-mp[a-1][b-1]; //左上( c-R+1,d-R+1 ) //右下( c,d ) int mx=0; for(int c=n;c&gt;=1;c--) for(int d=n;d&gt;=1;d--) &#123; int a=mymax(c-R,0),b=mymax(d-R,0); mp[c][d]=mp[c][d]-mp[c][b]-mp[a][d]+mp[a][b]; mx=mymax(mx,mp[c][d]); &#125; printf("%d",mx);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T3】逛公园]]></title>
    <url>%2Fposts%2Ff27c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T3Loj2316Luogu3953 Problem【Description】策策同学特别喜欢逛公园。公园可以看成一张 N 个点 M 条边构成的有向图，且没有 自环和重边。其中1号点是公园的入口， N 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。策策每天都会去逛公园，他总是从1号点进去，从 N 号点出来。策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 1号点 到 N 号点的最短路长为 d ，那么策策只会喜欢长度不超过 d+K 的路线。策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？为避免输出过大，答案对 P 取模。如果有无穷多条合法的路线，请输出 −1 。【Input】第一行包含一个整数 T , 代表数据组数。接下来 TTT 组数据，对于每组数据： 第一行包含四个整数 N,M,K,P ，每两个整数之间用一个空格隔开。接下来 MMM 行，每行三个整数 ai,bi,ci ，代表编号为 ai,bi​ 的点之间有一条权值为 ci​ 的有向边，每两个整数之间用一个空格隔开。【Output】输出文件包含 T 行，每行一个整数代表答案。【Limited conditions】T&lt;=5,n&lt;=10^5,m&lt;=2*10^5,k&lt;=50有0边1≤P≤10^9,1≤ai​,bi​≤N,0≤ci​≤1000 。数据保证：至少存在一条合法的路线。【Sample input】25 7 2 101 2 12 4 04 5 22 3 23 4 13 5 21 5 32 2 0 101 2 02 1 0【Sample output】3-1【Sample explanation】最短路为 3 。 1 – 5, 1 – 2 – 4 – 5, 1 – 2 – 3 – 5 为 3 条合法路径。 Record1h Analysis请先思考后再展开 通常计数问题可以考虑dp 在本题中，最难的地方在于考虑路径的长度是一个区间，而不是仅仅最短路；我们可以把K看作一个配额，然后我们在路径上进行分配设(x,a)是在x点，使用了a的配额后的路径计数然后显然(y,b)=能到达的(x,a)的和因为配额是单调递增的，所以把配额看作类似时间的东西，按照它来分层那么大致上，dp的转移是定向的 但到底怎么转移呢？由于做题太少，并没有思路请教队长后get到了新姿势：把转移建成边，拓扑dp至于环的存在，由于大致是单向的，所以跨层不会有环如果出现了环，必定在同一层，也就是0环，按照题意输出-1即可不过要确保这个0环是对最短路有影响的，所以跑一遍反图 这样搞一搞后，luogu时间还是差一点的，但保底70为什么呢？反思一下复杂度是nk的，应该完全没有问题====如果非要对此尝试提升（如果考场上显然没有这一步）考虑在转移的时候就进行一下可行性剪枝，直接去除无效转移边这样就达到了灰常优秀的时间了（这属于常数优化吧） Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int MAXN=110000,MAXM=210000,MAXK=60;const int INF=0x3f3f3f3f;int n,K,MOD;int calc(int x,int a) &#123; return (x-1)*(K+1)+a; &#125;struct Nod&#123; int hou[2]; int dis[2]; bool v; Nod() &#123; v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM*2];int ln;void ins(int x,int y,int c,int w)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou[w]; p[x].hou[w]=ln;&#125;void init()&#123; int m;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;MOD); ln=0;for(int i=1;i&lt;=n;i++) p[i].hou[0]=p[i].hou[1]=0; while(m--) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(a,b,c,0);ins(b,a,c,1); &#125;&#125;queue&lt;int&gt; q;void spfa(int st,int w)&#123; for(int i=1;i&lt;=n;i++) p[i].dis[w]=INF; p[st].dis[w]=0; p[st].v=1;q.push(st); while(!q.empty()) &#123; int x=q.front(); for(int k=p[x].hou[w];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis[w]&gt;p[x].dis[w]+e[k].c) &#123; p[y].dis[w]=p[x].dis[w]+e[k].c; if(!p[y].v) &#123; p[y].v=1; q.push(y); &#125; &#125; &#125; p[x].v=0;q.pop(); &#125;&#125;struct dp&#123; int hou; int ru; int ans;&#125;p2[MAXN*MAXK];struct Edge2&#123; int y,g;&#125;e2[MAXM*MAXK];int ln2;void ins2(int x,int y)&#123; ln2++; p2[y].ru++; e2[ln2].y=y; e2[ln2].g=p2[x].hou; p2[x].hou=ln2;&#125;void make_graph()&#123; ln2=0;//debug!! for(int i=0;i&lt;=calc(n,K);i++) p2[i].hou=p2[i].ru=p2[i].ans=0; p2[0].ans=1; for(int x=1;x&lt;=n;x++) &#123; for(int k=p[x].hou[0];k&gt;0;k=e[k].g) &#123; int y=e[k].y; for(int a=0;a&lt;=K;a++) &#123; int b=p[x].dis[0]+a+e[k].c-p[y].dis[0];//debug 改数组，忘dis下标 if(b&lt;=K and p[x].dis[0]+a+e[k].c+p[y].dis[1]&lt;=p[n].dis[0]+K) //debug 可行性剪枝 ins2( calc(x,a),calc(y,b) ); else break; &#125; &#125; &#125;&#125;int sta[MAXN*MAXK];int solve()&#123; int top=0; for(int i=0;i&lt;=calc(n,K);i++) if(p2[i].ru==0) sta[++top]=i; int sum=0; while(top&gt;0) &#123; int x=sta[top--]; sum++; for(int k=p2[x].hou;k&gt;0;k=e2[k].g) &#123; int y=e2[k].y; p2[y].ans=(p2[y].ans+p2[x].ans)%MOD; p2[y].ru--; if(p2[y].ru==0) sta[++top]=y; &#125; &#125; if(sum&lt;n*(K+1)) return -1; int ans=0; for(int i=calc(n,0);i&lt;=calc(n,K);i++) ans=(ans+p2[i].ans)%MOD; return ans;&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; init(); spfa(1,0);spfa(n,1); make_graph(); printf("%d\n",solve()); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>拓扑</tag>
        <tag>分层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T2】时间复杂度]]></title>
    <url>%2Fposts%2F25a7.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T2Loj2364Luogu3952 Problem【Description】小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。A++语言的循环结构如下：F i x y 循环体E其中F i x y表示新建变量 i （变量 i 不可与未被销毁的变量重名）并初始化为 x ， 然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 iii 都会被修改成 i+1 ，一旦 i 大于 y 终止循环。x 和 y 可以是正整数（ x 和 y 的大小关系不定）或变量 n 。 n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。【Input】输入文件第一行一个正整数 t ，表示有 t （ t≤10 ）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构允许嵌套。接下来每个程序的第一行包含一个正整数 L 和一个字符串， L 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为 n^w ，其中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。接下来 L 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 i 是一个小写字母（保证不为 n ），表示新建的变量名， x 和 y 可能是正整数或 n ，已知若为正整数则一定小于 100。程序行若以E开头，则表示循环体结束。【Output】输出文件共 t 行，对应输入的 t 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误，则输出ERR（其中语法错误只有:① F 和 E 不匹配②新建的变量与已经存在但未被销毁的变量重复两种情况） 。注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。【Limited conditions】1≤a,b≤1,000,000,000输入数据保证存在小凯无法准确支付的商品。【Sample input】82 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE【Sample output】YesYesERRYesNoYesYesERR【Sample explanation】无 Record1h Analysis请先思考后再展开 大模拟，不解释考场上没有出数据，过了大数据就信仰杠T1去了结果蜜汁ac感受一下…… 印象中，当时有个小bug就是ce了不能直接break，因为还要输入，调试了好一会儿还有就是，代码中有个地方写错了，但误打误撞没事…… Code1这是比赛代码，留作纪念请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char ss[50],s1[50];int strtoint()&#123; scanf("%s",s1); if(s1[0]=='n') return 0; int ts=0,len=strlen(s1); for(int i=0;i&lt;=len-1;i++) ts=ts*10+s1[i]-'0'; return ts;&#125;int nm[210];bool us[40];bool isn[210];bool noin[210];int main()&#123; int t;scanf("%d",&amp;t); while(t--) &#123; memset(us,0,sizeof(us)); memset(isn,0,sizeof(isn)); memset(noin,0,sizeof(noin)); int ln;char nn;int w; scanf("%d O(%c",&amp;ln,&amp;nn); if(nn=='1') w=0; else scanf("^%d",&amp;w); scanf(")"); int ans=0; int mxl=0,l=0; int tp=0; bool ce=0; for(int ll=1;ll&lt;=ln;ll++) &#123; scanf("%s",ss); if(ss[0]=='F') &#123; scanf("%s",&amp;ss); int x=strtoint(),y=strtoint(); tp++;if(tp&lt;=0) &#123;ce=1;continue;&#125; if(ce==1) continue; nm[tp]=ss[0]-'a'; if(us[nm[tp]]) ce=1; us[nm[tp]]=1; if(noin[tp-1]) &#123; noin[tp]=1; continue; &#125; if(x==0 and y==0) noin[tp]=0; else if(x!=0 and y==0)//1~n &#123; l++;isn[tp]=1; if(l&gt;mxl) ans+=1,mxl=l; &#125; else if(x==0 and y!=0) noin[tp]=1; else if(x&gt;y) noin[tp]=1; &#125; else &#123; if(ce==1) continue; if(tp&gt;0 and isn[tp]) isn[tp]=0,l--; if(tp&gt;0) us[nm[tp]]=0; noin[tp]=0; tp--; if(tp&lt;0) ce=1; &#125; &#125; if(ce or tp!=0) printf("ERR\n"); else &#123; if(w==ans) printf("Yes\n"); else printf("No\n"); &#125; &#125; //system("pause");&#125; Code2加上大量注释请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char ss[50],s1[50];int strtoint()&#123; scanf("%s",s1); if(s1[0]=='n') return 0; int ts=0,len=strlen(s1); for(int i=0;i&lt;=len-1;i++) ts=ts*10+s1[i]-'0'; return ts;&#125;int nm[210];//变量名记录bool us[40];//变量名的使用情况bool isn[210];//n的复杂度bool no_in[210];//没有真的进去int main()&#123; int t;scanf("%d",&amp;t); while(t--) &#123; memset(us,0,sizeof(us)); memset(isn,0,sizeof(isn)); memset(no_in,0,sizeof(no_in)); int ln;char nn; scanf("%d O(%c",&amp;ln,&amp;nn); int w; if(nn=='1') w=0; else scanf("^%d",&amp;w); scanf(")"); int ans=0; int mxl=0,l=0;//n^l int tp=0;//深度 bool ce=0; for(int ll=1;ll&lt;=ln;ll++) &#123; scanf("%s",ss); if(ss[0]=='F') &#123; scanf("%s",ss);//变量名 //scanf("%s",&amp;ss);这是当时代码，打错了 int x=strtoint(),y=strtoint(); tp++;if(tp&lt;=0) ce=1; if(ce==1) continue; nm[tp]=ss[0]-'a'; if(us[nm[tp]]) ce=1;//重名 us[nm[tp]]=1; if(no_in[tp-1])//只读入，不干活 &#123; no_in[tp]=1; continue; &#125; isn[tp]=0; if(x==0 and y==0) no_in[tp]=0;//n~n，忽略常数 else if(x!=0 and y==0)//1~n &#123; l++;isn[tp]=1; if(l&gt;mxl) ans+=1,mxl=l; &#125; else if(x==0 and y!=0) no_in[tp]=1;//n~1 else if(x&gt;y) no_in[tp]=1; else no_in[tp]=0;//x~y，忽略常数 &#125; else//收尾 &#123; if(ce==1) continue; if(tp&gt;0) &#123; us[nm[tp]]=0; no_in[tp]=0; if(isn[tp]) l--; &#125; tp--; if(tp&lt;0) ce=1; &#125; &#125; if(ce or tp!=0) puts("ERR"); else if(w==ans) puts("Yes"); else puts("No"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP17 D1T1】小凯的疑惑]]></title>
    <url>%2Fposts%2F34ee.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2017 提高组 D1T1Loj2363Luogu3951 Problem【Description】小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？【Input】输入数据仅一行，包含两个正整数 a 和 b，它们之间用一个空格隔开，表示小凯手中金币的面值。【Output】输出文件仅一行，一个正整数 N ，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。【Limited conditions】1≤a,b≤1,000,000,000输入数据保证存在小凯无法准确支付的商品。【Sample input】3 7【Sample output】11【Sample explanation】无 Record2h Analysis请先思考后再展开 此题为检验人心态的极好题目，值得推荐然后我就挂了…… 题目条件：$a&gt;0,b&gt;0,gcd(a,b)=1$然后求最大的$ax+by \neq K$ 很容易去想exgcd的做法既然互质，exgcd总是有解的，问题只是在于是否满足$x \geq 0,y \geq 0$那么我们求出x的最小正整数解，试图让y最大，这样就能够验证答案了 *题外话：比赛时，通过打表，我发现最大是a+b（要是向别人一样直接发现规律就没有这篇文章了）【然后通过这个让我避免的草哥的遭遇，结果又沉迷卡常去了】* 然后？我们似乎陷入了一个狭隘区——验证答案考虑寻找答案？ 首先，条件是不变的（正负性），思想也是不变的（x表示最小非负数解）那么对于$ax+by=K$,作为合法答案，要求$0 \leq x \leq b-1,y&lt;0$注意：这个时候K是我们要求的答案，所以x和y之间的关系变得没有影响则y=-1,x=b-1，得到合法最大值$K=a(b-1)+b(-1)=a \times b -a-b$ Code请先思考后再展开 略]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T3】愤怒的小鸟]]></title>
    <url>%2Fposts%2Ff5e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T3Loj2363Uoj265Luogu2831Caioj1580 Problem【Description】Kiana最近沉迷于一款神奇的游戏无法自拔。简单来说，这款游戏是在一个平面上进行的。有一架弹弓位于(0,0)处，每次Kiana可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如y=ax^2+bx的曲线，其中a, b是Kiana指定的参数，且必须满足a&lt;0。当小鸟落回地面（即x轴）时，它就会瞬间消失。在游戏的某个关卡里，平面的第一象限中有n只绿色的小猪，其中第i只小猪所在的坐标为(xi, yi)。如果某只小鸟的飞行轨迹经过了(xi, yi)，那么第i只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；如果一只小鸟的飞行轨迹没有经过(xi, yi)，那么这只小鸟飞行的全过程就不会对第i只小猪产生任何影响。例如，若两只小猪分别位于(1,3)和(3,3)，Kiana可以选择发射一只飞行轨迹为 y = -x^2 + 4x的小鸟，这样两只小猪就会被这只小鸟一起消灭。而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。这款神奇游戏的每个关卡对Kiana来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。假设这款游戏一共有T个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。【Input】第一行包含一个正整数T，表示游戏的关卡总数。下面依次输入这T个关卡的信息。每个关卡第一行包含两个非负整数n,m，分别 表示该关卡中的小猪数量和Kiana输入的神秘指令类型。接下来的n行中，第i行包含 两个正实数xi, yi，表示第i只小猪坐标为(xi, yi)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。如果m = 0，表示Kiana输入了一个没有任何作用的指令。如果m = 1，则这个关卡将会满足：至多用⌈n/3 + 1⌉只小鸟即可消灭所有小猪。如果m = 2，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少⌊n/3⌋只小猪。【Output】对每个关卡依次输出一行答案。输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。【Limited conditions】保证1&lt;=n&lt;=18，0&lt;=m&lt;=2，0&lt;xi, yi&lt;10，输入中的实数均保留到小数点后两位。【Sample input】75 00.01 0.190.02 0.380.03 0.570.04 0.760.05 0.952 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.002 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.0010 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99【Sample output】5112236【Sample explanation】无 Record2h卡精度 Analysis请先思考后再展开 前置知识： 中考常规操作之给出两个点，解二次函数y=ax^2+bx 卡精度的eps 然后，这么小的n，又是在noip的环境中，基本就是状压考虑状态压缩dp，然后对于一个s，如果从前往后递推，是可以线性的，因为满足最优子结构，然后前面的已经更新好了 然后一开始傻傻地觉得枚举a和b是灰常多的其实只要枚举两个点，解出一个二次函数就好然后只要预处理出cc，表示枚举两个点，能搞掉的点的集合复杂度就达到了O(2^n×n^2)然后因为多组数据，复杂度炸了 考虑优化掉一个n的方法（其实可以看作一个log般的存在）有一个灰常不显然的特性（很多时候正解都是这样）：因为所有点都在第一象限，对于需要经过的点中【横坐标最左边的】的那个，迟早要被枚举到或者覆盖到的那么与其等着去被覆盖，不如首先枚举那么在dp中，枚举i和j，变成了i确定枚举j这样就达到了无比优秀的O(2^n×n) Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=20,MAXS=1&lt;&lt;20;const double eps=1e-10;//*******************全局定义*******************int bin[MAXN];double xx[MAXN],yy[MAXN];int cc[MAXN][MAXN];int dp[MAXS];//*******************实现*******************double myabs(double x) &#123;return x&gt;0?x:-x;&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;MAXN;i++) bin[i]=bin[i-1]&lt;&lt;1; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;xx[i],&amp;yy[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; if(i==j) &#123;cc[i][j]=bin[i-1];continue;&#125; cc[i][j]=0; double a1=xx[i]*xx[i],b1=xx[i],c1=yy[i];//a1x+b1y=c1 double a2=xx[j]*xx[j],b2=xx[j],c2=yy[j];//a2x+b2y=c2 if(myabs(a1*b2-a2*b1)&lt;=eps) continue;//分母!=0 double x=(c1*b2-c2*b1)/(a1*b2-a2*b1); double y=(c1-a1*x)/b1;//y=(x)a^2+(y)a if(x&gt;=-eps) continue;//a&lt;0 for(int now=1;now&lt;=n;now++) &#123; double ny=x*xx[now]*xx[now]+y*xx[now]; if(myabs(ny-yy[now])&lt;=eps) cc[i][j]+=bin[now-1]; &#125; &#125; memset(dp,63,sizeof(dp));dp[0]=0; int tot=bin[n]-1;xx[n+1]=20; for(int s=0;s&lt;tot;s++) &#123; int i=n+1;for(int j=1;j&lt;=n;j++) if( (s&amp;bin[j-1])==0 and xx[j]&lt;xx[i]) i=j; for(int j=1;j&lt;=n;j++) dp[s|cc[i][j]]=mymin(dp[s|cc[i][j]],dp[s]+1); &#125; printf("%d\n",dp[tot]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T2】蚯蚓]]></title>
    <url>%2Fposts%2F867.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T2Loj2362Uoj264Bzoj4721Luogu2827Caioj1579 Problem【Description】蛐蛐国里现在共有n只蚯蚓（n为正整数）。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为ai(i=1, 2, …, n)，并保证所有的长度都是非负整数（即：可能存在长度为0的蚯蚓）。每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数p （是满足0&lt;p&lt;1的有理数）决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为⌊px⌋和x - ⌊px⌋的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q （是一个非负整常数）。蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来…… （m为非负整数）蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道：1. m秒内，每一秒被切断的蚯蚓被切断前的长度（有m个数）2. m秒后，所有蚯蚓的长度（有n + m个数）。 【Input】 第一行包含六个整数n,m,q,u,v,t， 其中： n,m,q的意义见【问题描述】； u,v,t均为正整数；你需要自己计算p = u/v (保证0&lt;u&lt;v) t是输出参数，其含义将会在 【输出格式】中解释。 第二行包含n个非负整数，为a1, a2, …, an，即初始时n只蚯蚓的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。 【Output】 第一行输出⌊m/t⌋个整数，按时间顺序，依次输出第t秒，第2t秒，第3t秒……被切断蚯蚓（在被切断前）的长度。 第二行输出⌊(n+m)/t⌋个整数，输出m秒后蚯蚓的长度；需要按从大到小的顺序 依次输出排名第t，第2t，第3t……的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。 【Limited conditions】 1&lt;=n&lt;=10^5，0 &lt;= m &lt;= 7e6， 0 &lt; u &lt; v &lt;= 10^9 0 &lt;= q &lt;= 200， 1 &lt;= t &lt;= 71， 0 &lt;= ai &lt;= 10^8。 【Sample input 1】 3 7 1 1 3 1 3 3 2 【Sample output 1】 3 4 4 4 5 5 6 6 6 6 5 5 4 4 3 2 2 【Sample input 2】 3 7 1 1 3 2 3 3 2 【Sample output 2】 4 4 5 6 5 4 3 2 【Sample input 3】 3 7 1 1 3 9 3 3 2 【Sample output 3】 //空行 2 【Sample explanation】** 在神刀手到来前：3只蚯蚓的长度为3,3,2。 1秒后：一只长度为3的蚯蚓被切成了两只长度分别为1和2的蚯蚓，其余蚯蚓的长度增加了1。最终4只蚯蚓的长度分别为(1,2),4,3。括号表示这个位置刚刚有一只蚯蚓被切断 2秒后：一只长度为4的蚯蚓被切成了1和3。5只蚯蚓的长度分别为：2,3,(1,3),4。 3秒后：一只长度为4的蚯蚓被切断。6只蚯蚓的长度分别为：3,4,2,4,(1,3)。 4秒后：一只长度为4的蚯蚓被切断。7只蚯蚓的长度分别为：4,(1,3),3,5,2,4。 5秒后：一只长度为5的蚯蚓被切断。8只蚯蚓的长度分别为：5,2,4,4,(1,4),3,5。 6秒后：一只长度为5的蚯蚓被切断。9只蚯蚓的长度分别为：（1,4),3,5,5,2,5,4,6。 7秒后：一只长度为6的蚯蚓被切断。10只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)。所以，7秒内被切断的蚯蚓的长度依次为3,4,4,4,5,5,6。7秒后，所有蚯蚓长度从大到小排序为6,6,6,5,5,4,4,3,2,2 Record3h Analysis请先思考后再展开 首先，一个显而易见的做法：当q=0，搞一个堆，那么每次取最大的出来，切开，然后把另外两端塞回去那这个q怎么处理呢？考虑一个全局常量add，然后就是堆里面所有元素都要加上这个常量，放东西进去的时候，放入的是d-add即可 然鹅这样是mlogm的，只有70分一开始没有抄数据范围，还以为是灰常优秀的做法……其实只是最暴力的 怎么优化呢？这个log有点烦 有没有什么题目的特性被忽略了？割点比值的固定！然后因为每次拿出来的蚯蚓，长度不递增所以切完后，左右两边同类比较的话，也是不递增的，满足单调性所以我们可以直接利用这个单调性，把堆用三个队列代替 具体来说：main队列，left队列，right队列，都满足不递增性质然后每次取得时候，取三个中的最大值即可 coding中煞笔错误： 开头的队列要有序 结束的队列，不能用sort，否则复杂度还是一样的，而是继续利用单调性 被卡了好多次…… 卡精度，题目中的p不要立刻算出来，而是用到再计算 卡最小值，应该设为负无穷，我通常是用其一半的，然后就被卡了…… Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;typedef long long ll;//*******************全局常量*******************const int MAXN=7000000+100000+10;const int INF=0x7fffffff;//*******************全局定义*******************struct Que&#123; int tou,wei; int a[MAXN]; Que() &#123; tou=1,wei=0; &#125; void push(int x) &#123; a[++wei]=x; &#125; void pop() &#123; tou++; &#125; int top() &#123; return a[tou]; &#125;&#125;qq[3];//main,left,right//*******************实现*******************int findmx()&#123; int tmp,mx=-INF; for(int i=0;i&lt;3;i++) if(qq[i].tou&lt;=qq[i].wei and qq[i].top()&gt;mx) tmp=i,mx=qq[i].top(); qq[tmp].pop(); return mx;&#125;//*******************主函数*******************int tmp[MAXN];int main()&#123; int n,m,q,u,v,t;scanf("%d%d%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t); qq[0].wei=n;for(int i=1;i&lt;=n;i++) scanf("%d",&amp;qq[0].a[i]); sort(qq[0].a+1,qq[0].a+n+1);reverse(qq[0].a+1,qq[0].a+n+1); for(int ti=1;ti&lt;=m;ti++)//回合 &#123; int add=q*(ti-1); int now=findmx();if(ti%t==0) printf("%d ",now+add); int l=ll(now+add)*u/v,r=(now+add)-l; qq[1].push(l-add-q);qq[2].push(r-add-q); &#125; putchar('\n'); for(int i=1;i&lt;=n+m;i++) &#123; int now=findmx(); if(i%t==0) printf("%d ",now+q*m); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>堆</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D2T2】换教室]]></title>
    <url>%2Fposts%2F8e5c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D2T2Loj2360Uoj262Bzoj4720Luogu1850Caioj1577 Problem【Description】对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中，有2n节课程安排在n个时间段上。在第i (1 &lt;= i &lt;= n)个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室ci上课，而另一节课程在教室di进行。在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第i个时间段去教室di上课，否则仍然在教室ci上课。由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第i节课程的教室时，申请被通过的概率是一个已知的实数ki，并且对于不同课程的申请，被通过的概率是互相独立的。学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多m节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的m门课程，也可以 不用完 这m个申请的机会，甚至可以一门课程都不申请。因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在的大学有v个教室，有e条道路。每条道路连接两间教室，并且是可以 双向通行 的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第i (1&lt;= i &lt;= n-1)节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的 路径 前往下一节课的教室。现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的 期望值 最小，请你帮他求出这个最小值。【Input】第一行四个整数n, m, v, e。n表示这个学期内的时间段的数量；m表示牛牛最多可以申请更换多少节课程的教室；v表示牛牛学校里教室的数量；e表示牛牛的学校里道路的数量。第二行n个正整数，第i (1&lt;=i&lt;=n)个正整数表示ci，即第i个时间段牛牛被安排上课的教室；第三行n个正整数，第i (1&lt;=i&lt;=n)个正整数表示di，即第i个时间段另一间上同样课程的教室；第四行n个实数，第i (1&lt;=i&lt;=n)个实数表示ki，即牛牛申请在第i个时间段更换教室获得通过的概率。接下来e行，每行三个正整数aj，bj，wj，表示有一条双向道路连接教室aj，bj，通过这条道路需要耗费的体力值是wj；【Output】输出一行，包含一个实数，四舍五入精确到小数点后 恰好2位 ，表示答案。你的输出必须和标准输出 完全一样 才算正确。测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于4 x 10^-3。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理）【Limited conditions】保证1 &lt;= Ci &lt;= v。保证1&lt;=di&lt;=v。保证0 &lt;= ki &lt;= 1。保证 1 &lt;= n &lt;= 2000，0 &lt;= m &lt;= 2000， 1 &lt;= v &lt;= 300， 0 &lt;= e &lt;= 90000。保证1 &lt;= aj, bj &lt;= v, 1 &lt;= wj &lt;= 100。保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。道路中可能会有多条双向道路连接相同的两间教室。也有可能有道路两端连接的是同一间教室。保证输入的实数最多包含3位小数。【Sample input】3 2 3 32 1 21 2 10.8 0.2 0.51 2 51 3 32 3 1【Sample output】2.80【Sample explanation】无 Record3h Analysis请先思考后再展开 期望=各种情况的【概率×权值】之和意义即尝试无限次后，平均的权值具有线性性所以就dp过去 $$f(i,j,0)=min\left{\begin{matrix}f(i-1,j,0)+dis(c_{i-1},c_i)\\f(i-1,j,1)+dis(c_{i-1},c_i)\times (1-k_{i-1})+dis(d_{i-1},c_i)\times k_{i-1}\end{matrix}\right.$$ $$f(i,j,1)=min\left{\begin{matrix}f(i-1,j-1,0)+dis(c_{i-1},c_i)\times (1-k_i)+dis(c_{i-1},d_i)\times k_i\\f(i-1,j-1,1)+dis(c_{i-1},c_i)\times (1-k_{i-1}) \times (1-k_i)+dis(c_{i-1},d_i)\times (1-k_{i-1}) \times k_i+dis(d_{i-1},c_i)\times k_{i-1}\times (1-k_i)+dis(d_{i-1},d_i)\times k_{i-1} \times k_i\end{matrix}\right.$$ Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125; const int MAXN=2100; int c[MAXN],d[MAXN]; int mp[310][310]; double p[MAXN]; double f[MAXN][MAXN][2];//f(x,k,0/1)表示考虑到第x个，使用状况为k，当前决策为0/1的期望值 void main() &#123; int n,m,v,e;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;v,&amp;e); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;p[i]); memset(mp,63,sizeof mp); for(int i=1;i&lt;=v;i++) mp[i][i]=0; while(e--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(c&lt;mp[x][y]) mp[x][y]=mp[y][x]=c; &#125; for(int k=1;k&lt;=v;k++)//debug 太久没打了，忘记在最前面 for(int i=1;i&lt;=v;i++) for(int j=1;j&lt;=v;j++) mp[i][j]=mymin(mp[i][j],mp[i][k]+mp[k][j]); memset(f,127,sizeof f); f[n][0][0]=f[n][1][1]=0; for(int x=n-1;x&gt;=1;x--) &#123; double cc=mp[c[x]][c[x+1]],cd=mp[c[x]][d[x+1]],dc=mp[d[x]][c[x+1]],dd=mp[d[x]][d[x+1]]; for(int k=0;k&lt;=mymin(n-x+1,m);k++) &#123; f[x][k][0]=mymin( f[x+1][k][0]+cc, f[x+1][k][1]+p[x+1]*cd+(1.0-p[x+1])*cc ); if(k&gt;0) f[x][k][1]=f[x+1][k-1][0]+p[x]*dc+(1.0-p[x])*cc; if(k&gt;1) f[x][k][1]=mymin( f[x][k][1], f[x+1][k-1][1]+p[x]*p[x+1]*dd+p[x]*(1.0-p[x+1])*dc+ (1.0-p[x])*p[x+1]*cd+(1.0-p[x])*(1.0-p[x+1])*cc ); &#125; &#125; double ans=0x3f3f3f3f; for(int k=0;k&lt;=m;k++) ans=mymin(ans,mymin(f[1][k][0],f[1][k][1])); printf("%.2lf",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP16 D1T2】天天爱跑步]]></title>
    <url>%2Fposts%2F9594.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2016 提高组 D1T2Loj2359Uoj261Bzoj4719Luogu1600Caioj1576 Problem【Description】 小C同学认为跑步灰常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。这个游戏的地图可以看作一棵包含n个结点和n - 1条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从1到n的连续正整数。现在有m个玩家，第i个玩家的起点为Si，终点为Ti。每天打卡任务开始时，所有玩家 在第0秒 同时从 自己的起点 出发，以 每秒跑一条边 的速度，不间断地沿着最短路径向着 自己的终点 跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）小C想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点j的观察员会选择在第Wj秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第Wj秒也 正好 到达了结点j。小C想知道每个观察员会观察到多少人？注意： 我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点j作为终点的玩家：若他在第Wj秒前到达 终点，则在结点j的观察员 不能观察到 该玩家；若他 正好 在第Wj秒到达终点，则在结点j的观察员 可以观察到 这个玩家。【Input】第一行有两个整数n和m。其中n代表树的结点数量，同时也是观察员的数量， m代表玩家的数量。接下来n - 1行每行两个整数u和v，表示结点u到结点v有一条边。接下来一行n个整数，其中第j个整数为Wj，表示结点j出现观察员的时间。 接下来m行，每行两个整数Si和Ti，表示一个玩家的起点和终点。【Output】输出1行n个整数，第j个整数表示结点j的观察员可以观察到多少人。【Limited conditions】对于所有的数据，保证1 &lt;= Si, Ti &lt;= n，0 &lt;= Wj &lt;= n。【Sample input 1】6 32 31 21 44 54 60 2 5 1 2 31 51 32 6【Sample output 1】2 0 0 1 1 1【Sample input 2】5 31 22 32 41 50 1 0 3 03 11 45 5【Sample output 2】1 2 1 0 1【Sample explanation】无 Record5h Analysis请先思考后再展开 首先，树上路径可以分割为两条链咱们推一推式子吧，d是深度向上：$d_y+w_y=d_x$ （y是求答案的点，x是路径起点）向下：$w_y-d_y=d_x-2\times d_{lca}$（y是求答案的点，x是路径起点，lca是路径lca） 然后发现就是两种值的维护，然后分上下讨论；但是怎么维护呢？ 我在晚修的时候忽然想到一种奇技淫巧用到了vector（不喜欢也可以写链表）把上面说的维护的两种值，按照值本身分成数组，然后我们要的就是对同值的编号，对于链上的部分，出现次数+1 那么我是使用树链剖分来搞的用线段树维护的话，空间复杂度是很高的使用灵活的差分，看起来还是一样，但其实我们可以运用vector的特点了，那就是实际总空间灰常小，然后定位的话，就是得到了l和r之后，在保证编号有序的情况下，二分查找一下就好了 那么最后的时候递推一下，累计一下答案，这道题就完成了但是其实细节还是很多的例如一开始忘记对两种情况分开维护之类 现在我们分析一下复杂度空间：$O(n)$，常数10以内时间：$O(nlogn)$，常数3以内吧大概；看起来虽然是log方，但数量灰常少，均摊小然鹅这样优秀的时间复杂度，居然不是很快？好像有些oj还会超时……好迷啊，之前那几个数据结构题也是类似的感觉，nlogn巨慢，不知道是不是复杂度算错？ UP 2018.8.9 rose用的是线段树维护虽然是区间操作，但还是可以动态开点至于复杂度，我们无敌的波老师（hanks_o大爷）有个证明：最多只会有logn层，然后每一次分治的时候，最多会分裂成两段，那么在第i层就分裂成logn段，所以说最多新开log方的节点，而且大概是很难构造的吧 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=310000;//*******************全局定义*******************struct Nod&#123; int hou; int dep; int siz; int son,tp,fa;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;; p[x].hou=ln;&#125;int w[MAXN];int ans[MAXN];//按dfs序//*******************实现*******************void pre(int x,int fa)&#123; p[x].fa=fa; p[x].dep=p[fa].dep+1; p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; pre(y,x); p[x].siz+=p[y].siz; if(p[y].siz&gt;p[p[x].son].siz) p[x].son=y; &#125;&#125;int id=0;int pos[MAXN],pos2[MAXN];//dfs序编号、原编号int getlca(int x,int y)&#123; while(p[x].tp!=p[y].tp) &#123; if(p[p[x].tp].dep&lt;p[p[y].tp].dep) swap(x,y); x=p[p[x].tp].fa; &#125; return (p[x].dep&lt;p[y].dep)?x:y;&#125;void poufen(int x,int tp)&#123; pos[x]=++id;pos2[id]=x;p[x].tp=tp; if(p[x].son&gt;0) poufen(p[x].son,p[x].tp); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa and y!=p[x].son) poufen(y,y); &#125;&#125;vector&lt;int&gt; upbh[MAXN*2],downbh[MAXN*2];//编号vector&lt;int&gt; upcf[MAXN*2],downcf[MAXN*2];//差分void solve()&#123; int st,ed;scanf("%d%d",&amp;st,&amp;ed); int up=p[st].dep+MAXN,down=p[st].dep-2*p[getlca(st,ed)].dep+MAXN; while(p[st].tp!=p[ed].tp) &#123; if(p[p[st].tp].dep&gt;p[p[ed].tp].dep)//向上 &#123; int l=lower_bound(upbh[up].begin(),upbh[up].end(),pos[p[st].tp])-upbh[up].begin(); int r=upper_bound(upbh[up].begin(),upbh[up].end(),pos[st])-upbh[up].begin()-1; upcf[up][l]++; upcf[up][r+1]--; st=p[p[st].tp].fa; &#125; else//向下 &#123; int l=lower_bound(downbh[down].begin(),downbh[down].end(),pos[p[ed].tp])-downbh[down].begin(); int r=upper_bound(downbh[down].begin(),downbh[down].end(),pos[ed])-downbh[down].begin()-1; downcf[down][l]++; downcf[down][r+1]--; ed=p[p[ed].tp].fa; &#125; &#125; if(p[st].dep&gt;p[ed].dep)//向上 &#123; int l=lower_bound(upbh[up].begin(),upbh[up].end(),pos[ed])-upbh[up].begin(); int r=upper_bound(upbh[up].begin(),upbh[up].end(),pos[st])-upbh[up].begin()-1; upcf[up][l]++; upcf[up][r+1]--; &#125; else//向下 &#123; int l=lower_bound(downbh[down].begin(),downbh[down].end(),pos[st])-downbh[down].begin(); int r=upper_bound(downbh[down].begin(),downbh[down].end(),pos[ed])-downbh[down].begin()-1; downcf[down][l]++; downcf[down][r+1]--; &#125;&#125;//*******************主函数*******************int main()&#123; memset(p,0,sizeof(p)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; pre(1,0);poufen(1,1); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n;i++) &#123; int x=pos2[i]; int w1=w[x]+p[x].dep+MAXN;if(w1&lt;2*MAXN) upbh[w1].push_back(i),upcf[w1].push_back(0); int w2=w[x]-p[x].dep+MAXN;if(w2&lt;2*MAXN) downbh[w2].push_back(i),downcf[w2].push_back(0); &#125; for(int i=0;i&lt;2*MAXN;i++)//debug upper_bound找不到 &#123; upbh[i].push_back(MAXN-1),upcf[i].push_back(0); downbh[i].push_back(MAXN-1),downcf[i].push_back(0); &#125; for(int i=1;i&lt;=m;i++) solve(); for(int i=0;i&lt;2*MAXN;i++) &#123; int now=0,sz; sz=upbh[i].size(); for(int j=0;j&lt;sz;j++) &#123; now+=upcf[i][j]; ans[ upbh[i][j] ]+=now; &#125; sz=downbh[i].size(); for(int j=0;j&lt;sz;j++) &#123; now+=downcf[i][j]; ans[ downbh[i][j] ]+=now; &#125; &#125; for(int x=1;x&lt;=n;x++) printf("%d ",ans[pos[x]]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T3】运输计划]]></title>
    <url>%2Fposts%2Fbb9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T3Uoj150Bzoj4326Luogu2680Caioj1574 Problem【Description】 公元 2044 年，人类进入了宇宙纪元。L 国有 n个星球，还有 n-1条双向航道，每条航道建立在两个星球之间，这 n-1 条 航道连通了 L 国的所有星球。小 P 掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物 流飞船需要从 ui 号星球沿最快的宇航路径飞行到 vi 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 j，任意飞船驶过它所花费的时间为 tj，并且任意两艘飞船之间不会产生任何干扰。为了鼓励科技创新，L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。在虫洞的建设完成前小 P 的物流公司就预接了 m个运输计划。在虫洞建设完成后， 这 m 个运输计划会同时开始，所有飞船一起出发。当这 m个运输计划都完成时，小 P 的 物流公司的阶段性工作就完成了。如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？【Input】 第一行包括两个正整数 n、m，表示 L 国中星球的数量及小 P 公司预接的运输计划的 数量，星球从 1 到 n 编号。接下来 n-1 行描述航道的建设情况，其中第 ii 行包含三个整数 ai, bi 和 ti，表示第 ii 条双向航道修建在 ai 与 bi 两个星球之间，任意飞船驶过它所花费的时间为 ti。接下来 m行描述运输计划的情况，其中第 j 行包含两个正整数 uj 和 vj，表示第 j个 运输计划是从 uj 号星球飞往 vj号星球。【Output】共 1 行，包含 1 个整数，表示小 P 的物流公司完成阶段性工作所需要的最短时间。【Limited conditions】【Sample input】6 31 2 31 6 43 1 74 3 63 5 53 62 54 5【Sample output】11【Sample explanation】无 Record2h很多变量忘记清零了……code20mincheck2h…… Analysis请先思考后再展开 首先一眼树链剖分是没问题的但我觉得应该会有更有意思的方法吧……不然就不做了看了看题解，还真有居然是树上差分！这东西我大概知道，但是说实话我一直没有用过然后发现我以前的猜测是错误的，它是从深度大的地方向上的（子树和）所以能很轻松地处理路径通过量的统计问题 总结一下： 先搞一搞lca 显然最小化最大值，搞个二分 然后就优化那个被所有【需要优化的路径】经过的边中长度最大者（不是被所有经过的话，就一定不能彻底解决问题），判断是否可行 时间复杂度：O(nlogn)那么理论上是灰常快的但是caioj和uoj都过不去……只过了另两个可能是被卡栈了？不管了无伤大雅 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;void qread(int &amp;x)&#123; x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10+c-'0',c=getchar();&#125;//*******************全局常量*******************const int MAXN=310000;//*******************全局定义*******************struct Nod&#123; int hou; int dep; int dis; int dis2;//与父亲 Nod() &#123; hou=dep=dis=dis2=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln;&#125;int n,m;int bin[30];int f[MAXN][30];//*******************实现*******************void dfs(int x,int fa)&#123; f[x][0]=fa;p[x].dep=p[fa].dep+1; for(int i=1;bin[i]&lt;=p[x].dep;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; p[y].dis2=e[k].c; dfs(y,x); &#125;&#125;int lca(int x,int y)&#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=20;i&gt;=0;i--) if(bin[i]&lt;=p[x].dep-p[y].dep) x=f[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];//上面的循环，曾经以为不用到0，还没错过……&#125;struct Road&#123; int x,y; int lca,length;&#125;s[MAXN];int sum[MAXN];//树上差分，与父亲int ss;int ans;//最长void dfs2(int x,int fa)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs2(y,x);sum[x]+=sum[y]; &#125; if(sum[x]==ss) ans=mymax(ans,p[x].dis2);&#125;bool check(int mid)&#123; memset(sum,0,sizeof sum);//debug int mxl=0;ss=0; for(int i=1;i&lt;=m;i++) if(s[i].length&gt;mid) &#123; mxl=mymax(mxl,s[i].length); ss++; sum[s[i].x]++; sum[s[i].y]++; sum[s[i].lca]-=2; &#125; ans=0;//debug dfs2(1,0); return mxl-ans&lt;=mid;&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;qread(x);qread(y);qread(c); ins(x,y,c);ins(y,x,c); &#125; dfs(1,0); for(int i=1;i&lt;=m;i++) &#123; qread(s[i].x);qread(s[i].y); s[i].lca=lca(s[i].x,s[i].y); s[i].length=p[s[i].x].dis+p[s[i].y].dis-2*p[s[i].lca].dis; &#125; int l=0,r=300000000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树剖</tag>
        <tag>倍增</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T2】 子串]]></title>
    <url>%2Fposts%2Fe5d4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T2Luogu2679Caioj1573 Problem【Description】 有两个仅包含小写英文字母的字符串 A 和 B。现在要从字符串 A 中取出 k 个 互不重叠 的非空子串， 然后把这 k 个子串按照其在字符串 A 中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 B 相等？ 注意：子串取出的位置不同也认为是不同的方案。【Input】第一行是三个正整数 n，m，k，分别表示字符串 A 的长度，字符串 B 的长度，以及问题描述中所提到的 k，每两个整数之间用一个空格隔开。第二行包含一个长度为 n 的字符串，表示字符串 A。 第三行包含一个长度为 m 的字符串，表示字符串 B。【Output】输出共一行，包含一个整数，表示所求方案数。(由于答案可能很大，所以这里要求输 出答案对 1,000,000,007 取模的结果。【Limited conditions】对于第 1 组数据:1≤n≤500,1≤m≤50,k=1;对于第 2 组至第 3 组数据:1≤n≤500,1≤m≤50,k=2;对于第 4 组至第 5 组数据:1≤n≤500,1≤m≤50,k=m;对于第 1 组至第 7 组数据:1≤n≤500,1≤m≤50,1≤k≤m;对于第 1 组至第 9 组数据:1≤n≤1000,1≤m≤100,1≤k≤m;对于所有 10 组数据:1≤n≤1000,1≤m≤200,1≤k≤m。【Sample input 1】6 3 1aabaabaab【Sample output 1】2【Sample input 2】6 3 2aabaabaab【Sample output 2】7【Sample input 3】6 3 3aabaabaab【Sample output 3】7【Sample explanation】 Record40min Analysis请先思考后再展开 提高组的字符串……八成是dp那么设$f[i][j][k]=用到A_i，填充到B_j，用了k个段的方案数$然后？？然后就蒙逼了 其实这是因为我们的决策需要把用了$A_i$的和没用的方案数分开来$g[i][j][k]表示用到A_i，填充到B_j，用了k个段的方案数$$f[i][j][k]表示到A_i为止（不一定用），填充到B_j，用了k个段的方案数$那么一下子就可以搞出递推式了： $$g[i][j][k]=\left{\begin{matrix}f[i-1][j-1][k-1]+g[i-1][j-1][k] &amp;(A[i-1]=B[j-1])\\0 &amp; (A[i-1] \neq B[j-1])\end{matrix}\right.$$ 然后累计$f[i][j][k]=f[i-1][j][k]+g[i][j][k]$ 但这样会mle哒循环数组就好了 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=210;const int MOD=1000000007;const int INF=0x3f3f3f3f;//*******************全局定义*******************char a[MAXN],b[MAXM];int f[2][MAXM][MAXM],g[2][MAXM][MAXM];//*******************实现*******************//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",a+1,b+1); int pre=0,now=1; f[pre][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; f[now][0][0]=1;//debug for(int j=1;j&lt;=m;j++) for(int kk=1;kk&lt;=k;kk++) &#123; if(a[i]==b[j]) g[now][j][kk]=(f[pre][j-1][kk-1]+g[pre][j-1][kk])%MOD; else g[now][j][kk]=0; f[now][j][kk]=(f[pre][j][kk]+g[now][j][kk])%MOD; &#125; swap(pre,now); &#125; printf("%d",f[pre][m][k]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D2T1】 跳石头]]></title>
    <url>%2Fposts%2F29c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D2T1Luogu2678Caioj1572 Problem【Description】一年一度的“跳石头”比赛又要开始了!这项比赛将在一条笔直的河道中进行,河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间,有 N 块岩石(不含起点和终 点的岩石)。在比赛过程中,选手们将从起点出发,每一步跳向相邻的岩石,直至到达 终点。为了提高比赛难度,组委会计划移走一些岩石,使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制,组委会至多从起点和终点之间移走 M 块岩石(不能 移走起点和终点的岩石)。【Input】 输入第一行包含三个整数 L，N，M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。接下来 N 行，每行一个整数，第 i 行的整数 Di（0&lt;Di&lt;L）表示第 i 块岩石与 起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同 一个位置。【Output】输出只包含一个整数，即最短跳跃距离的最大值。【Limited conditions】对于 20%的数据,0 ≤ M ≤ N ≤ 10。 对于50%的数据,0 ≤ M ≤ N ≤ 100。对于 100%的数据,0 ≤ M ≤ N ≤ 50,000,1 ≤ L ≤ 1,000,000,000。【Sample input】25 5 2211141721【Sample output】4【Sample explanation】将与起点距离为 2 和 14 的两个岩石移走后,最短的跳跃距离为 4(从与起点距离 17 的岩石跳到距离 21 的岩石,或者从距离 21 的岩石跳到终点)。 Record20min Analysis1请先思考后再展开 首先，看到最值的最值问题，应该先想到二分答案：例如目标答案是A，那么所有距离都要大于等于A 然后就dp转移，f[i]表示到i位置合法的，移动石子的最小值（显然单调递增）然后logn转移即可 这样的复杂度是O(nlognlogn) Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,m;int d[MAXN];int f[MAXN];//*******************实现*******************bool check(int mid)&#123; for(int i=1;i&lt;=n;i++) &#123; //if(mid==1 and i==n) if(d[i]&lt;mid) f[i]=INF; else &#123; int t=upper_bound(d+1,d+i+1,d[i]-mid)-d-1;//&lt;= f[i]=mymin(f[t]+mymax(i-t-1,0),i-1); &#125; &#125; //printf("mid=%d f[n]=%d\n",mid,f[n]); return f[n]&lt;=m;&#125;//*******************主函数*******************int main()&#123; int L;scanf("%d%d%d",&amp;L,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i]); n++;d[n]=L; int l=1,r=1000000000,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d",ans);&#125; Analysis2请先思考后再展开 上面的做法其实还算快，因为出题人并没有去卡然鹅其实可以更快的原谅我脑残了如果从起点开始，找到下一个能跳的地方，跳过去，就好了……这样就省掉了一个log]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP15 D1T2】信息传递]]></title>
    <url>%2Fposts%2F3244.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2015 提高组 D1T2Luogu2312Caioj1568 Problem【Description】有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti同学。游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？【Input】输入共 2 行。第 1 行包含 1 个正整数 n，表示 n 个人。第 2 行包含 n 个用空格隔开的正整数 T1, T2, … … , Tn，其中第 i 个整数Ti表示编号为 i 的同学的信息传递对象是编号为 Ti 的同学， Ti ≤ n 且 Ti ≠ i。数据保证游戏一定会结束。【Output】输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。【Limited conditions】对于 30%的数据， n ≤ 200；对于 60%的数据，n ≤ 2500；对于 100%的数据，n ≤ 200000。【Sample input】52 4 2 3 1【Sample output】3【Sample explanation】游戏的流程如图所示。当进行完第 3 轮游戏后，4 号玩家会听到 2 号玩家告诉他自己的生日，所以答案为 3。当然，第 3 轮游戏后，2 号玩家、3 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。 Record20min Analysis请先思考后再展开 一眼就是找最小环如果直接暴力枚举是n方级别的考虑题目特性，只有一条出边显然所有强连通都是以环的形式出现的找最小但至少有两个的强连通分量即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int dfn,low; bool v; Nod() &#123; hou=dfn=0; v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;//*******************实现*******************int id=0;int sta[MAXN],top=0;int siz[MAXN],cnt=0;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; siz[cnt]++; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); ins(i,t); &#125; for(int i=1;i&lt;=n;i++) if(!p[i].dfn) tarjan(i); int ans=INF; for(int i=1;i&lt;=cnt;i++) if(siz[i]&gt;=2 and siz[i]&lt;ans) ans=siz[i]; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T3】解方程]]></title>
    <url>%2Fposts%2Fc8d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T3Bzoj3751Luogu2312Caioj1568 Problem【Description】已知多项式方程：$$a_0+a_1x+a_2x^2+\cdots+a_nx^n=0$$求这个方程在 $[1,m]$ 内的整数解（$n$ 和 $m$ 均为正整数）。【Input】输入共 $n + 2$ 行。第一行包含 $2$ 个整数 $n, m$，每两个整数之间用一个空格隔开。接下来的 $n+1$ 行每行包含一个整数，依次为 $a_0,a_1,a_2\ldots a_n$。【Output】第一行输出方程在 $[1,m]$ 内的整数解的个数。接下来每行一个整数，按照从小到大的顺序依次输出方程在 $[1,m]$ 内的一个整数解。【Limited conditions】对于 $30\%$ 的数据：$0&lt;n\le 2,|a_i|\le 100,a_n≠0,m&lt;100$。对于 $50\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{100},a_n≠0,m&lt;100$。对于 $70\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{10000},a_n≠0,m&lt;10^4$。对于 $100\%$ 的数据：$0&lt;n\le 100,|a_i|\le 10^{10000},a_n≠0,m&lt;10^6$。【Sample input 1】2 101-21【Sample output 1】11【Sample input 2】2 102-31【Sample output 2】212【Sample input 3】2 10132【Sample output 3】0【Sample explanation】无 Record40min Analysis请先思考后再展开 一开始想着高精度肯定超时啊然后膜题解，发现自己忘记了这个套路：自然溢出，或者搞多几个模数之前也用过：等价表达式原理还是类似的：如果$f(x)=0$，那么$f(x)\%p=0$，而这个多项式又没有除法 然后用秦九昭就好了这东西之前看到，结果就觉得：煞笔玩意……然后现在居然没想到了感觉这东西和韦达定理是一个道理的…… 但是现在的复杂度大概是1亿的，然后还有个long long的常数5，还有两个模数的常数2有没有很虚的感觉？那怎么办么？随便卡卡常呗随便搞个小模数10007吧，这里面的数字，如果$f(x)=0$，那么后面的部分（即$f(10007\times b+x)$）显然就不用枚举了不知道为什么就快了灰常多呀（好像时间复杂度证明跟拉格朗日定理有关？） Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=1100000;const int MOD[5]=&#123;11261,19997,22877,21893,14843&#125;;//*******************全局定义*******************int a[5][MAXN];bool v[5][MAXN];int ans[MAXN],as=0;//*******************实现*******************int n;bool check(int x,int mod,int *f)&#123; int sum=0; for(int i=n;i&gt;=0;i--) sum=(sum*x%mod+f[i])%mod; return sum==0;&#125;//*******************主函数*******************char s[MAXN];int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) &#123; scanf("%s",s+1);int ln=strlen(s+1); int fg=1; for(int j=1;j&lt;=ln;j++) &#123; if(s[j]=='-') &#123;fg=-1;continue;&#125; for(int t=0;t&lt;5;t++) a[t][i]=(a[t][i]*10+s[j]-'0')%MOD[t]; &#125; for(int t=0;t&lt;5;t++) a[t][i]*=fg; &#125; for(int t=0;t&lt;5;t++) for(int i=1;i&lt;MOD[t];i++) v[t][i]=check(i,MOD[t],a[t]); for(int i=1;i&lt;=m;i++) if(v[0][i%MOD[0]] and v[1][i%MOD[1]] and v[2][i%MOD[2]] and v[3][i%MOD[3]] and v[4][i%MOD[4]]) ans[++as]=i; printf("%d\n",as); for(int i=1;i&lt;=as;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>秦九昭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T2】寻找道路]]></title>
    <url>%2Fposts%2Fbc9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T2Luogu2296Caioj1567 Problem【Description】 在有向图 G 中，每条边的长度均为 1，现给定起点和终点，请你在图中找一条从起点到 终点的路径，该路径满足以下条件：1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。2. 在满足条件 1 的情况下使路径最短。注意：图 G 中可能存在重边和自环，题目保证终点没有出边。 请你输出符合条件的路径的长度。【Input】 第一行有两个用一个空格隔开的整数 n 和 m，表示图有 n 个点和 m 条边。接下来的 m 行每行 2 个整数 x、y，之间用一个空格隔开，表示有一条边从点 x 指向点y。最后一行有两个用一个空格隔开的整数 s、t，表示起点为 s，终点为 t。【Output】 输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出-1。【Limited conditions】对于30%的数据，0&lt;n≤10，0&lt;m≤20；对于60%的数据，0&lt;n≤100，0&lt;m≤2000；对于100%的数据，0&lt;n≤10,000，0&lt;m≤200,000，0&lt;x，y，s，t≤n，x≠t。【Sample input】6 61 21 32 62 54 53 41 5【Sample output】3【Sample explanation】如上图所示，满足条件的路径为1 - &gt;3- &gt;4- &gt;5。注意点2 不能在答案路径中，因为点2连了一条边到点6 ，而点6 不与终点5 连通。 Record20min Analysis请先思考后再展开 sb题 建个反向边 判断连通性 从不连通的地方扫描标记 spfa Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=11000,MAXM=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; bool v,ar; int dis; Nod() &#123; hou=0; v=ar=0; dis=INF; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;//*******************实现*******************void dfs(int x)&#123; p[x].ar=p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(!p[y].ar) dfs(y); &#125;&#125;queue&lt;int&gt; lst;bool in[MAXN];int spfa(int st,int ed)&#123; if(!p[st].v) return -1; lst.push(st);p[st].dis=0;in[st]=1; while(!lst.empty()) &#123; int x=lst.front();lst.pop(); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+1 and p[y].v) &#123; p[y].dis=p[x].dis+1; if(!in[y]) &#123; in[y]=1; lst.push(y); &#125; &#125; &#125; in[x]=0; &#125; return (p[ed].dis==INF)?-1:p[ed].dis;&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(y,x); &#125; int st,ed;scanf("%d%d",&amp;st,&amp;ed); dfs(ed); for(int x=1;x&lt;=n;x++) if(!p[x].ar) for(int k=p[x].hou;k&gt;0;k=e[k].g) p[e[k].y].v=0; printf("%d",spfa(ed,st));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【GDOI2018 D1T2】【51nod1357】密码锁]]></title>
    <url>%2Fposts%2Ff4f8.html</url>
    <content type="text"><![CDATA[Source and JudgeGDOI2018 D1T2（模数不固定）51nod1357 Problem【Description】有一个密码锁，其有N位，每一位可以是一个0~9的数字，开启密码锁需要将锁上每一位数字转到解锁密码一致。这个类似你旅行用的行李箱上的密码锁，密码锁的每一位其实是一个圆形转盘，上面依次标了0,1，…9,对每一位来说可以正向或者逆向拨动，正向拨动时原有数字x会变成新的数字(x+1 mod 10),例如1-&gt;2，2-&gt;3，9-&gt;0；同理逆向拨动变为(x-1 mod 10)即9-&gt;8,5-&gt;4,0-&gt;9。定义对密码锁的一次操作：选择一个连续的区间[L,R]，可以只包含一位即L==R，将这个区间的所有数字正向拨动或逆向拨动一次，注意要么全部正着拨，要么全逆着。例如：12397正向后变成23408，逆向后变成01286。给出密码锁初始和解锁需要的终止状态，问最少多少次操作能解锁。【Input】多组测试数据，第一行一个整数T，表示测试数据数量每组测试数据有相同的结构构成：每组数据有两行构成，第一行是密码锁的初始状态S，第二行是解锁的终止状态E【Output】每组数据一行输出，即最少需要的操作数。【Limited conditions】1&lt;=len(S)=len(E)&lt;=2500,且都由0~9构成【Sample input】106076071234456737896565159478927782432854574946297839335216760603277426453582937390990599524328132169880751802416449917850055278844124181670313605874031469333653114254419369610778733406822463469353946356056711090437786504862201123112170209094423232218340629042147624501837850000000【Sample output】031066281421811【Sample explanation】无 Record2h这个是比赛的题目，但当时没有做出来然后因为讲课的时候不是那么明确，想做一做（就是想报仇的心态）在知乎上找到了类似的题目，不过都没人做wa了很多次……所以数据特别多，是我买的几组数据 Analysis请先思考后再展开 首先，gdoi的题目是最后要到0，而这里是指定的如何处理这一步呢？其实很好理解，因为每一个位是相对独立互不影响的，那么可以把目标位对其为0，然后把当前串映射过去（其实就是相减一下），那么现在对正确性没有影响的 但是，这道题目有个很迷惑人的地方，在于有模数刚才我们搞出来的当前串a是有负数的，但是我们先不管它 现在有+1和-1两种区间操作，那么一个不那么显然的套路就是差分一下（没想到啊555）那么现在，我们的目标就是，对于得到的差分数组cf，我们要把其中每一个元素变成m的倍数（包括0）而这两个区间操作，现在就变成了对一个数+1，一个数-1 不难发现这道题是一定有解的，因为你可以一个个拧过去我们要利用这个性质，辅助我们去理解这道题那一个个拧过去，其实就是这个+1，下一个-1所以我们的差分数组，长度应该是n+1而且，我们的+1和-1的个数是要相同的 那么对于每一个差分后的数，它都有一个上下界，因为跨越是没有意义的那么显然我们可以取个模，然后如果还是负数的话，把它+m后，其实是等效的 现在的问题就在于，如何分配+1和-1呢？首先明确一个数，只可能增加或减少，而不会重叠，否则答案不会更优（还不理解可以联想一下原问题，对于两个重叠的+1和-1区间，显然可以把中间的去掉，剩下的还是两个） 接下来，我们可以尝试贪心把差分的数字排个序，然后枚举一个断点（在空隙位置），这个断点左边的，也就是比它小的，全部都是要减小的，右边的都是要增加的那么线性地扫描一遍，如果左边的花费能否等于右边的花费，显然这个时候是最优的 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=3100;const int m=10;//*******************全局定义*******************char st[MAXN],ed[MAXN];//*******************实现*******************int myabs(int x) &#123;return (x&gt;0)?x:-x;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************主函数*******************struct Nod&#123; int cf; int a,b;//下、上&#125;p[MAXN];bool cmp(Nod a,Nod b) &#123;return a.cf&lt;b.cf;&#125;int a[MAXN];int l[MAXN],r[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",st+1,ed+1); int n=strlen(st+1); for(int i=1;i&lt;=n+1;i++) &#123; a[i]=st[i]-ed[i]; p[i].cf=(a[i]-a[i-1])%m; if(p[i].cf&lt;0) p[i].cf+=m;//对应位置 p[i].a=p[i].cf,p[i].b=10-p[i].cf; &#125; sort(p+1,p+n+1+1,cmp); l[0]=0;for(int i=1;i&lt;=n+1;i++) l[i]=l[i-1]+p[i].a; r[n+2]=0;for(int i=n+1;i&gt;=1;i--) r[i]=r[i+1]+p[i].b; int ans=-1; for(int i=1;i&lt;=n+2;i++) if(l[i-1]==r[i]) &#123;ans=l[i-1];break;&#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Sdoi2016】数字配对]]></title>
    <url>%2Fposts%2F6c7a.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2016Bzoj4514Luogu4068Loj2031 Problem【Description】有 n 种数字，第 i 种数字是 ai、有 bi 个，权值是 ci。若两个数字 ai、aj 满足，ai 是 aj 的倍数，且 ai/aj 是一个质数，那么这两个数字可以配对，并获得 ci×cj 的价值。一个数字只能参与一次配对，可以不参与配对。在获得的价值总和不小于 0 的前提下，求最多进行多少次配对。【Input】第一行一个整数 n。第二行 n 个整数 a1、a2、……、an。第三行 n 个整数 b1、b2、……、bn。第四行 n 个整数 c1、c2、……、cn。【Output】一行一个数，最多进行多少次配对【Limited conditions】 n≤200，ai≤10^9，bi≤10^5，|ci|≤10^5【Sample input】32 4 82 200 7-1 -2 1【Sample output】4【Sample explanation】无 Record1h Analysis请先思考后再展开 这道题有意思的地方不是构图 首先,对于(i,j),判断能否配对,直接枚举约数要sqrt(a),即使配上线筛也是灰常慢的.考虑条件的特性:多出一个质因数,因为前面有个条件限制着,完全可以看作质因数的幂之和+1所以这个是可以在枚举外面预处理的,然后其实线筛是可以省去的,因为合数已经被前面的筛去了. (st,i),cost=0,flow=b[i](i,j),cost=c[i]*c[j],flow=INF(i,ed),cost=0,flow=b[i]然后跑一下最大费用最大流其实会不会有种杀鸡用牛刀的感觉,毕竟很简单 然鹅最关键的地方在于,这个权值和不能是负数,那么当有一天我们跑出来的最长路乘上哪怕1的流量,已经会导致答案变负数了,显然game over还有一种情况是最长路是负数,那么就要限制一下流量,确保费用是非负数即可. 然后网上有人还要分奇偶,那根本就不是正常人的思维,其实答案直接除二就好,否则显然分配方案不对称的话不会使结果更优. Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=410,MAXM=80000;//*******************全局定义*******************typedef long long ll;const ll INF=(1ll&lt;&lt;60);int hou[MAXN];bool v[MAXN];struct Edge&#123; int y,g,oth; ll w,c;&#125;e[MAXM];int ln=0;void ins(int x,int y,ll w,ll c)&#123; e[++ln]=(Edge)&#123;y,hou[x],ln+1,w,c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],ln-1,-w,0&#125;;hou[y]=ln;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************实现*******************int st,ed;int lrd[MAXN];ll dis[MAXN],mic[MAXN];queue&lt;int&gt; lst;ll now=0,ans=0;bool bfs()&#123; memset(dis,-63,sizeof(dis)); memset(v,0,sizeof(v)); lst.push(st);dis[st]=0;v[st]=1;mic[st]=INF; while(!lst.empty()) &#123; int x=lst.front();lst.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(dis[y]&lt;dis[x]+e[k].w and e[k].c&gt;0) &#123; dis[y]=dis[x]+e[k].w; mic[y]=mymin(mic[x],e[k].c); lrd[y]=e[k].oth; if(!v[y]) v[y]=1,lst.push(y); &#125; &#125; v[x]=0; &#125; if(mic[ed]==0) return 0; ll cost=dis[ed],flow=mic[ed]; if(cost&lt;-now) return 0;//game over if(cost&lt;0) flow=mymin(flow,-now/cost); now+=flow*cost; ans+=flow; for(int x=ed;x!=st;x=e[lrd[x]].y) &#123; e[e[lrd[x]].oth].c-=flow; e[lrd[x]].c+=flow; &#125; return 1;&#125;//*******************主函数*******************int get(int x)&#123; int s=0; for(int i=2;i*i&lt;=x;i++) &#123;while(x%i==0) x/=i,s++;&#125; if(x&gt;1) s++; return s;&#125;int a[MAXN],b[MAXN];ll c[MAXN];int cnt[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),cnt[i]=get(a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;c[i]); st=0,ed=2*n+1; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,0,b[i]);ins(n+i,ed,0,b[i]); for(int j=1;j&lt;i;j++) &#123; if( ((a[i]%a[j])==0 and cnt[i]==cnt[j]+1) or ((a[j]%a[i])==0 and cnt[j]==cnt[i]+1) ) &#123; ins(i,n+j,c[i]*c[j],INF); ins(j,n+i,c[i]*c[j],INF); &#125; &#125; &#125; while(bfs()) ; printf("%lld\n",ans/2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDOI2018]]></title>
    <url>%2Fposts%2Fd688.html</url>
    <content type="text"><![CDATA[GDOI2018 题解(2019.4重做)GDOI2018似乎不允许贴题面啊，那就只给出题解和代码吧 D1T1根据调和级数直接模拟即可 123456789101112int a[MAX_N],pos[MAX_N],n;bool check(int T)&#123; for(int i=T;i&lt;=a[n];i+=T) if(a[pos[i]]!=i) return 0; return 1;&#125;void main()&#123; n=qread();for(int i=1;i&lt;=n;i++) a[i]=a[i-1]+qread(); for(int i=0;i&lt;=a[n];i++) pos[i]=lower_bound(a+1,a+n+1,i)-a; for(int T=1;T&lt;=a[n];T++) if(a[n]%T==0 and check(T))&#123;write(a[n]/T);return;&#125;&#125; D1T2upd：有道类似的题目可以对比着看，abc136e考虑差分后把操作转化为+1、-1而且有个结论，一定存在一个最优方案使得所有人只到一次m的倍数，否则可以调整，于是我们只需要确定向上还是向下就好了答案是max(向上，向下)，枚举向下k个，一定是选择ai%m最小的k个向下，那么排序后扫一遍就好了 123456789101112131415161718int a[MAX_N];ll sum[MAX_N];void main()&#123; int n=qread(),m=qread(); for(int i=1;i&lt;=n;i++) a[i]=qread(); for(int i=n;i&gt;=1;i--) a[i]=(a[i]-a[i-1]+m)%m; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i]; ll ans=LLINF; for(int i=0;i&lt;=n;i++)//i~n up &#123; ll left=(i==0?0:sum[i-1]); ll right=ll(n-i+1)*m-(sum[n]-(i==0?0:sum[i-1])); ans=min(ans, max(left,right) ); &#125; write(ans);&#125; D1T3$$\begin{aligned}&amp; 若询问点x，dep_i&gt;dep_x+t且dfn_x \leq dfn_i \leq dfn_x+siz_x-1\\&amp; 然后因为带修，那么多加入时间这一维，插入同上；那么就是个三位偏序，直接cdq+bit即可\\&amp; 时间复杂度为 nlog^2n\end{aligned}$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=998244353; const int MAX_N=3e5+10; int dfn[MAX_N],siz[MAX_N],dep[MAX_N],id=0; vc&lt;int&gt; son[MAX_N]; void dfs(int x,int fa) &#123; dfn[x]=++id;siz[x]=1;dep[x]=dep[fa]+1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue; dfs(y,x);siz[x]+=siz[y]; &#125; &#125; struct BIT &#123; ll bit[MAX_N];BIT()&#123;memset(bit,0,sizeof bit);&#125; #define lowbit(x) ((x)&amp;-(x)) void add(int x,int c)&#123;while(x&lt;MAX_N) bit[x]+=c,x+=lowbit(x);&#125; ll ask(int x)&#123;ll ans=0;while(x&gt;=1) ans+=bit[x],x-=lowbit(x);return ans;&#125; &#125;bit; struct Data &#123; int op,ti;//op=0节点/增加 1询问 pr gg;//(dep,dfn) or (dep+ti,dfn) or (dep+t,x) int w,id; &#125;p[MAX_N]; bool cmp(Data a,Data b)&#123;return a.ti&lt;b.ti or (a.ti==b.ti and a.op&lt;b.op);&#125; ll ans[MAX_N];int w[MAX_N]; bool cmp2(Data a,Data b)&#123;return a.gg.FR&gt;b.gg.FR;&#125; void cdq(int l,int r) &#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; cdq(l,mid);cdq(mid+1,r); sort(p+l,p+mid+1,cmp2);sort(p+mid+1,p+r+1,cmp2); int p1=l; for(int p2=mid+1;p2&lt;=r;p2++) if(p[p2].op==1) &#123; while(p1&lt;=mid and p[p1].gg.FR&gt;p[p2].gg.FR) &#123; if(p[p1].op==0) bit.add(p[p1].gg.SE,p[p1].w); p1++; &#125; int x=p[p2].gg.SE;//printf("id=%d x=%d\n",p[p2].id,x); ans[p[p2].id]+=bit.ask(dfn[x]+siz[x]-1)-bit.ask(dfn[x]-1); //iprintf("ans=%lld\n",ans[p[p2].id]); &#125; for(int i=l;i&lt;p1;i++) if(p[i].op==0) bit.add(p[i].gg.SE,-p[i].w); &#125; void main() &#123; int n=qread(),m=qread(),q=qread(); for(int i=1;i&lt;=n;i++) w[i]=qread(); for(int i=1;i&lt;n;i++)&#123;int x=qread(),y=qread();son[x].PB(y);son[y].PB(x);&#125; dfs(1,0); int cnt=0;for(int i=1;i&lt;=n;i++) p[++cnt]=(Data)&#123;0,0,MP(dep[i],dfn[i]),w[i],0&#125;; for(int i=1;i&lt;=m;i++) &#123; int t=qread(),x=qread(),ww=qread(); p[++cnt]=(Data)&#123;0,t+1,MP(dep[x]+t,dfn[x]),ww,0&#125;; &#125; for(int i=1;i&lt;=q;i++) &#123; int t=qread(),x=qread(); p[++cnt]=(Data)&#123;1,t,MP(dep[x]+t-2,x),0,i&#125;; &#125; sort(p+1,p+cnt+1,cmp);cdq(1,cnt); for(int i=1;i&lt;=q;i++) write2(ans[i]); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; D1T4 及 UR12密码锁听说jz做过密码锁，那么不妨先说这题 如果m=0，注意到拓扑序是唯一的一个序列，强连通数=边数+1，统计每条边的贡献，$1+\sum_{i=1}^{n-1} C_n^i \frac{1}{2^{i(n-i)}}$ 否则，注意到对于某个方案，若有k条关键边一个左一个右，则应乘上 $\prod 2P_t$ ，即抵消原本概率 然后因为m很小，考虑如何让指数只和m有关，注意到对于某个弱连通块，若有m条边则最多有m+1个点 那么把所有关键边加入，形成若干个弱连通，对每个连通块枚举集合S表示放在左边的点，然后枚举边直接计算对应贡献，将每个弱连通的答案按照集合大小暴力卷积起来，乘上系数 $\frac{1}{2^{i(n-i)}}$ 即可，时间复杂度不难分析为 $O(2^mm)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int MAX_N=40,MAX_M=20;ll P[MAX_N][MAX_N];int blg[MAX_N];vc&lt;int&gt; pt;int pos[MAX_N];void dfs(int x,int id)&#123; blg[x]=id;pt.PB(x); for(int y=1;y&lt;MAX_N;y++) if(P[x][y]&gt;=0 and blg[y]==0) dfs(y,id);&#125;ll f[MAX_N],ans[MAX_N],tmp[MAX_N];vc&lt;pr&gt; edge;ll bin[MAX_N],siz[1&lt;&lt;MAX_M];void main()&#123; bin[0]=1;for(int i=1;i&lt;MAX_N;i++) bin[i]=bin[i-1]*2%MOD; for(int i=1;i&lt;bin[MAX_M];i++) siz[i]=siz[i&gt;&gt;1]+(i&amp;1); int n=qread(),m=qread(); memset(P,-1,sizeof P);ll inv1=qpower(10000,MOD-2); for(int i=1;i&lt;=m;i++) &#123;int x=qread(),y=qread(),c=qread();P[x][y]=inv1*c%MOD;P[y][x]=inv1*(10000-c)%MOD;&#125; ans[0]=1; for(int rt=1,cnt=0;rt&lt;=n;rt++) if(!blg[rt]) &#123; pt.clear();dfs(rt,++cnt); int k=pt.size();for(int t=0;t&lt;k;t++) pos[pt[t]]=t; edge.clear();for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(blg[i]==cnt and P[i][j]&gt;=0) edge.PB(MP(i,j)); memset(f,0,sizeof f); for(int S=0;S&lt;bin[k];S++) &#123; ll now=1; for(int t=0;t&lt;(int)edge.size();t++) &#123; int x=edge[t].FR,y=edge[t].SE;bool a=(S&amp;bin[pos[x]])&gt;0,b=(S&amp;bin[pos[y]])&gt;0; if(a and b) continue;if(!a and !b) continue; if(!a) swap(x,y);now=now*P[x][y]*2%MOD; &#125; add(f[siz[S]],now); &#125; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;MAX_N;i++) for(int j=0;j&lt;MAX_N;j++) if(i+j&lt;MAX_N) add(tmp[i+j],ans[i]*f[j]%MOD); memcpy(ans,tmp,sizeof tmp); &#125; ll ANS=1; for(int i=1;i&lt;n;i++) add(ANS, ans[i]*qpower(qpower(bin[i],MOD-2),n-i)%MOD ); ANS=ANS*qpower(10000,n*(n-1))%MOD; ANS=(ANS+MOD)%MOD; write(ANS);&#125; 然后来看这个d，主要区别在于给出的是方向固定的路径 如果ki=2，因为路径没有公共点，则考虑两个都没选到或都选到的情况，则情况/2，概率乘2，所以做法和m=0是一样的 如果 $n \leq 3e3$ ，因为合法方案中每条路经最多有一条边跨过两边；而且因为路径不相交，所以非常好处理 对于每条链（单点也算）构造多项式 $G(x)=x^0+2x^1+2x^2……x^{k_t}$ 所有多项式的卷积A(i),$ans=\sum A(i) (\frac{1}{2})^{i(n-i)}$ 正确性不难理解，即当路径跨过中间这条边的时候，中间这条边不再亲自定向，抵消掉一个1/2 分治ntt优化即可（代码看起来很像板子），复杂度为 $O(nlog^2n)$ yww有log的做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=998244353; void add(ll &amp;x,ll y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=4e5+10; struct NTT &#123; int R[MAX_N]; void preR(int ln) &#123; for(int i=1;i&lt;ln;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;((int)log2(ln)-1)); &#125; ll w[2][MAX_N]; void prew() &#123; int ln=262144; ll now0=qpower(3,(MOD-1)/ln),now1=inv(now0); w[0][0]=w[1][0]=1;for(int i=1;i&lt;=ln;i++) w[0][i]=w[0][i-1]*now0%MOD,w[1][i]=w[1][i-1]*now1%MOD; &#125; void DFT(ll A[],int n,int f) &#123; for(int i=1;i&lt;n;i++) if(i&lt;R[i]) swap(A[i],A[R[i]]); for(int ln=1;ln&lt;=n/2;ln*=2) for(int st=0;st&lt;n;st+=2*ln) for(int k=0;k&lt;ln;k++) &#123; ll x=A[st+k],y=w[f][k*(262144/ln/2)]*A[st+ln+k]%MOD; A[st+k]=(x+y)%MOD;A[st+ln+k]=(x-y)%MOD; &#125; &#125; &#125;ntt; vc&lt;ll&gt; mm[30][MAX_N];ll A[MAX_N],B[MAX_N]; int siz[MAX_N]; void solve(int dep,int l,int r) &#123; if(l==r) &#123; mm[dep][l].PB(1);for(int t=1;t&lt;siz[l];t++)mm[dep][l].PB(2);mm[dep][l].PB(1); return; &#125; int mid=(l+r)&gt;&gt;1; solve(dep+1,l,mid);solve(dep+1,mid+1,r); int n=mm[dep+1][l].size();for(int t=0;t&lt;n;t++) A[t]=mm[dep+1][l][t]; int m=mm[dep+1][mid+1].size();for(int t=0;t&lt;m;t++) B[t]=mm[dep+1][mid+1][t]; int ln=1;while(ln&lt;=n+m-1) ln*=2;ntt.preR(ln);if(ln&gt;262144) puts("error"); ntt.DFT(A,ln,0);ntt.DFT(B,ln,0); for(int i=0;i&lt;ln;i++) A[i]=A[i]*B[i]%MOD;ntt.DFT(A,ln,1); for(int t=0;t&lt;n+m-1;t++) mm[dep][l].PB(A[t]*inv(ln)%MOD); for(int i=0;i&lt;ln;i++) A[i]=B[i]=0; &#125; void main() &#123; int n=qread(),m=qread(); int sum=0; for(int i=1;i&lt;=m;i++) &#123;siz[i]=qread();int kk=siz[i];sum+=kk;while(kk--) qread();&#125; for(int i=m+1;i&lt;=m+n-sum;i++) siz[i]=1; ntt.prew();solve(0,1,m+n-sum); ll ANS=1;for(int i=1;i&lt;n;i++) add(ANS, mm[0][1][i]*qpower(inv(2),ll(n-i)*i%(MOD-1))%MOD ); write((ANS+MOD)%MOD); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; D2T1直接莫比乌斯反演+二分+dij 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=998244353; void add(ll &amp;x,ll y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;=-MOD) x+=MOD;&#125; ll qpower(ll x,int e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; ll inv(ll x)&#123;return qpower(x,MOD-2);&#125; const int MAX_N=1e5+10; bool mark[MAX_N];int prn=0,pp[MAX_N];int mu[MAX_N];ll sum[MAX_N]; void pre() &#123; mu[1]=1; for(int i=2;i&lt;MAX_N;i++) &#123; if(!mark[i]) pp[++prn]=i,mu[i]=-1; for(int j=1;j&lt;=prn and (ll)i*pp[j]&lt;MAX_N;j++) &#123; int t=i*pp[j];mark[t]=1; if(i%pp[j]==0) break;mu[t]=-mu[i]; &#125; &#125; for(int i=1;i&lt;MAX_N;i++) sum[i]=sum[i-1]+mu[i]*i; &#125; ll S(ll n)&#123;return ll(1+n)*n/2;&#125; ll solve(int n,int m) &#123; if(n&gt;m) swap(n,m); ll ans=0; for(int l=1,r;l&lt;=n;l=r+1) r=min(n/(n/l),m/(m/l)),ans+=(S(n/l)*(m/l)+S(m/l)*(n/l))*(sum[r]-sum[l-1]); return ans; &#125; int n,m;ll T; vc&lt;pr&gt; to[MAX_N]; ll dis[MAX_N]; priority_queue&lt; pr,vc&lt;pr&gt;,greater&lt;pr&gt; &gt; q; ll check(ll mid) &#123; memset(dis,0x3f,sizeof dis); q.push(MP(0,1));dis[1]=0; while(q.size()) &#123; int x=q.top().SE;ll dd=q.top().FR;q.pop(); if(dd!=dis[x]) continue; for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t].SE;ll c=to[x][t].FR;c=max(c-mid,0ll); if(dis[y]&gt;dd+c) dis[y]=dd+c,q.push(MP(dis[y],y)); &#125; &#125; return dis[n]; &#125; int a[MAX_N]; void main() &#123; pre(); n=qread(),m=qread();T=qread(); for(int i=1;i&lt;=n;i++) a[i]=qread(); for(int i=1;i&lt;=m;i++) &#123; int x=qread(),y=qread();ll c=solve(a[x],a[y]);//printf("c=%lld\n",c); to[x].PB(MP(c,y));to[y].PB(MP(c,x)); &#125; ll l=0,r=LLINF*2,ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check(mid)&lt;=T) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%lld %lld",ans,check(ans)); &#125;&#125;;signed main()&#123;// freopen("z.txt","r",stdin); srand(time(0)); mine::main();&#125; D2T2此题我使用的是二项式定理，个人感觉难度海星，但rose说是送分题…… $(A+B)^k=\sum_{i=0}^k C_k^i A^i B^{k-i}$ 考虑树形dp，我们不能多开一维表示边的数量，注意到K较小，考虑存储K=k下的所有答案（$A^k f(A)$）； 那么当两个状态合并时，边求和，方案求积，考虑乘法分配率，$(A+B)^k f(A+B)=\sum_{i=0}^k C_k^i (\sum A^if(A)) (\sum B^{k-i} f(B))$ 复杂度为 $O(nk^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041vc&lt;int&gt; son[MAX_N];ll f[MAX_N][12][2],n,m,K;void dp(int x,int fa)&#123; f[x][0][0]=f[x][0][1]=1; for(int t=0;t&lt;(int)son[x].size();t++) &#123; int y=son[x][t];if(y==fa) continue;dp(y,x); for(int k=K;k&gt;=0;k--) &#123; ll tmp=0; for(int i=0;i&lt;=k;i++) add(tmp, f[x][i][0]*(f[y][k-i][0]+f[y][k-i][1])%MOD*C(k,i)%MOD ); f[x][k][0]=tmp; &#125; for(int k=K;k&gt;=0;k--)//两边都是1，则+1 &#123; ll tmp=0; for(int i=0;i&lt;=k;i++) add(tmp, f[y][i][1]*C(k,i)%MOD ); f[y][k][1]=tmp; &#125; for(int k=K;k&gt;=0;k--) &#123; ll tmp=0; for(int i=0;i&lt;=k;i++) add(tmp, f[x][i][1]*(f[y][k-i][0]+f[y][k-i][1])%MOD*C(k,i)%MOD ); f[x][k][1]=tmp; &#125; &#125;&#125;void main()&#123; fac[0]=1;for(int i=1;i&lt;MAX_N;i++) fac[i]=fac[i-1]*i%MOD; inv2[1]=1;for(int i=2;i&lt;MAX_N;i++) inv2[i]=ll(MOD-MOD/i)*inv2[MOD%i]%MOD; facinv[0]=1;for(int i=1;i&lt;MAX_N;i++) facinv[i]=facinv[i-1]*inv2[i]%MOD; n=qread(),m=qread(),K=qread(); for(int i=1;i&lt;=m;i++)&#123;int x=qread(),y=qread();son[x].PB(y);son[y].PB(x); &#125; dp(1,0); ll ans=(f[1][K][0]+f[1][K][1]); write((ans%MOD+MOD)%MOD);&#125; D2T3首先你需要知道，随机序列的笛卡尔树深度为log（每次期望为分成两半），则上升序列长度为log；笛卡尔树的子树大小也是log级别的 因为只有从1开始上升序列为有效左端点，以n结尾下降序列为有效右端点 如果能支持动态查询出序列，分别考虑左还是右为min，双指针即可 不妨继续考虑笛卡尔树，询问的时候直接跳，修改的话可以直接重构子树，然后暴力向上rotate 时间复杂度为$O(nlogn)$ 非常好写，但有些东西想错了，自闭了一下午没碰过代码核心部分（各种判断来debug找位置……） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=5e5+10; int n; struct Nod &#123; int xx,h; int fa,son[2]; void clear()&#123;fa=son[0]=son[1]=0;&#125; Nod()&#123;clear();&#125; &#125;p[MAX_N]; #define lc p[x].son[0] #define rc p[x].son[1] #define son(x) ((p[p[x].fa].son[1])==(x)) int build(int l,int r) &#123; for(int i=l;i&lt;=r;i++) p[i].clear(); for(int i=l+1;i&lt;=r;i++) &#123; int lst=i-1; while(p[lst].fa and p[lst].h&lt;=p[i].h) lst=p[lst].fa; if(p[lst].h&lt;=p[i].h) p[lst].fa=i,p[i].son[0]=lst; else &#123; int tson=p[lst].son[1]; if(tson) p[tson].fa=i,p[i].son[0]=tson; p[lst].son[1]=i,p[i].fa=lst; &#125; &#125; int x=l;while(p[x].fa) x=p[x].fa; return x; &#125; int pre(int x)&#123;int y=x;while(y and p[y].xx&gt;=p[x].xx) y=p[y].fa;return y;&#125; int nxt(int x)&#123;int y=x;while(y and p[y].xx&lt;=p[x].xx) y=p[y].fa;return y;&#125; vc&lt;int&gt; a,b; void solve(int l,int r) &#123; a.clear();b.clear();int x; x=l;while(x and x&lt;=r) a.PB(x),x=nxt(x);int o1=a.size(); x=r;while(x and x&gt;=l) b.PB(x),x=pre(x);int o2=b.size(); ll ans=0; for(int i=0,j=0;i&lt;o1;i++) &#123; while(j&lt;o2 and p[b[j]].h&lt;p[a[i]].h) j++; if(j&lt;o2 and p[a[i]].xx&lt;p[b[j]].xx) ans=max(ans, ll(p[b[j]].xx-p[a[i]].xx)*p[a[i]].h ); &#125; for(int i=0,j=0;j&lt;o2;j++) &#123; while(i&lt;o1 and p[a[i]].h&lt;p[b[j]].h) i++; if(i&lt;o1 and p[a[i]].xx&lt;p[b[j]].xx) ans=max(ans, ll(p[b[j]].xx-p[a[i]].xx)*p[b[j]].h ); &#125; write2(ans); &#125; void main() &#123; n=qread();int q=qread(); for(int i=1;i&lt;=n;i++) p[i].xx=qread(); for(int i=1;i&lt;=n;i++) p[i].h=qread(); build(1,n); while(q--) &#123; int op=qread(),l=qread(),r=qread(); if(op==1) solve(l,r); else if(op==2) &#123; int x=l;p[x].h=r; int now=son(x),fa=p[x].fa,tmp=x; x=p[tmp].son[0];while(x)&#123;if(lc)x=lc;else break;&#125;int fl=x==0?tmp:x; x=p[tmp].son[1];while(x)&#123;if(rc)x=rc;else break;&#125;int fr=x==0?tmp:x; int rt=build(fl,fr); p[rt].fa=fa;p[fa].son[now]=rt; x=rt; while(p[x].fa and p[p[x].fa].h&lt;p[x].h) &#123; int fa=p[x].fa,ff=p[fa].fa;if(ff) p[ff].son[son(fa)]=x; int w=son(x),tson=p[x].son[w^1];p[fa].son[w]=tson;p[x].son[w^1]=fa; p[x].fa=ff;p[fa].fa=x;if(tson) p[tson].fa=fa; &#125; &#125; else p[l].xx=r; &#125; &#125;&#125;;signed main()&#123; freopen("a.in","r",stdin); //freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125; D2T4走路题似乎又没做出来……其实修改这东西是假的，直接在线做，dij建出最短路树 注意到没有负权边，那么枚举环上两点（无二元环），如果这两点的fm相同，那么答案会在第一个交点那里取到 使用没有堆优化的dij，时间复杂度为 $O(qn^2)$ 不过由于某些原因，code的写法是，求出每个点【根节点下亲儿子】不同的前两个dis来判 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=4e2+10; bool ok[MAX_N];int n,mp[MAX_N][MAX_N]; pr f[MAX_N][2];bool out[MAX_N][2]; void insert(int x,int num,int fm) &#123; if(fm==f[x][0].SE or fm==f[x][1].SE) &#123; if(fm==f[x][0].SE) f[x][0]=min(f[x][0],MP(num,fm)); else if(fm==f[x][1].SE) f[x][1]=min(f[x][1],MP(num,fm)); if(f[x][0].FR&gt;f[x][1].FR) swap(f[x][0],f[x][1]); return; &#125; if(f[x][1].FR&lt;INF) &#123; if(num&lt;=f[x][0].FR) f[x][1]=f[x][0],f[x][0]=MP(num,fm); else if(num&lt;f[x][1].FR) f[x][1]=MP(num,fm); return; &#125; if(f[x][0].FR&lt;INF) f[x][1]=MP(num,fm); else f[x][0]=MP(num,fm); if(f[x][0].FR&gt;f[x][1].FR) swap(f[x][0],f[x][1]); &#125; void solve(int gg) &#123; memset(f,0x3f,sizeof f);memset(out,0,sizeof out);f[gg][0].FR=0;ok[gg]=0; while(1) &#123; int x=-1,t=0; for(int i=1;i&lt;=n;i++) for(int k=0;k&lt;=1;k++) if(!out[i][k] and (x&lt;0 or f[i][k].FR&lt;f[x][t].FR)) x=i,t=k; if(x&lt;0) break;out[x][t]=1; for(int y=1;y&lt;=n;y++) if(mp[x][y]&lt;INF and !out[y][1] and ok[y]) insert(y,f[x][t].FR+mp[x][y],x==gg?y:f[x][t].SE); &#125; int ans=INF; for(int i=1;i&lt;=n;i++) if(mp[gg][i]&lt;INF) &#123; if(f[i][0].SE!=i) chmin(ans,mp[gg][i]+f[i][0].FR); else chmin(ans,mp[gg][i]+f[i][1].FR); &#125; if(ans==INF) puts("-1"); else write2(ans); ok[gg]=1; &#125; void main() &#123; n=qread(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123;mp[i][j]=qread();if(mp[i][j]&lt;0)mp[i][j]=INF;&#125; for(int i=1;i&lt;=n;i++) ok[i]=1; int q=qread(); while(q--) &#123; int op=qread(),x=qread(); if(op==0) solve(x); else ok[x]^=1; &#125; &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; D3T1竞赛图的拓扑序唯一，所以答案为第一个强连通内的点 主席树优化建图即可 （官方的空间为512MB，栈为16MB），然后我需要800MB（3次大常数），256的栈（主要tarjan）…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e5+10; const int MAX_M=MAX_N*120; int n; struct Data&#123;int s[4],id;&#125;a[MAX_N]; bool cmp1(Data x,Data y)&#123;return x.s[1]&lt;y.s[1];&#125; bool cmp2(Data x,Data y)&#123;return x.s[2]&lt;y.s[2];&#125; bool cmp3(Data x,Data y)&#123;return x.s[3]&lt;y.s[3];&#125; int tmp[MAX_M]; void lsh(int op) &#123; for(int i=1;i&lt;=n;i++) tmp[i]=a[i].s[op];sort(tmp+1,tmp+n+1); for(int i=1;i&lt;=n;i++) a[i].s[op]=lower_bound(tmp+1,tmp+n+1,a[i].s[op])-tmp; &#125; vc&lt;int&gt; to[MAX_M];int id; int lc[MAX_M],rc[MAX_M]; #define mid (((l)+(r))&gt;&gt;1) int newnode(int x)&#123;int tmp=++id;lc[tmp]=lc[x];rc[tmp]=rc[x];return tmp; &#125; void add(int &amp;x,int l,int r,int pos,int pt) &#123; if(!x) x=newnode(0); if(l==r) to[x].PB(pt); else if(pos&lt;=mid) add( lc[x],l,mid,pos,pt ); else add( rc[x],mid+1,r,pos,pt ); &#125; void merg(int &amp;x,int y) &#123; if(!y) return; if(!x) &#123;x=y;return;&#125; x=newnode(x); merg(lc[x],lc[y]); merg(rc[x],rc[y]); &#125; void ins(int x,int l,int r,int fl,int fr,int pt) &#123; if(!x) return; if(l==fl and r==fr) &#123;to[pt].PB(x);return;&#125; if(fr&lt;=mid) ins(lc[x],l,mid,fl,fr,pt); else if(fl&gt;mid) ins(rc[x],mid+1,r,fl,fr,pt); else ins(lc[x],l,mid,fl,mid,pt),ins(rc[x],mid+1,r,mid+1,fr,pt); &#125; int rt[4][MAX_N]; void build(int op) &#123; for(int i=1;i&lt;=n;i++) &#123; if(a[i].s[op]&gt;1) ins(rt[op][i-1],1,n,1,a[i].s[op]-1,a[i].id); add(rt[op][i],1,n,a[i].s[op],a[i].id); merg(rt[op][i],rt[op][i-1]); &#125; &#125; stack&lt;int&gt; sta; int dfn[MAX_M],low[MAX_M],dfnid=0,cnt=0;bool insta[MAX_M]; void tarjan(int x) &#123; dfn[x]=low[x]=++dfnid; insta[x]=1;sta.push(x); for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t]; if(!dfn[y]) tarjan(y),chmin(low[x],low[y]); else if(insta[y]) chmin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; cnt++; while(sta.size()) &#123; int t=sta.top();sta.pop(); tmp[t]=cnt;insta[t]=0; if(t==x) break; &#125; &#125; &#125; void main() &#123; n=qread();for(int i=1;i&lt;=n;i++) a[i].s[1]=qread(),a[i].s[2]=qread(),a[i].s[3]=qread(),a[i].id=i; lsh(1);lsh(2);lsh(3);id=MAX_N; sort(a+1,a+n+1,cmp1);build(2); sort(a+1,a+n+1,cmp2);build(3); sort(a+1,a+n+1,cmp3);build(1); for(int i=MAX_N+1;i&lt;=id;i++) &#123; if(lc[i]) to[i].PB(lc[i]); if(rc[i]) to[i].PB(rc[i]); &#125; memset(tmp,0,sizeof tmp);//blg for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);memset(dfn,0,sizeof dfn);//indeg for(int x=1;x&lt;=id;x++) for(int t=0;t&lt;(int)to[x].size();t++) &#123;int y=to[x][t];if(tmp[x]!=tmp[y] and tmp[x] and tmp[y]) dfn[tmp[y]]++;&#125; for(int i=1;i&lt;=n;i++) if(dfn[tmp[i]]==0) printf("%d\n",i); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; D3T2此题看懂题意是关键（雾 给出一棵按“堆式存储编号”的带权二叉树，边权值是一个关于点编号的二次函数，其值非负；操作为选取一个结点，删去它及其子树，删去后，找到一个点使得所有点到它的距离之和最小，并输出距离和。 因为是一棵二叉树，深度为log，修改时维护siz；询问从根开始，按照 $2siz_y&gt;siz_1$ 判断即可；因为询问有限，动态开点就好了 D3T3网络流得出路径数， 然后二分+sa；如果按顺序枚举每个答案搞下界是线性的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; //#define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=100+10,MAX_M=2e4+10; const int MAX_K=2e5+10; struct MM &#123; int hou[MAX_N];pr edge[MAX_M];int n,m; struct Edge&#123;int y,g,c;&#125;e[MAX_M*2]; int ln;int oth(int x)&#123;return x&amp;1?x+1:x-1;&#125; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],0&#125;;hou[y]=ln; &#125; int st,ed; int h[MAX_N]; queue&lt;int&gt; q; bool bfs() &#123; memset(h,0,sizeof h); q.push(st);h[st]=1; while(q.size()) &#123; int x=q.front();q.pop(); for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(!h[y] and e[k].c) h[y]=h[x]+1,q.push(y); &#125; &#125; return h[ed]&gt;0; &#125; int dfs(int x,int flow) &#123; if(x==ed) return flow; int tmp=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c) &#123; int out=dfs(y,min(e[k].c,flow-tmp)); tmp+=out;e[k].c-=out;e[oth(k)].c+=out; if(tmp==flow) break; &#125; &#125; if(tmp==0) h[x]=0; return tmp; &#125; int solve() &#123; ln=0;memset(hou,0,sizeof hou);for(int i=1;i&lt;=m;i++) ins(edge[i].FR,edge[i].SE,1); st=1;ed=n;int ans=0;while(bfs()) ans+=dfs(st,INF);return ans; &#125; &#125;M; namespace SA &#123; char str[MAX_K];int n; int sa[MAX_K],rk[MAX_K],ct[MAX_K]; int wr[MAX_K*2],tmp[MAX_K]; void getsa() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[rk[i]=str[i]]++; for(int i=1;i&lt;MAX_K;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;n) &#123; int tot=0;for(int i=1;i&lt;=n;i++) if(i+ln&gt;n) tmp[++tot]=i; for(int i=1;i&lt;=n;i++) if(sa[i]-ln&gt;=1) tmp[++tot]=sa[i]-ln; memset(ct,0,sizeof ct);memset(wr,0,sizeof wr); for(int i=1;i&lt;=n;i++) ct[wr[tmp[i]]=rk[tmp[i]]]++; for(int i=1;i&lt;MAX_K;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[wr[tmp[i]]]--]=tmp[i]; int cnt=1;rk[sa[1]]=1; for(int i=2;i&lt;=n;i++) &#123; if(wr[sa[i-1]]!=wr[sa[i]] or wr[sa[i-1]+ln]!=wr[sa[i]+ln]) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; int hei[MAX_K]; void gethei() &#123; int lst=0; for(int i=1;i&lt;=n;i++) &#123; if(rk[i]==1) continue; int j=sa[rk[i]-1];if(lst) lst--; while(max(i,j)+lst&lt;=n and str[i+lst]==str[j+lst]) lst++; hei[rk[i]]=lst; &#125; &#125; void pre() &#123; n=strlen(str+1); getsa();gethei(); &#125; &#125;; pr a[MAX_K];int kk;bool vv[MAX_K]; int ggg; bool check(int T) &#123; using namespace SA; int cnt=0;memset(vv,0,sizeof vv); for(int i=1;i&lt;=kk;i++) &#123; if(a[i].SE-a[i].FR+1&lt;T) cnt++; else vv[rk[a[i].FR]]=1; &#125; int now=vv[1]; for(int i=2;i&lt;=n;i++) &#123; if(hei[i]&lt;T) &#123;if(now) cnt++,now=0;&#125; now+=vv[i]; &#125; if(now) cnt++; return ggg&gt;=cnt; &#125; void main() &#123; M.n=qread(),M.m=qread();for(int i=1;i&lt;=M.m;i++) M.edge[i].FR=qread(),M.edge[i].SE=qread(); ggg=M.solve(); using namespace SA; scanf("%s",str+1);pre(); kk=qread();for(int i=1;i&lt;=kk;i++) a[i].FR=qread(),a[i].SE=qread(); if(kk&lt;=ggg)&#123;puts("inf");return;&#125; int l=0,r=n,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,l=mid+1; else r=mid-1; &#125; write(ans); &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; D3T4需要快速切掉前面几题才会有空玩这题…… 首先这个建图似乎挺好玩的，然后就是求直径 求整数划分似乎是用五边形数，以后补以后补……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>GDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】动态树]]></title>
    <url>%2Fposts%2Fbebe.html</url>
    <content type="text"><![CDATA[Source and JudgeLuogu3690 Problem【Description】给定n个点以及每个点的权值，要你处理接下来的m个操作。操作有4种。操作从0到3编号。点从1到n编号。0：后接两个整数(x，y)，代表询问从x到y的路径上的点的权值的xor和。保证x到y是连通的。1：后接两个整数(x，y)，代表连接x到y，若x到y已经连通则无需连接。2：后接两个整数(x，y)，代表删除边(x，y)，不保证边(x，y)存在。3：后接两个整数(x，y)，代表将点x上的权值变成y。【Input】第1行两个整数，分别为n和m，代表点数和操作数。第2行到第n+1行，每行一个整数，整数在［1，10^9］内，代表每个点的权值。第n+2行到第n+m+1行，每行三个整数，分别代表操作类型和操作所需的量。【Output】对于每一个0号操作，你须输出x到y的路径上点权的xor和。【Limited conditions】单词数n&lt;=60所有字符串长度、m&lt;=100【Sample input】3 31231 1 20 1 20 1 1【Sample output】31【Sample explanation】无 Record1h Analysis请先思考后再展开 省选前模板练手 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(ll &amp;x,ll y) &#123;if(x&lt;y) x=y;&#125;void chmin(ll &amp;x,ll y) &#123;if(x&gt;y) x=y;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=510000;//*******************全局定义*******************struct Lct&#123; int son[2],f; int d,c;//值、xor和 bool fz;&#125;p[MAXN];//*******************实现*******************void pushup(int x)&#123; int lc=p[x].son[0],rc=p[x].son[1]; p[x].c=p[x].d; if(lc&gt;0) p[x].c^=p[lc].c; if(rc&gt;0) p[x].c^=p[rc].c;&#125;void pushdown(int x)&#123; if(!p[x].fz) return; p[x].fz=0;//debug swap(p[x].son[0],p[x].son[1]); int lc=p[x].son[0],rc=p[x].son[1]; p[lc].fz^=1;p[rc].fz^=1;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(ff&gt;0) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; pushup(f); pushup(x);&#125;bool isrt(int x,int rt)&#123; return (p[x].f==rt)or(p[p[x].f].son[0]!=x and p[p[x].f].son[1]!=x);&#125;int lst[MAXN];void splay(int x,int rt)&#123; int t=x,s=0; while(!isrt(t,rt)) lst[++s]=t,t=p[t].f; lst[++s]=t;while(s&gt;0) pushdown(lst[s--]); while(!isrt(x,rt)) &#123; int f=p[x].f,ff=p[f].f; if(isrt(f,rt)) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); return; &#125; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125;&#125;void access(int x)&#123; int y=0; while(x&gt;0) &#123; splay(x,0); p[x].son[1]=y; pushup(x); y=x;x=p[x].f; &#125;&#125;void makeroot(int x)&#123; access(x); splay(x,0); p[x].fz^=1;&#125;void splity(int x,int y)&#123; makeroot(x); access(y); splay(y,0);&#125;int findrt(int x)&#123; access(x); splay(x,0); while(1) &#123; pushdown(x);//debug if(!p[x].son[0]) break; x=p[x].son[0]; &#125; splay(x,0);//速度 return x;&#125;void link(int x,int y)&#123; makeroot(y); p[y].f=x;&#125;void cut(int x,int y)&#123; splity(x,y); if(p[y].son[0]!=x or (p[y].son[0]==x and p[x].son[1]&gt;0)) return; p[p[y].son[0]].f=0;//debug p[y].son[0]=0; pushup(y);//debug&#125;//*******************主函数*******************int d[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i].d); p[i].c=p[i].d; p[i].son[0]=p[i].son[1]=p[i].f=0; p[i].fz=0; &#125; while(m--) &#123; int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(op==0) &#123; splity(x,y); printf("%d\n",p[y].c); &#125; if(op==1) &#123; if(findrt(x)!=findrt(y)) link(x,y); &#125; if(op==2) &#123; if(findrt(x)==findrt(y)) cut(x,y); &#125; if(op==3) &#123; splay(x,0); p[x].d=y; pushup(x); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JSOI2007】文本生成器]]></title>
    <url>%2Fposts%2Feec3.html</url>
    <content type="text"><![CDATA[Source and JudgeJSOI2007 文本生成器Bzoj1030Luogu4052 Problem【Description】给出一些单词和文本固定长度，求所有满足此长度的，包含至少一个单词的文本的数量，对10007取模。【Input】第一行两个数表示单词数量n和文本长度m。接下来每行一个字符串表示单词。【Output】答案。【Limited conditions】单词数n&lt;=60所有字符串长度、m&lt;=100【Sample input】2 2AB【Sample output】100【Sample explanation】无 Record3h Analysis请先思考后再展开 最先，也是最重要的一点：把答案容斥，转化为更容易计算的，不包含任何单词的文本数量，然后用总量26^m-数量即是答案。而这种包含与否的关系，很容易联想到多串匹配，那当然少不了AC自动机。接下来呢？ 我们所要求的，就是跳m次，没有跳到任何一个【单词结尾节点】的方案数。但是考虑这样一种情况：只有单词a和bbabbb，m=3，然后我们跳到第三层的a，然后以为没有经过任何单词，就累计了答案。然鹅，不难发现其实我们还是包含了单词a。所以必须确保其任何后缀都不是单词的结尾。网上大部分人都是暴力跳fail去验证，然鹅其实可以在计算fail的时候，顺便递推过来，能节省时间（注意要用与运算），因为此时的bfs，fail的深度一定比x小。 一种直观的想法就是直接dfs跳，然后套一个记忆化。。。那既然如此不如直接dp？反正是等效的吧 那我们就可以愉快地dp啦你可以想象一个长度为m的任意字符串在ac机上面跳来跳去所以我们可以在任何时刻任意追加字符然鹅这样空间消耗灰常大但是不难发现，对于一个不在ac机上面的点，其接下来的拓展性与自己无关（fail=0），所以是等价于根节点0的，所以为了方便和节省空间，可以把空节点也设为0.一开始连模板都打错了qwq Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=110;const int MOD=10007;//*******************全局定义*******************char s[MAXN];int Mod(int x) &#123;return (x%MOD+MOD)%MOD;&#125;//*******************实现*******************struct Trie&#123; int ch[26]; bool ed; int fail; void clear() &#123; memset(ch,0,sizeof(ch)); fail=ed=0; &#125;&#125;a[MAXN*60];int cnt=0;void add()&#123; scanf("%s",s+1); int ln=strlen(s+1); int now=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'A'; if(!a[now].ch[t]) a[now].ch[t]=++cnt,a[cnt].clear(); now=a[now].ch[t]; &#125; a[now].ed=1;&#125;queue&lt;int&gt; q;void getfail()&#123; q.push(0); while(!q.empty()) &#123; int x=q.front();q.pop(); for(int i=0;i&lt;26;i++) &#123; int son=a[x].ch[i]; if(!son) continue; if(x==0) a[son].fail=0;//debug 模板都打错了 else &#123; int p=a[x].fail; while(p&gt;0 and !a[p].ch[i]) p=a[p].fail; a[son].fail=a[p].ch[i]; a[son].ed|=a[a[son].fail].ed;//debug 与运算 &#125; q.push(son); &#125; &#125;&#125;int ans=0,m;int f[MAXN][MAXN*60];bool v[MAXN][MAXN*60];typedef pair&lt;int,int&gt; pp;queue&lt;pp&gt; q2;void solve()&#123; f[0][0]=v[0][0]=1; q2.push(pp(0,0)); while(!q2.empty()) &#123; int now=q2.front().first,sp=q2.front().second;q2.pop(); if(sp==m) &#123;ans=Mod(ans+f[sp][now]);continue;&#125; for(int i=0;i&lt;26;i++) &#123; int tmp=now; while(tmp&gt;0 and !a[tmp].ch[i]) tmp=a[tmp].fail; int son=a[tmp].ch[i]; if(!a[son].ed) &#123; f[sp+1][son]=Mod(f[sp+1][son]+f[sp][now]); if(!v[sp+1][son]) &#123; v[sp+1][son]=1; q2.push(pp(son,sp+1)); &#125; &#125; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d%d",&amp;n,&amp;m); a[0].clear(); while(n--) add(); getfail(); solve(); int fm=1;for(int i=1;i&lt;=m;i++) fm=Mod(fm*26); printf("%d",Mod(fm-ans));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AC自动机</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AHOI2005】【CQOI2014】病毒检测/通配符匹配]]></title>
    <url>%2Fposts%2F4a8c.html</url>
    <content type="text"><![CDATA[Source and JudgeAHOI2005 病毒检测Bzoj1966Luogu2536CQOI2014 通配符匹配Bzoj3507Luogu3167 Problem【Description】给出通配符字符串，其中 * 的意思是可以匹配上0个或任意多个字符，而 ? 的意思是匹配上任意一个字母，询问给出字符串是否能匹配。【Input】如题目描述【Output】如题目描述【Limited conditions】0&lt;N&lt;100通配符字符串的长度不超过100000询问字符串的长度不超过500通配符个数不超过10【Sample input 1】123**ASD*ASDASD*A?SD?*AS?D*SAD?A?D*?1ASDASDASDADSDASSDASDDDSADAASDAAAAS【Sample output 1】0【Sample input 2】1234567*a*5asdasdddasssdd【Sample output 2】2【Sample explanation】无 Record10h话说我的心路历程可真有意思：ac机=》Here=》贪心比它还长……虽然都没有打代码233 Analysis请先思考后再展开 这道题……栋老师跟Claris学，我跟栋老师学…… 前置知识：Hash 通配符就是本题最关键的部分对于星号，连长度都是任意的，是有很高自由度的，也是最高优先级的，所以要以其为分割点分成一个个段。对于问号，虽然说没有星号这么bt，好歹限制了长度，但其作用并非万能字符那么简单。 咱们先从一些显然的事实开始入手： 如果没有星号，直接匹配 对于第一个星号左边的，必须匹配；最后一个星号后面的部分同理 剩下的段，如果每一个都尽量地偏前面匹配，显然是最优的（或者说，否则不会更优）如果不计算匹配的话，以上过程最坏是O(q*星号数量*n)=1kw 然鹅要怎么匹配呢？如果可以常数级别那当然是极好的那验证相同性……当然要祭出hash不过可别忽略问号哦，所以按照问号拆分开来就好了因为通配符数量的保证，复杂度是常数级别的。 然后就没有然后了。。。。 Code1CQOI2014请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=110000;const int MXCNT=15;const ull base=13331;//*******************全局定义*******************ull bs[MAXN];char s[MAXN];int ln;int cnt,pos[MXCNT];int num[MXCNT],sum[MXCNT][MXCNT];//数量，每个小段数量ull ha[MXCNT][MXCNT];//每个小段hash值//*******************实现*******************bool cmp(char a,char b) &#123;return (a=='?' or b=='?')?1:(a==b);&#125;ull hb[MAXN];//Hashull gethash(int l,int r) &#123; return hb[r]-hb[l-1]*bs[r-l+1]; &#125;bool check(int k,int l)&#123; for(int i=0;i&lt;=num[k-1];i++) &#123; if(sum[k-1][i]==0) &#123;l++;continue;&#125; if(ha[k-1][i]!=gethash(l,l+sum[k-1][i]-1)) return false; l+=sum[k-1][i]+1;//注意+1，因为问号 &#125; return true;&#125;char s2[MAXN];bool solve()&#123; scanf("%s",s2+1);int ln2=strlen(s2+1); if(!cnt)//无星号 &#123; if(ln!=ln2) return false; for(int i=1;i&lt;=ln;i++) if(!cmp(s[i],s2[i])) return false; &#125; else &#123; for(int i=1;i&lt;pos[1];i++) if(!cmp(s[i],s2[i])) return false; for(int i=1;i&lt;=ln-pos[cnt];i++) if(!cmp(s[ln-i+1],s2[ln2-i+1])) return false; int l=pos[1],r=ln2-(ln-pos[cnt])+1;//对于s2 for(int i=l;i&lt;=r;i++) hb[i]=hb[i-1]*base+s2[i]; for(int k=2;k&lt;=cnt;k++) &#123; for(;l&lt;=r;l++) if(check(k,l)) break; l+=pos[k]-pos[k-1]-1; if(l&gt;r) return false; &#125; &#125; return true;&#125;//*******************主函数*******************int main()&#123; bs[0]=1;for(int i=1;i&lt;MAXN;i++) bs[i]=bs[i-1]*base; scanf("%s",s+1);ln=strlen(s+1); cnt=0; for(int i=1;i&lt;=ln;i++) if(s[i]=='*') pos[++cnt]=i; else if(s[i]=='?') ++num[cnt]; else sum[cnt][num[cnt]]++,ha[cnt][num[cnt]]=ha[cnt][num[cnt]]*base+s[i]; int q;scanf("%d",&amp;q); while(q--) solve()?puts("YES"):puts("NO");&#125; Code2AHOI2005请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100;const int MXCNT=2100;const ull base=13331;//*******************全局定义*******************ull bs[MAXN];char s[MAXN];int ln;int cnt,pos[MXCNT];int num[MXCNT],sum[MXCNT][MXCNT];//数量，每个小段数量ull ha[MXCNT][MXCNT];//每个小段hash值//*******************实现*******************bool cmp(char a,char b) &#123;return (a=='?' or b=='?')?1:(a==b);&#125;ull hb[MAXN];//前缀Hashull gethash(int l,int r) &#123; return hb[r]-hb[l-1]*bs[r-l+1]; &#125;bool check(int k,int l)&#123; for(int i=0;i&lt;=num[k-1];i++) &#123; if(sum[k-1][i]==0) &#123;l++;continue;&#125; if(ha[k-1][i]!=gethash(l,l+sum[k-1][i]-1)) return false; l+=sum[k-1][i]+1;//注意+1，因为问号 &#125; return true;&#125;char s2[MAXN];bool solve()&#123; scanf("%s",s2+1);int ln2=strlen(s2+1); if(!cnt)//无星号 &#123; if(ln!=ln2) return false; for(int i=1;i&lt;=ln;i++) if(!cmp(s[i],s2[i])) return false; &#125; else &#123; for(int i=1;i&lt;pos[1];i++) if(!cmp(s[i],s2[i])) return false; for(int i=1;i&lt;=ln-pos[cnt];i++) if(!cmp(s[ln-i+1],s2[ln2-i+1])) return false; int l=pos[1],r=ln2-(ln-pos[cnt])+1;//对于s2 for(int i=l;i&lt;=r;i++) hb[i]=hb[i-1]*base+s2[i]; for(int k=2;k&lt;=cnt;k++) &#123; for(;l&lt;=r;l++) if(check(k,l)) break; l+=pos[k]-pos[k-1]-1; if(l&gt;r) return false; &#125; &#125; return true;&#125;//*******************主函数*******************int main()&#123; bs[0]=1;for(int i=1;i&lt;MAXN;i++) bs[i]=bs[i-1]*base; scanf("%s",s+1);ln=strlen(s+1); cnt=0; for(int i=1;i&lt;=ln;i++) if(s[i]=='*') pos[++cnt]=i; else if(s[i]=='?') ++num[cnt]; else sum[cnt][num[cnt]]++,ha[cnt][num[cnt]]=ha[cnt][num[cnt]]*base+s[i]; int q;scanf("%d",&amp;q); int ans=0; while(q--) ans+=!solve(); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2013】【Bzoj3325】【Luogu3279】密码]]></title>
    <url>%2Fposts%2F4b95.html</url>
    <content type="text"><![CDATA[Source and JudgeSCOI2013Bzoj3325Luogu3279 Problem【Description】已知一个字符串的：1. 长度为N。2. 仅含小写字母。3. 以每一个字符为中心的最长回文串长度。4. 以每两个相邻字符的间隙为中心的最长回文串长度。输出满足条件的字符串中字典序最小的。【Input】输入由三行组成。第一行仅含一个整数N，表示长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。【Output】输出答案，保证有解【Limited conditions】对于20% 的数据，1 &lt;= n &lt;= 100。另有30% 的数据，1 &lt;= n &lt;= 1000。最后50% 的数据，1 &lt;= n &lt;= 10^5。【Sample input 1】31 1 10 0【Sample output 1】abc【Sample input 2】31 3 10 0【Sample output 2】aba【Sample input 3】31 3 12 2【Sample output 3】aaa【Sample explanation】无 Record2h Analysis请先思考后再展开 一开始想贪心乱搞，然后显然是不可靠の玄学的怎样稳一点呢？相等性和互斥性，而且不是二分图，那不就是并查集了嘛！但是我们并不能单单处理相同的，然后去合并，也不能像某些二分图的时候那样拆成两个对立点，把所有对立的合并起来，因为字母不只2个。有种灰常妙的办法：建边！把与该点所在集合存在互斥关系的集合连上边，然后分配的时候，因为要求字典序最小，则必须选择一个【没有被在前面的，与当前互斥】的字母。注意一定要从整个集合来看，网上有人直接从当前点出发，显然是不正确的，虽然说数据比较水这样，我们就有50分辣！激动吗？（雾 首先，通常来说，如果一个正规比赛题面有灰常类似某个算法的裸题的描述的话，通常来说其实不是用这种算法。。。然鹅今天连做两道题都是要用到那个算法。。（另一个是动物园。。kmp）所以我们还是要借鉴一下manacher的神奇线性做法滴 例如这种情况，就造成了重复，虽然并不是那么直观。manacher的跳过，是不需要验证相同。这道题的跳过，是不需要使它们相同。操作的类似使复杂度也是O(n)的。 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************int n;int ma[MAXN],g[MAXN];int v[30];//时间戳int c[MAXN];//分配//*******************实现*******************int fa[MAXN];int findfa(int x) &#123;return (x==fa[x])?x:fa[x]=findfa(fa[x]);&#125;void merg(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;int hou[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];//互斥关系int ln=0;void ins(int x,int y)&#123; if(!(1&lt;=x and x&lt;=n)) return; if(!(1&lt;=y and y&lt;=n)) return; e[++ln]=(Edge)&#123;y,hou[x]&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y]&#125;;hou[y]=ln;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;g[2*i]),++g[2*i]; for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;g[2*i+1]),++g[2*i+1]; n=n*2;ma[1]=1; for(int i=1;i&lt;=n;i++) fa[i]=i;//debug 在后面 int md=1,rx=md+ma[md]-1; for(int i=2;i&lt;=n;i++) &#123; ma[i]=(i&gt;rx)?1:mymin(ma[2*md-i],rx-i+1); for(;ma[i]&lt;g[i];ma[i]++) merg(i-ma[i],i+ma[i]); //ins(i-g[i],i+g[i]);//必须不同 if(i+ma[i]-1&gt;rx) md=i,rx=md+ma[md]-1; &#125; for(int i=2;i&lt;=n;i++) ins(findfa(i-g[i]),findfa(i+g[i]));//必须不同 //奇数位已经无意义 for(int i=2;i&lt;=n;i+=2) &#123; int fx=findfa(i); if(!c[fx])//不能占用0…… &#123; for(int k=hou[fx];k&gt;0;k=e[k].g) v[ c[findfa(e[k].y)] ]=i; for(int j=1;j&lt;=26;j++) if(v[j]&lt;i) &#123;c[fx]=j;break;&#125; &#125; putchar('a'+c[fx]-1); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【USACO12DEC】【Bzoj3012】【Luogu3065】First!]]></title>
    <url>%2Fposts%2F710f.html</url>
    <content type="text"><![CDATA[Source and JudgeUsaco2012 DecBzoj3012Luogu3065 Problem【Description】给n个字符串，问如果重定义字典序，有哪些单词可能排在字典的第一名。字典序计算：1. 优先找不同的字母2. 其次长度小则前【Input】字符串总量n每行一个字符串【Output】满足条件的数量每行一个，输出原串（按输入顺序）【Limited conditions】1 &lt;= N &lt;= 30,000字符总数不会超过300,000只有小写字母【Sample input】4ommmoomomommnom【Sample output】2ommmom【Sample explanation】如果定义 o 在 m 之前，则omm 可排第一，如果定义 m 在 o 之前，则mom 可排第一，但余下两个单词是无论如何不可能排在第一的。 Record2h Analysis请先思考后再展开 首先： 从面向数据编程的角度，看到字符串总长度，而且只有小写字母，可以考虑字典树 从字符串比较的角度，是从前往后的，也就是前缀，那也是字典树 然后可以考虑枚举每一个字符串，然后什么条件下它能够成为字典序最小的呢？ 不能存在某个字符串是它的前缀 对于某个位置，如果前面都一样，则这个不一样的部分，我的将是最小的显然两个都跟前缀有关，可以用字典树搞一搞然后对于2，产生了一些不等关系 那么有三种思路（大致时间复杂度都是O(N^2)）： 用拓扑排序，如果某一时刻没有入度为0的点，则无解 用差分约束，有负环无解 用强连通找环，有环无解那么网上的大部分都是用第一种的，事实上这也是性价比最高的，所以另外两种就不写了，但是理解还是一定要的。 至于空间的话……网上都说每个串不超过20，但为了不被卡，用了string，慢也是正常的。 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=31000;//*******************全局定义*******************string s[MAXN];//*******************验证*******************const int C=26;int ru[C];bool mp[C][C];bool check()&#123; for(int cnt=1;cnt&lt;=C;cnt++) &#123; int i; for(i=0;i&lt;C;i++) if(ru[i]==0) break; if(i==C) return 0;//环 ru[i]=-1; for(int j=0;j&lt;C;j++) if(mp[i][j]) ru[j]--; &#125; return 1;&#125;//*******************Trie*******************struct Trie&#123; int s; int ch[26]; bool ed;&#125;;vector&lt;Trie&gt; a;void add(int x)&#123; int ln=s[x].length(); int now=0; for(int i=0;i&lt;ln;i++) &#123; int t=s[x][i]-'a'; if(a[now].ch[t]==0) &#123; a.push_back((Trie)&#123;&#125;); a[now].ch[t]=a.size()-1; &#125; now=a[now].ch[t]; a[now].s++; &#125; a[now].ed=1;&#125;bool solve(int x)&#123; memset(mp,0,sizeof(mp)); memset(ru,0,sizeof(ru)); int ln=s[x].length(); int now=0; for(int i=0;i&lt;ln;i++) &#123; if(a[now].ed) return 0; int t=s[x][i]-'a'; for(int j=0;j&lt;C;j++) if(j!=t and !mp[t][j] and a[ a[now].ch[j] ].s&gt;0) mp[t][j]=1,ru[j]++; now=a[now].ch[t]; &#125; return check();&#125;//*******************主函数*******************char sss[310000];bool fine[MAXN];int main()&#123; a.push_back((Trie)&#123;&#125;); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",sss); s[i]=sss; add(i); &#125; int cnt=0; for(int i=1;i&lt;=n;i++) if(solve(i)) fine[i]=1,cnt++; printf("%d\n",cnt); for(int i=1;i&lt;=n;i++) if(fine[i]) printf("%s\n",s[i].c_str());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>拓扑</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3670】【Luogu2375】动物园]]></title>
    <url>%2Fposts%2F53a7.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj3670Luogu2375 Problem【Description】对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。输出所有(num[i]+1)的乘积，对1,000,000,007取模的结果即可。【Input】第1行仅包含一个正整数n ，表示测试数据的组数。随后n行，每行描述一组测试数据。每组测试数据仅含有一个字符串S，S的定义详见题目描述。【Output】包含 n 行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对 1,000,000,007 取模的结果。【Limited conditions】S中仅含小写字母。1 N ≤ 5, L ≤ 502 N ≤ 5, L ≤ 2003 N ≤ 5, L ≤ 2004 N ≤ 5, L ≤ 10,0005 N ≤ 5, L ≤ 10,0006 N ≤ 5, L ≤ 100,0007 N ≤ 5, L ≤ 200,0008 N ≤ 5, L ≤ 500,0009 N ≤ 5, L ≤ 1,000,00010 N ≤ 5, L ≤ 1,000,000【Sample input】3aaaaaababcababc【Sample output】36132【Sample explanation】S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] =1， num[3] = 1,num[5] = 2 Record1h Analysis请先思考后再展开 不难发现，就是求每个点，在nxt树上有多少个祖先满足不超过当前i的一半直接倍增会t 考虑把nxt树具体画出来就是i-1向上一条链，i向上一条链，然后i-1祖先中某个能+1到i的父亲那么我们维护指针j表示i-1的num，然后在j和i-1之间的，即使某个k能通过+1到达i的祖先，因为k对于i-1是非法的，则k+1对于i也是非法的，以后都没有用了（这个没人提到，我卡了很久）那么这个j每次向上找一个位置能+1到i的祖先，然后判断一下要不要向上跳一步即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(int num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back inline void chmax(int &amp;x,int y) &#123;x=x&gt;y?x:y;&#125; inline void chmin(int &amp;x,int y) &#123;x=x&lt;y?x:y;&#125; const int MOD=1e9+7; const int MAX_N=1e6+10; int nxt[MAX_N],dep[MAX_N];char str[MAX_N]; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s",str+1);int n=strlen(str+1); nxt[1]=0;dep[1]=1; int x=0;ll ans=1; for(int i=2;i&lt;=n;i++) &#123; int j=nxt[i-1];while(j&gt;0 and str[j+1]!=str[i]) j=nxt[j]; nxt[i]=j+(str[j+1]==str[i]); dep[i]=dep[nxt[i]]+1; while(x&gt;0 and str[x+1]!=str[i]) x=nxt[x]; if(str[x+1]==str[i]) x++; if(x&gt;0 and 2*x&gt;i) x=nxt[x]; ans=ans*(dep[x]+1)%MOD; &#125; printf("%lld\n",ans); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1677】陶陶的名字]]></title>
    <url>%2Fposts%2F9bc9.html</url>
    <content type="text"><![CDATA[Source and JudgeVijos1677 Problem【Description】某一天，陶陶想把自己的名字涂在墙上。由于他的名字太长，为了省事，他从自己名字的开头截取了一段作为模板。我们不妨设这个模板的长度为l，陶陶的名字的长度为L，那么有1≤l≤L。然后陶陶会用这个模板进行若干次喷涂，喷出自己的名字（后一次喷涂会覆盖前一次喷涂的结果，例如当前墙上已经有abc三个字符，那么如果在c处进行喷涂，就会得到ababc）。陶陶喷涂名字总是从前向后喷的，假设陶陶喷涂了k次，这k次喷涂按时间顺序第i次喷涂的位置是s[i]，那么s[i]&lt;s[i+1]。【Input】陶陶的名字【Output】最短的模版长度【Limited conditions】对于10%的数据， n≤200对于30%的数据， n≤1000对于100%的数据，n≤1000000【Sample input】abcabababc【Sample output】3【Sample explanation】陶陶的名字是abcabababc，最短的模版是abc。注意，印刷只能从前向后印 Record2h Analysis请先思考后再展开 性质： 此前缀一定也是后缀 满足条件1的长度序列上，满足二分性 然后下面用到了exkmp，不想写可以考虑hash+二分，知道自己的复杂度很优秀就行了 方法一，O(nlogn)利用二分性，考虑能否用ln以内的前缀得出考虑dp，记录最后一个能覆盖的位置lst，枚举到lst并尝试向后，长度为max(ln,ext[i]) 方法二，O(n)考虑kmp，如果某个前缀满足条件1，而且后面（不包括自己）没有nxt=0的位置，则合法证明：首先是能构造出方案的，因为所有位置都能在前缀取非0的长度然后不存在更小的，因为如果某个位置后面有这种0的地方，毫无覆盖的办法（如果有覆盖办法，显然不会是0）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=1e6+10; char s[MAX_N];int ln; int nxt[MAX_N],lst=1; void kmp() &#123; nxt[1]=0; for(int i=2;i&lt;=ln;i++) &#123; int j=nxt[i-1];while(j!=0 and s[j+1]!=s[i]) j=nxt[j]; nxt[i]=j+(s[j+1]==s[i]); if(nxt[i]==0) lst=i; &#125; &#125; typedef unsigned long long ull; const ull base=13331; ull bs[MAX_N]; ull hash[MAX_N]; ull calc(int l,int r) &#123; return hash[r]-hash[l-1]*bs[r-l+1]; &#125; bool v[MAX_N]; void main() &#123; bs[0]=1;for(int i=1;i&lt;MAX_N;i++) bs[i]=bs[i-1]*base; scanf("%s",s+1);ln=strlen(s+1); for(int i=1;i&lt;=ln;i++) hash[i]=hash[i-1]*base+s[i]; for(int i=1;i&lt;=ln;i++) v[i]=(calc(1,i)==calc(ln-i+1,ln)); kmp(); for(int i=lst;i&lt;=ln;i++) if(v[i]) &#123;printf("%d",i);return;&#125; &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>复习</tag>
        <tag>kmp</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51Nod1304】字符串的相似度]]></title>
    <url>%2Fposts%2F23a.html</url>
    <content type="text"><![CDATA[Source and Judge51Nod1304 Problem【Description】我们定义2个字符串的相似度等于两个串的相同前缀的长度。例如 “abc” 同 “abd” 的相似度为2，”aaa” 同 “aaab” 的相似度为3。给出一个字符串S，计算S同他所有后缀的相似度之和。例如：S = “ababaa”，所有后缀为：ababaa 6babaa 0abaa 3baa 0aa 1a 1S同所有后缀的相似度的和 = 6 + 0 + 3 + 0 + 1 + 1 = 11【Input】输入一个字符串S，L为字符串S的长度，且S由a-z的小写字母组成。【Output】输出S同所有后缀的相似度的和。【Limited conditions】1 &lt;= L &lt;= 1000000【Sample input】ababaa【Sample output】11【Sample explanation】无 Record20min Analysis请先思考后再展开 exkmp裸题ex数组之和一开始忘开long long了，wa了一个 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char sa[MAXN],sb[MAXN];int la,lb;int ext[MAXN],ex[MAXN];//*******************实现*******************void pre_exkmp()&#123; ext[1]=lb; ext[2]=0;while(2+ext[2]&lt;=lb and sb[1+ext[2]]==sb[2+ext[2]]) ext[2]++; int k=2,rx=k+ext[k]-1; for(int i=3;i&lt;=lb;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ext[i]=L; else &#123;ext[i]=mymax(rx-i+1,0);while(i+ext[i]&lt;=lb and sb[1+ext[i]]==sb[i+ext[i]]) ext[i]++;&#125; if(i+ext[i]-1&gt;rx) k=i,rx=k+ext[k]-1; &#125;&#125;void exkmp()&#123; pre_exkmp(); ex[1]=0;while(1+ex[1]&lt;=lb and sb[1+ex[1]]==sa[1+ex[1]]) ex[1]++; int k=1,rx=k+ex[k]-1; for(int i=2;i&lt;=la;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ex[i]=L; else &#123;ex[i]=mymax(rx-i+1,0);while(1+ex[i]&lt;=lb and i+ex[i]&lt;=la and sb[1+ex[i]]==sa[i+ex[i]]) ex[i]++;&#125; if(i+ex[i]-1&gt;rx) k=i,rx=k+ex[k]-1; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%s",sa+1); memcpy(sb,sa,sizeof(sa)); la=lb=strlen(sa+1); exkmp(); ll ans=0; for(int i=1;i&lt;=la;i++) ans+=ex[i]; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1462】回文串]]></title>
    <url>%2Fposts%2Ff89e.html</url>
    <content type="text"><![CDATA[Source and JudgeCaioj1462 Problem【Description】给出26个字母所代表的权值和一个字符串，要求把字符串分成两段（每一段长度至少为1，也就是必须要有字符），假如这一段子串是一个回文串，那么加上该串所有字符权值之和，求最大的权值和。【Input】输入一个整数T，表示数据组数.每组数据第一行输入26个数，表示26个字母的权值，第二行输入一个字符串【Output】输出每组数据的最大权值和【Limited conditions】保证字符串内全是小写字母,2&lt;=字符串长度&lt;=500000【Sample input】21 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1aba1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1acacac【Sample output】16【Sample explanation】无 Record30min Analysis请先思考后再展开 对于回文字符串，常用的特性：对称性然鹅有个更通俗易懂大众化的但是很容易被忽略的特性：反转后与原串一样而exkmp正好可以后缀匹配另一个的最长前缀 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=510000;//*******************全局定义*******************char sa[MAXN],sb[MAXN];int la,lb;int ext[MAXN],ex[MAXN];//*******************实现*******************void pre_exkmp()&#123; ext[1]=lb; ext[2]=0;while(2+ext[2]&lt;=lb and sb[1+ext[2]]==sb[2+ext[2]]) ext[2]++; int k=2,rx=k+ext[k]-1; for(int i=3;i&lt;=lb;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ext[i]=L; else &#123;ext[i]=mymax(rx-i+1,0);while(i+ext[i]&lt;=lb and sb[1+ext[i]]==sb[i+ext[i]]) ext[i]++;&#125; if(i+ext[i]-1&gt;rx) k=i,rx=k+ext[k]-1; &#125;&#125;void exkmp()&#123; pre_exkmp(); ex[1]=0;while(1+ex[1]&lt;=lb and sb[1+ex[1]]==sa[1+ex[1]]) ex[1]++; int k=1,rx=k+ex[k]-1; for(int i=2;i&lt;=la;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ex[i]=L; else &#123;ex[i]=mymax(rx-i+1,0);while(1+ex[i]&lt;=lb and i+ex[i]&lt;=la and sb[1+ex[i]]==sa[i+ex[i]]) ex[i]++;&#125; if(i+ex[i]-1&gt;rx) k=i,rx=k+ex[k]-1; &#125;&#125;int cc[300];int sum[MAXN];bool f[MAXN];int solve()&#123; for(char i='a';i&lt;='z';i++) scanf("%d",&amp;cc[i]); scanf("%s",sa+1);la=lb=strlen(sa+1); memcpy(sb,sa,sizeof(sa)); std::reverse(sb+1,sb+lb+1); exkmp(); for(int i=2;i&lt;=lb;i++) f[i]=(ex[i]==lb-i+1); std::swap(sa,sb); exkmp(); for(int i=1;i&lt;=lb;i++) sum[i]=sum[i-1]+cc[sa[i]]; int ans=0; for(int i=1;i&lt;=lb-1;i++) &#123; int tmp=0; if(f[lb-i+1]) tmp+=sum[i]; if(ex[i+1]==lb-i) tmp+=sum[lb]-sum[i]; ans=mymax(ans,tmp); &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int T;scanf("%d",&amp;T); while(T--) printf("%d\n",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5290】【Luogu4438】Hnoi2018道路]]></title>
    <url>%2Fposts%2Fd692.html</url>
    <content type="text"><![CDATA[Source and JudgeHnoi2018Bzoj5290Luogu4438 Problem【Description】W 国的交通呈一棵树的形状。W 国一共有 n - 1 个城市和 n 个乡村，其中城市从 1 到 n−1 编号，乡村从 1 到 n 编号，且 1 号城市是首都。道路都是单向的，本题中我们只考虑从乡村通往首都的道路网络。对于每一个城市，恰有一条公路和一条铁路通向这座城市。对于城市i， 通向该城市的道路（公路或铁路）的起点，要么是一个乡村，要么是一个编号比 i 大的城市。 没有道路通向任何乡村。除了首都以外，从任何城市或乡村出发只有一条道路；首都没有往 外的道路。从任何乡村出发，沿着唯一往外的道路走，总可以到达首都。W 国的国王小 W 获得了一笔资金，他决定用这笔资金来改善交通。由于资金有限，小 W 只能翻修 n−1 条道路。小 W 决定对每个城市翻修恰好一条通向它的道路，即从公路和铁 路中选择一条并进行翻修。小 W 希望从乡村通向城市可以尽可能地便利，于是根据人口调 查的数据，小 W 对每个乡村制定了三个参数，编号为 i 的乡村的三个参数是a,b,c 。假设 从编号为 i 的乡村走到首都一共需要经过 x 条未翻修的公路与 y 条未翻修的铁路，那么该乡村 的不便利值为(a+x)×(b+y)×c。在给定的翻修方案下，每个乡村的不便利值相加的和为该翻修方案的不便利值。 翻修 n−1 条道路有很多方案，其中不便利值最小的方案称为最优翻修方案，小 W 自然希望找到最优翻修方案，请你帮助他求出这个最优翻修方案的不便利值。【Input】第一行为正整数 n 。接下来 n−1 行，每行描述一个城市。其中第 i 行包含两个数 si,ti 。si 表示通向第 i 座城市 的公路的起点，ti 表示通向第i座城市的铁路的起点。如果si&gt;0 ，那么存在一条从第si 座城 市通往第 i 座城市的公路，否则存在一条从第 −si个乡村通往第i座城市的公路； ti 类似地，如 果 ti&gt;0 ，那么存在一条从第 ti 座城市通往第i座城市的铁路，否则存在一条从第 −ti 个乡村通 往第 i 座城市的铁路。接下来 n 行，每行描述一个乡村。其中第i行包含三个数 a,b,c，其意义如题面所示。【Output】输出一行一个整数，表示最优翻修方案的不便利值。【Limited conditions】n≤20000,1≤ai,bi≤60,1≤ci≤10^9，任意乡村可以通过不超过40条道路到达首都。【Sample input 1】62 34 5-1 -2-3 -4-5 -61 2 31 3 22 1 32 3 13 1 23 2 1【Sample output 1】54【Sample input 2】92 -23 -34 -45 -56 -67 -78 -8-1 -91 60 11 60 11 60 11 60 11 60 11 60 11 60 11 60 11 60 1【Sample output 2】548【Sample input 3】122 45 3-7 1011 9-1 68 7-6 -10-9 -4-12 -5-2 -3-8 -1153 26 49124 58 19017 37 35615 51 99730 19 3983 45 2752 55 83816 18 93158 24 21243 25 19854 15 17234 5 524【Sample output 3】5744902【Sample explanation】如图所示，我们分别用蓝色、黄色节点表示城市、乡村；用绿色、红色箭头分别表示 公路、铁路；用加粗箭头表示翻修的道路。一种不便利值等于54的方法是：翻修通往城市2和城市5的铁路，以及通往其他城市的 公路。用→和⇒表示公路和铁路，用∗→和∗⇒表示翻修的公路和铁路，那么：编号为1的乡村到达首都的路线为：-1 ∗→ 3 ⇒ 1，经过0条未翻修公路和1条未翻修铁 路，代价为3 × (1 + 0) × (2 + 1) = 9；编号为2的乡村到达首都的路线为：-2 ⇒ 3 ⇒ 1，经过0条未翻修公路和2条未翻修铁 路，代价为2 × (1 + 0) × (3 + 2) = 10；编号为3的乡村到达首都的路线为：-3 ∗→ 4 → 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为3 × (2 + 1) × (1 + 0) = 9；编号为4的乡村到达首都的路线为：-4 ⇒ 4 → 2 ∗→ 1，经过1条未翻修公路和1条未翻 修铁路，代价为1 × (2 + 1) × (3 + 1) = 12；编号为5的乡村到达首都的路线为：-5 → 5 ∗⇒ 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为2 × (3 + 1) × (1 + 0) = 8；编号为6的乡村到达首都的路线为：-6 ∗⇒ 5 ∗⇒ 2 ∗→ 1，经过0条未翻修公路和0条未翻修铁路，代价为1 × (3 + 0) × (2 + 0) = 6；总的不便利值为9 + 10 + 9 + 12 + 8 + 6 = 54。可以证明这是本数据的最优解。 Record30min Analysis请先思考后再展开 好菜啊，没想到记忆化，考试的时候打了个暴力主要是自己傻傻地把边拉出来决策……这样就根本不会联想到记忆化好吧 听说这个题当初省选现场没有省队大爷AC……这道题的精髓就在于，把2^n的大暴力通过记忆化变成了精悍的树形dp Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=21000;//*******************全局定义*******************struct Nod&#123; int lc,rc;&#125;a[MAXN];struct Xj&#123; ll a,b,c;&#125;b[MAXN];ll f[MAXN][41][41];//*******************实现*******************ll solve(int now,ll x,ll y)&#123; if(now&lt;0) return (b[-now].a+x)*(b[-now].b+y)*b[-now].c; if(f[now][x][y]&lt;f[0][0][0]) return f[now][x][y]; return f[now][x][y]=mymin( solve(a[now].lc,x,y)+solve(a[now].rc,x,y+1), solve(a[now].lc,x+1,y)+solve(a[now].rc,x,y) );&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) scanf("%d%d",&amp;a[i].lc,&amp;a[i].rc); for(int i=1;i&lt;=n;i++) scanf("%lld%lld%lld",&amp;b[i].a,&amp;b[i].b,&amp;b[i].c); memset(f,63,sizeof(f)); printf("%lld",solve(1,0,0));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF838-B】Diverging Directions]]></title>
    <url>%2Fposts%2Fb187.html</url>
    <content type="text"><![CDATA[Source and JudgeCF838-B Problem【Description】西瓜们生活在编号 1⋯n 的 n个平行时空中，2n−2 台时光机将这些平行时空联系在一起。一台时光机有 3个整数参数 u,v,t 表示从时空 u 可以花费 t 的时间穿梭到时空 v。为了确保时空之间可以相互穿梭，同时方便作为现世的 1号时空的通行，西瓜们将这些时光机进行分工：前 n−1 台时光机确保从 1号时空可以直接 / 间接抵达任意时空，后 n−1台时光机负责从 2⋯n号时空直接返回 1号时空。【Input】第一行 3 个整数 n,q 分别表示 平行时空，操作 的个数。接下来 2n−2 行，每行 3 个整数 u,v,t 表示一台时光机。接下来 q 行，每行 3 个整数 id,x,y：若 $id=1$，表示第 $x$ 台时光机的运行时间变成了 $y$。若 $id=2$，表示当前有一个西瓜想要从时空 $x$ 穿梭到 时空 $y$；【Output】每次询问输出最短时间。【Limited conditions】n,q&lt;=2*10^6【Sample input】5 91 3 13 2 21 4 33 5 45 1 53 1 62 1 74 1 82 1 12 1 32 3 52 5 21 1 1002 1 31 8 302 4 22 2 4【Sample output】014810013210【Sample explanation】无 Record1h Analysis请先思考后再展开 显然是一个树类似树链剖分的思想，准确地说是dfs序如果对dfs序不是很懂的话，可以去看看这道经典题软件包管理器很水呀但是机房居然只有三个人过…… Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int INF=0x3f3f3f3f;typedef long long ll;void qread(int &amp;x)&#123; x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10+c-'0',c=getchar();&#125;void qreadll(ll &amp;x)&#123; x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10ll+c-'0',c=getchar();&#125;ll mymin(ll x,ll y) &#123;return (x&lt;y)?x:y;&#125;const int MAXN=210000;struct Seg&#123; int l,r,mid; int lc,rc; ll mi,lz;&#125;s[MAXN*2];int cnt=0;int build(int l,int r)&#123; int t=++cnt; if(l==r) s[t]=(Seg)&#123;l,r,l,0,0,0,0&#125;; else &#123; s[t]=(Seg)&#123;l,r,(l+r)&gt;&gt;1,0,0,0,0&#125;; s[t].lc=build(l,s[t].mid); s[t].rc=build(s[t].mid+1,r); s[t].mi=mymin(s[s[t].lc].mi,s[s[t].rc].mi); &#125; return t;&#125;void pushdown(int x)&#123; int lc=s[x].lc,rc=s[x].rc; if(lc&gt;0) &#123;s[lc].mi+=s[x].lz;s[lc].lz+=s[x].lz;&#125; if(rc&gt;0) &#123;s[rc].mi+=s[x].lz;s[rc].lz+=s[x].lz;&#125; s[x].lz=0;&#125;void change(int x,int l,int r,ll o)&#123; if(s[x].l==l and s[x].r==r) &#123; s[x].mi+=o; s[x].lz+=o; return; &#125; if(s[x].lz!=0) pushdown(x); int lc=s[x].lc,rc=s[x].rc; if(r&lt;=s[x].mid) change(lc,l,r,o); else if(l&gt;s[x].mid) change(rc,l,r,o); else change(lc,l,s[x].mid,o),change(rc,s[x].mid+1,r,o); s[x].mi=mymin(s[lc].mi,s[rc].mi);&#125;ll ask(int x,int l,int r)&#123; if(s[x].l==l and s[x].r==r) return s[x].mi; if(s[x].lz!=0) pushdown(x); int lc=s[x].lc,rc=s[x].rc; if(r&lt;=s[x].mid) return ask(lc,l,r); if(l&gt;s[x].mid) return ask(rc,l,r); return mymin( ask(lc,l,s[x].mid),ask(rc,s[x].mid+1,r) );&#125;struct Nod&#123; int hou; int siz; ll dis,tt; Nod() &#123; hou=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,ll c)&#123; e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln;&#125;int yz[MAXN],id=0;void dfs(int x,int fa)&#123; yz[x]=++id;p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; dfs(y,x); p[x].siz+=p[y].siz; &#125;&#125;struct SG&#123; int x,y; ll z;&#125;ss[2*MAXN];ll solve(int x,int y)&#123; if(yz[x]&lt;=yz[y] and yz[y]&lt;=yz[x]+p[x].siz-1) return ( ask(1,yz[y],yz[y])-p[y].tt )-( ask(1,yz[x],yz[x])-p[x].tt ); return ask(1,yz[x],yz[x]+p[x].siz-1)-(ask(1,yz[x],yz[x])-p[x].tt)+(ask(1,yz[y],yz[y])-p[y].tt);&#125;int main()&#123; int n,q;qread(n);qread(q); for(int i=1;i&lt;=2*n-2;i++) &#123; int x,y;ll z; qread(x);qread(y);qreadll(z); ss[i]=(SG)&#123;x,y,z&#125;; if(y==1) p[x].tt=z; else ins(x,y,z); &#125; dfs(1,0); build(1,n); for(int i=2;i&lt;=n;i++) change(1,yz[i],yz[i],p[i].dis+p[i].tt); while(q--) &#123; int id,x,y;qread(id);qread(x);qread(y); if(id==2) printf("%I64d\n",solve(x,y)); else &#123; int nx=ss[x].x,ny=ss[x].y; if(ny==1) change(1,yz[nx],yz[nx],-p[nx].tt+y),p[nx].tt=y; else change(1,yz[ny],yz[ny]+p[ny].siz-1,-ss[x].z+y),ss[x].z=y; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>树剖</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1178】最长共同前缀长度]]></title>
    <url>%2Fposts%2Ff934.html</url>
    <content type="text"><![CDATA[Source and JudgeCaioj1178 Problem【Description】给出模板串A和子串B，长度分别为lenA和lenB，要求对于每个A[i],(1&lt;=i&lt;=lenA)，求出A[i..lenA]与B的最长公共前缀长度【Input】输入A，B两个串【Output】输出lenA个数，表示A[i…lenA]与B的最长公共前缀长度，每个数之前有空格【Limited conditions】lenB&lt;=lenA&lt;=1000000【Sample input】aabbabaaabaabb【Sample output】4 1 0 0 1 0 2 3 1 0【Sample explanation】无 Record2h Analysis请先思考后再展开 exkmp入门题，求ex数组详见：【OI之路】10字符串-3ExKMP Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char sa[MAXN],sb[MAXN];int la,lb;int ext[MAXN],ex[MAXN];//*******************实现*******************void pre_exkmp()&#123; lb=strlen(sb+1); ext[1]=lb; ext[2]=0;while(2+ext[2]&lt;=lb and sb[1+ext[2]]==sb[2+ext[2]]) ext[2]++; int k=2,rx=k+ext[k]-1; for(int i=3;i&lt;=lb;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ext[i]=L; else &#123;ext[i]=mymax(rx-i+1,0);while(i+ext[i]&lt;=lb and sb[1+ext[i]]==sb[i+ext[i]]) ext[i]++;&#125; if(i+ext[i]-1&gt;rx) k=i,rx=k+ext[k]-1; &#125;&#125;void exkmp()&#123; la=strlen(sa+1); ex[1]=0;while(1+ex[1]&lt;=lb and sb[1+ex[1]]==sa[1+ex[1]]) ex[1]++; int k=1,rx=k+ex[k]-1; for(int i=2;i&lt;=la;i++) &#123; int j=i-k+1,L=ext[j];//对应点 if(L&lt;rx-i+1) ex[i]=L; else &#123;ex[i]=mymax(rx-i+1,0);while(1+ex[i]&lt;=lb and i+ex[i]&lt;=la and sb[1+ex[i]]==sa[i+ex[i]]) ex[i]++;&#125; if(i+ex[i]-1&gt;rx) k=i,rx=k+ex[k]-1; &#125;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); scanf("%s%s",sa+1,sb+1); pre_exkmp(); exkmp(); for(int i=1;i&lt;=la;i++) printf("%d ",ex[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3461】Oulipo]]></title>
    <url>%2Fposts%2Feaf4.html</url>
    <content type="text"><![CDATA[Source and JudgeBAPC 2006 QualificationPoj3461Caioj1460 Problem【Description】给出串A、B，判断A在B中出现次数，可重叠。【Input】第一行的正整数表示数据组数。每组数据两个不包含空格的字符串表示串A、B。【Output】每组数据输出一个数，表示匹配个数。【Limited conditions】字符串仅由大写字母组成。1 ≤ |A| ≤ 10,000|A| ≤ |B| ≤ 1,000,000.【Sample input】3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN【Sample output】130【Sample explanation】无 Record30min Analysis1请先思考后再展开 这道题是kmp的经典入门问题 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************char a[MAXN],b[MAXN];int la,lb;//*******************实现*******************int nxt[MAXN];void prekmp()&#123; lb=strlen(b+1); for(int i=2;i&lt;=lb;i++) &#123; int j=nxt[i-1]; while(j&gt;0 and b[j+1]!=b[i]) j=nxt[j]; if(b[j+1]==b[i]) nxt[i]=j+1; else nxt[i]=0; &#125;&#125;int kmp()&#123; la=strlen(a+1); int ans=0; int j=0; for(int i=1;i&lt;=la;i++) &#123; while(j&gt;0 and b[j+1]!=a[i]) j=nxt[j]; if(b[j+1]==a[i]) j++; if(j==lb) ans++; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",b+1,a+1); prekmp(); printf("%d\n",kmp()); &#125;&#125; Analysis2请先思考后再展开 然后这道题练习hash也是极好的$S(l,r)=f[r]-b^{r-l+1}\times f[l-1]$ Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const ull base=13331;//*******************全局定义*******************char a[MAXN],b[MAXN];ull f[MAXN];//*******************实现*******************ull bs[MAXN];ull getf(int l,int r)&#123; return f[r]-f[l-1]*bs[r-l+1];&#125;int solve()&#123; int la=strlen(a+1),lb=strlen(b+1); ull hb=0;for(int i=1;i&lt;=lb;i++) hb=hb*base+b[i]; int ans=0; for(int r=1;r&lt;=la;r++) &#123; f[r]=f[r-1]*base+a[r]; if(r&gt;=lb and getf(r-lb+1,r)==hb) ans++; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); bs[0]=1;for(int i=1;i&lt;MAXN;i++) bs[i]=bs[i-1]*base;//base^i int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",b+1,a+1); printf("%d\n",solve()); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>难度1</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3124】【Luogu3304】直径]]></title>
    <url>%2Fposts%2F15f6.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2013Bzoj3124Luogu3304 Problem【Description】给定一棵树，求直径的长度，以及有多少条边满足【所有的直径都经过】。【Input】第一行包含一个整数N，表示节点数。接下来N-1行，每行三个整数a, b, c ，表示点 a和点b之间有一条长度为c的无向边。【Output】共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。【Limited conditions】2&lt;=N&lt;=200000，所有点的编号都在1..N的范围内，边的权值&lt;=10^9【Sample input】63 1 10001 4 104 2 1004 5 504 6 100【Sample output】11102【Sample explanation】直径共有两条，3 到2的路径和3到6的路径。这两条直径都经过边(3, 1)和边(1, 4)。 Record30min Analysis请先思考后再展开 很有趣的一道题思路来自akc大爷： 找出一条直径 把直径扯直，其它子树挂在上面，此时答案一定从其中产生 预处理出直径上前缀和、后缀和，以及每个子树的最大深度mxi 从右往左找到第一个满足【mx+sum=L（直径长度）】，则意味着排除左边所有边，记录此l 从左往右同理，记录r 于是我们就可以枚举左右端点去枚举这种情况：【mx1+sum+mx2=L】复杂度O(n) Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************struct Nod&#123; int hou; int fa; ll dis; bool v; Nod() &#123; hou=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;ll c;&#125;e[MAXN*2];int ln=0;void ins()&#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,c&#125;;p[y].hou=ln;&#125;//*******************实现*******************int tmp;void dfs(int x,int fa)&#123; p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; p[y].dis=p[x].dis+e[k].c; if(p[y].dis&gt;p[tmp].dis) tmp=y; dfs(y,x); &#125;&#125;//*******************主函数*******************int f[MAXN];int sum[MAXN],mx[MAXN];int cnt=0;//记录直径int main()&#123; //freopen("tmp.in","r",stdin); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) ins(); tmp=1;p[tmp].dis=0;dfs(tmp,0);int aa=tmp; tmp=aa;p[tmp].dis=0;dfs(tmp,0);int bb=tmp; printf("%lld\n",p[bb].dis); int x=bb; while(1) &#123; f[++cnt]=x; p[x].v=1; if(x==aa) break; x=p[x].fa; &#125; for(int i=1;i&lt;=cnt;i++) &#123; tmp=f[i]; sum[i]=p[tmp].dis; p[tmp].dis=0; dfs(tmp,0); mx[i]=p[tmp].dis; &#125; int l=1;for(int i=cnt;i&gt;=1;i--) if(mx[i]==sum[1]-sum[i]) &#123;l=i;break;&#125; int r=cnt;for(int i=1;i&lt;=cnt;i++) if(mx[i]==sum[i]) &#123;r=i;break;&#125; printf("%d",r-l);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T3】飞扬的小鸟]]></title>
    <url>%2Fposts%2Fad3d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T3Luogu1941Caioj1565 Problem【Description】Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。为了简化问题，我们对游戏规则进行了简化和改编：1. 游戏界面是一个长为 n ，高为 m 的二维平面，其中有 k 个管道（忽略管道的宽度）。2. 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。3. 小鸟每个单位时间沿横坐标方向右移的距离为1 ，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度X ，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度Y 。小鸟位于横坐标方向不同位置时，上升的高度X 和下降的高度Y 可能互不相同。4. 小鸟高度等于0 或者小鸟碰到管道时，游戏失败。小鸟高度为 m 时，无法再上升。现在，请你判断是否可以完成游戏。如果可以 ，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。【Input】第1 行有3 个整数n ，m ，k ，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；接下来的n 行，每行2 个用一个空格隔开的整数X 和Y ，依次表示在横坐标位置0 ~n- 1上玩家点击屏幕后，小鸟在下一位置上升的高度X ，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度Y 。接下来k 行，每行3 个整数P ，L ，H ，每两个整数之间用一个空格隔开。每行表示一个管道，其中P 表示管道的横坐标，L 表示此管道缝隙的下边沿高度为L ，H 表示管道缝隙上边沿的高度（输入数据保证P 各不相同，但不保证按照大小顺序给出）。【Output】共两行。第一行，包含一个整数，如果可以成功完成游戏，则输出1 ，否则输出0 。第二行，包含一个整数，如果第一行为1 ，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。【Limited conditions】对于 30%的数据：5≤n≤10，5≤m≤10，k=0，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；对于 50%的数据：5≤n≤20，5≤m≤10，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；对于 70%的数据：5≤n≤1000，5≤m≤100；对于 100%的数据：5≤n≤10000，5≤m≤1000，0≤k&lt;n，0&lt;X&lt;m，0&lt;Y&lt;m，0&lt;P&lt;n，0≤L&lt;H ≤m，L+1&lt;H。【Sample input 1】10 10 63 99 91 21 31 21 12 12 11 62 21 2 75 1 56 3 57 5 88 7 99 1 3【Sample output 1】16【Sample input 2】10 10 41 23 12 21 81 83 22 12 12 21 21 0 26 7 99 1 43 8 10【Sample output 2】03【Sample explanation】如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。 Record3h Analysis1请先思考后再展开 首先，题意不是很明确，有个细节：当高度达到m以上，并不是非法，而是视作m！解法1：bfs爆搜预计得分：75时间复杂度：$O(nm^2log_2(nm))$ Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=10001;//*******************全局定义*******************int n,m;int ll[MAXN],rr[MAXN];int xx[MAXN],yy[MAXN];struct Pt&#123; int x,y,g; Pt(int tx=0,int ty=0,int tg=0) &#123;x=tx,y=ty,g=tg;&#125;&#125;;bool operator &lt; (Pt a,Pt b) &#123;return a.g&gt;b.g;&#125;//*******************实现*******************priority_queue&lt;Pt&gt; q;//小根堆int ans2=0;int vis[MAXN][1001];//min( g() )void ins(Pt now)&#123; if(now.y&gt;ll[now.x] and now.y&lt;rr[now.x] and vis[now.x][now.y]&gt;now.g) &#123; vis[now.x][now.y]=now.g; ans2=mymax(ans2,now.x); q.push(now); &#125;&#125;int solve()&#123; memset(vis,127,sizeof(vis)); for(int i=1;i&lt;=m;i++) ins( Pt(0,i,0) ); while(!q.empty()) &#123; Pt now=q.top();q.pop(); if(now.g&gt;vis[now.x][now.y]) continue;//old imformation if(now.x==n) return now.g; //1. down ins(Pt(now.x+1,now.y-yy[now.x],now.g)); //2. up int y=now.y,g=now.g; while(y&lt;rr[now.x+1])//剪枝 &#123; y+=xx[now.x]; if(y&gt;m) y=m; ins( Pt(now.x+1,y,++g) ); if(y==m) break; &#125; &#125; return -1;&#125;//*******************主函数*******************int pp[MAXN];int main()&#123; //freopen("tmp.in","r",stdin); int k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;=n-1;i++) scanf("%d%d",&amp;xx[i],&amp;yy[i]); memset(ll,0,sizeof(ll)); memset(rr,127,sizeof(rr)); for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;pp[i]); scanf("%d%d",&amp;ll[ pp[i] ],&amp;rr[ pp[i] ]); &#125; int ans=solve(); if(ans&gt;=0) printf("1\n%d",ans); else &#123; sort(pp+1,pp+k+1); printf("0\n%d",lower_bound(pp+1,pp+k+1,ans2)-pp-1); &#125;&#125; Analysis2请先思考后再展开 在上一个做法中，我们忽略了这道题一个重要的特性：方向固定（向右）所以是可以dp的把上升看作【多次背包】，下降看作【单次背包】 朴素的$O(nm^2)$：$$f[i][j] =\left{\begin{matrix}\underset{k}{min}(f[i-1][j-k\times x[i-1]])+k&amp; (j-k\times x[i-1]&gt;0) \\f[i-1][j+y[i-1]]&amp; (j+y[i-1]\leq m)\end{matrix}\right.$$ 然鹅，对于这之中耗时最多的枚举k，其实我们完全可以【放后影响】，从上一遍搞过来（显而易见，打bfs的时候想过但是不适用……然鹅dp是可以的）于是就下降到了$O(nm)$辣：$$f[i][j] =\left{\begin{matrix}min(f[i-1][j-x[i-1]],f[i][j-x[i-1])+1&amp; (j-x[i-1]&gt;0) \\f[i-1][j+y[i-1]]&amp; (j+y[i-1]\leq m)\end{matrix}\right.$$ 注意：对于撞到管子的$f[i][j]$，还是要计算的，因为有这种情况：我们从$f[i][j-x[i-1]]$转移过来，它撞墙了，但$f[i][j]$没有撞墙，它去没得继承了。所以要顺便说一句：感觉这个dp很像维护一个二维前缀 所以，综上所述，对于每一列： 无视水管，dp（特判m的情况），只考虑上升做多重背包 水管上，还原为inf 水管空档的下降，01背包 总结：如果有单向性，先考虑一下dp，再去想爆搜 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=10001;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,m,k;int xx[MAXN],yy[MAXN];int l[MAXN],r[MAXN];//*******************实现*******************int f[MAXN][1001];void solve()&#123; memset(f,63,sizeof(f)); for(int i=1;i&lt;=m;i++) f[0][i]=0; for(int x=1;x&lt;=n;x++) &#123; //1. up for(int y=xx[x-1]+1;y&lt;=m;y++) f[x][y]=mymin(f[x-1][y-xx[x-1]],f[x][y-xx[x-1]])+1; //2. up-特判m for(int k=m-xx[x-1];k&lt;=m;k++) f[x][m]=mymin( f[x][m],mymin(f[x-1][k],f[x][k])+1 ); //3. lock for(int y=1;y&lt;=l[x];y++) f[x][y]=INF; for(int y=r[x];y&lt;=m;y++) f[x][y]=INF; //4. down for(int y=l[x]+1;y&lt;=r[x]-1;y++) if(y+yy[x-1]&lt;=m) f[x][y]=mymin(f[x][y],f[x-1][y+yy[x-1]]); &#125;&#125;//*******************主函数*******************int pp[MAXN];int main()&#123; //freopen("tmp.in","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;=n-1;i++) scanf("%d%d",&amp;xx[i],&amp;yy[i]); for(int i=0;i&lt;=n;i++) l[i]=0,r[i]=m+1; for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;pp[i]); scanf("%d%d",&amp;l[ pp[i] ],&amp;r[ pp[i] ]); &#125; solve(); int ans=INF,cnt=k; for(int x=n;x&gt;=1;x--) &#123; for(int y=l[x]+1;y&lt;=r[x]-1;y++) ans=mymin(ans,f[x][y]); if(ans!=INF) break;//成功 if(r[x]&lt;=m) cnt--;//失败 &#125; if(cnt==k) printf("1\n%d",ans); else printf("0\n%d",cnt);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D2T1】无线网络发射器选址]]></title>
    <url>%2Fposts%2F3a8c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D2T1Luogu1941Caioj1566 Problem【Description】假设某城市的布局为由严格平行的129 条东西向街道和129 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 1。东西向街道从北到南依次编号为0,1,2…128 , 南北向街道从西到东依次编号为0,1,2…128。东西向街道和南北向街道相交形成路口，规定编号为 x 的南北向街道和编号为 y 的东西向街道形成的路口的坐标是（x, y）。在某些路口存在一定数量的公共场所。由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 2*d 的正方形。传播范围包括正方形边界。例如下图是一个d = 1 的无线网络发射器的覆盖范围示意图。现在政府有关部门准备安装一个传播参数为 d 的无线网络发射器，希望你帮助他们在城市内找出合适的安装地点，使得覆盖的公共场所最多。【Input】第一行包含一个整数 d，表示无线网络发射器的传播距离。第二行包含一个整数 n，表示有公共场所的路口数目。接下来 n 行，每行给出三个整数 x, y, k, 中间用一个空格隔开，分别代表路口的坐标(x, y)以及该路口公共场所的数量。同一坐标只会给出一次。【Output】输出一行，包含两个整数，用一个空格隔开，分别表示能覆盖最多公共场所的安装地点方案数，以及能覆盖的最多公共场所的数量。【Limited conditions】1 ≤ d ≤ 20，1 ≤ n ≤ 20， 0 ≤ x ≤ 128, 0 ≤ y ≤ 128, 0 &lt; k ≤ 1,000,000【Sample input】124 4 106 6 20【Sample output】1 30【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 12345678910111213141516171819202122232425int mp[150][150];int main()&#123; int d,n;scanf("%d%d",&amp;d,&amp;n); for(int i=1;i&lt;=n;i++) &#123; int x,y,k; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); mp[x][y]=k; &#125; int ans=0,cnt=0; for(int x=0;x&lt;=128;x++) &#123; for(int y=0;y&lt;=128;y++) &#123; int tmp=0; for(int i=x-d;i&lt;=x+d;i++) for(int j=y-d;j&lt;=y+d;j++) if(i&gt;=0 and i&lt;=128 and j&gt;=0 and j&lt;=128) tmp+=mp[i][j]; if(tmp==ans) cnt++; if(tmp&gt;ans) ans=tmp,cnt=1; &#125; &#125; printf("%d %d",cnt,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T2】联合权值]]></title>
    <url>%2Fposts%2Fb8ea.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T2Luogu1351Caioj1564 Problem【Description】给出一棵树，点从 1 到 n 依次编号，编号为 i 的点的权值为Wi ，每条边的长度均为1 。对于点对(u, v) ，若它们的距离为2 ，则它们之间会产生Wu×Wv 的联合权值。请问所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？【Input】第一行包含1 个整数n 。接下来n - 1 行，每行包含 2 个用空格隔开的正整数u 、v ，表示编号为 u 和编号为v 的点之间有边相连。最后1 行，包含 n 个正整数，每两个正整数之间用一个空格隔开，其中第 i 个整数表示图G 上编号为i 的点的权值为W i 。【Output】输出共1 行，包含2 个整数，之间用一个空格隔开，依次为图G 上联合权值的最大值和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对10007 取余。【Limited conditions】对于30% 的数据，1 &lt; n≤ 100 ；对于60% 的数据，1 &lt; n≤ 2000；对于100%的数据，1 &lt; n≤ 200 , 000 ，0 &lt; wi≤ 10, 000 。【Sample input】51 22 33 44 51 5 2 3 10【Sample output】20 74【Sample explanation】本例输入的图如上所示，距离为2 的有序点对有( 1,3) 、( 2,4) 、( 3,1) 、( 3,5) 、( 4,2) 、( 5,3) 。其联合权值分别为2 、15、2 、20、15、20。其中最大的是20，总和为74。 Record20min Analysis请先思考后再展开 先把有序变无序，sum乘2即可那么只有两种情况： 与祖父搞 和同父亲的哥哥搞 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=210000;const int MOD=10007;//*******************全局定义*******************struct Nod&#123; int hou; int w;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;int mx=0,sum=0;//*******************实现*******************void dfs(int x,int f,int ff)&#123; mx=mymax(mx,p[x].w*p[ff].w); sum=(sum+p[x].w*p[ff].w%MOD)%MOD; int wmx=0,wsum=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==f) continue; mx=mymax(mx,wmx*p[y].w); sum=(sum+wsum*p[y].w%MOD)%MOD; dfs(y,x,f); wmx=mymax(wmx,p[y].w); wsum=(wsum+p[y].w)%MOD; &#125;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].w),p[i].w%=MOD; dfs(1,0,0); printf("%d %d",mx,sum*2%MOD);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP14 D1T1】生活大爆炸版石头剪刀布]]></title>
    <url>%2Fposts%2Fe3ff.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2014 提高组 D1T1Luogu1328Caioj1563 Problem【Description】石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第8 集中出现了一种石头剪刀布的升级版游戏。升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：斯波克：《星际迷航》主角之一。蜥蜴人：《星际迷航》中的反面角色。这五种手势的胜负关系如表一所示，表中列出的是甲对乙的游戏结果。现在，小A 和小B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。已知小A 和小B 一共进行N 次猜拳。每一次赢的人得1 分，输的得0 分；平局两人都得0 分。现请你统计N 次猜拳结束之后两人的得分。【Input】第一行包含三个整数：N ，NA，NB，分别表示共进行 N 次猜拳、小 A 出拳的周期长度，小B 出拳的周期长度。数与数之间以一个空格分隔。第二行包含NA个整数，表示小 A 出拳的规律，第三行包含NB个整数，表示小 B 出拳的规律。其中，0 表示“剪刀”，1 表示“石头”，2 表示“布”，3 表示“蜥蜴人”， 4 表示“斯波克”。数与数之间以一个空格分隔。【Output】输出一行， 包含两个整数，以一个空格分隔，分别表示小A 、小B 的得分。【Limited conditions】0 &lt; N ≤ 200 ，0 &lt; NA ≤ 200 ， 0 &lt; NB ≤ 200 。【Sample input】9 5 50 1 2 3 41 0 3 2 4【Sample output】4 4【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=210;const int k[5][5]=&#123; &#123; 0,-1, 1, 1,-1&#125;, &#123; 1, 0,-1 ,1,-1&#125;, &#123;-1, 1, 0,-1, 1&#125;, &#123;-1,-1, 1, 0, 1&#125;, &#123; 1, 1,-1,-1, 0&#125;&#125;;//*******************全局定义*******************int a[MAXN],b[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int n,na,nb;scanf("%d%d%d",&amp;n,&amp;na,&amp;nb); for(int i=1;i&lt;=na;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=nb;i++) scanf("%d",&amp;b[i]); int ax=1,bx=1; int ans1=0,ans2=0; while(n--) &#123; int t1=a[ax],t2=b[bx]; if(k[t1][t2]&gt;0) ans1++; if(k[t1][t2]&lt;0) ans2++; ax++;if(ax&gt;na) ax=1; bx++;if(bx&gt;nb) bx=1; &#125; printf("%d %d",ans1,ans2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T3】华容道]]></title>
    <url>%2Fposts%2F23c4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T3Luogu1979Caioj1562 Problem【Description】给定一种局面，华容道是否根本就无法完成，如果能完成，最少需要多少时间。游戏规则：1. 在一个 n*m 棋盘上有 n*m 个格子，其中有且只有一个格子是空白的，其余 n*m-1个格子上每个格子上有一个棋子，每个棋子的大小都是 1*1 的；2. 有些棋子是固定的，有些棋子则是可以移动的；3. 任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。 游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。给定一个棋盘，游戏可以玩 q 次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第 i 次玩的时候，空白的格子在第 EX 行第 EY 列，指定的可移动棋子的初始位置为第 SX 行第 SY 列，目标位置为第 TX 行第 TY 列。假设小 B 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小 B 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。【Input】第一行有 3 个整数，每两个整数之间用一个空格隔开，依次表示 n、m 和 q；接下来的 n 行描述一个 n*m 的棋盘，每行有 m 个整数，每两个整数之间用一个空格隔开，每个整数描述棋盘上一个格子的状态，0 表示该格子上的棋子是固定的，1 表示该格子上的棋子可以移动或者该格子是空白的。接下来的 q 行，每行包含 6 个整数依次是Ex、Ey、SX、SY、TX、TY，每两个整数之间用一个空格隔开，表示每次游戏空白格子的位置，指定棋子的初始位置和目标位置。【Output】输出有 q 行，每行包含 1 个整数，表示每次游戏所需要的最少时间.如果某次游戏无法完成目标则输出−1。【Limited conditions】对于 30%的数据，1 ≤ n, m ≤ 10，q = 1；对于 60%的数据，1 ≤ n, m ≤ 30，q ≤ 10；对于 100%的数据，1 ≤ n, m ≤ 30，q ≤ 500。【Sample input】3 4 20 1 1 10 1 1 00 1 0 03 2 1 2 2 21 2 2 2 3 2【Sample output】3【Sample explanation】棋盘上划叉的格子是固定的，红色格子是目标位置，圆圈表示棋子，其中绿色圆圈表示目标棋子。第一次游戏，空白格子的初始位置是 (3, 2)（图中空白所示），游戏的目标是将初始位置在(1, 2)上的棋子（图中绿色圆圈所代表的棋子）移动到目标位置(2, 2)（图中红色的格子）上。移动过程如下：第二次游戏，空白格子的初始位置是（1, 2）（图中空白所示），游戏的目标是将初始位置在（2, 2）上的棋子（图中绿色圆圈所示）移动到目标位置 (3, 2)上。要将指定块移入目标位置，必须先将空白块移入目标位置，空白块要移动到目标位置，必然是从位置（2， 2）上与当前图中目标位置上的棋子交换位置，之后能与空白块交换位置的只有当前图中目标位置上的那个棋子，因此目标棋子永远无法走到它的目标位置， 游戏无法完成。 Record5h Analysis请先思考后再展开 这是一道有脑子的搜索题 本质上就是空白的棋子到处和别人交换来达成目标，固定即不可交换那么只要记录当前空白的位置和目标棋子的位置，就可以bfs了，据说有70分时间复杂度：O(q(nm)^2)，虽然稳tle，但考场上还是灰常值得的，也可以拿来拍 那我们梳理一下，可以这样想象：目标棋子和前面的空白交换，然后空白到后面之后，又屁颠屁颠地跑到目标棋子前面……周边的普通棋子就像群众，一旦墙壁明确，存在性等同于空气。怎么样，题意是不是明确了很多显然仅当【空白在棋子旁边】的状态是有用的，仅有3600种！但是我们虽然减少了状态，但并不代表忽略bfs还是要有的，但不能每一次都搞呀，不然还是炸（特别是无解的时候）因为如果指定棋子要移动，首先空格要到它旁边，而这段信息基本是公共的，尽管空格位置每次不同。也就是说，需要计算出dis(ax,ay,bx,by,d)，分别表示空格和指定棋子位置以及最后空格在棋子的方位（0表示下方，1表示上方，2表示左方，3表示右方）注意！没有必要枚举两点，用到的时候再处理而且，不能忽略终点来bfs（我一开始是这样想的），因为bfs的要求是不能穿越终点（否则空格就会影响到当前棋子的值，而这个我们应单独处理） 那么搜索中有个强大的东西：A*！教程的话，因为也在很多领域有应用，所以网上有灰常多的资料。然后据说这东西的神奇之处在于，对于搜索题，帮你搞定很多想不到的剪枝。但我对这东西不是太熟练，特别是其使用条件（适用范围） 首先，预处理出相邻可移动棋子的距离（用于求解中） 估价函数h(n)：指定棋子到终点位置的曼哈顿距离 实际代价函数g(n)：当前步数 open表：搞一个小根堆即可（ f*(n)=h*(n)+g*(n) ） hash表：hash(state.x,state.y,state.d)=min{ g(state) } 那么，对于每一次求解，先预处理这一次bfs距离值然后每一次取出小根堆中第一个来拓展然后两种情况： 空格与棋子交换，注意方向调换 空格走到棋子其他侧 最后说一句，这道题既考验脑力，也考验码力，挺不错的 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=31;const int tx[4]=&#123;1,-1,0,0&#125;;const int ty[4]=&#123;0,0,1,-1&#125;;//*******************全局定义*******************int n,m;int mp[MAXN][MAXN];int dis[MAXN][MAXN][MAXN][MAXN][4];//不能碰到终点//*******************预处理*******************struct Pt&#123; int x,y; Pt(int tx=0,int ty=0) &#123;x=tx;y=ty;&#125;&#125;;queue&lt;Pt&gt; q1;int tmp[MAXN][MAXN];void bfs(Pt st,Pt ed)&#123; memset(tmp,-1,sizeof(tmp)); for(int i=0;i&lt;4;i++) dis[st.x][st.y][ed.x][ed.y][i]=-1; q1.push(st);tmp[st.x][st.y]=0; while(!q1.empty()) &#123; Pt now=q1.front();q1.pop(); for(int i=0;i&lt;4;i++) &#123; if(ed.x+tx[i]==now.x and ed.y+ty[i]==now.y) dis[st.x][st.y][ed.x][ed.y][i]=tmp[now.x][now.y]; int nx=now.x+tx[i],ny=now.y+ty[i]; if(nx&lt;1 or nx&gt;n or ny&lt;1 or ny&gt;m or !mp[nx][ny]) continue; if(tmp[nx][ny]!=-1 or (nx==ed.x and ny==ed.y)) continue;//debug tmp[nx][ny]=tmp[now.x][now.y]+1; q1.push( Pt(nx,ny) ); &#125; &#125;&#125;//*******************实现*******************struct Data&#123; Pt now;//目标棋子 int d;//空白所在方向 int g,h;//实际步数、预估剩余步数&#125;;bool operator &lt; (Data a,Data b) &#123;return a.g+a.h&gt;b.g+b.h;&#125;priority_queue&lt;Data&gt; q2;//小根堆int hs[MAXN][MAXN][4];//Hash表，存储g()void ins(Data x)&#123; if(hs[x.now.x][x.now.y][x.d]&gt;x.g) &#123; hs[x.now.x][x.now.y][x.d]=x.g; q2.push(x); &#125;&#125;Pt e,st,ed;int H(Pt now) &#123;return myabs(now.x-ed.x)+myabs(now.y-ed.y);&#125;int solve()&#123; scanf("%d%d%d%d%d%d",&amp;e.x,&amp;e.y,&amp;st.x,&amp;st.y,&amp;ed.x,&amp;ed.y); if(st.x==ed.x and st.y==ed.y) return 0;//debug memset(hs,127,sizeof(hs)); while(!q2.empty()) q2.pop();//debug bfs(e,st); for(int i=0;i&lt;4;i++) if(dis[e.x][e.y][st.x][st.y][i]!=-1) ins( (Data)&#123;st,i,dis[e.x][e.y][st.x][st.y][i],H(st)&#125; ); while(!q2.empty()) &#123; Data x=q2.top();q2.pop(); if(x.now.x==ed.x and x.now.y==ed.y) return x.g; Pt kg=Pt(x.now.x+tx[x.d],x.now.y+ty[x.d]);//空格位置 //1. 空格与棋子交换，注意方向调换 ins( (Data)&#123;kg,x.d^1,x.g+1,H(kg)&#125; ); //2. 空格走到棋子其他侧 for(int i=0;i&lt;4;i++) if(dis[kg.x][kg.y][x.now.x][x.now.y][i]!=-1) ins( (Data)&#123;x.now,i,x.g+dis[kg.x][kg.y][x.now.x][x.now.y][i],x.h&#125; ); &#125; return -1;&#125;//*******************主函数*******************int main()&#123; //freopen("tmp.in","r",stdin); int q;scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;mp[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(mp[i][j]) for(int t=0;t&lt;4;t++) if(mp[i+tx[t]][j+ty[t]]) bfs( Pt(i,j),Pt(i+tx[t],j+ty[t]) ); while(q--) printf("%d\n",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>bfs</tag>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1379】八数码]]></title>
    <url>%2Fposts%2F6628.html</url>
    <content type="text"><![CDATA[Source and Judge经典问题Luogu1379Caioj1046 Problem【Description】在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。【Input】输入初始状态，一行九个数字，空格用0表示。【Output】只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数(测试数据中无特殊无法到达目标状态数据)【Limited conditions】无【Sample input】283104765【Sample output】4【Sample explanation】无 Record30min Analysis请先思考后再展开 这道题可谓搜索算法的超级经典入门题然后方法也灰常多，康托展开（如今看来没有什么卵用，而且想想就知道了）、bool数组乱搞那么今天因为要用到A*算法，打算用这道题试一试然后网上看到一个大概是acmer的，炒鸡变态地用八种做法做了：强烈推介 那关于A*的做法教程，这篇文章还是挺好的：this Code请先思考后再展开 然鹅我并不想打搜索题了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T2】花匠]]></title>
    <url>%2Fposts%2F56ba.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T2Luogu1970Caioj1561 Problem【Description】花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。具体而言，栋栋的花的高度可以看成一列整数h1, h2, … , hn。设当一部分花被移走后，剩下的花的高度依次为g1, g2, … , gm，则栋栋希望下面两个条件中至少有一个满足（i为正整数）：注意上面两个条件在m = 1时同时满足，当m &gt; 1时最多有一个能满足。请问，栋栋最多能将多少株花留在原地。【Input】输入的第一行包含一个整数n，表示开始时花的株数。第二行包含n个整数，依次为h1,h2..hn,表示每株花的高度。【Output】输出一行，包含一个整数m，表示最多能留在原地的花的株数。【Limited conditions】对于 20%的数据，n ≤ 10；对于 30%的数据，n ≤ 25；对于 70%的数据，n ≤ 1000，0 ≤ ℎi≤ 1000；对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤ hi≤ 1,000,000，所有的 hi 随机生成，所有随机数服从某区间内的均匀分布。【Sample input】55 3 2 1 2【Sample output】3【Sample explanation】有多种方法可以正好保留 3 株花，例如，留下第 1、4、5 株，高度分别为 5、1、2，满足条件 B。 Record30min Analysis请先思考后再展开 贪心即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=210000;//*******************全局定义*******************//*******************实现*******************//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); int ans=1;int bk=-1;//-1未定0下降1上升 int ed;scanf("%d",&amp;ed); for(int i=2;i&lt;=n;i++) &#123; int now;scanf("%d",&amp;now); if(bk&lt;0) &#123; if(ed!=now) bk=!(now&gt;ed),ed=now,ans++; &#125; else if(bk) &#123; if(ed&lt;now) bk=!bk,ed=now,ans++; else ed=now; &#125; else &#123; if(ed&gt;now) bk=!bk,ed=now,ans++; else ed=now; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D2T1】积木大赛]]></title>
    <url>%2Fposts%2Fd499.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D2T1Luogu1969Caioj1560 Problem【Description】一座宽度为n的大厦可以看成由n块宽度为1的积木组成，第i块积木的最终高度需要是hi。在搭建开始之前，没有任何积木（可以看成n块高度为 0 的积木）。接下来每次操作，小朋友们可以选择一段连续区间[l, r]，然后将第第 L 块到第 R 块之间（含第 L 块和第 R 块）所有积木的高度分别增加1。小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。【Input】输入包含两行，第一行包含一个整数n，表示大厦的宽度。第二行包含n个整数，第i个整数为hi 。【Output】仅一行，即建造所需的最少操作数。【Limited conditions】对于 30%的数据，有1 ≤ n ≤ 10；对于 70%的数据，有1 ≤ n ≤ 1000；对于 100%的数据，有1 ≤ n ≤ 100000，0 ≤ hi≤ 10000。【Sample input】52 3 4 1 2【Sample output】5【Sample explanation】其中一种可行的最佳方案，依次选择1[1,5][1,3][2,3][3,3][5,5] Record30min Analysis请先思考后再展开 这道题很容易被数据结构和数据范围误导啊然后我又是没有什么好思路不要脸地去膜“普及-”的题解……然后坚定了我noip前必刷usaco的想法 原来方案看起来是灰常复杂的，但是只要求次数，那么问题的难度会暴跌为什么呢？因为答案的单一性意味着可以边搞边调整方案，甚至不理会具体方案 对于这道题，把积木看作山峰，不难发现费用都和上坡有关，因为下坡必然能由上坡搞定所以只要记录上一个，每次比较判断是否为山峰，然后更新答案即可。 Code请先思考后再展开 123456789101112int main()&#123; int n;scanf("%d",&amp;n); int ans,lst;scanf("%d",&amp;lst);ans=lst; for(int i=2;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t&gt;lst) ans+=(t-lst); lst=t; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T3】货车运输]]></title>
    <url>%2Fposts%2F622b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T3Luogu1967 Problem【Description】A 国有 n 座城市，编号从 1 到 n，城市之间有 m 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。【Input】第一行有两个用一个空格隔开的整数 n，m，表示 A 国有 n 座城市和 m 条道路。接下来 m 行每行 3 个整数 x、 y、 z，每两个整数之间用一个空格隔开，表示从 x 号城市到 y 号城市有一条限重为 z 的道路。注意： x 不等于 y，两座城市之间可能有多条道路 。接下来一行有一个整数 q，表示有 q 辆货车需要运货。接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。【Output】输出共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。【Limited conditions】对于 30%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 10,000，0 &lt; q&lt; 1,000；对于 60%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 50,000，0 &lt; q&lt; 1,000；对于 100%的数据，0 &lt; n &lt; 10,000，0 &lt; m &lt; 50,000，0 &lt; q&lt; 30,000，0 ≤ z ≤ 100,000。【Sample input】4 31 2 42 3 33 1 131 31 41 3【Sample output】3-13【Sample explanation】无 Record30min Analysis请先思考后再展开 先求出最大生成树，证明见我生成树相关的证明既然是树了，那两点间路径就一条，相当于查询最小值罢了。然后因为是稀疏图，就用kruskal，实在是森林就-1至于查询，因为没有修改，不用出动树链剖分，直接倍增即可。 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=11000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int dep; Nod() &#123; hou=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,c,p[y].hou&#125;;p[y].hou=ln;&#125;int n,m;int f[MAXN][20],ds[MAXN][20];//*******************实现*******************void pre(int x,int fa)&#123; p[x].dep=p[fa].dep+1; f[x][0]=fa; for(int i=1;i&lt;=15;i++) &#123; f[x][i]=f[ f[x][i-1] ][i-1]; ds[x][i]=mymin(ds[x][i-1],ds[ f[x][i-1] ][i-1]); if(f[x][i]==0) break; &#125; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; ds[y][0]=e[k].c; pre(y,x); &#125;&#125;int bin[20];int query(int x,int y)&#123; int mi=INF; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=15;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) mi=mymin(mi,ds[x][i]),x=f[x][i]; if(x==y) return mi; for(int i=15;i&gt;=0;i--) if(f[x][i]!=f[y][i]) mi=mymin(mi,mymin(ds[x][i],ds[y][i])),x=f[x][i],y=f[y][i]; return mymin(mi,mymin(ds[x][0],ds[y][0]));//debug&#125;int fa[MAXN];int findfa(int x) &#123;return (x==fa[x])?x:fa[x]=findfa(fa[x]);&#125;struct Road&#123; int x,y,c;&#125;rd[51000];bool cmp(Road a,Road b) &#123;return a.c&gt;b.c;&#125;void kruskal()&#123; sort(rd+1,rd+m+1,cmp); for(int i=1;i&lt;=n;i++) fa[i]=i; int cnt=0; for(int i=1;i&lt;=m and cnt&lt;n-1;i++) &#123; int fx=findfa(rd[i].x),fy=findfa(rd[i].y); if(fx!=fy) &#123; cnt++; fa[fx]=fy; ins(rd[i].x,rd[i].y,rd[i].c); &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;rd[i].x,&amp;rd[i].y,&amp;rd[i].c); kruskal(); for(int i=1;i&lt;=n;i++) if(p[i].dep==0) pre(i,0);//debug 忘记是森林，被hack啦 bin[0]=1;for(int i=1;i&lt;=15;i++) bin[i]=bin[i-1]&lt;&lt;1; int q;scanf("%d",&amp;q); while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(findfa(x)!=findfa(y)) printf("-1\n"); else printf("%d\n",query(x,y)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP11 D1T2】选择客栈]]></title>
    <url>%2Fposts%2Fec55.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T2Luogu1311 Problem【Description】丽江河边有n家很有特色的客栈，客栈按照其位置顺序从1到n编号。每家客栈都按照某一种色调进行装饰（总共k种，用整数0~ k-1表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过p。他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过p元的咖啡店小聚。【Input】第一行三个整数n，k，p，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值；接下来的n行，第i+1行两个整数，之间用一个空格隔开，分别表示i号客栈的装饰色调和i号客栈的咖啡店的最低消费。【Output】输出只有一行，一个整数，表示可选的住宿方案的总数。【Limited conditions】对于30% 的数据，有 n ≤100；对于50% 的数据，有 n ≤1,000；对于100%的数据，有 2 ≤n ≤200,000，0&lt;k ≤50，0≤p ≤100 ， 0 ≤最低消费≤100。【Sample input】5 2 30 51 30 21 41 5【Sample output】3【Sample explanation】2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住4 、5 号客栈的话，4 、5 号客栈之间的咖啡店的最低消费是4 ，而两人能承受的最低消费是3 元，所以不满足要求。因此只有前 3 种方案可选。 Record30min Analysis请先思考后再展开 对于区间问题，可以考虑枚举其中一个端点然后以当前颜色最后一个可行点代表前面的可行点去累计答案 Code请先思考后再展开 123456789101112131415161718192021int lst[60];//颜色最后位置int sum[60];//okay前数量int cnt[60];//总数量int main()&#123; int n,k,p;scanf("%d%d%d",&amp;n,&amp;k,&amp;p); int ans=0; int okay=0; for(int r=1;r&lt;=n;r++) &#123; int col,cst;scanf("%d%d",&amp;col,&amp;cst); if(cst&lt;=p) okay=r;//自己也行 if(lst[col]&lt;=okay) sum[col]=cnt[col];//okay最近出现 ans+=sum[col]; lst[col]=r; cnt[col]++; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T2】火柴排队]]></title>
    <url>%2Fposts%2F421b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T2Luogu1966Caioj1558 Problem【Description】两个长为 n 的序列 a,b ，定义两个序列的距离为：sigma (ai-bi)^2每个序列中相邻两个位置的数可以交换，问最少需要交换多少次，可以最小化这个式子？最小交换次数对 99,999,997 取模。【Input】共三行，第一行包含一个整数 n。第二行有 n 个整数，每两个整数之间用一个空格隔开，表示第一列数。第三行有 n 个整数，每两个整数之间用一个空格隔开，表示第二列数。【Output】输出共一行，包含一个整数，表示最少交换次数对 99,999,997 取模的结果。【Limited conditions】对于 10%的数据， 1 ≤ n ≤ 10；对于 30%的数据，1 ≤ n ≤ 100；对于 60%的数据，1 ≤ n ≤ 1,000；对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤火柴高度≤ maxint【Sample input】41 3 4 21 7 2 4【Sample output】2【Sample explanation】最小距离是 10，最少需要交换 2 次，比如：交换第 1 列的中间 2 根火柴的位置，再交换第 2 列中后 2 根火柴的位置。 Record30min Analysis请先思考后再展开 显然为了让两列差值最小，让【两边同一排名的在一行】显然是最优的（可以自己推推式子，其他调整不会更优）那么既然只关心排名，先离散化一波 然后两边保证不同，是两个排列，现在要对齐将右边变成1、2、3……左边对应修改然后就相当于对左边排序，逆序对即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; int n; const int MAX_N=110000; int bit[MAX_N]; int lowbit(int x)&#123;return x&amp;-x;&#125; void change(int x,int c) &#123; while(x&lt;=n) &#123; bit[x]+=c; x+=lowbit(x); &#125; &#125; int ask(int x) &#123; int ans=0; while(x&gt;0) ans+=bit[x],x-=lowbit(x); return ans; &#125; struct Nod&#123;int d,p;&#125;p[MAX_N],p2[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.d&lt;b.d;&#125; int a[MAX_N],b[MAX_N]; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].d),p[i].p=i; sort(p+1,p+n+1,cmp); int now=1;a[p[1].p]=now; for(int i=2;i&lt;=n;i++) &#123; if(p[i-1].d!=p[i].d) now++; a[p[i].p]=now; &#125; memcpy(p2,p,sizeof p);//backup for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].d),p[i].p=i; sort(p+1,p+n+1,cmp); now=1;b[p[1].p]=now; for(int i=2;i&lt;=n;i++) &#123; if(p[i-1].d!=p[i].d) now++; b[p[i].p]=now; &#125; for(int i=1;i&lt;=n;i++) &#123; int to=lower_bound(p2+1,p2+n+1,(Nod)&#123;b[i],0&#125;,cmp )-p2; a[ p2[to].p ]=i; &#125; for(int i=1;i&lt;=n;i++) if(LOCAL) printf("a[%d]=%d\n",i,a[i]); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int all=i-1,sm=ask(a[i]); ans=(ans+all-sm)%99999997; change(a[i],1); &#125; printf("%d\n",ans); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>归并排序</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP13 D1T1】转圈游戏]]></title>
    <url>%2Fposts%2Fd86a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2013 提高组 D1T1Luogu1965Caioj1557 Problem【Description】n 个小伙伴（编号从 0 到 n-1）围坐一圈玩游戏。按照顺时针方向从0 到 n-1，给 n 个位置编号。最初，第 0 号小伙伴在第 0 号位置，第 1 号小伙伴在第 1 号位置，……，依此类推。游戏规则如下：每一轮第 0 号位置上的小伙伴顺时针走到第 m 号位置，第 1 号位置小伙伴走到第 m+1 号位置，……，依此类推，第n−m号位置上的小伙伴走到第 0 号位置，第n-m+1 号位置上的小伙伴走到第 1 号位置，……，第 n-1 号位置上的小伙伴顺时针走到第m-1 号位置。现在，一共进行了 10^k轮，请问 x 号小伙伴最后走到了第几号位置。【Input】输入共 1 行，包含 4 个整数 n、m、k、x，每两个整数之间用一个空格隔开。【Output】输出共 1 行，包含 1 个整数，表示 10^k 轮后 x 号小伙伴所在的位置编号。【Limited conditions】对于 30%的数据，0 &lt; k &lt; 7；对于 80%的数据，0 &lt; k &lt; 10^7；对于 100%的数据，1 &lt;n &lt; 1,000,000，0 &lt; m &lt; n，1 ≤ x ≤ n，0 &lt; k &lt; 10^9【Sample input】10 3 4 5【Sample output】5【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题ans=x+10^k*m (mod n) Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,m,k,x;//*******************实现*******************ll power(int x,int e)&#123; int ans=1; while(e&gt;0) &#123; if(e&amp;1) ans=(ans*x)%n; x=(x*x)%n;e&gt;&gt;=1; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;x); m=power(10,k)*m%n; printf("%d",(x+m)%n);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu4902】Nice boat]]></title>
    <url>%2Fposts%2Fddc6.html</url>
    <content type="text"><![CDATA[Source and Judge2014 Multi-University Training Contest 4作者：陈立杰%%%Hdu4902 Problem【Description】多组数据给你n个数，Q次操作操作分两类对于第一类操作(type1)，将区间[l,r]内的数改成x对于第二类操作(type2)，将区间[l,r]内&gt;x的a[i]$改成gcd(x,a[i])你需要输出Q次操作后的序列【Input】第一行正整数T，表示数据组数第一行两个数n,Q接着一行n个数a[i]接下来Q行，每行四个数type,l,r,x，分别代表操作类型，操作区间[l,r]和x【Output】每行n个数，代表Q次操作后的序列，用空格隔开【Limited conditions】n,Q&lt;=100000,0&lt;=x,a[i]&lt;=2^31-1【Sample input】11016807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709101 3 6 742430422 4 8 165317291 3 4 14748331692 1 8 11315709332 7 9 15057953352 3 7 1019292671 4 10 16243791492 2 8 21100106722 6 7 1560917451 2 5 937186357【Sample output】16807 937186357 937186357 937186357 937186357 1 1 1624379149 1624379149 1624379149【Sample explanation】无 Record1h Analysis请先思考后再展开 第一眼就觉得是线段树然后gcd有点烦证明了单纯地gcd是可以叠加的但这道题对于操作对象有讲究所以就不叠加了 比赛的时候码了半小时吧，然后对拍了两小时，还是比较稳的对了，那时候看错时限了，以为是1s（其实是1.5s），然后自己造极限数据，跑了0.95s，于是还搞了点卡常 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int gcd(int x,int y)&#123; return (y==0)?x:gcd(y,x%y);&#125;int a[MAXN];int qread()&#123; char c=getchar(); int t=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') t=t*10+c-'0',c=getchar(); return t;&#125;void qwrite(int x)&#123; if(x&gt;9) qwrite(x/10); putchar('0'+x%10);&#125;struct Seg&#123; int l,r,mid; int lc,rc; int c; int lz1,lz2;&#125;p[MAXN&lt;&lt;1];int ln;int build(int l,int r)&#123; if(l&gt;r) return 0;//debug int t=++ln; p[t]=(Seg)&#123;l,r,(l+r)&gt;&gt;1,0,0,-1,-1,0&#125;; if(l==r) p[t].c=a[l]; else &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;void pushdown(int x)&#123; if(x&lt;=0) return; int lc=p[x].lc,rc=p[x].rc; if(p[x].lz1&gt;=0) &#123; p[lc].c=p[lc].lz1=p[x].lz1; p[rc].c=p[rc].lz1=p[x].lz1; p[x].lz1=-1;p[x].lz2=0; &#125; else if(p[x].lz2&gt;0) &#123; pushdown(lc);pushdown(rc); p[lc].lz2=gcd(p[lc].lz2,p[x].lz2); p[rc].lz2=gcd(p[rc].lz2,p[x].lz2); if(p[lc].c&gt;p[x].lz2) p[lc].c=gcd(p[lc].c,p[x].lz2); if(p[rc].c&gt;p[x].lz2) p[rc].c=gcd(p[rc].c,p[x].lz2); p[x].lz2=0; &#125;&#125;void change1(int x,int l,int r,int xx)&#123; if(l&gt;r) return; if(p[x].l==l and p[x].r==r) &#123; p[x].lz1=p[x].c=xx; p[x].lz2=0; return; &#125; pushdown(x); if(r&lt;=p[x].mid) change1(p[x].lc,l,r,xx); else if(l&gt;p[x].mid) change1(p[x].rc,l,r,xx); else change1(p[x].lc,l,p[x].mid,xx),change1(p[x].rc,p[x].mid+1,r,xx);&#125;void change2(int x,int l,int r,int xx)&#123; if(l&gt;r) return; if(p[x].l==l and p[x].r==r) &#123; pushdown(x); p[x].lz2=gcd(p[x].lz2,xx); if(p[x].c&gt;xx) p[x].c=gcd(p[x].c,xx); return; &#125; pushdown(x); if(r&lt;=p[x].mid) change2(p[x].lc,l,r,xx); else if(l&gt;p[x].mid) change2(p[x].rc,l,r,xx); else change2(p[x].lc,l,p[x].mid,xx),change2(p[x].rc,p[x].mid+1,r,xx);&#125;void ask(int x,int ps)&#123; if(p[x].l==p[x].r) &#123;qwrite(p[x].c);putchar(' ');return;&#125; pushdown(x); ask((ps&lt;=p[x].mid)?p[x].lc:p[x].rc,ps);&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i]=qread(); ln=0;build(1,n); int q;scanf("%d",&amp;q); while(q--) &#123; int op=qread(),l=qread(),r=qread(),x=qread(); if(op==1) change1(1,l,r,x); else change2(1,l,r,x); &#125; for(int i=1;i&lt;=n;i++) ask(1,i); putchar('\n'); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1529】【Luogu3420】ska Piggy banks]]></title>
    <url>%2Fposts%2Ff249.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2005Bzoj1529Luogu3420 Problem【Description】Byteazar the Dragon拥有N个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar想要买一辆小汽车，而且需要打开所有的存钱罐。然鹅，他想要破坏尽量少的存钱罐，帮助Byteazar去决策最少要破坏多少存钱罐。【Input】第一行一个整数 N 表示存钱罐的总数.接下来每行一个整数,第 i+1行的整数代表第i个存钱罐的钥匙放置的存钱罐编号.【Output】一个整数表示最少打破多少个存钱罐.【Limited conditions】1&lt;=N&lt;=1000000【Sample input】42124【Sample output】2【Sample explanation】无 Record30min Analysis1请先思考后再展开 考试的时候打的是强连通，然后被卡空间了 首先，可以通过存储关系建边构图然后最无敌的做法：强连通缩点，统计入度为0的点然后比赛的时候这样是能AC的当然 Code1请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000001;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct Nod&#123; int hou; int dfn,low; bool v; Nod() &#123; hou=dfn=low=0; v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;y,p[x].hou&#125;;p[x].hou=ln;&#125;int id=0;int sta[MAXN],top=0;int cnt=0;int belg[MAXN];void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;//debug 不需要判fa if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low);//debug 写错了p[y].v==0 &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; belg[t]=cnt; if(t==x) break; &#125; &#125;&#125;int ru[MAXN];int a[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); if(i!=a[i]) ins(a[i],i); &#125; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) if(belg[i]!=belg[a[i]]) ru[belg[i]]++; int ans=0; for(int i=1;i&lt;=cnt;i++) if(ru[i]==0) ans++; printf("%d",ans);&#125; Analysis2请先思考后再展开 那么上面的做法在bzoj中是会被卡空间的（好像是爆栈）那么有没有更优美的做法呢？来看看题目中的特殊条件你看，边只有n条，那么对于一个强连通块，显然只会有一个入口既然如此，答案就是多少个连通块那在这道题中，强连通块和双向边块是等效的，因为每个点只会有一个入边（不排除是自己）所以用并查集就好啦 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1000001;int fa[MAXN];int findfa(int x)&#123; if(fa[x]!=x) fa[x]=findfa(fa[x]); return fa[x];&#125;void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) fa[fx]=fy;&#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(i!=t) join(t,i); &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans+=(fa[i]==i); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3784】树上的路径]]></title>
    <url>%2Fposts%2F1486.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj3784 Problem【Description】给定一个n个结点的树，结点用正整数1..n编号，每条边有一个正整数权值。用d(a,b)表示从结点a到结点b路边上经过边的权值，输出前大M的距离（去同两个点）。【Input】第一行两个正整数N,M下面N-1行，每行三个正整数a,b,c。表示结点a到结点b有一条权值为c的边。【Output】共M行，如题所述。【Limited conditions】a,b&lt;=n，c&lt;=10000N&lt;=50000M&lt;=Min(300000,n*(n-1)/2)【Sample input】5 101 2 11 3 22 4 32 5 4【Sample output】7 7 6 5 4 4 3 3 2 1【Sample explanation】无 Record2h Analysis请先思考后再展开 首先，有个弱化版：超级钢琴那么现在假设你已经理解了上面这道题 然后我们从暴力开始思考，显然枚举每个起点dfs去搞，复杂度是n^2的 然后既然是前m大，当然是用堆维护尝试枚举起点后，搞出一个dfs序，那么以【数量与深度有关的每个父亲】作为中介，搞出一条条链，而且显然【终点】是连续的。那么因为不能重复，考虑对于点y，只找dfs序比y小的点x。为了方便，不先枚举起点，而是先枚举中介父亲，然后才是起点。于是现在每个点被访问的次数是深度，复杂度是深度*n 那么现在大概就能拿到不错的分数了但是很容易被链啊，扫把啊什么的卡主要是这个“深度”所以点分治一波就好啦然后就是nlogn了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=51000,MAXID=MAXN*40;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int siz; bool v;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,c,p[y].hou&#125;;p[y].hou=ln;&#125;int n,k;//*******************实现*******************int h[MAXID];//当前dfs序节点与当前中介父亲int id=0;void pre(int x,int fa,int dis)&#123; h[++id]=dis; p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; pre(y,x,dis+e[k].c); p[x].siz+=p[y].siz; &#125;&#125;int st[MAXID][20];int bin[20],lg[MAXID];int _mx(int x,int y)&#123; return (h[x]&gt;h[y])?x:y;&#125;void preST()&#123; bin[0]=1;for(int i=1;bin[i]&lt;=id;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;=id;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;=id;i++) st[i][0]=i; for(int j=1;bin[j]&lt;=id;j++) for(int i=1;i+bin[j]-1&lt;=id;i++) st[i][j]=_mx(st[i][j-1],st[i+bin[j-1]][j-1]);&#125;int rmq(int l,int r)&#123; int t=lg[r-l+1]; return _mx( st[l][t],st[r-bin[t]+1][t] );&#125;int f[MAXN];int G,sum;void getrt(int x,int fa)&#123; f[x]=0;p[x].siz=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; getrt(y,x); f[x]=mymax(f[x],p[y].siz); p[x].siz+=p[y].siz; &#125; f[x]=mymax(f[x],sum-p[x].siz); if(f[x]&lt;f[G]) G=x;&#125;struct Data&#123; int now,l,r; int mx;&#125;;vector&lt;Data&gt; tmp;void divi(int x)&#123; p[x].v=1; int begin=id; h[++id]=0;//自己 int ss=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v) continue; pre(y,x,e[k].c); for(int i=1;i&lt;=p[y].siz;i++) tmp.push_back( (Data)&#123;begin+ss+i,begin+1,begin+ss,0&#125; ); ss+=p[y].siz; &#125; //注意不能合并循环，因为dfs序要求【同深度同层】，等完成后再分治 for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v) continue; sum=p[y].siz;G=0;getrt(y,x);divi(G); &#125;&#125;bool operator &lt; (Data a,Data b)&#123; return h[a.now]+h[a.mx]&lt;h[b.now]+h[b.mx];&#125;priority_queue&lt;Data&gt; q;void solve()&#123; f[0]=INF;G=0;sum=n;getrt(1,0);divi(G); preST(); int tz=tmp.size(); for(int i=0;i&lt;tz;i++) &#123; tmp[i].mx=rmq(tmp[i].l,tmp[i].r);//debug 忘记st表还没做好 q.push(tmp[i]); &#125; while(k--) &#123; Data x=q.top();q.pop(); printf("%d\n",h[x.now]+h[x.mx]); if(x.l&lt;=x.mx-1) q.push( (Data)&#123;x.now,x.l,x.mx-1,rmq(x.l,x.mx-1)&#125; ); if(x.mx+1&lt;=x.r) q.push( (Data)&#123;x.now,x.mx+1,x.r,rmq(x.mx+1,x.r)&#125; ); &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c); &#125; solve();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>难度2</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2010】超级钢琴]]></title>
    <url>%2Fposts%2Fe5b3.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj2006Luogu2048 Problem【Description】求给定序列中长度为L~R之间的前k大子串（连续）的和【Input】输入第一行包含四个正整数n, k, L, R。其中n为音符的个数，k为乐曲所包含的超级和弦个数，L和R分别是超级和弦所包含音符个数的下限和上限。接下来n行，每行包含一个整数Ai，表示按编号从小到大每个音符的美妙度。【Output】输出只有一个整数，表示乐曲美妙度的最大值。【Limited conditions】-1000≤Ai≤1000，1≤L≤R≤n且保证一定存在满足要求的乐曲。【Sample input】4 3 2 332-68【Sample output】11【Sample explanation】共有5种不同的超级和弦：1. 音符1~2，美妙度为3 + 2 = 52. 音符2~3，美妙度为2 + (-6) = -43. 音符3~4，美妙度为(-6) + 8 = 24. 音符1~3，美妙度为3 + 2 + (-6) = -15. 音符2~4，美妙度为2 + (-6) + 8 = 4最优方案为：乐曲由和弦1，和弦3，和弦5组成，美妙度为5+2+4=11。 Record2h Analysis请先思考后再展开 哇发现所谓st表就是Sparse Table然后最大子串，也就是区间，如果用前缀和表示，那么当确定一个右端点r，就是要找一个区间内最小的前缀和值来确定l，那么可以用一个st表来搞 有个要注意的点就是，因为不能重复，拿出一个点，需要把两个左右边填回去 然后就算比较水了，提高+吧 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n,k,L,R;ll s[MAXN];struct Data&#123; int now,l,r; int mi;&#125;;bool operator &lt; (Data a,Data b)&#123; return (s[a.now]-s[a.mi])&lt;(s[b.now]-s[b.mi]);&#125;priority_queue&lt;Data&gt; q;int mn(int a,int b) &#123;return (s[a]&lt;s[b])?a:b;&#125;//*******************实现*******************int bin[20];int lg[MAXN];int st[MAXN][20];int rmq(int l,int r)&#123; int t=lg[r-l+1]; return mn(st[l][t],st[r-bin[t]+1][t]);&#125;ll solve()&#123; for(int i=L;i&lt;=n;i++) &#123; int l=mymax(i-R,0),r=i-L;//debug if(l&lt;=r) q.push( (Data)&#123;i,l,r,rmq(l,r)&#125; ); &#125; ll ans=0; for(int i=1;i&lt;=k;i++) &#123; Data x=q.top();q.pop(); ans+=s[x.now]-s[x.mi]; if(x.l&lt;=x.mi-1) q.push( (Data)&#123;x.now,x.l,x.mi-1,rmq(x.l,x.mi-1)&#125; ); if(x.mi+1&lt;=x.r) q.push( (Data)&#123;x.now,x.mi+1,x.r,rmq(x.mi+1,x.r)&#125; ); &#125; return ans;&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=19;i++) bin[i]=bin[i-1]&lt;&lt;1; lg[1]=0;for(int i=2;i&lt;MAXN;i++) lg[i]=lg[i&gt;&gt;1]+1; scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;s[i]); s[i]+=s[i-1]; st[i][0]=i; &#125; for(int j=1;bin[j]&lt;=n;j++) for(int i=0;i+bin[j]-1&lt;=n;i++)//从0开始 st[i][j]=mn(st[i][j-1],st[i+bin[j-1]][j-1]); printf("%lld",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1112】砖块]]></title>
    <url>%2Fposts%2F2ed3.html</url>
    <content type="text"><![CDATA[Source and JudgePOI2008Bzoj1112 Problem【Description】给出n个数，希望有连续k个是一样的。可以由两种操作：1. 一个数-12. 一个数+1求完成任务的最少操作数【Input】第一行给出N,K。下面N行,每行代表这柱砖的高度.【Output】最小的动作次数【Limited conditions】1≤k≤n≤1000000≤hi≤1000000【Sample input】5 339231【Sample output】2【Sample explanation】无 Record2h Analysis请先思考后再展开 等价于，对于一个长度为k的区间，把所有数变成数轴上的点，找到一个位置使所有点到此距离之和最小。之前在糖果中讲过，这个位置必然是中位数，否则存在使答案更小的办法。 然后搞一个数据结构，维护一下第k大来找中位数，统计答案即可。然后类似在数轴上滑动的一个窗，从而利用之前的信息而不必重构（显然考试的时候还是忘记啦）时间复杂度：$O(nlogn)$ 考试的时候打了个很挫的主席树，而且没想到可以搞中位数，只想到是抛物线至于二次函数上三分……不会，好像也蛮慢的 Code1先来一发无脑splay好处是值可以灰常大而不受限制，空间也少一个log请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int son[2],f; int c,n; ll d,sum;&#125;p[MAXN];//*******************Splay*******************void update(int x)&#123; p[x].c=p[x].n;p[x].sum=p[x].d*p[x].n;//debug!! int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c,p[x].sum+=p[lc].sum; if(rc&gt;0) p[x].c+=p[rc].c,p[x].sum+=p[rc].sum;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;void splay(int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findip(ll d)&#123; int x=root; while(p[x].d!=d) &#123; if(d&lt;p[x].d) &#123; if(p[x].son[0]&gt;0) x=p[x].son[0]; else break; &#125; else &#123; if(p[x].son[1]&gt;0) x=p[x].son[1]; else break; &#125; &#125; return x;&#125;int cnt=0;void add(ll d,int f)&#123; cnt++; p[cnt].son[0]=p[cnt].son[1]=-1; p[cnt].c=p[cnt].n=1; p[cnt].sum=p[cnt].d=d; p[cnt].f=f; if(d&lt;p[f].d) p[f].son[0]=cnt; else p[f].son[1]=cnt;&#125;void insert(ll d)&#123; if(!root) &#123; add(d,0); root=cnt; return; &#125; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; splay(x,0); &#125; else &#123; add(d,x); splay(cnt,0); &#125;&#125;void del(ll d)&#123; int x=findip(d); splay(x,0); if(p[x].n&gt;1) &#123; p[x].n--; update(x); return; &#125; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==-1 and rc&gt;0) &#123; root=rc; p[root].f=0; &#125; else if(lc&gt;0 and rc==-1) &#123; root=lc; p[root].f=0; &#125; else &#123; int t=rc; while(p[t].son[0]&gt;0) t=p[t].son[0]; splay(t,root);p[t].f=0;root=t; p[t].son[0]=lc;p[lc].f=t; update(root);//debug &#125;&#125;ll findk(int k)&#123; int x=root; while(1) &#123; int lc=p[x].son[0],lcc=(lc&gt;0)?p[lc].c:0; if(k&lt;=lcc) x=lc; else if(k&gt;lcc+p[x].n) k-=lcc+p[x].n,x=p[x].son[1]; else break; &#125; splay(x,0); return p[x].d;&#125;//*******************实现*******************ll solve(int k)&#123; ll mid=findk(k/2+1); int lc=p[root].son[0],rc=p[root].son[1]; ll sm1=mid*p[lc].c,sm2=p[lc].sum; ll bg1=mid*p[rc].c,bg2=p[rc].sum; ll ans=0; if(lc&gt;0) ans+=sm1-sm2; if(rc&gt;0) ans+=bg2-bg1; return ans;//debug 没有其中儿子&#125;//*******************主函数*******************int h[MAXN];int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]); for(int i=1;i&lt;=k;i++) insert(h[i]); ll ans=solve(k); for(int r=k+1;r&lt;=n;r++) &#123; insert(h[r]); del(h[r-k]); ans=mymin(ans,solve(k)); &#125; printf(BIGN,ans);&#125; Code2是不是觉得巨长？其实有代码又短，常数又小的树状数组小心空间复杂度请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=110000;const int MAXNUM=1000001;//1000000+1const int INF=0x3f3f3f3f;//*******************全局定义*******************int bin[21];ll cnt[MAXNUM],sum[MAXNUM];//次数、和//*******************树状数组*******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void add(int p,int c,ll *s)&#123; while(p&lt;=MAXNUM) s[p]+=c,p+=lowbit(p);&#125;ll getsum(int p,ll *s)&#123; ll ans=0; while(p&gt;=1) ans+=s[p],p-=lowbit(p); return ans;&#125;ll findk(int k)&#123; int now=0,tk=0; for(int i=20;i&gt;=0;i--)//逆向求和 &#123; now+=bin[i]; if(now&lt;=MAXNUM and tk+cnt[now]&lt;k) tk+=cnt[now]; else now-=bin[i]; &#125; return now+1;//【小于k数量】+1&#125;//*******************实现*******************void insert(ll d)&#123; add(d,1,cnt); add(d,d,sum);&#125;void del(ll d)&#123; add(d,-1,cnt); add(d,-d,sum);&#125;ll solve(int k)&#123; ll mid=findk(k/2+1); ll sm1=mid*getsum(mid-1,cnt),sm2=getsum(mid-1,sum); ll bg1=mid*(getsum(MAXNUM,cnt)-getsum(mid,cnt)),bg2=getsum(MAXNUM,sum)-getsum(mid,sum); return (sm1-sm2)+(bg2-bg1);&#125;//*******************主函数*******************int h[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]),h[i]++;//debug 有0 for(int i=1;i&lt;=k;i++) insert(h[i]); ll ans=solve(k); for(int r=k+1;r&lt;=n;r++) &#123; insert(h[r]); del(h[r-k]); ans=mymin(ans,solve(k)); &#125; printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度2</tag>
        <tag>伸展树</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1084】【Bzoj1465】【Bzoj1045】糖果传递]]></title>
    <url>%2Fposts%2Ffa4.html</url>
    <content type="text"><![CDATA[Source and JudgeHAOI2008Luogu2512Bzoj1045Bzoj1465 Problem【Description】有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。【Input】小朋友个数n下面n个ai【Output】使所有人获得均等糖果的最小代价。【Limited conditions】n&lt;=1000000【Sample input】41 2 5 4【Sample output】4【Sample explanation】无 Record1h Analysis请先思考后再展开 首先，为了方便，把传递的双向改为单向（例如左边），这样传递量可能是负数。 $a[i]$=原本干草数$ed$=期望干草数$x[i]$=给左边干草数(可能是负数) $a[i]-x[i]+x[i+1]=ed$$\Rightarrow x[i+1]=x[i]-(a[i]-ed)$对于第1堆：$x[1]=x[n]-(a[n]-ed)=x[1]$ （还是使用x[1]本身较适合）对于第2堆：$x[2]=x[1]-(a[2]-ed)$对于第3堆：$x[3]=x[2]-(a[3]-ed)=x[1]-(a[2]-ed)-(a[3]-ed)$为了简化模型，变成单变量极值问题定义$c[i]=c[i-1]+(a[i]-ed)（i&gt;1,可能是负数）$于是$x[i]=x[1]-c[i]$ 我们希望 $答案=|x[2]|….+|x[n]|$ 最小也就是 $|x[1]-c[2]|….+|x[1]-c[n]|$ 最小 注意c[1]=0 所以现在x1是变量，而c是常量 绝对值几何意义：数轴上两点距离所以问题变成了：数轴上的n个点，找出一个【到他们的距离】之和最小的点问题解答：中位数 所以原题解答：$最好的x[1]=c的中位数$$ans=\sum_{i=2}^n abs(x1-c[i])$ 中位数证明：想象数轴上任意一点，首先假设，它左边有4个点，右边有2个点，把该点往左移动d单位距离（并且不碰到别的点），距离之和减少了2d当右边点较多时同理，【左右点数量差】越小越好，即最好的是中位数如果输入点有奇数个，则最优解应该是中间那个点即中位数如果有偶数个，则可以位于最中间两个点的任意位置（还是可用中位数解决） 另外，以后只要转化为这个数轴模型，就能使用中位数解决 然后这道题是很久以前做的，今天打比赛碰到类似题没想出来……同学提醒我做过这样一道题 所以有兴趣的也可以看看这道类似题：砖块 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************ll a[MAXN],c[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); ll sum=0;for(int i=1;i&lt;=n;i++) scanf(BIGN,&amp;a[i]),sum+=a[i]; ll ed=sum/n;for(int i=2;i&lt;=n;i++) c[i]=c[i-1]+(a[i]-ed); sort(c+1,c+n+1);ll x1=(n&amp;1)?c[n/2+1]:(c[n/2]+c[n/2+1])/2; ll ans=0; for(int i=1;i&lt;=n;i++) ans+=myabs(x1-c[i]); printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5194】Snow Boots]]></title>
    <url>%2Fposts%2F1f6f.html</url>
    <content type="text"><![CDATA[Source and JudgeUSACO 2018 February Gold 原题 Bzoj5194 Luogu4269 Problem【Brief description】N个点，从1开始编号，第i个位置有个ai有b双鞋，每双有两个属性s和d，使你能走过所有ai&lt;=s的地方，并且跳跃时一次最多能跳d步求每一双鞋子能否只用它从1到达n（确保这两个位置ai=0）【Input】第一行包含两个空格分隔的整数N和B。第二行包含N个空格分隔的整数，表示a。下面b行，每行两个数，表示s和d。【Output】n行，用0和1表示可行性【Limited conditions】1≤N,B≤10^50≤ai≤10^90≤s≤10^91≤d≤N-1【Sample input】8 70 3 8 5 6 9 0 00 50 66 28 110 15 3150 7【Sample output】0110111【Sample explanation】无 Record1h Analysis请先思考后再展开 首先要明确，从1到n的时候，是既可以走（+1）也可以跳（+d以内）的 那么显然，对于一只鞋，我们需要的，就是判断它所不能走的地方最大连续长度，只要这个最大长度是比d小的，就是能走过去的。 【因为做题量少+被“过河”误导+被没说清楚的题目误导（原来是可以跳短一点的），担心了各种细节，把题意复杂化了，所以考试的时候战略性放弃了】 开始讲做法： 把鞋子按照s从大到小排序，然后把点也按照从大到小排序个序 现在按排序还处理鞋子，这样能走的点只会减少，把能走的点用链表维护 维护一个【最大的能走的点间距离】，那么也就是最长的不能走的长度 每次删除链表中的点时，距离只会变大，更新一下答案即可 时间复杂度：O(nlogn+blogb)，那么题目的数据范围是灰常宽松的，加读优的暴力也能跑70 所以出题还是要卡一卡 当然，方法还有很多 用线段树而非链表维护，最长区间长度，但这样会慢一点，实现也麻烦 鞋子也可以从小到大排序，即能走的点增多，则可以考虑写一个可删堆或线段树 也就是说，如果从大到小，是完全没必要写线段树的 如果非要从小到大，可能写个可删堆会比较快？虽然常数大一点 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=110000;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int n,b;struct Lb&#123; int a; int id; int q,h;//链表&#125;p[MAXN],lb[MAXN];struct Qes&#123; int s,d; int id; bool ans;&#125;q[MAXN];bool cmp1(Lb a,Lb b) &#123;return a.a&gt;b.a;&#125;bool cmp2(Qes a,Qes b) &#123;return a.s&gt;b.s;&#125;bool cmp3(Qes a,Qes b) &#123;return a.id&lt;b.id;&#125;int first=1;int mx=0;bool solve(int x)&#123; for(;p[first].a&gt;q[x].s;first++) &#123; int t=p[first].id; int q=lb[t].q,h=lb[t].h; lb[q].h=h;lb[h].q=q; mx=mymax(mx,h-q-1);//长度 &#125; return q[x].d&gt;mx;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;b); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].a),p[i].id=i; for(int i=1;i&lt;=b;i++) scanf("%d%d",&amp;q[i].s,&amp;q[i].d),q[i].id=i; memcpy(lb,p,sizeof(p));for(int i=1;i&lt;=n;i++) lb[i].q=i-1,lb[i].h=i+1; sort(p+1,p+n+1,cmp1); sort(q+1,q+b+1,cmp2); for(int i=1;i&lt;=b;i++) q[i].ans=solve(i); sort(q+1,q+b+1,cmp3); for(int i=1;i&lt;=b;i++) printf("%d\n",q[i].ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2500】幸福的道路]]></title>
    <url>%2Fposts%2F73a.html</url>
    <content type="text"><![CDATA[Source and JudgeBzoj2500 Problem【Brief description】给一棵n个点的树，边长为$w_i$。现在假设有n天，每一天都可以从点i出发，然后走一条最长路径（每条边只经过一次）现在要求选择最长的连续几天，这些天的极差不超过$M$，求最大长度。【Input】第一行包含两个整数$N, M$，表示节点数和波动上限。第二至第$N$行,每行两个数字$F_i , w_i$, 第i行表示第i个节点的父亲是$F_i$,且路径长度是$w_i$.【Output】一行表示答案。【Limited conditions】50%的数据N&lt;=100080%的数据N&lt;=100 000100%的数据N&lt;=1000 000【Sample input】3 21 11 3【Sample output】3【Sample explanation】无 Record5h Analysis请先思考后再展开 首先，求每个点的最长链$g[i]$有几个方法： ① 两次dfs求出树的直径，每个点求与直径端点距离，复杂度$O(2n+2nlogn)$ ② 两次dfs求出树的直径，从直径两个端点再dfs更新每个点的答案，复杂度$O(4n)$ ③ dfs1把每个点子树内最长链和次长链计算出，然后dfs2用父亲的答案更新儿子的，复杂度$O(2n)$ 然后因为是连续的一段，所以可以用单调队列搞一搞 但怎么“搞”呢？考试的时候想半天没想到 首先我们单调的限制条件，就是极差是m以内 那所谓极差就是最大和最小值的差 我们可以同时维护两个单调队列【据说这是常规操作】 一个上升，一个下降，先维护其单调性 然后现在加入了一个点$r$，也就是当前连续的几天的右端点 把不符合条件的，从头开始踢出，同时把$l$用$max$维护一下就好了 注意，此时我们不一定把所有$l$前面的踢出了，但他们既不影响更新，也迟早会出去 同理，$l$之后的也不一定都在里面，只是因为不满足单调性而被去除了而已 哎刚开始打的时候没想通，还以为是用单调队列的长度这玩意真的挺有意思的 搞了这么久，主要是犯了很多sb错误 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymaxll(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int qread()&#123; int x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') x=x*10+c-'0',c=getchar(); return x;&#125;const int MAXN=1000001;struct Nod&#123; int hou; ll dis; Nod() &#123; hou=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g; ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,ll c)&#123; e[++ln]=(Edge)&#123;y,p[x].hou,c&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,p[y].hou,c&#125;;p[y].hou=ln;&#125;void dfs(int x,int fa)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dis=p[x].dis+e[k].c; dfs(y,x); &#125;&#125;ll g[MAXN];//最长链void dfs2(int x,int fa,ll dis)&#123; g[x]=mymaxll(g[x],dis); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs2(y,x,dis+e[k].c); &#125;&#125;int q1[MAXN];int q2[MAXN];int main()&#123; int n=qread(),m=qread(); for(int i=2;i&lt;=n;i++)//debug 被坑了一天!!!! &#123; int a=qread(),b=qread(); ins(a,i,ll(b)); &#125; int aa=1;p[1].dis=0;dfs(1,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[aa].dis) aa=i; int bb=aa;p[aa].dis=0;dfs(aa,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[bb].dis) bb=i; dfs2(aa,0,0);dfs2(bb,0,0); int ans=1; int tou1=1,wei1=1;q1[1]=1;//递增 int tou2=1,wei2=1;q2[1]=1;//递减 int l=1;//左端点 for(int r=1;r&lt;=n;r++)//右端点 &#123; while(tou1&lt;=wei1 and g[q1[wei1]]&gt;=g[r]) wei1--;q1[++wei1]=r;//维护单调性 while(tou1&lt;=wei1 and g[r]-g[q1[tou1]]&gt;m) l=mymax(l,q1[tou1]+1),tou1++;//维护合法性 while(tou2&lt;=wei2 and g[q2[wei2]]&lt;=g[r]) wei2--;q2[++wei2]=r;//维护单调性 while(tou2&lt;=wei2 and g[q2[tou2]]-g[r]&gt;m) l=mymax(l,q2[tou2]+1),tou2++;//维护合法性 ans=mymax(ans,r-l+1); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>单调队列</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF566A】【51Nod1615】Matching Names]]></title>
    <url>%2Fposts%2Ff13e.html</url>
    <content type="text"><![CDATA[Source and JudgeVK Cup 2015 - Finals分配笔名51Nod1626CF566A 但是CF的麻烦，懒得打了…… Problem【Brief description】班里有n个同学。老师为他们选了n个笔名。现在要把这些笔名分配给每一个同学，每一个同学分配到一个笔名，每一个笔名必须分配给某个同学。现在定义笔名和真名之间的相关度是他们之间的最长公共前缀。那么我们就可以得到匹配的质量是每一个同学笔名和真名之间相关度的和。现在要求分配笔名，使得匹配质量最大。【Input】第一行有一个整数n ，表示班级中同学的数目。接下来n行，表示每一个同学的真名，每一个名字是非空串，且由小写字母组成。名字可能重复。最后n行是老师已经安排好的笔名。每一个笔名是一个非空串，且由小写字母组成。笔名可能重复。【Output】输出最大的匹配质量【Limited conditions】1≤n≤100000输入的字符总数目不超过 800000。【Sample input】5gennadygalyaborisbilltoshikbilbotoringendalfsmauggaladriel【Sample output】11以下为CF额外：4 12 51 35 23 4【Sample explanation】无 Record1h Analysis请先思考后再展开 字典树 然后考试的时候写错了，漏了情况 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int INF=0x3f3f3f3f;struct Trie&#123; int s,ch[26];&#125;p[1000000];void clear(int x)&#123; p[x].s=0; memset(p[x].ch,-1,sizeof(p[x].ch));&#125;int cnt;char s[810000];void add()&#123; int ln=strlen(s+1); int x=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; if(p[x].ch[t]&lt;=0) &#123; p[x].ch[t]=++cnt; clear(cnt); &#125; x=p[x].ch[t]; p[x].s++; &#125;&#125;int solve()&#123; int ans=0; int ln=strlen(s+1); int x=0; for(int i=1;i&lt;=ln;i++) &#123; int t=s[i]-'a'; if(p[x].ch[t]&lt;=0) break; x=p[x].ch[t]; if(p[x].s&gt;0) p[x].s--,ans++; //下面的是错误的代码 //if(p[x].s&lt;=0) break; //p[x].s--;ans++; //反例 名字aab 笔名aa aab &#125; return ans;&#125;int main()&#123; int n;scanf("%d",&amp;n);getchar(); clear(0);cnt=0; for(int i=1;i&lt;=n;i++) &#123; gets(s+1); add(); &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; gets(s+1); ans+=solve(); &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF11B】【51Nod1615】Jumping Jack]]></title>
    <url>%2Fposts%2Fff50.html</url>
    <content type="text"><![CDATA[Source and Judge跳跃的杰克51Nod1615CF11BCF的原题好像已经被删了 Problem【Brief description】杰克正站在X坐标轴原点上。他想跳到坐标(x,0)上，为了达到训练效果，他决定首次跳跃的距离是1，之后每一次跳跃的距离将会比上一次跳跃的距离大1个单位。每一次跳跃，他可以选择往左或者往右跳。他很好奇至少要经过多少次跳跃才能到达终点。【Input】整数x【Output】输出杰克到达终点所需要的最少的跳跃次数【Limited conditions】-10^9&lt;=x&lt;=10^9【Sample input】2【Sample output】3【Sample explanation】无 Record30min 考试签到题 Analysis请先思考后再展开 思维题 首先，既然我们在0，那x可以直接转正 然后考虑贪心，在没到x前一直往右 然后到了以后有两种情况： now-x是奇数，则试图调整前面的，但无论前面是什么数，调换方向后都是偶数，所以无法到x now-x是偶数，则把(now-x)/2的数，方向反转即可 Code请先思考后再展开 123456789101112131415#include&lt;cstdio&gt;using namespace std;int main()&#123; int x;scanf("%d",&amp;x); if(x&lt;0) x=-x; int now=0,f=0; while(now&lt;x or (now-x)&amp;1) &#123; f++; now+=f; &#125; printf("%d\n",f);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1084】疫情控制]]></title>
    <url>%2Fposts%2F32f8.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T3Luogu1084Caioj1556 Problem【Brief description】H 国有 n 个城市，这 n 个城市用 n-1 条双向道路相互连通构成一棵树，1 号城市是首都，也是树中的根节点。H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。 【Input】第一行一个整数 n，表示城市个数。接下来的 n-1 行，每行 3 个整数，u、v、w，每两个整数之间用一个空格隔开，表示从城市 u 到城市 v 有一条长为 w 的道路。数据保证输入的是一棵树，且根节点编号为 1。接下来一行一个整数 m，表示军队个数。接下来一行 m 个整数，每两个整数之间用一个空格隔开，分别表示这 m 个军队所驻扎的城市的编号。 【Output】共一行，包含一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出-1。 【Limited conditions】保证军队不会驻扎在首都。对于 20%的数据，2≤ n≤ 10；对于 40%的数据，2 ≤n≤50，0&lt;w &lt;10^5；对于 60%的数据，2 ≤ n≤1000，0&lt;w &lt;10^6；对于 80%的数据，2 ≤ n≤10,000；对于 100%的数据，2≤m≤n≤50,000，0&lt;w &lt;10^9。 【Sample input】41 2 11 3 23 4 322 2 【Sample output】3 【Sample explanation】**第一支军队在 2 号点设立检查点，第二支军队从 2 号点移动到 3 号点设立检查点，所需时间为 3 个小时。 Record5h Analysis请先思考后再展开 显然就是让时间最长的最小，然后可以考虑二分然后，显然除了到根节点，其他时候深度越小越好，而且还是一棵树，那么就可以倍增搞一搞而且，对于那些在时限内无法到达根节点的点，直接跑到最高处即可于是，现在问题转化为：确定时限，判断【能到根节点而又余力的军队】和【没有接触瘟疫的根的子树】如何分配（显然过了根节点，就没有必要往深处走了） 然后又是一波贪心2333，首先把军队和子树从小到大排序一下情况①：同子树未覆盖，则优先覆盖（无条件），这样最节省资源情况②：只能找其他子树下的空缺，有可能无任何贡献这个方法的正确性是显而易见的，然鹅看到有人用奇奇怪怪的贪心也过去了……可能有人看到这个“显而易见”又不爽？补充一下对于一个a，如果本来是由b负责的，因为已经排好序，如果b不是搞a，而是搞a后面的c，把a交给了b后面的d，则可行性不变，不会更优 最后提醒一下：有一种错误的贪心（自己想错了……然后被自己卡了）就是把有余力的军队，留最短的那支去管理自己的但可能有一种情况：三个点，然后一个很长，没人有空余，一个中间，有一个空余，一个很短，有两个空余然后短的那部分，只能去中间长度的按照现在的做法，会强行把中间那个留下，但其实放到长那地方，短的派一个过来会更优 正确的做法是，先把自己不能到根再回来的留下一个（这种情况，到别的更短地方不会更优）那么剩下的就很好处理了，只要贪心的大管大即可其中第一步很重要，避免原本能管理自己的，因为【空余减去到根距离】太小，导致浪费 这个贪心，万一在考场上太激动，没想到这个反例，然后分数被卡炸就惨了…… Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int hou[MAXN];struct Edge&#123; int y,g; ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,ll c)&#123; e[++ln]=(Edge)&#123;y,hou[x],c&#125;;hou[x]=ln; e[++ln]=(Edge)&#123;x,hou[y],c&#125;;hou[y]=ln;&#125;//*******************预处理*******************int f[MAXN][20];ll ds[MAXN][20];void dfs(int x,int fa)&#123; f[x][0]=fa; for(int i=1;i&lt;=16;i++) &#123; f[x][i]=f[f[x][i-1]][i-1]; ds[x][i]=ds[x][i-1]+ds[f[x][i-1]][i-1]; if(f[x][i]==0) break; &#125; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; ds[y][0]=e[k].c; dfs(y,x); &#125;&#125;//*******************寻找*******************bool fg[MAXN];void dfs2(int x)&#123; if(fg[x]) return; bool son=0; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==f[x][0]) continue; son=1; dfs2(y); if(!fg[y]) return;//空缺 &#125; if(son) fg[x]=1;&#125;//*******************统计和分配*******************int na,nb;struct Nod//有余力的军队、空缺的【根节点下子树】&#123; int id;//【根节点下子树】编号 ll rst;//长度&#125;sa[MAXN],sb[MAXN];bool cmp(Nod a,Nod b) &#123;return a.rst&lt;b.rst;&#125;void presb()&#123; for(int k=hou[1];k&gt;0;k=e[k].g) &#123; int y=e[k].y; dfs2(y); if(!fg[y]) sb[++nb]=(Nod)&#123;y,e[k].c&#125;; &#125;&#125;//*******************验证*******************int n,m;int army[MAXN];bool check(ll mid)&#123; na=nb=0; memset(fg,0,sizeof(fg)); for(int i=1;i&lt;=m;i++) &#123; int x=army[i];ll now=0;//已走长度 for(int j=16;j&gt;=0;j--) if(f[x][j]&gt;1 and now+ds[x][j]&lt;=mid)//非0且非根节点 now+=ds[x][j],x=f[x][j]; if(f[x][0]==1) sa[++na]=(Nod)&#123;x,mid-now-ds[x][0]&#125;; else fg[x]=1;//debug &#125; presb(); if(na&lt;nb) return 0; sort(sa+1,sa+na+1,cmp); sort(sb+1,sb+nb+1,cmp); int x=1; for(int i=1;i&lt;=na;i++) &#123; if(!fg[sa[i].id]) fg[sa[i].id]=1;//优先同子树 else &#123; if(sa[i].rst&gt;=sb[x].rst) fg[sb[x++].id]=1; else ;//无用 &#125; while(x&lt;=nb and fg[sb[x].id]) x++;//准备 &#125; return x&gt;nb;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,ll(c)); &#125; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;army[i]); dfs(1,0); ll l=0,r=ll(INF)*n,ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1083】借教室]]></title>
    <url>%2Fposts%2Fb9a5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T2Luogu1083Caioj1555 Problem【Brief description】在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。面对海量租借教室的信息，我们自然希望编程解决这个问题。我们需要处理接下来n天的借教室信息，其中第i天学校有$ri$个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为$dj,sj,tj$，表示某租借者需要从第$sj$天到第$tj$天租借教室（包括第$sj$天和第$tj$天），每天需要租借$dj$个教室。我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$dj$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$sj$天到第$tj$天中有至少一天剩余的教室数量不足$dj$个。现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。【Input】第一行包含两个正整数n,m，表示天数和订单的数量。第二行包含n个正整数，其中第i个数为$ri$，表示第i天可用于租借的教室数量。接下来有m行，每行包含三个正整数$dj,sj,tj$，表示租借的数量，租借开始、结束分别在第几天。每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。【Output】如果所有订单均可满足，则输出只有一行，包含一个整数 0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。【Limited conditions】对于10%的数据，有1≤ n,m≤ 10；对于30%的数据，有1≤ n,m≤1000；对于 70%的数据，有1 ≤ n,m ≤ 10^5；对于 100%的数据，有1 ≤ n,m ≤ 10^6,0 ≤ ri,dj≤ 10^9,1 ≤ sj≤ tj≤ n。【Sample input】4 32 5 4 32 1 33 2 44 2 4【Sample output】-12【Sample explanation】第 1 份订单满足后，4 天剩余的教室数分别为 0，3，2，3。第 2 份订单要求第 2 天到第 4 天每天提供 3 个教室，而第 3 天剩余的教室数为 2，因此无法满足。分配停止，通知第 2 个申请人修改订单。 Record2h upd 2019.10.5 一个线性做法：见oi之路的【一类线性二分】 Analysis1请先思考后再展开 先来个线段树 区间最小值和区间减小，打个lazy标记 然后网上说的70分，却拿到了95 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int l,r,mid; int lc,rc; int mi,lz;&#125;p[MAXN*2];int a[MAXN];//*******************实现*******************int ln=0;int build(int l,int r)&#123; int t=++ln; int mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; p[t]=(Nod)&#123;l,r,mid,build(l,mid),build(mid+1,r),0,0&#125;; p[t].mi=mymin(p[p[t].lc].mi,p[p[t].rc].mi); &#125; else p[t]=(Nod)&#123;l,r,mid,-1,-1,a[l],0&#125;; return t;&#125;void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(lc&gt;0) p[lc].mi+=p[x].lz,p[lc].lz+=p[x].lz; if(rc&gt;0) p[rc].mi+=p[x].lz,p[rc].lz+=p[x].lz; p[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].mi+=c; p[x].lz+=c; return; &#125; if(p[x].lz!=0) update(x); int lc=p[x].lc,rc=p[x].rc; if(r&lt;=p[x].mid) change(lc,l,r,c); else if(l&gt;p[x].mid) change(rc,l,r,c); else change(lc,l,p[x].mid,c),change(rc,p[x].mid+1,r,c); p[x].mi=mymin(p[p[x].lc].mi,p[p[x].rc].mi);&#125;int ask(int x,int l,int r)&#123; if(p[x].l==l and p[x].r==r) return p[x].mi; if(p[x].lz!=0) update(x); int lc=p[x].lc,rc=p[x].rc; if(r&lt;=p[x].mid) return ask(lc,l,r); if(l&gt;p[x].mid) return ask(rc,l,r); return mymin(ask(lc,l,p[x].mid),ask(rc,p[x].mid+1,r));&#125;//*******************主函数*******************int qread()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) a[i]=qread(); build(1,n); for(int i=1;i&lt;=m;i++) &#123; int d=qread(),l=qread(),r=qread(); if(ask(1,l,r)&gt;=d) change(1,l,r,-d); else &#123; printf("-1\n%d",i); return 0; &#125; &#125; printf("0");&#125; Analysis2请先思考后再展开 网上看到了针对区间修改的”永久标记“，于是试一发 然鹅并没有任何卵用 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int l,r,mid; int lc,rc; int mi,lz;&#125;p[MAXN*2];int a[MAXN];//*******************实现*******************int ln=0;int build(int l,int r)&#123; int t=++ln; int mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; p[t]=(Nod)&#123;l,r,mid,build(l,mid),build(mid+1,r),0,0&#125;; p[t].mi=mymin(p[p[t].lc].mi,p[p[t].rc].mi); &#125; else p[t]=(Nod)&#123;l,r,mid,-1,-1,a[l],0&#125;; return t;&#125;void change(int x,int l,int r,int c)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].mi+=c; p[x].lz+=c; return; &#125; if(r&lt;=p[x].mid) change(p[x].lc,l,r,c); else if(l&gt;p[x].mid) change(p[x].rc,l,r,c); else change(p[x].lc,l,p[x].mid,c),change(p[x].rc,p[x].mid+1,r,c); p[x].mi=mymin(p[p[x].lc].mi,p[p[x].rc].mi)+p[x].lz;&#125;int ask(int x,int l,int r,int lz)//注意标记叠加&#123; if(p[x].l==l and p[x].r==r) return p[x].mi+lz;//debug if(r&lt;=p[x].mid) return ask(p[x].lc,l,r,lz+p[x].lz); if(l&gt;p[x].mid) return ask(p[x].rc,l,r,lz+p[x].lz); return mymin(ask(p[x].lc,l,p[x].mid,lz+p[x].lz),ask(p[x].rc,p[x].mid+1,r,lz+p[x].lz));&#125;//*******************主函数*******************int qread()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) a[i]=qread(); build(1,n); for(int i=1;i&lt;=m;i++) &#123; int d=qread(),l=qread(),r=qread();//scanf("%d%d%d",&amp;d,&amp;l,&amp;r); if(ask(1,l,r,0)&gt;=d) change(1,l,r,-d); else &#123; printf("-1\n%d",i); return 0; &#125; &#125; printf("0");&#125; Analysis3请先思考后再展开 现在的目的就是加速辣 区间修改$O(Klogn)$ （减法） 区间验证$O(Klogn)$ （找最小值） 总时间$O(m\times 2Klogn)$ 其中K是由于区间修改而导致的复杂度上升，当然打标记已经尽量优化了，多大我也不知道 那如果引入差分呢？ 区间修改$O(1)$ 区间验证$O(n)$ （暴力验证） 那么这个差分乍一看是没有这么优秀的，看起来像个暴力，但是具体实现也有两种： ①一个个搞过去，总时间$O(m\times n)$ ②二分验证，验证的时候要花一点时间在把前面订单搞定，总时间$O(logm\times (m+n))$ 于是，采用②，时间才会真正达到$O(nlogn)$的复杂度 而区间修改的线段树则有点危险 这tm怎么想得到？？？ Code3请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int n;int a[MAXN],s[MAXN];int d[MAXN],st[MAXN],ed[MAXN];//*******************实现*******************bool check(int mid)&#123; memset(s,0,sizeof(s));//需求量 for(int i=1;i&lt;=mid;i++) s[st[i]]+=d[i],s[ed[i]+1]-=d[i]; int sum=0; for(int i=1;i&lt;=n;i++) &#123; sum+=s[i]; if(sum&gt;a[i]) return 0; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;d[i],&amp;st[i],&amp;ed[i]); int l=1,r=m,ans=-1;//最左的 while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(!check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(ans&lt;0) printf("0"); else printf("-1\n%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1082】同余方程]]></title>
    <url>%2Fposts%2Fad35.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D2T1Luogu1082Caioj1554 Problem【Brief description】求关于 x 的同余方程 $ax ≡ 1 (\mod b)$的最小正整数解。 【Input】输入只有一行，包含两个正整数 a, b，用一个空格隔开。 【Output】输出只有一行，包含一个正整数 x0，即最小正整数解。输入数据保证一定有解。 【Limited conditions】对于 40%的数据，2 ≤b≤ 1,000；对于 60%的数据，2 ≤b≤ 50,000,000；对于 100%的数据，2 ≤a, b≤ 2,000,000,000。 【Sample input】3 10 【Sample output】7 【Sample explanation】**无 Record10min Analysis请先思考后再展开 经典题 详见【OI之路】02数论算法-1公约数公倍数与欧几里得 Code请先思考后再展开 12345678910111213141516171819202122232425int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1;y=0; return a; &#125; int tx,ty; int t=exgcd(b,a%b,tx,ty); x=ty; y=tx-(a/b)*ty; return t;&#125;int main()&#123; int a,b;scanf("%d%d",&amp;a,&amp;b); int A=a,B=b,K=1; int x,y; int gcd=exgcd(A,B,x,y); x=x*(K/gcd); int t=B/K; int XX=(x%t+t)%t; printf("%d",XX);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>拓展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1081】开车旅行]]></title>
    <url>%2Fposts%2Ff1fd.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T3Luogu1081Caioj1553 Problem【Brief description】现在有n个城市，每个城市有它的高度Hi，保证每个Hi互不相同。我们定义两个城市之间的距离$disi,j=|Hi−Hj|$，并且只能从编号小的城市去到编号大的城市。现在有两个人，小A和小B要开车去旅行。小A先开一天，小B再开一天。每一天都可以从一个开到另一个城市。小A会选择去离当前城市第二近的城市，小B会选择去离当前城市最近的那个城市（如果两个城市与现在距离相同，则认为高度低的更近）。如果他们行驶的总路程将会超过给定的X就会不继续开车，结束旅行。求：1：给定一个X，求从哪一个城市出发，【小A行驶的路程/小B行驶的路程】最小（认为一个非0数/0=∞）。若有多个城市相等，选择高度最高的那个。2：给出m个询问，每次询问从S出发，限制为X，小A走的路程和小B走的路程。【Input】第一行包含一个整数 N，表示城市的数目。第二行有 N 个整数，每两个整数之间用一个空格隔开，依次表示城市 1 到城市 N 的海拔高度，即 H1，H2，……，Hn，且每个 Hi都是不同的。第三行包含一个整数 X0。第四行为一个整数 M，表示给定 M 组 Si 和 Xi。接下来的 M 行，每行包含 2 个整数 Si 和 Xi，表示从城市 Si出发，最多行驶 Xi公里。【Output】第一行包含一个整数 S0，表示对于给定的 X0，从编号为 S0的城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值最小。接下来的 M 行，每行包含 2 个整数，之间用一个空格隔开，依次表示在给定的 Si 和 Xi 下小 A 行驶的里程总数和小 B 行驶的里程总数。【Limited conditions】对于30%的数据，有1≤N≤20，1≤M≤20；对于40%的数据，有1≤N≤100，1≤M≤100；对于50%的数据，有1≤N≤100，1≤M≤1,000；对于70%的数据，有1≤N≤1,000，1≤M≤10,000；对于100%的数据，有1≤N≤100,000，1≤M≤100,000，-1,000,000,000≤Hi≤1,000,000,000，0≤X0≤1,000,000,000，1≤Si≤N，0≤Xi≤1,000,000,000，数据保证Hi 互不相同。【Sample input 1】42 3 1 4341 32 33 34 3【Sample output 1】11 12 00 00 0【Sample input 2】104 5 6 1 2 3 7 8 9 107101 72 73 74 75 76 77 78 79 710 7【Sample output 2】23 22 42 12 45 15 12 12 00 00 0【Sample explanation】【输入输出样例 1 说明】各个城市的海拔高度以及两个城市间的距离如上图所示。如果从城市 1 出发，可以到达的城市为 2,3,4，这几个城市与城市 1 的距离分别为 1,1,2，但是由于城市 3 的海拔高度低于城市 2，所以我们认为城市 3 离城市 1 最近，城市 2 离城市1 第二近，所以小 A 会走到城市 2。到达城市 2 后，前面可以到达的城市为 3,4，这两个城市与城市 2 的距离分别为 2,1，所以城市 4 离城市 2 最近，因此小 B 会走到城市 4。到达城市 4 后，前面已没有可到达的城市，所以旅行结束。如果从城市 2 出发，可以到达的城市为 3,4，这两个城市与城市 2 的距离分别为 2,1，由于城市 3 离城市 2 第二近，所以小 A 会走到城市 3。到达城市 3 后，前面尚未旅行的城市为4，所以城市 4 离城市 3 最近，但是如果要到达城市 4，则总路程为 2+3=5&gt;3，所以小 B 会直接在城市 3 结束旅行。如果从城市 3 出发，可以到达的城市为 4，由于没有离城市 3 第二近的城市，因此旅行还未开始就结束了。如果从城市 4 出发，没有可以到达的城市，因此旅行还未开始就结束了。【输入输出样例 2 说明】当 X=7 时， 如果从城市 1 出发，则路线为 1 -&gt; 2 -&gt; 3 -&gt; 8 -&gt; 9，小 A 走的距离为 1+2=3，小 B 走的距离为 1+1=2。（在城市 1 时，距离小 A 最近的城市是 2 和 6，但是城市 2 的海拔更高，视为与城市 1 第二近的城市，所以小 A 最终选择城市 2；走到 9 后，小 A 只有城市 10 可以走，没有第 2 选择可以选，所以没法做出选择，结束旅行）如果从城市 2 出发，则路线为 2 -&gt; 6 -&gt; 7 ，小 A 和小 B 走的距离分别为 2，4。如果从城市 3 出发，则路线为 3 -&gt; 8 -&gt; 9，小 A 和小 B 走的距离分别为 2，1。如果从城市 4 出发，则路线为 4 -&gt; 6 -&gt; 7，小 A 和小 B 走的距离分别为 2，4。如果从城市 5 出发，则路线为 5 -&gt; 7 -&gt; 8 ，小 A 和小 B 走的距离分别为 5，1。如果从城市 6 出发，则路线为 6 -&gt; 8 -&gt; 9，小 A 和小 B 走的距离分别为 5，1。如果从城市 7 出发，则路线为 7 -&gt; 9 -&gt; 10，小 A 和小 B 走的距离分别为 2，1。如果从城市 8 出发，则路线为 8 -&gt; 10，小 A 和小 B 走的距离分别为 2，0。如果从城市 9 出发，则路线为 9，小 A 和小 B 走的距离分别为 0，0（旅行一开始就结束了）。如果从城市10出发，则路线为 10，小A 和小B 走的距离分别为0，0。从城市 2 或者城市 4 出发小 A 行驶的路程总数与小 B 行驶的路程总数的比值都最小，但是城市 2 的海拔更高，所以输出第一行为 2。 Record3h Analysis请先思考后再展开 其实这东西有点类似弹飞绵羊，但是因为那个有修改，所以分块更优，而这个不修改，所以搞个倍增。 那么有一个很关键的东西，就是确定，每个点，A和B开一次车会到哪里（即最近和次近） 那么如果模拟需要$O(n^2)$，不过70分的暴力分也算挺多的了 那么有一种显然的思想，就是排序，这样就到了$O(nlogn)$，不过怎么处理只能向右这个条件？ 网上有很多种方法啊，其中双向链表和set还是比较好理解的，当然线段树也可以但麻烦，至于并查集？？懵逼 那么一开始尝试set，发现接口不是很友好啊，那还是自己实现算了，虽然有点麻烦但不算难 20行，半个小时过去了…… 然后正如上面所说的，可以愉快地倍增了 注意到A和B是交替开车的，所以定义交替一次为一轮。 $A[x][i]$=在x点开始，走$2^i$轮，A走过的距离 B数组同理 $m[x][i]$=在x点开始，走$2^i$轮，到达的点 然后预处理倍增一下 然后回答询问： 第一个，枚举每一个点倍增回答，$O(nlogx)$ 后面的，倍增回答，共$O(mlogx)$ Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=110000; const ll INF=(1ll&lt;&lt;62); int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int bin[40]; int n; struct Lb &#123; int d; int l,r; int pos; Lb() &#123; pos=-1; &#125; &#125;lb[MAX_N]; int fd[MAX_N];//原数列对应链表编号 bool cmp(Lb a,Lb b) &#123;return a.d&lt;b.d;&#125; ll dis(int x,int y) &#123;return (x==0 or y==0 or x&gt;n or y&gt;n)?INF:myabs(lb[x].d-lb[y].d);&#125; int h[MAX_N]; int nx1[MAX_N],nx2[MAX_N];//没有则-1 void pre()//预处理最大和次大 &#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]*2; for(int i=1;i&lt;=n;i++) lb[i].d=h[i],lb[i].pos=i; sort(lb+1,lb+n+1,cmp); for(int i=1;i&lt;=n;i++) lb[i].l=i-1,lb[i].r=i+1,fd[lb[i].pos]=i; memset(nx1,-1,sizeof nx1); memset(nx2,-1,sizeof nx2); for(int i=1;i&lt;=n;i++)//左到右 &#123; int x=fd[i]; int fl=lb[x].l,fr=lb[x].r; int fll=lb[fl].l,frr=lb[fr].r; ll a=dis(fll,x),b=dis(fl,x),c=dis(fr,x),d=dis(frr,x); if(b==c) nx1[i]=lb[fl].pos,nx2[i]=lb[fr].pos; else if(b&lt;c) &#123; nx1[i]=lb[fl].pos; if(a&lt;=c) nx2[i]=lb[fll].pos; else nx2[i]=lb[fr].pos; &#125; else &#123; nx1[i]=lb[fr].pos; if(b&lt;=d) nx2[i]=lb[fl].pos; else nx2[i]=lb[frr].pos; &#125; //printf("%d=%d,%d\n",i,nx1[i],nx2[i]); lb[fl].r=fr;lb[fr].l=fl; &#125; &#125; ll fa[MAX_N][30],fb[MAX_N][30]; int ed[MAX_N][30];//没有则-1 void pre2()//预处理倍增 &#123; memset(ed,-1,sizeof ed); for(int i=1;i&lt;=n;i++) &#123; if(nx2[i]&gt;0) fa[i][0]=myabs(h[i]-h[nx2[i]]); if(nx2[i]&gt;0 and nx1[i]&gt;0) fb[i][0]=myabs(h[nx2[i]]-h[nx1[nx2[i]]]); ed[i][0]=nx1[nx2[i]]; &#125; for(int t=1;t&lt;=20;t++) for(int x=1;x&lt;=n;x++) &#123; if(ed[x][t-1]&lt;=0) continue; fa[x][t]=fa[x][t-1]+fa[ed[x][t-1]][t-1]; fb[x][t]=fb[x][t-1]+fb[ed[x][t-1]][t-1]; ed[x][t]=ed[ed[x][t-1]][t-1]; &#125; &#125; ll Ta,Tb; void solve(int st,ll mx) &#123; Ta=Tb=0; for(int i=20;i&gt;=0;i--) &#123; if(ed[st][i]&gt;0 and Ta+fa[st][i]+Tb+fb[st][i]&lt;=mx) &#123; Ta+=fa[st][i]; Tb+=fb[st][i]; st=ed[st][i]; &#125; &#125; if(nx2[st]&gt;0 and Ta+fa[st][0]+Tb&lt;=mx) Ta+=fa[st][0]; &#125; void solve1() &#123; int x0;scanf("%d",&amp;x0); double ans=-1;int id=-1; for(int st=1;st&lt;=n;st++) &#123; solve(st,x0); double t=(Tb==0)?INF:(double)Ta/Tb; if(ans&lt;0 or t&lt;ans or (t==ans and h[st]&gt;h[id])) ans=t,id=st; &#125; printf("%d\n",id); &#125; void solve2() &#123; int st,mx;scanf("%d%d",&amp;st,&amp;mx); solve(st,mx); printf("%lld %lld\n",Ta,Tb); &#125; void main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;h[i]); pre(); pre2(); solve1(); int q;scanf("%d",&amp;q); while(q--) solve2(); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1080】国王游戏]]></title>
    <url>%2Fposts%2F1b05.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T2Luogu1080Caioj1552 Problem【Brief description】恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。【Input】第一行包含一个整数 n，表示大臣的人数。第二行包含两个整数 a和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。【Output】输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。【Limited conditions】对于 20%的数据，有 1≤ n≤ 10，0 &lt; a、b &lt; 8；对于 40%的数据，有 1≤ n≤20，0 &lt; a、b &lt; 8；对于 60%的数据，有 1≤ n≤100；对于 60%的数据，保证答案不超过 10^9；对于 100%的数据，有 1 ≤ n ≤1,000，0 &lt; a、b &lt; 10000。【Sample input】31 12 37 44 6【Sample output】2【Sample explanation】按 1、2、3 号大臣这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 1、3、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 2、1、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 2、3、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9；按 3、1、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；按 3、2、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9。因此，奖赏最多的大臣最少获得 2 个金币，答案输出 2。 Record1h Analysis请先思考后再展开 根据贪心，我们可以证明用每个人左右手乘积从小到大排序，是最优解。 证明：贪心有种证明方式叫做微扰就是说证明，对于任意两个相邻的元素，最优解中，把他们交换可能得到更坏的结果。 那么在本题中就是，设大臣1和大臣2，他们是相邻的 身份 左手 右手 国王 a0 …… …… （乘积省略到a0中） …… 大臣1 a1 b1 …… XXX …… 大臣2 a2 b2 …… …… …… 则有两种方案：方案① 大臣1在前：$A=\frac{a0}{b1}$$B=XXX\times a0\times \frac{a1}{b2}$$ANS1=max(A,B)$ 方案② 大臣2在前：$C=\frac{a0}{b2}$$D=XXX\times a0 \times \frac{a2}{b1}$$ANS2=max(C,D)$ 选择小的那个方案就是最优解 由于都是正整数，已知$A\leq D$$C\leq B$关于A和B的大小关系，又有两种情况情况① $A&lt;B$，则$A,C \leq B,D$，根据B,D大小决策【等价于左右手乘积小的在前面】情况② $A\geq B$，则$C \leq B \leq A \leq D$，可以直接选择方案② 但现在有两种决策方案，显然不利于实现我们可以把情况②看作情况①的一部分因为如果按照乘积比较的话，能得到同样的结果 综上所述，对于相邻的两个元素，乘积小的应该在前面那么根据冒泡排序，我们可以通过交换相邻元素去消除逆序对当逆序对数=0时是最优的，也就是可以通过排序得到最优解。 然后极限是$10000^{1000}$，即4000个位……所以要写高精度的乘和除（还好是与单精度的，不然真的不会） 最后，感谢这位大佬League丶翎在我解题过程中的耐心解释 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Boy&#123; int a,b; ll ab;&#125;p[MAXN];bool cmp(Boy a,Boy b) &#123;return a.ab&lt;b.ab;&#125;//*******************实现*******************struct Bnum&#123; int a[4100],ln; Bnum() &#123; memset(a,0,sizeof(a)); &#125;&#125;;Bnum cheng(Bnum a,int b)&#123; Bnum c;c.ln=a.ln; for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]*b; if(c.a[i]&gt;9) &#123; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;Bnum chu(Bnum a,int b)&#123; Bnum c;c.ln=a.ln; int ys=0; for(int i=c.ln;i&gt;=1;i--) &#123; ys=ys*10+a.a[i]; c.a[i]=ys/b; ys%=b; &#125; for(int i=1;i&lt;=c.ln;i++) if(c.a[i]&gt;9) &#123; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; if(i==c.ln) c.ln++; &#125; while(c.ln&gt;1 and c.a[c.ln]==0) c.ln--; return c;&#125;bool comp(Bnum a,Bnum b)&#123; if(a.ln!=b.ln) return a.ln&lt;b.ln; for(int i=a.ln;i&gt;=1;i--) if(a.a[i]!=b.a[i]) return a.a[i]&lt;b.a[i]; return a.a[0]&lt;b.a[0];&#125;//*******************主函数*******************Bnum now,tmp,ans;int main()&#123; int n;scanf("%d",&amp;n); for(int i=0;i&lt;=n;i++) &#123; scanf("%d%d",&amp;p[i].a,&amp;p[i].b); p[i].ab=ll(p[i].a)*p[i].b; &#125; sort(p+1,p+n+1,cmp); now.a[1]=1;now.ln=1;now=cheng(now,p[0].a); for(int i=1;i&lt;=n;i++) &#123; tmp=chu(now,p[i].b); if(comp(ans,tmp)) ans=tmp; now=cheng(now,p[i].a); &#125; for(int i=ans.ln;i&gt;=1;i--) printf("%d",ans.a[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1079】Vigenère密码]]></title>
    <url>%2Fposts%2F745a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2012 提高组 D1T1Luogu1079Caioj1551 Problem【Brief description】16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法――Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。在密码学中，我们称需要加密的信息为明文，用 M 表示；称加密后的信息为密文，用C 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 k。在 Vigenère 密码中，密钥 k 是一个字母串，k=k1k2…kn。当明文 M=m1m2…mn时，得到的密文 C=c1c2…cn，其中 ci=mi®ki，运算®的规则如下表所示：Vigenère 加密在操作时需要注意：1. ®运算忽略参与运算的字母的大小写，并保持字母在明文 M 中的大小写形式；2. 当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。【Input】第一行为一个字符串，表示密钥 k，长度不超过 100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过 1000，其中仅包含大小写字母。【Output】一个字符串，表示输入密钥和密文所对应的明文。【Limited conditions】对于10% 的数据，k=0 ；对于20% 的数据，k=1 ；对于40% 的数据，2 ≤ n ≤ 50，1 ≤ m ≤ 1,000，0 ≤ k ≤ 20，0 ≤ Di ≤ 10，0 ≤ T i ≤ 500；对于60% 的数据，1 ≤ n ≤ 100，1 ≤ m ≤ 1,000，0 ≤ k ≤ 100 ，0 ≤ Di ≤ 100，0 ≤ T i ≤ 10,000 ；对于100%的数据，1 ≤ n ≤ 1,000，1 ≤ m ≤ 10,000 ，0 ≤ k ≤ 100,000，0 ≤ Di ≤ 100 ，0 ≤ T i ≤ 100,000。【Sample input】CompleteVictoryYvqgpxaimmklongnzfwpvxmniytm【Sample output】Wherethereisawillthereisaway【Sample explanation】输入的密钥的长度不超过 100，输入的密文的长度不超过 1000，且都仅包含英文字母。 Record10min Analysis请先思考后再展开 设‘a’为0 ci=(mi+ki)%26 mi=(ci-ki+26)%26 Code请先思考后再展开 123456789101112131415161718192021char k[110],c[1100];char m[1100];char getm(char cc,char kk)&#123; if(cc&gt;='A' and cc&lt;='Z') cc-='A'; else cc-='a'; if(kk&gt;='A' and kk&lt;='Z') kk-='A'; else kk-='a'; return 'a'+(26+cc-kk)%26;&#125;int main()&#123; scanf("%s%s",k+1,c+1); int ln1=strlen(c+1),ln2=strlen(k+1); int t=1; for(int i=1;i&lt;=ln1;i++) &#123; m[i]=getm(c[i],k[t]); if(c[i]&gt;='A' and c[i]&lt;='Z') m[i]+='A'-'a'; t++;if(t&gt;ln2) t=1; &#125; puts(m+1);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1315】观光公交]]></title>
    <url>%2Fposts%2Fb81a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T3Luogu1315Caioj1550 Problem【Brief description】风景迷人的小城Y 市，拥有n 个美丽的景点。由于慕名而来的游客越来越多，Y 市特意安排了一辆观光公交车，为游客提供更便捷的交通服务。观光公交车在第 0 分钟出现在 1号景点，随后依次前往 2、3 、4 ……n 号景点。从第 i 号景点开到第 i+1 号景点需要 Di 分钟。任意时刻，公交车只能往前开，或在景点处等待。设共有m 个游客，每位游客需要乘车1 次从一个景点到达另一个景点，第i 位游客在Ti 分钟来到景点 Ai ，希望乘车前往景点Bi （Ai&lt;Bi ）。为了使所有乘客都能顺利到达目的地，公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。假设乘客上下车不需要时间。一个乘客的旅行时间，等于他到达目的地的时刻减去他来到出发地的时刻。因为只有一辆观光车，有时候还要停下来等其他乘客，乘客们纷纷抱怨旅行时间太长了。于是聪明的司机ZZ给公交车安装了 k 个氮气加速器，每使用一个加速器，可以使其中一个 Di 减1 。对于同一个Di 可以重复使用加速器，但是必须保证使用后Di 大于等于0 。那么ZZ该如何安排使用加速器，才能使所有乘客的旅行时间总和最小？【Input】第 1 行是3 个整数n, m, k ，每两个整数之间用一个空格隔开。分别表示景点数、乘客数和氮气加速器个数。第 2 行是n-1 个整数，每两个整数之间用一个空格隔开，第i 个数表示从第i 个景点开往第i+1 个景点所需要的时间，即 Di 。第 3 行至m+2 行每行 3 个整数 Ti, Ai, Bi，每两个整数之间用一个空格隔开。第 i+2 行表示第i 位乘客来到出发景点的时刻，出发的景点编号和到达的景点编号。【Output】共一行，包含一个整数，表示最小的总旅行时间。【Limited conditions】对于10% 的数据，k=0 ；对于20% 的数据，k=1 ；对于40% 的数据，2 ≤ n ≤ 50，1 ≤ m ≤ 1,000，0 ≤ k ≤ 20，0 ≤ Di ≤ 10，0 ≤ T i ≤ 500；对于60% 的数据，1 ≤ n ≤ 100，1 ≤ m ≤ 1,000，0 ≤ k ≤ 100 ，0 ≤ Di ≤ 100，0 ≤ T i ≤ 10,000 ；对于100%的数据，1 ≤ n ≤ 1,000，1 ≤ m ≤ 10,000 ，0 ≤ k ≤ 100,000，0 ≤ Di ≤ 100 ，0 ≤ T i ≤ 100,000。【Sample input】3 3 21 40 1 31 1 25 2 3【Sample output】10【Sample explanation】对D2 使用2 个加速器，从2 号景点到 3 号景点时间变为 2 分钟。公交车在第1 分钟从1 号景点出发，第2 分钟到达2 号景点，第5 分钟从2 号景点出发，第7 分钟到达 3 号景点。第1 个旅客旅行时间 7-0 = 7 分钟。第2 个旅客旅行时间 2-1 = 1 分钟。第3 个旅客旅行时间 7-5 = 2 分钟。总时间 7+1+2 = 10分钟。 Record6h Analysis1请先思考后再展开 首先，对于同一个点上车的乘客，除了最后那一个，其他人什么时候到达时没有关系的，只影响答案统计但不影响决策，因为他在这个点的等待时间无法改变，所以用lst[i]表示第i个点最后到的人的时间。 先定义几个数组 $tot[t]$=在t点下车的乘客数量 $arr[ t]$=当前方案，开车到t点的时间=$max(arr[t-1],lst[t-1])+d[t]$ 那么思考在什么地方用加速器呢？可以考虑贪心一下 假如要对$(t-1,t)$这条边加速， ①$lst[t]\geq arr[t]$，则对于【不在i点下车的乘客】，旅行时间不变，贡献$tot[t]$ ②$lst[t]&lt;arr[t]​$，贡献$\sum_{i=t}^{g[t]} tot[i]​$，g[t]是当前连续情况②的最后一个，因为一旦碰到①又要等了 然后tot不变，可以搞个前缀和 总结：把没有加速的答案先搞定，然后一个个贪心 复杂度：$O(kn)$ 至于数据……别管了很伪的，反正不会T 但是为什么能贪心呢？这个我没相通，因为感觉决策是变化很大的 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int t,st,ed;&#125;p[11000];int d[MAXN];int tot[MAXN];int arr[MAXN],lst[MAXN];int g[MAXN];//最后影响点//*******************实现*******************//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;p[i].t,&amp;p[i].st,&amp;p[i].ed); lst[p[i].st]=mymax(lst[p[i].st],p[i].t); tot[p[i].ed]++; &#125; for(int i=2;i&lt;=n;i++) tot[i]+=tot[i-1]; arr[1]=lst[1];//debug for(int i=2;i&lt;=n;i++) arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; int ans=0;for(int i=1;i&lt;=m;i++) ans+=arr[ p[i].ed ]-p[i].t; while(k--) &#123; g[n-1]=n;for(int i=n-2;i&gt;=1;i--) g[i]=(arr[i+1]&lt;=lst[i+1])?i+1:g[i+1]; int mx=0,t=-1; for(int i=1;i&lt;=n-1;i++)//i~i+1 if(d[i]&gt;0 and mx&lt;tot[g[i]]-tot[i]) &#123; mx=tot[g[i]]-tot[i]; t=i; &#125; if(t&lt;0) break; ans-=mx;d[t]--; for(int i=2;i&lt;=n;i++) arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; &#125; printf("%d",ans);&#125; Analysis2请先思考后再展开 费用流~ 感觉思路真的很妙，不好想 但还是很好理解的，而且比贪心慢不了太多，但感觉特别稳 核心： 一次加速器，碰到$lst[t]\geq arr[t]$也就是上面的情况①就会停止 那么也就是说加速器个数超过$max(arr[i]-lst[i],0)$就停止影响 那么考虑把每一个点拆成【到达】和【离开】 然后用变化的【加速器分配方案】作为流量 则构图如下（i作为边i~i+1遍历）： 边 单位流量费用 流量 作用 $S\rightarrow S’$ 0 k 限制总个数 $S’\rightarrow i’$ 0 $d[i]$ $边权\geq 0$ $i’\rightarrow i+1$ $-tot[i+1]$ $INF$ 追求最小 $i\rightarrow i’$ 0 $max(arr[i]-lst[i],0)$ 确保影响范围 $i’\rightarrow T$ 0 $INF$ 统计答案 大功告成！ Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Boy&#123; int t,st,ed;&#125;b[11000];int d[MAXN];int tot[MAXN];int arr[MAXN],lst[MAXN];//*******************实现*******************struct Nod&#123; int hou; int dis; int fm,mic; bool v; Nod() &#123; hou=v=0; &#125;&#125;p[MAXN*2];struct Edge&#123; int y,w,c,g; int oth;&#125;e[MAXN*8];int ln=0;void ins(int x,int y,int c,int w)&#123; e[++ln]=(Edge)&#123;y,w,c,p[x].hou,ln+1&#125;;p[x].hou=ln; e[++ln]=(Edge)&#123;x,-w,0,p[y].hou,ln-1&#125;;p[y].hou=ln;&#125;int cost;int q[MAXN*3];bool spfa(int st,int ed)&#123; for(int i=1;i&lt;=ed;i++) p[i].dis=p[i].mic=INF; int tou=1,wei=2;q[1]=st; p[st].v=1;p[st].dis=0;p[st].mic=INF;//debug while(tou!=wei) &#123; int x=q[tou++];if(tou==MAXN) tou=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].w and e[k].c&gt;0) &#123; p[y].dis=p[x].dis+e[k].w; p[y].mic=mymin(p[x].mic,e[k].c); p[y].fm=k; if(!p[y].v) &#123; p[y].v=1; q[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125; if(p[ed].dis==INF) return 0; cost+=p[ed].mic*p[ed].dis; int x=ed; while(x!=st) &#123; e[p[x].fm].c-=p[ed].mic; e[e[p[x].fm].oth].c+=p[ed].mic; x=e[e[p[x].fm].oth].y; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;b[i].t,&amp;b[i].st,&amp;b[i].ed); lst[b[i].st]=mymax(lst[b[i].st],b[i].t); tot[b[i].ed]++; &#125; arr[1]=lst[1];//debug for(int i=2;i&lt;=n;i++) arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; int st=2*n+1,st2=st+1,ed=st+2; ins(st,st2,k,0); for(int i=1;i&lt;=n-1;i++) &#123; ins(st2,n+i,d[i],0); ins(i,n+i,mymax(arr[i]-lst[i],0),0); ins(n+i,i+1,INF,-tot[i+1]); ins(i+1,ed,INF,0); &#125; int ans=0;for(int i=1;i&lt;=m;i++) ans+=arr[ b[i].ed ]-b[i].t; cost=0;while(spfa(st,ed)) ; printf("%d",ans+cost);&#125; Analysis3请先思考后再展开 然后猛地发现，虽然上面两种看起来都灰常快，事实上跑官方数据也确实算快 然鹅，理论复杂度都是灰常大的 有没有更快的呢？我才不会告诉你这几个解法我一个都没想到 其实优化一下贪心就好了 把arr的更新，从全部减少为更新范围（根据上面的限制公式） 每次用多几个加速器（根据上面的限制公式） 然后速度就从700ms到了12ms…… Code3请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int t,st,ed;&#125;p[11000];int d[MAXN];int tot[MAXN];int arr[MAXN],lst[MAXN];int g[MAXN];//最后影响点//*******************实现*******************int n,m,k;int ans=0;bool solve()&#123; int best_tot=0,best_i,best_wei; int now_k=INF,best_k=INF; int wei=n;//之前的g[] for(int i=n-1;i&gt;=1;i--)//i~i+1 &#123; if(arr[i+1]&lt;=lst[i+1]) &#123; now_k=arr[i+1]; wei=i+1; &#125; else now_k=mymin(now_k,arr[i+1]-lst[i+1]); if(d[i]&gt;0 and best_tot&lt;tot[wei]-tot[i]) &#123; best_tot=tot[wei]-tot[i]; best_i=i; best_wei=wei; best_k=mymin(now_k,mymin(d[i],k)); &#125; &#125; if(best_k==0) return 0; k-=best_k; d[best_i]-=best_k; ans-=best_k*best_tot; for(int i=best_i+1;i&lt;=best_wei;i++) arr[i]-=best_k; return 1;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n-1;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;p[i].t,&amp;p[i].st,&amp;p[i].ed); lst[p[i].st]=mymax(lst[p[i].st],p[i].t); tot[p[i].ed]++; &#125; arr[1]=lst[1]; for(int i=2;i&lt;=n;i++) &#123; tot[i]+=tot[i-1]; arr[i]=mymax(arr[i-1],lst[i-1])+d[i-1]; &#125; for(int i=1;i&lt;=m;i++) ans+=arr[ p[i].ed ]-p[i].t; while(solve()) ; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>坑</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1314】聪明的质监员]]></title>
    <url>%2Fposts%2Fe6e5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T2Luogu1314Caioj1549 Problem【Brief description】小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有n个矿石，从1到n逐一编号，每个矿石都有自己的重量wi以及价值vi。检验矿产的流程是：1、给定m个区间[Li，Ri]；2、选出一个参数W；3、对于一个区间[Li，Ri]，计算矿石在这个区间上的 检验值Yi：$Y_i = (\sum\limits_j 1) * (\sum\limits_j v_j) , j \in [L_i,R_i] 且 w_j \ge W$即数量×价值和这批矿产的检验结果Y为各个区间的检验值之和。即：Y1+Y2…+Ym通过调整参数W 的值，使得S-Y 的绝对值最小。请你帮忙求出这个最小值。【Input】第一行包含三个整数n，m，S，分别表示矿石的个数、区间的个数和标准值。接下来的n 行，每行2个整数，中间用空格隔开，第i+1 行表示 i 号矿石的重量 wi 和价值vi。接下来的m 行，表示区间，每行2 个整数，中间用空格隔开，第i+n+1 行表示区间[Li,Ri]的两个端点Li 和Ri。【Output】输出只有一行，包含一个整数，表示所求的最小值。【Limited conditions】不同区间可能重合或相互重叠。对于10% 的数据，有 1 ≤n ，m≤10；对于30% 的数据，有 1 ≤n ，m≤500 ；对于50% 的数据，有 1 ≤n ，m≤5,000；对于70% 的数据，有 1 ≤n ，m≤10,000 ；对于100%的数据，有 1 ≤n ，m≤200,000，0 &lt; wi, vi≤10^6，0 &lt; S≤10^12，1 ≤ Li ≤ Ri ≤n 。【Sample input】5 3 151 52 53 54 55 51 52 43 3【Sample output】10【Sample explanation】当 W 选 4 的时候，三个区间上检验值分别为 20、5 、0 ，这批矿产的检验结果为 25，此时与标准值S 相差最小为10。 Record30min Analysis请先思考后再展开 首先这个W是满足二分答案的性质的，log2后大概是40 那我的想法是二份答案验证 但是如果一个一个区间搞，很容易被卡 考虑每次验证，构造两个前缀和 然后一个个区间统计即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=200010,MAXM=800010;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int w; ll v;&#125;p[MAXN];struct Qes&#123; int l,r;&#125;q[MAXN];int n,m;ll S;ll cnt[MAXN];ll sum[MAXN];//*******************实现*******************ll check(int w)&#123; cnt[0]=sum[0]=0; for(int i=1;i&lt;=n;i++) &#123; cnt[i]=cnt[i-1]+(p[i].w&gt;=w); sum[i]=sum[i-1]+p[i].v*(p[i].w&gt;=w); &#125; ll ans=0; for(int i=1;i&lt;=m;i++) ans+=(cnt[q[i].r]-cnt[q[i].l-1])*(sum[q[i].r]-sum[q[i].l-1]); return ans;&#125;ll solve()&#123; int l=0,r=1000000; ll ans=ll(INF)*INF; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; ll t=check(mid); if(t&gt;S) ans=mymin(ans,t-S),l=mid+1; else ans=mymin(ans,S-t),r=mid-1; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;S); for(int i=1;i&lt;=n;i++) scanf("%d%lld",&amp;p[i].w,&amp;p[i].v); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;q[i].l,&amp;q[i].r); printf("%lld",solve());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1313】计算系数]]></title>
    <url>%2Fposts%2F8493.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D2T1Luogu1313Caioj1548 Problem【Brief description】给定一个多项式(by+ax)^k，请求出多项式展开后x^n*y^m 项的系数。【Input】共一行，包含 5 个整数，分别为 a，b，k，n ，m，每两个整数之间用一个空格隔开。【Output】输出共1 行，包含一个整数，表示所求的系数，这个系数可能很大，输出对10007 取模后的结果。【Limited conditions】对于30% 的数据，有 0 ≤k ≤10 ；对于50% 的数据，有 a = 1，b = 1；对于100%的数据，有 0 ≤k ≤1,000，0≤n, m≤k ，且n+m = k ，0 ≤a ，b ≤1,000,000。【Sample input】1 1 3 1 2【Sample output】3【Sample explanation】无 Record30minwa了一次忘记模底数了以后小心点，20分啊 Analysis请先思考后再展开 二项式定理题目转化：$$C_{n+m}^n \timesa^n \timesb^m$$ Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MOD=10007;const int INF=0x3f3f3f3f;//*******************全局定义*******************int c[1100][1100];//*******************实现*******************int power(int x,int e)&#123; int ans=1;x%=MOD;//debug while(e&gt;0) &#123; if(e&amp;1) ans=(ans*x)%MOD; x=(x*x)%MOD;e&gt;&gt;=1; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; int a,b,k,n,m;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;k,&amp;n,&amp;m); c[0][0]=1; for(int i=1;i&lt;=n+m;i++) &#123; c[i][0]=1; for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD; &#125; int ans=((c[n+m][n]*power(a,n)%MOD)*power(b,m))%MOD; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>二项式定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1312】Mayan游戏]]></title>
    <url>%2Fposts%2F62b4.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T3Luogu1312Caioj1547 Problem【Brief description】Mayan puzzle是最近流行起来的一个游戏。游戏界面是一个 7 行 5 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下：1 、每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图6到图7）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图1 和图2）；2 、任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图1 到图3）。上面图1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为（0, 0），将位于（3, 3）的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为4 的方块，满足消除条件，消除连续3 块颜色为4 的方块后，上方的颜色为3 的方块掉落，形成图 3 所示的局面。注意：a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图4 ，三个颜色为1 的方块和三个颜色为 2 的方块会同时被消除，最后剩下一个颜色为 2 的方块）。b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图5 所示的情形，5 个方块会同时被消除）。3 、方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。【Input】第一行为一个正整数n ，表示要求游戏通关的步数。接下来的5 行，描述 7*5 的游戏界面。每行若干个整数，每两个整数之间用一个空格隔开，每行以一个0 结束，自下向上表示每竖列方块的颜色编号（颜色不多于10种，从1 开始顺序编号，相同数字表示相同颜色）。【Output】如果有解决方案，输出 n 行，每行包含 3 个整数x，y，g ，表示一次移动，每两个整数之间用一个空格隔开，其中（x，y）表示要移动的方块的坐标，g 表示移动的方向，1 表示向右移动，-1表示向左移动。注意：多组解时，按照 x 为第一关健字，y 为第二关健字，1优先于-1 ，给出一组字典序最小的解。游戏界面左下角的坐标为（0 ，0 ）。如果没有解决方案，输出一行，包含一个整数-1。【Limited conditions】输入数据保证初始棋盘中没有可以消除的方块。对于30% 的数据，初始棋盘上的方块都在棋盘的最下面一行；对于100%的数据，0&lt;n≤5。【Sample input】31 02 1 02 3 4 03 1 02 4 3 4 0【Sample output】2 1 13 1 13 0 1【Sample explanation】按箭头方向的顺序分别为图6 到图11样例输入的游戏局面如上面第一个图片所示，依次移动的三步是：（2，1）处的方格向右移动，（3，1）处的方格向右移动，（3，0）处的方格向右移动，最后可以将棋盘上所有方块消除。 Record3h Analysis请先思考后再展开 首先，把操作看作是相邻交换，所以bfs剪枝：因为有多解的时候优先x、y、右所以如果左边是非空，则交给左边的来搞 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXS=310000;const int tx[4]=&#123;0,0,1,-1&#125;;const int ty[4]=&#123;1,-1,0,0&#125;;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Ans&#123; int x,y,g;&#125;;struct State&#123; int mp[6][8]; int step; Ans ans[11]; State() &#123; memset(mp,0,sizeof(mp)); &#125;&#125;st;set&lt;ll&gt; has;int maxstep;//*******************实现*******************bool okay(int x,int y) &#123;return x&gt;=1 and x&lt;=5 and y&gt;=1 and y&lt;=7;&#125;ll key(State a)//hash&#123; ll ans=0,t=1; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=7;j++) &#123; ans+=t*ll(a.mp[i][j]); t*=11; &#125; return ans;&#125;void push(State &amp;a,int i)//自由落体&#123; for(int j=1;j&lt;=7;j++) &#123; while(a.mp[i][j]==0)//debug &#123; int sum=0; for(int k=j+1;k&lt;=7;k++) sum+=a.mp[i][k],swap(a.mp[i][k-1],a.mp[i][k]); if(!sum) break; &#125; &#125;&#125;bool cl[10][10];bool clear(State &amp;a)//消除&#123; memset(cl,0,sizeof(cl)); for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=7;j++) if(a.mp[i][j]&gt;0) &#123; int ln1=1,l1=i,r1=i,nx; nx=i-1;while(okay(nx,j) and a.mp[nx][j]==a.mp[i][j]) nx--,ln1++,l1--; nx=i+1;while(okay(nx,j) and a.mp[nx][j]==a.mp[i][j]) nx++,ln1++,r1++; int ln2=1,l2=j,r2=j,ny; ny=j-1;while(okay(i,ny) and a.mp[i][ny]==a.mp[i][j]) ny--,ln2++,l2--; ny=j+1;while(okay(i,ny) and a.mp[i][ny]==a.mp[i][j]) ny++,ln2++,r2++; if(ln1&gt;=3) for(int k=l1;k&lt;=r1;k++) cl[k][j]=1; if(ln2&gt;=3) for(int k=l2;k&lt;=r2;k++) cl[i][k]=1; &#125; bool bk=0; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=7;j++) if(cl[i][j]) bk=1,a.mp[i][j]=0; if(bk) for(int t=1;t&lt;=5;t++) push(a,t); return bk;&#125;State lst[MAXS];void solve()&#123; st.step=0;has.insert(key(st)); int tou=1,wei=2;lst[1]=st; while(tou!=wei) &#123; State now=lst[tou++];if(tou==MAXS) tou=1; if(now.step==maxstep) break; for(int x=1;x&lt;=5;x++) &#123; for(int y=1;now.mp[x][y]&gt;0;y++)//仅移动有色块 &#123; for(int t=1;t&gt;=-1;t--) &#123; if(t==0) continue; int nx=x+t; if(!okay(nx,y) or now.mp[x][y]==now.mp[nx][y]) continue; if(t&lt;0 and now.mp[nx][y]&gt;0) continue;//剪枝2，从左边过来 State nxt=now; swap(nxt.mp[x][y],nxt.mp[nx][y]); for(int i=1;i&lt;=5;i++) push(nxt,i);//debug while(clear(nxt)) ;//干干净净 nxt.step=now.step+1;nxt.ans[nxt.step]=(Ans)&#123;x,y,t&#125;; ll hs=key(nxt); if(hs==0) &#123; for(int i=1;i&lt;=nxt.step;i++) printf("%d %d %d\n",nxt.ans[i].x-1,nxt.ans[i].y-1,nxt.ans[i].g); return; &#125; if(has.count(hs)) continue;//去重 has.insert(hs); lst[wei++]=nxt;if(wei==MAXS) wei=1; &#125; &#125; &#125; &#125; printf("-1");&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;maxstep); for(int i=1;i&lt;=5;i++) for(int t=1;t==1 or st.mp[i][t-1]!=0;t++) scanf("%d",&amp;st.mp[i][t]); solve();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1514】铺地毯]]></title>
    <url>%2Fposts%2F1666.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2011 提高组 D1T1Luogu1514Caioj1544 Problem【Brief description】为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n 张地毯，编号从 1 到n 。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。【Input】输入共n+2 行。第一行，一个整数n ，表示总共有 n 张地毯。接下来的n 行中，第 i+1 行表示编号i 的地毯的信息，包含四个正整数 a ，b ，g ，k ，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a ，b）以及地毯在x轴和y 轴方向的长度。第n+2 行包含两个正整数 x 和y，表示所求的地面的点的坐标（x ，y）。【Output】输出共1 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1 。【Limited conditions】对于30% 的数据，有 n ≤2 ；对于50% 的数据，0 ≤a, b, g, k≤100；对于100%的数据，有 0 ≤n ≤10,000 ，0≤a, b, g, k ≤100,000。【Sample input】31 0 2 30 2 3 32 1 3 32 2【Sample output】3【Sample explanation】如下图，1 号地毯用实线表示，2 号地毯用虚线表示，3 号用双实线表示，覆盖点（2,2）的最上面一张地毯是 3 号地毯。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=11000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int a,b,w,h;&#125;p[MAXN];//*******************实现*******************//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d%d%d",&amp;p[i].a,&amp;p[i].b,&amp;p[i].w,&amp;p[i].h); int x,y;scanf("%d%d",&amp;x,&amp;y); for(int i=n;i&gt;=1;i--) &#123; if(x&gt;=p[i].a and y&gt;=p[i].b and x&lt;=p[i].a+p[i].w and y&lt;=p[i].b+p[i].h) &#123; printf("%d",i); return 0; &#125; &#125; printf("-1");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1514】引水入城]]></title>
    <url>%2Fposts%2Fd2e5.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T4Luogu1514Caioj1544 Problem【Brief description】在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个N 行M 列的矩形，如图所示。其中每个格子都代表一座城市，每座城市都有一个海拔高度。为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。因此，只有与湖泊毗邻的第1 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第N 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。【Input】每行中两个数之间用一个空格隔开。输入的第一行是两个正整数 N 和 M，表示矩形的规模。接下来 N 行，每行 M 个正整数，依次代表每座城市的海拔高度。【Output】如果能满足要求，输出的第一行是整数1，第二行是一个整数，代表最少建造几个蓄水厂；如果不能满足要求，输出的第一行是整数0，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。【Limited conditions】【Sample input】3 68 4 5 6 4 47 3 4 3 3 33 2 2 1 1 2【Sample output】13【Sample explanation】上图中，在 3 个粗线框出的城市中建造蓄水厂，可以满足要求。以这 3 个蓄水厂为源头在干旱区中建造的输水站分别用 3 种颜色标出。当然，建造方法可能不唯一。 Record3h Analysis请先思考后再展开 本来看着这个图，硬是yy了一个本来不会的费用流【因为自己灵光一闪发现好久没用啦】然后中午做了两道裸题学会了费用流然后打、调了两个小时这题，建图：把开通一个地方看作费用为1这是因为之前做过一道费用不是单位而是边的题目但其实那道题是每条边只能用一次的，所以没有关系但这道题的话，用费用的时候，spfa完全没有任何比较能力，所以是错误的！心疼我的两小时，特别是今天已经不得不去考统测五而浪费一天时间 然后正解又是爆搜……noip不搞这个会死 首先，如果有解，显然每一个蓄水站，所覆盖的地方一定是一段连续的区间，否则断开的地方别的蓄水站也无法进入于是就变成了区间覆盖问题 那区间，就是l和r，灰常好维护，考虑dp但是不能直接从下往上来dp，从样例就能看出，可能水会往上所以用更加灵活的记忆化搜索代替dp即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510;const int INF=0x3f3f3f3f;const int tx[4]=&#123;0,0,1,-1&#125;;const int ty[4]=&#123;1,-1,0,0&#125;;//*******************全局定义*******************int n,m;int mp[MAXN][MAXN];int l[MAXN][MAXN],r[MAXN][MAXN];bool v[MAXN][MAXN];//*******************实现*******************void dfs(int x,int y)&#123; v[x][y]=1; for(int i=0;i&lt;=3;i++) &#123; int nx=x+tx[i],ny=y+ty[i]; if(nx&gt;=1 and nx&lt;=n and ny&gt;=1 and ny&lt;=m and mp[nx][ny]&lt;mp[x][y]) &#123; if(!v[nx][ny]) dfs(nx,ny); l[x][y]=mymin(l[x][y],l[nx][ny]); r[x][y]=mymax(r[x][y],r[nx][ny]); &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;mp[i][j]); memset(l,0x3f,sizeof(l)); memset(r,0,sizeof(r)); for(int i=1;i&lt;=m;i++) l[n][i]=r[n][i]=i; for(int i=1;i&lt;=m;i++) if(!v[1][i]) dfs(1,i); int ans=0; for(int i=1;i&lt;=m;i++) if(!v[n][i]) ans++; if(ans&gt;0) printf("0\n%d",ans); else &#123; int lf=1; while(lf&lt;=m) &#123; int rt=0;//最右的覆盖 for(int i=1;i&lt;=m;i++) if(l[1][i]&lt;=lf) rt=mymax(rt,r[1][i]); ans++;lf=rt+1; &#125; printf("1\n%d",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2135】Farm Tour]]></title>
    <url>%2Fposts%2F2acf.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T4Poj2135Caioj1544 Problem【Brief description】一个无向图有 N 个点和 M 无向边，出发点是 1，终点为 N求从点1出发到点N再从点N回到点1的最短路程，并且要求每条边只能走一次。【Input】第一行： 两个整数N和M。下来M行，每行三个整数: X Y L 分别表示一条无向边两个点的编号和边的长度。【Output】输出一个整数，最短路程。【Limited conditions】1&lt;=N&lt;=10001&lt;=M&lt;=10000每条边的长度小于等于35000。【Sample input】4 51 2 12 3 13 4 11 3 22 4 2【Sample output】6【Sample explanation】无 Record30min Analysis请先思考后再展开 最小费用最大流把边权作为边的费用，1作为边的容量即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=1100,MAXM=41000;//*******************全局定义*******************struct Nod&#123; int hou; int dis; bool v; int fm; Nod() &#123; hou=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,w,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int w,int c)&#123; e[++ln].y=y;e[ln].w=w;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; e[++ln].y=x;e[ln].w=-w;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln;&#125;int getoth(int t) &#123;return (t&amp;1)?t+1:t-1;&#125;//*******************实现*******************int n;int st,ed;int lst[MAXN];bool spfa()&#123; for(int i=st;i&lt;=ed;i++) p[i].dis=INF; int tou=1,wei=2;lst[1]=st; p[st].v=1;p[st].dis=0; while(tou!=wei) &#123; int x=lst[tou++]; if(tou==MAXN) tou=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dis&gt;p[x].dis+e[k].w and e[k].c&gt;0)//debug &#123; p[y].dis=p[x].dis+e[k].w; p[y].fm=k; if(p[y].v==0) &#123; p[y].v=1; lst[wei++]=y; if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125; return p[ed].dis&lt;INF;&#125;int mincost()&#123; int ans=0; while(spfa()) &#123; ans+=p[ed].dis; int x=ed; while(x!=st) &#123; int k=p[x].fm,ok=getoth(k); e[k].c-=1; e[ok].c+=1; x=e[ok].y; &#125; &#125; return ans;&#125;//*******************主函数*******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,w;scanf("%d%d%d",&amp;x,&amp;y,&amp;w); ins(x,y,w,1);ins(y,x,w,1); &#125; st=0,ed=n+1; ins(st,1,0,2);ins(n,ed,0,2); printf("%d",mincost());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1525】关押罪犯]]></title>
    <url>%2Fposts%2F8b22.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T3Luogu1525Caioj1543 Problem【Brief description】S 城现有两座监狱，一共关押着N 名罪犯，编号分别为1~N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。在详细考察了N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？【Input】每行中两个数之间用一个空格隔开。第一行为两个正整数 N 和 M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 M 行每行为三个正整数aj，bj，cj，表示 aj 号和 bj 号罪犯之间存在仇恨，其怨气值为cj。【Output】共1 行，为Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。【Limited conditions】数据保证1&lt;=aj&lt;=bj&lt;=N，0&lt;cj≤1,000,000,000，且每对罪犯组合只出现一次。对于30%的数据有N≤ 15。对于70%的数据有N≤ 2000，M≤ 50000。对于100%的数据有N≤ 20000，M≤ 100000。【Sample input】4 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884【Sample output】3512【Sample explanation】罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是3512（由 2 号和 3 号罪犯引发）。其他任何分法都不会比这个分法更优。 Record30min Analysis请先思考后再展开 考虑一个贪心：优先处理权值大的关系证明：因为本题求的是最大值，如果放弃当前，那么无论你后面多么优秀，答案都是确定的然后因为要维护互斥的关系，可以很巧妙地用拆点解决，然后就可以并查集了 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; int fa[41000]; int findfa(int x) &#123;return fa[x]=(fa[x]==x?x:findfa(fa[x]));&#125; struct Edge &#123; int x,y,c; &#125;e[110000]; bool cmp(Edge a,Edge b) &#123;return a.c&gt;b.c;&#125; void main() &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n*2;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].c); sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++) &#123; int x=e[i].x,y=e[i].y; int fx=findfa(x),fy=findfa(y); if(fx==fy) &#123;printf("%d",e[i].c);return;&#125; fa[fx]=findfa(y+n); fa[fy]=findfa(x+n); &#125; puts("0"); &#125;&#125;;int main()&#123; mine::main();&#125; Analysis2请先思考后再展开 也可以二分答案，然后对于大于mid的边，判断是否是二分图]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1541】乌龟棋]]></title>
    <url>%2Fposts%2Fe616.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T2Luogu1541Caioj1542 Problem【Brief description】乌龟棋的棋盘是一行N个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第N格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。乌龟棋中M张爬行卡片，分成4种不同的类型（M张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有1、2、3、4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？【Input】第1行2个正整数N和M，分别表示棋盘格子数和爬行卡片数。第2行N个非负整数，a1 a2……aN，其中ai表示棋盘第i个格子上的分数。第3行M个整数，b1 b2……bM，表示M张爬行卡片上的数字。输入数据保证到达终点时刚好用光M张爬行卡片。【Output】1个整数，表示小明最多能得到的分数。【Limited conditions】对于30%的数据有1≤N≤30，1≤M≤12。对于50%的数据有1≤N≤120，1≤M≤50，且4种爬行卡片，每种卡片的张数不会超过20。对于100%的数据有1≤N≤350，1≤M≤120，且4种爬行卡片，每种卡片的张数不会超过40；0≤ai≤100，1≤i≤N；1≤bi≤4，1≤i≤M。【Sample input】9 56 10 14 2 8 8 18 5 171 3 1 2 1【Sample output】73【Sample explanation】小明使用爬行卡片顺序为1，1，3，1，2，得到的分数为6+10+14+8+18+17=73。注意，由于起点是1，所以自动获得第1格的分数6。 Record30min Analysis请先思考后再展开 一眼dp,12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970空间：2560000时间：21760000枚举的时候按照n、d、c、b的顺序&#123;% endfold %&#125;## Code&#123;% fold 请先思考后再展开 %&#125;```cpp//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN &quot;%I64d&quot;#else#define BIGN &quot;%lld&quot;#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=10;//*******************全局定义*******************int ct[5];int s[400];int f[50][50][50][50];//*******************实现*******************//*******************主函数*******************int main()&#123; int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n-1;i++) scanf(&quot;%d&quot;,&amp;s[i]); for(int i=1;i&lt;=m;i++) &#123; int t; scanf(&quot;%d&quot;,&amp;t); ct[t]++; &#125; f[0][0][0][0]=s[0]; for(int i=0;i&lt;=n-2;i++) &#123; for(int d=0;d&lt;=ct[4];d++) &#123; for(int c=0;c&lt;=ct[3];c++) &#123; for(int b=0;b&lt;=ct[2];b++) &#123; int a=i-4*d-3*c-2*b; if(a&lt;0) break; if(a&gt;ct[1]) continue;//debug f[a+1][b][c][d]=mymax(f[a+1][b][c][d],f[a][b][c][d]+s[i+1]); f[a][b+1][c][d]=mymax(f[a][b+1][c][d],f[a][b][c][d]+s[i+2]); f[a][b][c+1][d]=mymax(f[a][b][c+1][d],f[a][b][c][d]+s[i+3]); f[a][b][c][d+1]=mymax(f[a][b][c][d+1],f[a][b][c][d]+s[i+4]); &#125; &#125; &#125; &#125; printf(&quot;%d&quot;,f[ct[1]][ct[2]][ct[3]][ct[4]]);//n-1&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1075】机器翻译]]></title>
    <url>%2Fposts%2F3759.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2010 提高组 T1Luogu1540Caioj1541 Problem【Brief description】小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。题目描述这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。假设内存中有M个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过M-1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。假设一篇英语文章的长度为N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。【Input】第一行为两个正整数M和N，代表内存容量和文章的长度。第二行为N个非负整数，按照文章的顺序，每个数（大小不超过1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。【Output】软件需要查词典的次数。【Limited conditions】对于10%的数据有M=1，N≤5。对于100%的数据有0&lt;=M&lt;=100，0&lt;=N&lt;=1000。【Sample input】3 71 2 1 5 4 4 1【Sample output】5【Sample explanation】整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：空：内存初始状态为空。1． 1：查找单词1并调入内存。2． 1 2：查找单词2并调入内存。3． 1 2：在内存中找到单词1。4． 1 2 5：查找单词5并调入内存。5． 2 5 4：查找单词4并调入内存替代单词1。6． 2 5 4：在内存中找到单词4。7． 5 4 1：查找单词1并调入内存替代单词2。共计查了5次词典。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=10;//*******************全局定义*******************deque&lt;int&gt; q;bool v[1100];//*******************实现*******************//*******************主函数*******************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); int ans=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(!v[t]) &#123; v[t]=1; if(q.size()==m) v[q.front()]=0,q.pop_front(); q.push_back(t); ans++; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1075】靶形数独]]></title>
    <url>%2Fposts%2Fead0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T4Luogu1074Caioj1540 Problem【Brief description】小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z博士请教，Z 博士拿出了他最近发明的“靶形数独” ，作为这两个孩子比试的题目。靶形数独的方格同普通数独一样，在9×9的大九宫格中有9个3×3的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入1到9的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法） ，而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。求出对于给定的靶形数独，能够得到的最高分数。【Input】一共 9 行。每行 9 个整数（每个数都在0—9的范围内），表示一个尚未填满的数独方格，未填的空格用“0”表示。每两个数字之间用一个空格隔开。【Output】输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1。【Limited conditions】40%的数据，数独中非0数的个数不少于30。80%的数据，数独中非0数的个数不少于26。100%的数据，数独中非0数的个数不少于24。【Sample input】7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2【Sample output】2829【Sample explanation】无 Record3h Analysis1请先思考后再展开 通过估价函数（实时变化），也就是通过行、列、宫确定数来找最优决策顺序然后暴力即可 本代码可100，但有点危险而且还牺牲了最优化方案【某种平衡？】有点莫队中【分块与哈密顿距离最小生成树】的感觉 UP:洗了个澡回来就想了种新想法：其实直接预处理出顺序就好了瞬间比所谓”跳舞链“差不了多少 应该比大部分题解快而简单了吧于是就是很稳的正解啦！ Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=10;const int score[MAXN][MAXN]=&#123; &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,6,6,6,6,6,6,6,6,6&#125;, &#123;0,6,7,7,7,7,7,7,7,6&#125;, &#123;0,6,7,8,8,8,8,8,7,6&#125;, &#123;0,6,7,8,9,9,9,8,7,6&#125;, &#123;0,6,7,8,9,10,9,8,7,6&#125;, &#123;0,6,7,8,9,9,9,8,7,6&#125;, &#123;0,6,7,8,8,8,8,8,7,6&#125;, &#123;0,6,7,7,7,7,7,7,7,6&#125;, &#123;0,6,6,6,6,6,6,6,6,6&#125;&#125;;//*******************全局定义*******************int mp[MAXN][MAXN];bool hang[MAXN][MAXN],lie[MAXN][MAXN],block[MAXN][MAXN];int hangs[MAXN],lies[MAXN],blocks[MAXN];int n;//*******************实现*******************int getid(int x,int y) &#123; return ((x-1)/3)*3+(y-1)/3+1; &#125;void getmx(int &amp;nx,int &amp;ny)&#123; int mx=-1;//debug for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) if(mp[i][j]==0) &#123; int t=hangs[i]+lies[j]+blocks[ getid(i,j) ]; if(t&gt;mx) mx=t,nx=i,ny=j; &#125; //9的常数 /*int mx; mx=-1;for(int i=1;i&lt;=9;i++) if(hangs[i]&gt;mx and hangs[i]&lt;9) mx=hangs[i],nx=i; mx=-1;for(int j=1;j&lt;=9;j++) if(lies[j]&gt;mx and !mp[nx][j]) mx=lies[j],ny=j;*/ //玄学，但有用的估价？ //有点莫队中【分块与哈密顿距离最小生成树】的感觉&#125;pair&lt;int,int&gt; ss[MAXN*MAXN];void pre()&#123; for(int i=1;i&lt;=n;i++) &#123; int x,y;getmx(x,y); ss[i].first=x;ss[i].second=y; mp[x][y]=1;//仅标记 hangs[x]++;lies[y]++;blocks[getid(x,y)]++; &#125; for(int i=1;i&lt;=n;i++) &#123; int x=ss[i].first,y=ss[i].second; mp[x][y]=0;//仅标记 hangs[x]--;lies[y]--;blocks[getid(x,y)]--; &#125;&#125;int maxscore=-1;void dfs(int x,int y,int dep,int nowsc)&#123; if(dep&gt;n) &#123; maxscore=mymax(maxscore,nowsc); return; &#125; int id=getid(x,y); mp[x][y]=1;//仅标记 hangs[x]++;lies[y]++;blocks[id]++; int nx=ss[dep+1].first,ny=ss[dep+1].second; for(int i=1;i&lt;=9;i++) &#123; if(hang[x][i] or lie[y][i] or block[id][i]) continue; hang[x][i]=lie[y][i]=block[id][i]=1; dfs(nx,ny,dep+1,nowsc+i*score[x][y]); hang[x][i]=lie[y][i]=block[id][i]=0; &#125; mp[x][y]=0;//仅标记 hangs[x]--;lies[y]--;blocks[id]--;&#125;//*******************主函数*******************int main()&#123; int nowsc=0; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) &#123; scanf("%d",&amp;mp[i][j]); int d=mp[i][j]; if(d&gt;0) &#123; hang[i][d]=1;hangs[i]++; lie[j][d]=1;lies[j]++; int id=getid(i,j);block[id][d]=1;blocks[id]++; nowsc+=mp[i][j]*score[i][j]; &#125; else n++; &#125; pre(); dfs(ss[1].first,ss[1].second,1,nowsc); printf("%d",maxscore);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1073】最优贸易]]></title>
    <url>%2Fposts%2Fb656.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T3Luogu1073Caioj1539 Problem【Brief description】C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。【Input】第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y 之间的双向道路。【Output】共 1 行，包含 1 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 0。【Limited conditions】输入数据保证 1 号城市可以到达 n 号城市。对于 10%的数据，1≤n≤6。对于 30%的数据，1≤n≤100。对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 100%的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市水晶球价格≤100。【Sample input】5 54 3 5 6 11 2 11 4 12 3 23 5 14 5 2【Sample output】5【Sample explanation】C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1。阿龙可以选择如下一条线路：1-&gt;2-&gt;3-&gt;5，并在 2 号城市以 3 的价格买入水晶球，在 3号城市以 5 的价格卖出水晶球，赚取的旅费数为 2。阿龙也可以选择如下一条线路 1-&gt;4-&gt;5-&gt;4-&gt;5，并在第 1 次到达 5 号城市时以 1 的价格买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。 Record1h Analysis1请先思考后再展开 图上灰常规dp注意两个很重要的剪枝【如果不喜欢剪枝，可以用强连通搞一搞，总之就是避免环】 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;const int MAXN=110000,MAXM=1100000;//*******************全局定义*******************struct Nod&#123; int hou,c; Nod() &#123; hou=c=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; e[++ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int mix[MAXN];int f[MAXN];//走到i的最大收益//*******************实现*******************void dfs(int x,int fa,int mi)//路上最便宜&#123; bool bk=0; mi=mymin(mi,p[x].c);//剪枝1 if(mi&lt;mix[x]) mix[x]=mi,bk=1; int mx=mymax(f[fa],p[x].c-mi);//剪枝2 if(mx&gt;f[x]) f[x]=mx,bk=1; if(!bk) return; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; dfs(y,x,mi); &#125;&#125;//*******************主函数*******************int main()&#123; memset(mix,63,sizeof(mix)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].c); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y);if(c&gt;1) ins(y,x); &#125; dfs(1,0,INF); printf("%d",f[n]);&#125; Analysis2请先思考后再展开 主要到这道题的方法灰常多，算是不错的题目，比较创新而且大家都是尽力简化各种方法各种奇奇怪怪题解嗯以我的尿性，肯定是选了最简单最快的了…… UP 2018.8.29看了看正规的做法，其实一点都不难对于这种，和路径上先后顺序有关的题目，可以按照节点，把路径拆分一下具体而言就是计算出每个节点，在原图上过来的所有路径中最小，反图上过来最大，这两个信息具体实现大概用spfa会比较方便]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>dp</tag>
        <tag>并查集</tag>
        <tag>最短路</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1072】Hankson的趣味题]]></title>
    <url>%2Fposts%2F7398.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T2Luogu1072Caioj1538 Problem【Brief description】已知正整数 a0,a1,b0,b1，正整数 x 满足：1. gcd(x,a0)=a12. lcm(x,b0)=b1求x的个数【Input】第一行为一个正整数 n，表示有 n 组输入数据。接下来的 n 行每行一组输入数据，为四个正整数 a0，a1，b0，b1，每两个整数之间用一个空格隔开。【Output】共 n 行。每组输入数据的输出结果占一行，为一个整数。对于每组数据：若不存在这样的 x，请输出 0；若存在这样的 x，请输出满足条件的 x 的个数；【Limited conditions】输入数据保证 a0 能被 a1 整除，b1 能被 b0 整除。对于 50%的数据，保证有 1≤a0，a1，b0，b1≤10000 且 n≤100。对于 100%的数据，保证有 1≤a0，a1，b0，b1≤2,000,000,000 且 n≤2000。【Sample input】241 1 96 28895 1 37 1776【Sample output】62【Sample explanation】第一组输入数据，x 可以是 9、18、36、72、144、288，共有 6 个。第二组输入数据，x 可以是 48、1776，共有 2 个。 Record1h Analysis1请先思考后再展开 优雅的暴力：观察式子，不难发现x是a1的倍数，b1的约数枚举b1约数即x，验证即可 时间复杂度：最坏$O(n*sqrt(b1)*log2(b1))$极限26亿，然鹅luogu上还是很快的 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=150;//*******************全局定义*******************//*******************实现*******************int gcd(int x,int y) &#123;return (y==0)?x:gcd(y,x%y);&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); while(n--) &#123; int a0,a1,b0,b1;scanf("%d%d%d%d",&amp;a0,&amp;a1,&amp;b0,&amp;b1); int ans=0; for(int x=1;x*x&lt;=b1;x++) &#123; if(b1%x==0 and x%a1==0 and gcd(x,a0)==a1 and gcd(x,b0)*b1==x*b0) ++ans; int tx=b1/x; if(tx!=x and b1%tx==0 and tx%a1==0 and gcd(tx,a0)==a1 and gcd(tx,b0)*b1==tx*b0) ++ans; &#125; printf("%d\n",ans); &#125;&#125; Analysis2请先思考后再展开 虽然过去了，显然跑得很慢呀 UP 2018.8.6：讲讲正解吧为了方便，改改字母gcd(x,a)=clcm(x,b)=d 先从优化的角度反思上面的做法，我们可以把暴力判断gcd消耗的log省去具体做法是，从质因数p的层面上考虑gcd和lcm，那么就变成了次幂的min和max也就是说，枚举约数质因数p，设其在a,b,c,d,x中次幂数分别是ma,mb,mc,md,mx对于gcd：①$ma=mc,mx&gt;=mc$②$ma&gt;mc,mx=mc$③$ma&lt;mc,无解$对于lcm：①$mb=md,mx=md$②$mb&lt;md,mx=md$③$mb&gt;md,无解$ 合并情况如下：①$ma=mc,mb=md,mc&lt;=md,则mc&lt;=mx&lt;=md$，共md-mc+1种②$ma=mc,mb&lt;md,mc&lt;=md,则mx=md$，共1种③$ma&gt;mc,mb=md,mc&lt;=md,则mx=mc$，共1种④$ma&gt;mc,mb&lt;md,mc=md,则mx=mc=md$，共1种⑤其他，无解 最后把每种p下，mx可行的选择数乘法原理即可把质数预处理一下，然后根据分布数量这样的复杂度是$O(n \times \sqrt d / log_2( \sqrt d) )$ Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110000;const int INF=0x3f3f3f3f;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;const int MAXNUM=50000;int prime[MAXNUM],pr=0;bool v[MAXNUM];void pre()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and ll(i)*prime[j]&lt;MAXNUM;j++) &#123; v[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int a,b,c,d;int ans;void solve(int prm)&#123; int ma=0;while(a%prm==0) ma++,a/=prm; int mb=0;while(b%prm==0) mb++,b/=prm; int mc=0;while(c%prm==0) mc++,c/=prm; int md=0;while(d%prm==0) md++,d/=prm; if(ma==mc and mb==md and mc&lt;=md) ans*=md-mc+1; else if(ma==mc and mb&lt;md and mc&lt;=md) ; else if(ma&gt;mc and mb==md and mc&lt;=md) ; else if(ma&gt;mc and mb&lt;md and mc==md) ; else ans=0;&#125;int main()&#123; pre(); int T;scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d%d",&amp;a,&amp;c,&amp;b,&amp;d); ans=1; for(int i=1;i&lt;=pr;i++) if(d%prime[i]==0) solve(prime[i]); if(d&gt;1) solve(d);//剩下的唯一质因数 printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1071】潜伏者]]></title>
    <url>%2Fposts%2F9e5c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2009 提高组 T1Luogu1071Caioj1537 Problem【Brief description】R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母‘A’-‘Z’构成（无空格等其他字符）。2. S 国对于每个字母规定了对应的“密字”。加密的过程就是将原信息中的所有字母替换为其对应的“密字”。3. 每个字母只对应一个唯一的“密字”，不同的字母对应不同的“密字”。“密字”可以和原字母相同。例如，若规定‘A’的密字为‘A’，‘B’的密字为‘C’（其他字母及密字略），则原信息“ABA”被加密为“ACA”。现在，小C通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小C希望能通过这条信息，破译S国的军用密码。小C的破译过程是这样的：扫描原信息，对于原信息中的字母 x（代表任一大写字母），找到其在加密信息中的对应大写字母 y，并认为在密码里 y 是 x 的密字。如此进行下去直到停止于如下的某个状态：1. 所有信息扫描完毕，‘A’-‘Z’ 所有 26 个字母在原信息中均出现过并获得了相应的“密字”。2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。例如某条信息“XYZ”被翻译为“ABA”就违反了“不同字母对应不同密字”的规则。在小C忙得头昏脑涨之际，R国司令部又发来电报，要求他翻译另外一条从S国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。【Input】第 1 行为小 C 掌握的一条加密信息。第 2 行为第 1 行的加密信息所对应的原信息。第 3 行为 R 国司令部要求小 C 翻译的加密信息。输入数据保证所有字符串仅由大写字母‘A’-‘Z’构成，且第 1 行长度与第 2 行相等。【Output】共 1 行。若破译密码停止时出现 2，3 两种情况，请你输出“Failed”（不含引号，注意首字母大写，其它小写）。否则请输出利用密码翻译电报中加密信息后得到的原信息。【Limited conditions】字符串长度在 1 到 100 之间。【Sample input 1】AAABEOWIE【Sample output 1】Failed【Sample input 2】QWERTYUIOPLKJHGFDSAZXCVBNABCDEFGHIJKLMNOPQRSTUVWXYDSLIEWO【Sample output 2】Failed【Sample input 3】MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPPYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLLFLSO【Sample output 3】NOIP【Sample explanation】【输入输出样例 1 说明】原信息中的字母‘A’和‘B’对应相同的密字，输出“Failed”。【输入输出样例 2 说明】字母‘Z’在原信息中没有出现，输出“Failed”。 Record30min Analysis请先思考后再展开 模拟即可 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int INF=0x3f3f3f3f;//*******************全局定义*******************char s1[110],s2[110],s3[110];int to[30];//*******************实现*******************//*******************主函数*******************int main()&#123; scanf("%s%s%s",s1+1,s2+1,s3+1); int ln1=strlen(s1+1),ln3=strlen(s3+1); bool bk=0; for(int i=1;i&lt;=ln1;i++) &#123; if(to[s1[i]-'A'+1]&gt;0 and to[s1[i]-'A'+1]!=s2[i]) bk=1; to[s1[i]-'A'+1]=s2[i]; &#125; for(int i=1;i&lt;=26;i++) if(to[i]==0) bk=1; for(int i=1;i&lt;=25;i++) for(int j=i+1;j&lt;=26;j++) if(to[i]&gt;0 and to[i]==to[j]) bk=1; if(bk) printf("Failed"); else for(int i=1;i&lt;=ln3;i++) putchar( to[s3[i]-'A'+1] );&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1155】双栈排序]]></title>
    <url>%2Fposts%2F958b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T4Luogu1155Caioj1536 Problem【Brief description】Tom最近在研究一个有趣的排序问题。如图所示，通过2个栈S1和S2，Tom希望借助以下4种操作实现将输入序列升序排序。操作a如果输入序列不为空，将第一个元素压入栈S1操作b如果栈S1不为空，将S1栈顶元素弹出至输出序列操作c如果输入序列不为空，将第一个元素压入栈S2操作d如果栈S2不为空，将S2栈顶元素弹出至输出序列如果一个1~n的排列P可以通过一系列操作使得输出序列为1，2，…，(n-1)，n，Tom就称P是一个“可双栈排序排列”。例如(1,3,2,4)就是一个“可双栈排序序列”，而(2,3,4,1)不是。下图描述了一个将(1,3,2,4)排序的操作序列：&lt;a,c,c,b,a,d,d,b&gt;当然，这样的操作序列有可能有几个，对于上例(1,3,2,4)，&lt;a,c,c,b,a,d,d,b&gt;是另外一个可行的操作序列。Tom希望知道其中字典序最小的操作序列是什么。【Input】第一行是一个整数n。第二行有n个用空格隔开的正整数，构成一个1~n的排列。【Output】共一行，如果输入的排列不是“可双栈排序排列”，输出数字0；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。【Limited conditions】30%的数据满足：n&lt;=1050%的数据满足：n&lt;=50100%的数据满足：n&lt;=1000【Sample input】41 3 2 4【Sample output】a b a a b b a b【Sample explanation】无 Record2h这种题打不了暴力，建议手出数据检验 Analysis1请先思考后再展开 首先，因为放进去就不变了，两个栈都要保持单调递减考虑栈在排序中起了什么作用，其实就是辅助交换逆序对 那么很好想的方法一：贪心也就是说，尽量找操作编号小的来搞 先想简单的出栈，判断条件很简单：只要是当前需要输出的值在栈顶就弹出因为显然弹出一定最优 但是，入栈是有一定条件滴（以下数值都表示相对大小）既然是“双”，有一个经典的套路思想：由一及多先从单栈排序思考：如果出现2…3…1的情况，则无解而有了第二个栈（设为辅栈），就有了缓冲空间，但一旦出现如2…3…4…1的情况，就会炸分析一下为什么？ “1”的存在使2、3不能弹出 “3”和“4”的存在，都无法满足递减的要求 然鹅，双栈的特点在于多种可能所以即使没有直接像上面一样无解，也不能乱入栈，特别是到底入哪个栈考虑哪些情况会导致不能共存（这个方法二也会有）如3…2…5…1？那把5放辅栈就好了，这不是我们当前搞“2”要考虑的【当辅栈什么也没有，我们多了一条命】但，如果辅栈有东西呢？3…2…5…14哇肿么办【可以发现，这个其实无解，但这是等到5的时候再判断的】 “1”的存在又是让我们不能轻易弹出 “4”的存在让5不能过去所以这个时候，只能把“2”放过去 总结：对于主栈，即使有top1&gt;a[now]，如果有a[now]&lt;a[x1]且top2&lt;a[x1]同时有a[now]&gt;a[x2]限制弹出，则now只能尝试去辅栈上述条件对辅栈无效，因为辅栈没用就直接GG了 这样一来，判断无解就简单很多了：什么也干不了的时候 时间复杂度：O(n^2) Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************//*******************全局定义*******************int n,a[1100],now=1;int ned=1,ans[2100];stack&lt;int&gt; s1,s2;//*******************实现*******************bool check()&#123; if(s1.empty() or s2.empty()) return 1;//无敌 int x; for(x=now+1;x&lt;=n;x++) if(a[now]&lt;a[x] and s2.top()&lt;a[x]) break; for(x=x+1;x&lt;=n;x++) if(a[now]&gt;a[x]) return 0; return 1;&#125;bool solve()&#123; for(int i=1;i&lt;=2*n;i++) &#123; if(now&lt;=n and ( (s1.empty())or(s1.top()&gt;a[now]) ) and check()) &#123; ans[i]=1; s1.push(a[now++]); continue; &#125; if(!s1.empty() and s1.top()==ned) &#123; ans[i]=2; s1.pop(); ned++; continue; &#125; if(now&lt;=n and ( (s2.empty())or(s2.top()&gt;a[now]) )) &#123; ans[i]=3; s2.push(a[now++]); continue; &#125; if(!s2.empty() and s2.top()==ned) &#123; ans[i]=4; s2.pop(); ned++; continue; &#125; return 0;//无计可施 &#125; return 1;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); if(!solve()) printf("0"); else for(int i=1;i&lt;=2*n;i++) printf("%c ",ans[i]+'a'-1);&#125; Analysis2请先思考后再展开 贪心这种东西，其实挺好的但考场上打还是要慎重所以考虑另一种显然的算法：二分图染色构图就是用不能共存的条件，从而划分为两个集合原因：只有两个栈 然后这种做法代码长一点，但比较无脑~时间复杂度：O(n^2) 【但事实上更快】 Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou,c; Nod() &#123; hou=c=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; e[++ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;bool bk=0;void dfs(int x,int c)&#123; p[x].c=c; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].c==c) bk=1; if(!p[y].c) dfs(y,3-c); &#125;&#125;int n,a[MAXN];int mi[MAXN];//*******************实现*******************int now=1,ned=1;stack&lt;int&gt; s1,s2;bool solve()&#123; for(int i=1;i&lt;=2*n;i++) &#123; if(now&lt;=n and p[now].c==1 and ( (s1.empty())or(s1.top()&gt;a[now]) )) &#123; printf("a "); s1.push(a[now++]); continue; &#125; if(!s1.empty() and s1.top()==ned) &#123; printf("b "); s1.pop(); ned++; continue; &#125; if(now&lt;=n and p[now].c==2 and ( (s2.empty())or(s2.top()&gt;a[now]) )) &#123; printf("c "); s2.push(a[now++]); continue; &#125; if(!s2.empty() and s2.top()==ned) &#123; printf("d "); s2.pop(); ned++; continue; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); mi[n+1]=INF;//debug mi[n]=a[n];for(int i=n-1;i&gt;=1;i--) mi[i]=mymin(a[i],mi[i+1]); for(int i=1;i&lt;=n-1;i++) for(int j=i+1;j&lt;=n;j++) if(a[i]&lt;a[j] and a[i]&gt;mi[j+1]) ins(i,j),ins(j,i); for(int i=1;i&lt;=n;i++) if(p[i].c==0) dfs(i,1);//优先1 if(bk) printf("0"); else solve();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>难度2</tag>
        <tag>二分图染色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1006】传纸条]]></title>
    <url>%2Fposts%2F7e9b.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T3Luogu1006Caioj1535 Problem【Brief description】小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。【Input】第一行有2个用空格隔开的整数m和n，表示班里有m行n列。接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。【Output】包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。【Limited conditions】1&lt;=m,n&lt;=50【Sample input】3 30 3 92 8 55 7 0【Sample output】34【Sample explanation】 Record30minWA:枚举行的时候忽略了步数的限制，导致错误下标访问【感谢网上一篇文章，讲了一个错误点，让我解决了问题，所以我也要传递一下】【所以说之前方格取数的代码也是错误的，但20个数据只有一个错误……】 Analysis请先思考后再展开 首先，所谓双向，其实就是单向其次，所谓只能帮忙一次，就是只有一次贡献，因为所有数大于等于0，所以经过这里相当于没有经过 综上说述，问题转化为方格取数真没想到NOIP居然会重复考同一道题目…… Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************int mp[60][60];int f[110][60][60];//步数、下1、下2//*******************实现******************//*******************主函数******************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;mp[i][j]); for(int p=1;p&lt;=n+m;p++)//步数 &#123; for(int i=1;i&lt;=mymin(p,m);i++)//行1 &#123; for(int j=1;j&lt;=mymin(p,m);j++)//行2 &#123; int i2=p-i,j2=p-j;//列1、列2 f[p][i][j]= f[p-1][i][j]+mp[i][i2]+mp[j][j2]*(i!=j); //都右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//都下 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j]+mp[i][i2]+mp[j][j2]*(i!=j) );//下右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//右下 &#125; &#125; &#125; printf("%d",f[n+m][m][m]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1004】方格取数]]></title>
    <url>%2Fposts%2F3f83.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T4Luogu1004Caioj1503 Problem【Brief description】设有N*N的方格图，我们将其中的某些方格中填入正整数，而其他的方格中则放数字0。某人从图的左上角的A点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。此人从A点到B点共走两次，试找出2条这样的路径，使得取得的数之和为最大。【Input】输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。【Output】一个整数，表示2条路径上取得的最大的和。【Limited conditions】N&lt;=10【Sample input】82 3 132 6 63 5 74 4 145 2 215 6 46 3 157 2 140 0 0【Sample output】67【Sample explanation】12345678910A0 0 0 0 0 0 0 00 0 13 0 0 6 0 00 0 0 0 7 0 0 00 0 0 14 0 0 0 00 21 0 0 0 4 0 00 0 15 0 0 0 0 00 14 0 0 0 0 0 00 0 0 0 0 0 0 0 B Record30min Analysis请先思考后再展开 dp经典题两个人一起dp，避免过于贪心，便于处理只能拿一次的条件 UP:之前代码有误，现已更正详见：传纸条 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************int mp[20][20];int f[30][20][20];//步数、下1、下2//*******************实现****************** //*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); while(1) &#123; int x,y,z;scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(x==0) break; mp[x][y]=z; &#125; for(int p=1;p&lt;=2*n;p++)//步数 &#123; for(int i=1;i&lt;=mymin(p,n);i++)//行1 &#123; for(int j=1;j&lt;=mymin(p,n);j++)//行2 &#123; int i2=p-i,j2=p-j;//列1、列2 f[p][i][j]= f[p-1][i][j]+mp[i][i2]+mp[j][j2]*(i!=j);//都右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//都下 f[p][i][j]=mymax(f[p][i][j], f[p-1][i-1][j]+mp[i][i2]+mp[j][j2]*(i!=j) );//下右 f[p][i][j]=mymax(f[p][i][j], f[p-1][i][j-1]+mp[i][i2]+mp[j][j2]*(i!=j) );//右下 &#125; &#125; &#125; printf("%d",f[2*n][n][n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1126】火柴棒等式]]></title>
    <url>%2Fposts%2Fce8e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T2Luogu1126Caioj1534 Problem【Brief description】给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示：注意：1. 加号与等号各自需要两根火柴棍2. 如果A≠B，则A+B=C与B+A=C视为不同的等式（A、B、C&gt;=0）3. n根火柴棍必须全部用上【Input】共一行，又一个整数n。【Output】能拼成的不同等式的数目【Limited conditions】n&lt;=24【Sample input】14【Sample output】2【Sample explanation】2个等式为0+1=1和1+0=1。 Record1h Analysis请先思考后再展开 整理每个数字：2: 13: 74: 45: 2,3,56: 0,6,97: 8然后暴力走一走详细点说就是预处理费用下所有数然后枚举分配方案 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;const int MAXN=30;//****************全局定义****************int prenum[10][10]=&#123; &#123;0,0,0,0&#125;, &#123;0,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;0,7,0,0&#125;, &#123;0,4,0,0&#125;, &#123;0,2,3,5&#125;, &#123;0,0,6,9&#125;, &#123;0,8,0,0&#125;&#125;;int prect[10]=&#123;0,0,1,1,1,3,3,1&#125;;//数量int num[40][400000],ct[50];//****************实现****************void pre(int now,int c,int pst)&#123; if(c==0) &#123; num[pst][++ct[pst]]=now; return; &#125; for(int i=2;i&lt;=mymin(7,c);i++) for(int j=1;j&lt;=prect[i];j++) if(now&gt;0 or (now==0 and prenum[i][j]&gt;0))//前导零 pre(now*10+prenum[i][j],c-i,pst);&#125;int ans=0;int a[3];//分配方案void dfs(int x,int c)&#123; if(x==3) &#123; for(int i=1;i&lt;=ct[a[1]];i++) for(int j=1;j&lt;=ct[a[2]];j++) for(int k=1;k&lt;=ct[c];k++) if(num[a[1]][i]+num[a[2]][j]==num[c][k]) &#123; //printf("%d+%d=%d\n",num[a[1]][i],num[a[2]][j],num[c][k]); ans++; &#125; return; &#125; for(int i=2;i&lt;=mymin(c-2,MAXN-4);i++) &#123; a[x]=i; dfs(x+1,c-i); &#125;&#125;//****************主函数****************int main()&#123; ct[6]=1;num[6][1]=0;//debug for(int i=2;i&lt;=MAXN-4;i++) pre(0,i,i);//预处理 int n;scanf("%d",&amp;n); dfs(1,n-4); printf("%d",ans);&#125; 如何毒瘤地Hack？其实当看到题目难度标签是普及-的时候就感觉有点不对劲于是在噼里啪啦打完上面的不简单的爆搜后，一看题解woc都是直接枚举每一种数字但想半天也搞不懂他们是怎么取这个数字的（如1000、1111、2400） 那我当然就很不爽啊所以要把他们卡掉！那如果空间128MB的话，可能n可以出30，那25~30，恩怎么说卡30分是可以的~毕竟他们是N^2]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1125】笨小猴]]></title>
    <url>%2Fposts%2F8bcb.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2008 提高组 T1Luogu1125Caioj1533 Problem【Brief description】假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。【Input】一个单词【Output】第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出0。【Limited conditions】单词中只可能出现小写字母，并且长度小于100。【Sample input】error【Sample output】Lucky Word2【Sample explanation】单词error中出现最多的字母r出现了3次，出现次数最少的字母出现了1次，3-1=2，2是质数。 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;const int MAXN=510000,MAXM=1100000;//****************全局定义****************char s[110];int a[27];//****************实现****************bool isprime(int x)&#123; if(x&lt;=1) return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1;&#125;//****************主函数****************int main()&#123; scanf("%s",s+1);int ln=strlen(s+1); for(int i=1;i&lt;=ln;i++) a[ s[i]-'a'+1 ]++; int mx=1,mi=INF; for(int i=1;i&lt;=26;i++) if(a[i]&gt;0) &#123; mx=mymax(mx,a[i]); mi=mymin(mi,a[i]); &#125; int t=mx-mi; if(isprime(t)) printf("Lucky Word\n%d",t); else printf("No Answer\n0");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1999】【Luogu1099】树网的核]]></title>
    <url>%2Fposts%2Fb262.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T4Bzoj1999Luogu1099Caioj1532 Problem【Brief description】一句话：求直径上的路径F，长度不超过s，使树上最远点与其距离最小。精炼完整版：在无根树T上有n个结点，称d(a,b)为a,b两结点间的距离。一点v到一条路径P的距离为该点与P上的最近的结点的距离。无根树的直径：无根树中最长的路径称为无根树的直径。对于给定的无根树T，直径不一定是唯一的，但各直径的中点是唯一的。（不一定恰好是某个结点，可能在某条边的内部），我们称该点为无根树的中心。偏心距ECC(F)：无根树T中距路径F最远的结点到路径F的距离。任务：对于给定的无根树T和非负整数s，求一个路径F，它是某直径上的一段路径（该路径两端均为无根树中的结点），其长度不超过s，使偏心距ECC(F)最小。我们称这个路径为无根树T的核。必要时，F可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。下面的图给出了无根树的一个实例。图中，A-B与A-C是两条直径，长度均为20。点W是无根树的中心，EF边的长度为5。如果指定s=11，则无根树的核为路径DEFG（也可以取为路径DEF），偏心距为8。如果指定s=0（或s=1、s=2），则无根树的核为结点F，偏心距为12。【Input】第1行，两个正整数n和s。其中n为树网结点的个数，s为树网的核的长度的上界。设结点编号依次为1，2，……，n。从第2行到第n行，每行给出3个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。【Output】只有一个非负整数，为指定意义下的最小偏心距。【Limited conditions】5&lt;=n&lt;=500000, 0&lt;=s&lt;2^31边长度为不超过1000的正整数。【Sample input】8 61 3 22 3 23 4 64 5 34 6 44 7 27 8 3【Sample output】5【Sample explanation】无 Record5h Analysis请先思考后再展开 其实就是一道大水题关键：不同直径具有等效性经典思想（来自akc）：想象把直径挂起来成一条横线，然后其他东西挂在下面假设当前直径有ed个节点，等会当做已经有连续的编号，便于理解 解法1：n^3随便找一个直径，假设上面有t个节点乱搞枚举l和r，dfs找下面的东西 解法2：n^2首先，显然在合法（长度s内）的情况下，核的长度越大越好在解法1的基础上面用尺取法即可 解法3：nlogsum二分答案，然后把两个端点l和r缩短直到与直径左右端点的距离即将超过mid那么把l到r之间的，作为核最后检查中间部分是否超过s，同时看挂在核上面的子树，最深距离是否在mid以内即可 不用检查1~l-1和r+1~ed部分的地方，向下挂的部分，是因为由于直径的最长性对于那上面的任意位置x，下面挂的最大深度不会超过x与端点的最短距离（否则会有更长的直径） 解法4：n对于直径上的ed节点，考虑每个l和r的贡献$min { max (l到r间挂的最大深度,dis(直径左端点,l),dis(r,直径右端点)) }$此时如果用单调队列是可以直接搞定的了但还能更简单：根据解法3的最后一条，左右两边向下深度没有影响所以直接记从1到ed这每个节点向下最大深度的最大值为mx$min { max (mx,dis(直径左端点,l),dis(r,直径右端点)) }$ Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=510000; const int INF=0x3f3f3f3f; int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; struct Nod &#123; int hou; int fa; int dis; bool v; Nod() &#123; hou=0; v=0; &#125; &#125;p[MAX_N]; struct Edge &#123; int y,c,g; &#125;e[MAX_N*2]; int ln=0; void ins(int x,int y,int c) &#123; e[++ln]=(Edge)&#123;y,c,p[x].hou&#125;; p[x].hou=ln; &#125; int mx; void dfs(int x,int fa) &#123; p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v or y==fa) continue; p[y].dis=p[x].dis+e[k].c; mx=mymax(mx,p[y].dis); dfs(y,x); &#125; &#125; void main() &#123; int n,s;scanf("%d%d",&amp;n,&amp;s); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; int a=1;p[1].dis=0;dfs(1,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[a].dis) a=i; int b=1;p[a].dis=0;dfs(a,0);for(int i=1;i&lt;=n;i++) if(p[i].dis&gt;p[b].dis) b=i; //b=&gt;...=&gt;a 通过fa连接的链表 int ans=INF; for(int l=b,r=b;r!=p[a].fa;r=p[r].fa) &#123; while(p[l].dis-p[r].dis&gt;s) l=p[l].fa;//尺取法 ans=mymin(ans,mymax(p[b].dis-p[l].dis,p[r].dis)); &#125; mx=0; for(int x=b;x!=p[a].fa;x=p[x].fa) p[x].v=1,p[x].dis=0,dfs(x,p[x].fa); printf("%d",mymax(ans,mx)); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>单调队列</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1005】矩阵取数游戏]]></title>
    <url>%2Fposts%2F836e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T3Luogu1005Caioj1531 Problem【Brief description】对于一个给定的n*m的矩阵，矩阵中的每个元素均为非负整数。游戏规则如下：1.每次取数时须从每行各取走一个元素，共n个，m次后取完矩阵所有元素2.每次取走的各个元素只能是该元素所在行的行首或行尾3.每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分=被取走的元素值*2^i，其中i表示第i次取数（从1开始编号）；4.游戏结束总得分为m次取数得分之和。帅帅想请你帮忙写一个程序，对于任意矩阵取数后的最大得分。【Input】第1行为两个用空格隔开的整数n和m。第2~n+1行为n*m矩阵，其中每行有m个用单个空格隔开的非负整数。【Output】一个整数，即输入矩阵取数后的最大得分【Limited conditions】1&lt;=n, m&lt;=80，0&lt;=aij&lt;=1000【Sample input】2 31 2 33 4 2【Sample output】82【Sample input】2 1096 56 54 46 86 12 23 88 80 4316 95 18 29 30 53 88 83 64 67【Sample output】316994【Sample explanation】无 Record1h Analysis请先思考后再展开 分析题目，先简化问题：答案是由行组成的，所以可以每一行算出答案再累加而没有影响 首先，我的第一想法是贪心但是让我们举个反例： 解释 1 2 3 4 矩阵 13 1 10 11 我的傻瓜贪心 16 8 4 2 显然更合理的分配 2 4 8 16 分析一下为什么？显然贪心这种东西通常都是鼠目寸光的而每一次我们的选择显然会对后面的状态有影响 那么怎么办？正着不行就反过来嘛，从什么也没有开始，一个个加入？【因为总次数已经确定，所以能实现】但怎么加呢？难道枚举起点？那然后呢？总不能又回到贪心的老路子上 其实反过来后，很容易发现虽然一次选择鼠目寸光，但我们可以比较方案啊！再仔细思考，没错，这玩意是满足最优子结构的，也就是说，可以区间dp搞一搞 总结：区间dp+高精度【这很显然】 Code1惯例，先没有高精度请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************ll a[90];ll f[90][90];ll bin[90];//****************实现**************** //****************主函数****************int main()&#123; bin[0]=1;for(int i=1;i&lt;=80;i++) bin[i]=bin[i-1]*2; int n,m;scanf("%d%d",&amp;n,&amp;m); ll ans=0; for(int i=1;i&lt;=n;i++) &#123; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;a[i]); f[i][i]=a[i]*bin[m]; &#125; for(int k=m-1;k&gt;=1;k--) &#123; int ln=m-k+1; for(int st=1;st&lt;=m-ln+1;st++) &#123; int ed=st+ln-1; f[st][ed]=mymax( f[st+1][ed]+a[st]*bin[k],f[st][ed-1]+a[ed]*bin[k] ); &#125; &#125; ans+=f[1][m]; &#125; printf("%lld",ans);&#125; Code2正确代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义**************** //****************实现****************struct Bnum&#123; int a[100],ln; Bnum() &#123; memset(a,0,sizeof(a)); &#125;&#125;;Bnum jia(Bnum a,Bnum b)&#123; Bnum c;c.ln=mymax(a.ln,b.ln); for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]+b.a[i];//debug if(c.a[i]&gt;9) &#123; c.a[i]-=10; c.a[i+1]++; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;Bnum cheng(Bnum a,int b)&#123; Bnum c;c.ln=a.ln; for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]*b; if(c.a[i]&gt;9) &#123; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;bool cmp(Bnum a,Bnum b)&#123; if(a.ln!=b.ln) return a.ln&lt;b.ln; for(int i=a.ln;i&gt;=1;i--) if(a.a[i]!=b.a[i]) return a.a[i]&lt;b.a[i]; return 0;&#125;//****************主函数****************int a[90];Bnum f[90][90];Bnum bin[90];int main()&#123; bin[0].ln=1;bin[0].a[1]=1; for(int i=1;i&lt;=80;i++) bin[i]=cheng(bin[i-1],2); int n,m;scanf("%d%d",&amp;n,&amp;m); Bnum ans;ans.ln=1; for(int i=1;i&lt;=n;i++) &#123; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;a[i]); f[i][i]=cheng(bin[m],a[i]); &#125; for(int k=m-1;k&gt;=1;k--) &#123; int ln=m-k+1; for(int st=1;st&lt;=m-ln+1;st++) &#123; int ed=st+ln-1; Bnum x=jia( f[st+1][ed],cheng(bin[k],a[st]) ); Bnum y=jia( f[st][ed-1],cheng(bin[k],a[ed]) ); f[st][ed]=cmp(x,y)?y:x; &#125; &#125; ans=jia(ans,f[1][m]); &#125; for(int i=ans.ln;i&gt;=1;i--) putchar('0'+ans.a[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1098】字符串的展开]]></title>
    <url>%2Fposts%2Fa5cf.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T2Luogu1098Caioj1530 Problem【Brief description】约定如下：(1) 遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号“-”，减号两侧同为小写字母或同为数字，且按照ASCII码的顺序，减号右边的字符严格大于左边的字符。(2) 参数p1：展开方式。p1=1时，对于字母子串，填充小写字母；p1=2时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。p1=3时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号“*”来填充。(3) 参数p2：填充字符的重复个数。p2=k表示同一个字符要连续填充k个。例如，当p2=3时，子串“d-h”应扩展为“deeefffgggh”。减号两边的字符不变。(4) 参数p3：是否改为逆序：p3=1表示维持原来顺序，p3=2表示采用逆序输出，注意这时候仍然不包括减号两端的字符。例如当p1=1、p2=2、p3=2时，子串“d-h”应扩展为“dggffeeh”。(5)如果减号右边的字符恰好是左边字符的后继，只删除中间的减号。例如：“d-e”应输出为“de”，“3-4”应输出为“34”。如果减号右边的字符按照ASCII码的顺序小于或等于左边字符，输出时，要保留中间的减号例如：“d-d”应输出为“d-d”，“3-1”应输出为“3-1”。【Input】第1行为用空格隔开的3个正整数，依次表示参数p1，p2，p3。第2行为一行字符串，仅由数字、小写字母和减号“-”组成。行首和行末均无空格。【Output】只有一行，为展开后的字符串。【Limited conditions】1&lt;=p1&lt;=3，1&lt;=p2&lt;=8，1&lt;=p3&lt;=2字符串长度不超过100【Sample input】1 2 1abcs-w1234-9s-4zz【Sample output】abcsttuuvvw1234556677889s-4zz【Sample explanation】无 Record20min Analysis请先思考后再展开 sb题 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int p1,p2,p3;char s[110];//****************实现****************bool isabc(char c)&#123; return c&gt;='a' and c&lt;='z';&#125;bool okay(char l,char r)&#123; return ( (isdigit(l) and isdigit(r) )or( isabc(l) and isabc(r)) ) and l&lt;=r;&#125;void printchar(char c,int times)&#123; for(int i=1;i&lt;=p2*times;i++) putchar(c);&#125;void print(char l,char r,int times)&#123; if(isabc(l) and p1==2) l+='A'-'a',r+='A'-'a'; if(p3==1) &#123; for(char t=l;t&lt;=r;t++) printchar(t,times); &#125; else &#123; for(char t=r;t&gt;=l;t--) printchar(t,times); &#125;&#125;//****************主函数****************int main()&#123; scanf("%d%d%d%s",&amp;p1,&amp;p2,&amp;p3,s+1); int ln=strlen(s+1); for(int i=1;i&lt;=ln;i++) &#123; char l=s[i-1],r=s[i+1]; if(s[i]!='-' or !okay(l,r)) putchar(s[i]); else if(l+1==r) ; else if(l==r) putchar('-'); else &#123; l++;r--; if(p1==3) print('*','*',r-l+1); else print(l,r,1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1097】统计数字]]></title>
    <url>%2Fposts%2Fc868.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2007 提高组 T1Luogu1097Caioj1529 Problem【Brief description】某次科研调查时得到了n个自然数，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。【Input】第一行是整数n，表示自然数的个数；第2~n+1每行一个自然数。【Output】包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。【Limited conditions】1&lt;=n&lt;=200000每个数均不超过1500000000（1.5*10^9）【Sample input】8242451002100【Sample output】2 34 25 1100 2【Sample explanation】无 Record10min Analysis请先思考后再展开 sb题 Code请先思考后再展开 1234567891011121314int a[210000];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); int ans=1; for(int i=2;i&lt;=n;i++) &#123; if(a[i-1]==a[i]) ans++; else printf("%d %d\n",a[i-1],ans),ans=1; &#125; printf("%d %d",a[n],ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1066】2^k进制数]]></title>
    <url>%2Fposts%2Fa045.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T4Luogu1065Caioj1528 Problem【Brief description】设r是个2^k进制数，并满足以下条件：（1）r至少是个2位的2^k进制数。（2）作为2^k进制数，除最后一位外，r的每一位严格小于它右边相邻的那一位。（3）将r转换为2进制数q后，则q的总位数不超过w。在这里，正整数k和w是事先给定的。我们再从另一角度作些解释：设S是长度为w的01字符串，S对应于上述条件（3）中的q。将S从右起划分为若干个长度为k的段，每段对应一位2^k进制的数，如果S至少可分成2段，则S所对应的二进制数又可以转换为上述的2^k进制数r。问：满足上述条件的不同的r共有多少个？【Input】输入只有1行，为两个正整数，用一个空格隔开：k W【Output】输出为1行，是一个正整数，为所求的计算结果，即满足条件的不同的r的个数（用十进制数表示），要求最高位不得为0，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。（提示：作为结果的正整数可能很大，但不会超过200位）【Limited conditions】1&lt;=k&lt;=9k&lt;W&lt;=30000【Sample input】3 7【Sample output】36【Sample explanation】例：设k=3，w=7。则r是个八进制数（2^3=8）。由于w=7，长度为7的01字符串按3位一段分，可分为3段（即1，3，3，左边第一段只有一个二进制位），则满足条件的八进制数有：2位数：高位为1：6个（即12，13，14，15，16，17），高位为2：5个，…，高位为6：1个（即67）。共6+5+…+1=21个。3位数：高位只能是1，第2位为2：5个（即123，124，125，126，127），第2位为3：4个，…，第2位为6：1个（即167）。共5+4+…+1=15个。所以，满足要求的r共有36个。 Record2h Analysis1请先思考后再展开 比较裸的数位dp，套个高精度说的很轻松，居然没有想出来，好菜啊 首先，分析条件由条件1知，r的长度最少为2由条件3知，r的长度最多为$s= \left \lceil \frac{w}{k} \right \rceil$并且当达到最大长度的时候，r的最高位最多为$q=2^{w\%k}-1$，否则转化为二进制后超过w 那么剩下的就是条件2了，这个限制条件可以看做一种递推关系考虑设$f(i,j)$表示长度为i的r，$最后一位\leq j$的方案数则有$f(i,j)=f(i,j-1)+f(i-1,j-1)$意思就是，$(最后一位\leq j-1)+(最后一位=j)$【注意：题目要求是严格小于】 那么答案就是$$\sum_{长度ln=2}^{s-1} f(ln,2^k-1)+\sum_{最高位m=1}^{q} f(s-1,q-m)$$解释右式：最高位m已经确定，剩下的s-1个数，范围是$m+1 \sim mx$，相当于$1 \sim mx-m$ 补充一个细节：向上取整的时候，可以直接+1，即使加多了，q=0，没有影响 先丢个简单易懂的非高精度吧，居然有70，但加上高精度也没多难 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int f[31000][520];//****************实现****************//****************主函数****************int main()&#123; int k,w;scanf("%d%d",&amp;k,&amp;w); int s=w/k+1,q=(1&lt;&lt;(w%k))-1,mx=(1&lt;&lt;k)-1; int ans=0; for(int i=1;i&lt;=mx;i++) f[1][i]=i;//debug for(int ln=2;ln&lt;=s-1;ln++) &#123; for(int j=ln;j&lt;=mx;j++) &#123; f[ln][j]=f[ln][j-1]+f[ln-1][j-1]; &#125; ans+=f[ln][mx]; &#125; for(int m=1;m&lt;=q;m++) ans+=f[s-1][mx-m];//debug printf("%d",ans);&#125; Analysis2请先思考后再展开 基本功——高精度但是这样会炸空间呀……考场是只能瞎搞一个大小了【其实也有可能是其他解法，例如组合数学】恩通过计算，在不炸空间的情况下，只能开190然鹅事实证明太小啦！其实压位不就好了……手动抠鼻压9位就阔以1600了，这三十分能拿多少拿多少嘛~ 【以上模拟考场策略】 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;const int MOD=1000000000;//压9//****************全局定义****************struct Bnum&#123; int a[26],ln; Bnum() &#123; memset(a,0,sizeof(a)); &#125;&#125;;Bnum f[1601][513];//81MB//****************实现****************Bnum jia(Bnum a,Bnum b)&#123; Bnum c;c.ln=mymax(a.ln,b.ln); for(int i=1;i&lt;=c.ln;i++) &#123; c.a[i]+=a.a[i]+b.a[i]; if(c.a[i]&gt;=MOD) &#123; c.a[i]-=MOD; c.a[i+1]+=1; if(i==c.ln) c.ln++; &#125; &#125; return c;&#125;void putnum(int x)&#123; int t=MOD/10;while(x&lt;t) putchar('0'),t/=10; if(x&gt;0) printf("%d",x);&#125;//****************主函数****************int main()&#123; int k,w;scanf("%d%d",&amp;k,&amp;w); int s=w/k+1,q=(1&lt;&lt;(w%k))-1,mx=(1&lt;&lt;k)-1; Bnum ans;ans.ln=1; for(int i=1;i&lt;=mx;i++) &#123; f[1][i].ln=1; f[1][i].a[1]=i; &#125; for(int ln=2;ln&lt;=s-1;ln++) &#123; for(int j=ln;j&lt;=mx;j++) f[ln][j]=jia(f[ln][j-1],f[ln-1][j-1]); ans=jia(ans,f[ln][mx]); &#125; for(int m=1;m&lt;=q;m++) ans=jia(ans,f[s-1][mx-m]); printf("%d",ans.a[ans.ln]); for(int i=ans.ln-1;i&gt;=1;i--) putnum(ans.a[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1065】作业调度方案]]></title>
    <url>%2Fposts%2Fa978.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T3Luogu1065Caioj1527长长的原题面，我已简化 Problem【Brief description】我们现在要利用m台机器加工n个工件，每个工件都有m道工序。每道工序都在不同的指定的机器上完成，每个工件的每道工序都有指定的加工时间。每个工件的每个工序称为一个操作，给出操作顺序，你的任务就是设计符合该顺序的实施方案。实施方案条件（后面不得违背前面）：1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；2. 同一时刻每一台机器至多只能加工一个工件。3. 在安排后面的操作时，不能改动前面已安排的操作的工作状态。4. 尽量靠前插入空档。5. 如果有多个空档可以插入，就插入到最前面的一个空档。操作顺序以以下格式描述：共n*m个正整数，表示对应的工件编号，同一工件编号共出现m次，分别表示m个工序的执行顺序【原理是方案条件1】注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的。请你计算出该方案完成全部任务所需的总时间。【Input】输入文件的第1行为两个正整数，用一个空格隔开：m n （其中m表示机器数，n表示工件数）第2行：m*n个用空格隔开的数，为给定的安排顺序。接下来的2n行，每行都是用空格隔开的m个正整数，每个数不超过20。其中前n行依次表示每个工件的每个工序所使用的机器号，第1个数为第1个工序的机器号，第2个数为第2个工序机器号，等等。后n行依次表示每个工件的每个工序的加工时间。【Output】一个正整数，为最少的加工时间【Limited conditions】m&lt;20n&lt;20物品的价格都是10元的整数倍【Sample input】2 31 1 2 3 3 21 21 22 13 22 52 4【Sample output】10【Sample explanation】 Record30min Analysis请先思考后再展开 时间上限：8000模拟即可 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int a[30][30],b[30][30];//机器、时间bool used[30][8100];//工作否int sx[410];//操作顺序int done[30];//完成工序数int last[30];//上一工序完成时间//****************实现****************bool check(int jq,int st,int ed)&#123; for(int i=st;i&lt;=ed;i++) if(used[jq][i]) return 0; for(int i=st;i&lt;=ed;i++) used[jq][i]=1;//占用 return 1;&#125;//****************主函数****************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n);//机器、工件 for(int i=1;i&lt;=m*n;i++) scanf("%d",&amp;sx[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;b[i][j]); int ans=0; for(int i=1;i&lt;=m*n;i++) &#123; int x=sx[i],t=++done[x]; int jq=a[x][t],time=b[x][t]; int st=last[x]+1,ed=st+time-1; while(!check(jq,st,ed)) st++,ed++; last[x]=ed;ans=mymax(ans,ed); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1063】能量项链]]></title>
    <url>%2Fposts%2Fd69c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T1Luogu1063Caioj1525 Problem【Brief description】在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。【Input】输入的第一行是一个正整数N，表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当1≤i&lt;N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。【Output】一个正整数E，为一个最优聚合顺序所释放的总能量。【Limited conditions】4≤N≤100E≤2.1*10^9【Sample input】42 3 5 10【Sample output】710【Sample explanation】4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：(4⊕1)=10*2*3=60。这一串项链可以得到最优值的一个聚合顺序所释放的总能量为((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。 Record30min Analysis请先思考后再展开 首先，这是一个环，经典的套路就是复制一次在后面然后就是一个单纯的dp了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************ll a[210];ll f[210][210];//****************实现****************//****************主函数****************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]),a[n+i]=a[i]; ll ans=0; for(int ln=2;ln&lt;=n;ln++) &#123; for(int st=1;st&lt;=n;st++) &#123; int ed=st+ln-1; for(int k=st;k&lt;=ed-1;k++) f[st][ed]=mymax(f[st][ed],f[st][k]+f[k+1][ed]+a[st]*a[k+1]*a[ed+1]); if(ln==n) ans=mymax(ans,f[st][ed]); &#125; &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1064】金明的预算方案]]></title>
    <url>%2Fposts%2F8231.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2006 提高组 T2Luogu1064Caioj1526 Problem【Brief description】如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。【Input】输入的第1行，为两个正整数，用一个空格隔开：N m （其中N表示总钱数，m为希望购买物品的个数。）从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数v p q（其中v表示该物品的价格，p表示该物品的重要度（1~5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）【Output】输出只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）【Limited conditions】N&lt;32000m&lt;60v&lt;10000物品的价格都是10元的整数倍【Sample input】1000 5800 2 0400 5 1300 5 1400 3 0500 2 0【Sample output】2200【Sample explanation】无 Record30min Analysis请先思考后再展开 这题的关键在于附件的存在，但“附件的个数不超过2”大大降低了难度那么对于每个主件，只有以下情况 只买主件 买主件和附件1 买主件和附件2 买主件和两个附件将输入整理后，就转化成了背包问题中的经典问题：采药 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int a[70][3],b[70][3];int f[33000];//****************实现****************//****************主函数****************int main()&#123; int N,m;scanf("%d%d",&amp;N,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,z;scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(z==0) a[i][0]=x,b[i][0]=y; else if(b[z][1]==0) a[z][1]=x,b[z][1]=y; else a[z][2]=x,b[z][2]=y; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=N;j&gt;=0;j--) &#123; int x,y; x=a[i][0]; y=a[i][0]*b[i][0]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); x=a[i][0]+a[i][1]; y=a[i][0]*b[i][0]+a[i][1]*b[i][1]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); x=a[i][0]+a[i][2]; y=a[i][0]*b[i][0]+a[i][2]*b[i][2]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); x=a[i][0]+a[i][1]+a[i][2]; y=a[i][0]*b[i][0]+a[i][1]*b[i][1]+a[i][2]*b[i][2]; if(j&gt;=x) f[j]=mymax(f[j],f[j-x]+y); &#125; &#125; printf("%d",f[N]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1051】篝火晚会]]></title>
    <url>%2Fposts%2Fb7e3.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T3Luogu1053Caioj1523 Problem【Brief description】佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有n个同学，编号从1到n。一开始，同学们按照1，2，……，n的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。佳佳可向同学们下达命令，每一个命令的形式如下：(b1, b2,… bm -1, bm)这里m的值是由佳佳决定的，每次命令m的值都可以不同。这个命令的作用是移动编号是b1，b2，…… bm的这m个同学的位置。要求b1换到b2的位置上，b2换到b3的位置上，……，要求bm换到b1的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动m个人的位置，那么这个命令的代价就是m。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？【Input】第一行是一个整数n，表示一共有n个同学。其后n行每行包括两个不同的正整数，以一个空格隔开，分别表示编号是1的同学最希望相邻的两个同学的编号，编号是2的同学最希望相邻的两个同学的编号，……，编号是n的同学最希望相邻的两个同学的编号。【Output】这一行只包含一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出-1。【Limited conditions】3&lt;=n&lt;=50000【Sample input】43 44 31 21 2【Sample output】2【Sample explanation】无 Record2h Analysis请先思考后再展开 首先，假设现在有k个人在错误的位置上，那么最小花费显然就是k【猜结论】那么问题就在于如何判断多少个人错误呢?因为这是一个环，当构造出当前环和目标环后，比较也是要O(n^2)，tle妥妥的 那么接下来就是求最少错误的，等价于求最多正确的当然这里的错误与正确只是相对的，分离出不同的链就有不同的结果，取得是最多的罢了那么怎么求呢？有个很妙的方法：所谓正确的，在环状态下，其实它们与原位置的偏移量是相同的那么计算出偏移量，选取其中最多的一种方案即可 不过猜结论还是有点危险啊，因为还要反着跑一遍栗子：当前：2 3 4 1目标：4 3 2 1其实目标就是4 1 2 3，也就是反过来那么答案不是2而是0 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n;int d[51000][2];int c[51000];int s[51000];//****************实现****************int ans=INF;bool solve(int t)//方向&#123; c[1]=1;c[2]=d[1][t]; for(int i=3;i&lt;=n;i++)//构造目标环 &#123; if(c[i-2]==d[c[i-1]][0]) c[i]=d[c[i-1]][1]; else c[i]=d[c[i-1]][0]; &#125; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++) &#123; int dis=( (c[i]-i)+n )%n;//c[i]当前 i目的 s[dis]++; ans=mymin(ans,n-s[dis]); &#125;&#125;//****************主函数****************int main()&#123; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;d[i][0],&amp;d[i][1]); for(int i=1;i&lt;=n;i++)//判无解 &#123; if(d[d[i][0]][0]!=i and d[d[i][0]][1]!=i or d[d[i][1]][0]!=i and d[d[i][1]][1]!=i) &#123; printf("-1"); return 0; &#125; &#125; solve(0);solve(1); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1054】等价表达式]]></title>
    <url>%2Fposts%2F146c.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T4Luogu1054Caioj1524 Problem【Brief description】明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。这个选择题中的每个表达式都满足下面的性质：1． 表达式只可能包含一个变量‘a’。2． 表达式中出现的数都是正整数，而且都小于10000。3． 表达式中可以包括四种运算‘+’，‘-’，‘*’，‘^’，以及小括号‘(’，‘)’。（注意：运算符‘+’，‘-’，‘*’，‘^’以及小括号‘(’，‘)’都是英文字符）小括号的优先级最高，其次是‘^’，然后是‘*’，最后是‘+’和‘-’。‘+’和‘-’的优先级是相同的。相同优先级的运算从左到右进行。4． 幂指数只可能是1到10之间的正整数（包括1和10）。5． 表达式内部，头部或者尾部都可能有一些多余的空格。下面是一些合理的表达式的栗子：123456((a ^1)^2)^3a* a+a-a((a+a) )9999+(a-a)*a1+(a -1)^31^ 10^9【Input】第一行给出的是题干中的表达式。第二行是一个整数n，表示选项的个数。后面n行，每行包括一个选项中的表达式。这n个选项的标号分别是A，B，C，D……输入中的表达式的长度都不超过50个字符，而且保证选项中总有表达式和题干中的表达式是等价的。【Output】一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。【Limited conditions】2&lt;=n&lt;=26【Sample input】12345( a + 1) ^23(a-1)^2+4*aa + 1+ aa^2 + 2 * a * 1 + 1^2 + 10 -10 +a -a【Sample output】AC【Sample explanation】无 Record30min Analysis请先思考后再展开 看到题面，突然就想到了NOIP2017D1T2的“时间复杂度”都是很有意思的题目呢虽然理论上“侦探推理”也很有意思，但纯属码农题 其实这道题感觉小学的时候想过，当时想设计四则运算的计算器，但半途而废了…… 好了讲正事用函数递归求解每次找优先级最低的地方，递归左右后计算即可 然后本来想自然溢出的，结果差一个点，改long long就行了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************char s[2][60];int ln[2];ll ans[2][30];//****************实现****************bool isok(char c)&#123; return c&gt;='0' and c&lt;='9';&#125;ll power(ll x,int e) &#123;ll t=1;for(int i=1;i&lt;=e;i++) t=t*x;return t;&#125;ll make(int t,int l,int r,int a)&#123; int mi=INF,mp,now=0; bool op=0; for(int i=r;i&gt;=l;i--)//从后往前，保证自左向右结合性 &#123; int me=INF; if(s[t][i]==')') now+=100; if(s[t][i]=='(') now-=100; if(s[t][i]=='^') me=now+3,op=1; if(s[t][i]=='*') me=now+2,op=1; if(s[t][i]=='+') me=now+1,op=1; if(s[t][i]=='-') me=now+1,op=1; if(me&lt;mi) mi=me,mp=i; &#125; if(op==0) &#123; ll sum=0; for(int i=l;i&lt;=r;i++) &#123; if(s[t][i]=='a') return a; if(isok(s[t][i]))//去空格、换行、括号 sum=sum*10+s[t][i]-'0'; &#125; return sum; &#125; if(s[t][mp]=='^') return power( make(t,l,mp-1,a),make(t,mp+1,r,a) ); if(s[t][mp]=='*') return make(t,l,mp-1,a)*make(t,mp+1,r,a); if(s[t][mp]=='+') return make(t,l,mp-1,a)+make(t,mp+1,r,a); if(s[t][mp]=='-') return make(t,l,mp-1,a)-make(t,mp+1,r,a);&#125;//****************主函数****************int main()&#123; //gets(s[0]+1); scanf("%[^\r]",s[0]+1);getchar(); ln[0]=strlen(s[0]+1); for(int j=0;j&lt;=30;j++) ans[0][j]=make(0,1,ln[0],j-15); int n;scanf("%d",&amp;n);getchar(); for(int i=1;i&lt;=n;i++) &#123; //gets(s[1]+1); scanf("%[^\r]",s[1]+1);getchar(); ln[1]=strlen(s[1]+1); for(int j=0;j&lt;=30;j++) ans[1][j]=make(1,1,ln[1],j-15); if(memcmp(ans[0],ans[1],sizeof(ans[0]))==0) printf("%c",'A'+i-1); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1092】虫食算]]></title>
    <url>%2Fposts%2F6a62.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T4Luogu1092Caioj1519 Problem【Brief description】所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的栗子：123 43#9865#045+ 8468#6633=44445509678其中#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。现在，我们对问题做两个限制：首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字,但是这N个字母并不一定顺序地代表0到N-1。输入数据保证N个字母分别至少出现一次。123 BADC+CBDA DCCC上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解.【Input】包含四行。第一行有一个正整数N，后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。【Output】包含一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出N个数字，分别表示A，B，C……所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。【Limited conditions】N&lt;=26【Sample input】5ABCEDBDACEEBBAA【Sample output】1 0 3 4 2【Sample explanation】无 Record1h Analysis1请先思考后再展开 先打了个暴力，想着数据可能水【其实的确没有极限数据】但依然TLE，但已经剪枝了然后跟着题解，发现可以不递推进位，减更多这时候还是差一点，然后就是一个神奇的玄学操作了：重新编号（从后往前），dfs决断的时候编号从大到小我一开始想着，这是为了搞掉首位进位（这个也是跟题解学的）那既然如此编号从前往后，dfs的时候从小到大也一样吧结果差距是几十倍？？ 考场上绝对不能这么玩，会死的很惨 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n;int a[30];bool used[30];int jia1[30],jia2[30],he[30];//****************实现****************bool finaljudge()&#123; int jw=0; for(int i=1;i&lt;=n;i++) &#123; int x=a[jia1[i]],y=a[jia2[i]],z=a[he[i]]; if( (x+y+jw)%n!=z ) return 0; jw=(x+y+jw)/n; &#125; return 1;&#125;bool check()&#123; if(a[jia1[n]]+a[jia2[n]]&gt;=n) return 0; for(int i=1;i&lt;=n;i++)//从后往前 &#123; int x=a[jia1[i]],y=a[jia2[i]],z=a[he[i]]; if(x&lt;0 or y&lt;0 or z&lt;0) continue;//残缺 if( (x+y)%n!=z and (x+y+1)%n!=z ) return 0; &#125; return 1;&#125;int nxt[30];//新编号-Importantvoid Print()&#123; for(int i=1;i&lt;=n;i++) printf("%d ",a[i]); exit(0);&#125;void dfs(int x)&#123; if(x&gt;n) &#123; if(finaljudge()) Print(); return; &#125; //for(int i=0;i&lt;=n-1;i++) 玄学操作 for(int i=n-1;i&gt;=0;i--) if(used[i]==0) &#123; a[ nxt[x] ]=i; if(check()) &#123; used[i]=1; dfs(x+1); used[i]=0; &#125; a[ nxt[x] ]=-1; &#125;&#125;int cnt=0;//新编号-Importantvoid putnxt(int x)&#123; if(used[x]==0) &#123; used[x]=1;//借用 nxt[++cnt]=x; &#125;&#125;//****************主函数****************char ch[30];int main()&#123; scanf("%d",&amp;n); scanf("%s",ch+1);for(int i=n;i&gt;=1;i--) jia1[n-i+1]=ch[i]-'A'+1; scanf("%s",ch+1);for(int i=n;i&gt;=1;i--) jia2[n-i+1]=ch[i]-'A'+1; scanf("%s",ch+1);for(int i=n;i&gt;=1;i--) he[n-i+1]=ch[i]-'A'+1; for(int i=1;i&lt;=n;i++)//新编号-Important &#123; putnxt(jia1[i]); putnxt(jia2[i]); putnxt(he[i]); &#125; memset(used,0,sizeof(used)); memset(a,-1,sizeof(a)); dfs(1);&#125; Analysis2请先思考后再展开 并没有看懂的正解：https://blog.csdn.net/JeremyGJY/article/details/50611568https://blog.csdn.net/outer_form/article/details/50611820 Code2请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1051】谁拿了最多奖学金]]></title>
    <url>%2Fposts%2F5b4d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T1Luogu1051Caioj1521 Problem【Brief description】某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：1)院士奖学金，每人8000元，期末平均成绩高于80分，并且在本学期内发表1篇或1篇以上论文的学生均可获得；2)五四奖学金，每人4000元，期末平均成绩高于85分，并且班级评议成绩高于80分的学生均可获得；3)成绩优秀奖，每人2000元，期末平均成绩高于90分的学生均可获得；4)西部奖学金，每人1000元，期末平均成绩高于85分的西部省份学生均可获得；5)班级贡献奖，每人850元，班级评议成绩高于80分的学生干部均可获得；只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。【Input】第一行是一个整数N，表示学生的总数。接下来的N行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过20的字符串（不含空格）；期末平均成绩和班级评议成绩都是0到100之间的整数（包括0和100）；是否是学生干部和是否是西部省份学生分别用一个字符表示，Y表示是，N表示不是；发表的论文数是0到10的整数（包括0和10）。每两个相邻数据项之间用一个空格分隔。【Output】第一行是获得最多奖金的学生的姓名，第二行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。第三行是这N个学生获得的奖学金的总数。【Limited conditions】1&lt;=N&lt;=100【Sample input】4YaoLin 87 82 Y N 0ChenRuiyi 88 78 N Y 1LiXin 92 88 N N 0ZhangQin 83 87 Y N 1【Sample output】ChenRuiyi900028700【Sample explanation】例如姚林的期末平均成绩是87分，班级评议成绩82分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是4850元。 Record30min Analysis请先思考后再展开 模拟题 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************struct Boy&#123; char name[30];//姓名 int qm,bj;//期末平均成绩，班级评议成绩 bool gb,xb;//是否是学生干部，是否是西部省份学生 int lw;//发表的论文数 int jj;//奖金&#125;p[110];//****************实现****************void judge1(int x)&#123; if(p[x].qm&gt;80 and p[x].lw&gt;=1) p[x].jj+=8000;&#125;void judge2(int x)&#123; if(p[x].qm&gt;85 and p[x].bj&gt;80) p[x].jj+=4000;&#125;void judge3(int x)&#123; if(p[x].qm&gt;90) p[x].jj+=2000;&#125;void judge4(int x)&#123; if(p[x].qm&gt;85 and p[x].xb) p[x].jj+=1000;&#125;void judge5(int x)&#123; if(p[x].bj&gt;80 and p[x].gb) p[x].jj+=850;&#125;//****************主函数****************char s1[5],s2[5];int main()&#123; int n;scanf("%d",&amp;n); int mx=0,sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%s%d%d%s%s%d",p[i].name+1,&amp;p[i].qm,&amp;p[i].bj,s1,s2,&amp;p[i].lw); p[i].gb=(s1[0]=='Y');p[i].xb=(s2[0]=='Y');p[i].jj=0; judge1(i);judge2(i);judge3(i);judge4(i);judge5(i); sum+=p[i].jj; if(p[i].jj&gt;p[mx].jj) mx=i;//没有歧义 &#125; printf("%s\n%d\n%d",p[mx].name+1,p[mx].jj,sum);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1052】过河]]></title>
    <url>%2Fposts%2F200e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2005 提高组 T2Luogu1052Caioj1522 Problem【Brief description】在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0，1，……，L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。【Input】第一行有一个正整数L，表示独木桥的长度。第二行有三个正整数S，T，M，分别表示青蛙一次跳跃的最小距离，最大距离，及桥上石子的个数。第三行有M个不同的正整数分别表示这M个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。【Output】只包括一个整数，表示青蛙过河最少需要踩到的石子数。【Limited conditions】1&lt;=L&lt;=10^91&lt;=S&lt;=T&lt;=10，1&lt;=M&lt;=100【Sample input】102 3 52 3 5 6 7【Sample output】2【Sample explanation】无 Record30min Analysis请先思考后再展开 虽然说s和t都是不固定的，但它们的范围都灰常小，一种方案是状压，但代码复杂度较高，而且对新手不友好，按下不表。 其实，既然步数只有可能是1到10，那么由于题目根本不关心具体是怎么走过去的，甚至总步数都不关心，那么对于一段很长的距离，怎么走几乎是随便的。那么其实，无论s和t的取值是什么，对于1到10的最小公倍数2520（有的人会问怎么计算？把所有数字列出来，然后诸如4和8，就只取8，剩下7、8、9、10，那么因为10里面有2,8变成4，于是它们的乘积即2520了）然后根据位置差，排序后压缩路径，用bool数组对点记录即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334const int INF=0x3f3f3f3f;int a[110],b[110],c[110];int f[610000];bool v[610000];//****************主函数****************int main()&#123; int l,s,t,m;scanf("%d%d%d%d",&amp;l,&amp;s,&amp;t,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+m); for(int i=1;i&lt;=m;i++) &#123; b[i]=a[i]-a[i-1]; int tmp=b[i]%2520; if(b[i]&gt;=2520 and tmp&lt;=t) tmp+=2520;//确保正确性 c[i]=c[i-1]+tmp; v[ c[i] ]=1; &#125; memset(f,63,sizeof(f));f[0]=0; int tmp=(l-a[m])%2520; if((l-a[m])&gt;=2520 and tmp&lt;=t) tmp+=2520;//确保正确性 l=c[m]+tmp; int ans=INF; for(int i=1;i&lt;=l+t-1;i++) &#123; for(int p=s;p&lt;=t;p++) if(i-p&gt;=0) f[i]=min(f[i],f[i-p]+v[i]); if(i&gt;=l) ans=min(ans,f[i]); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1091】合唱队形]]></title>
    <url>%2Fposts%2F10e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T3Luogu1091Caioj1518 Problem【Brief description】N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。剩下的k个同学，要求顺序不变的情况下，身高从低到高再到低。已知所有N位同学的身高，计算最少需要几位同学出列。【Input】第一行是一个整数N，表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti是第i位同学的身高(厘米)。【Output】一个整数，就是最少需要几位同学出列【Limited conditions】2&lt;=N&lt;=100130&lt;=Ti&lt;=230【Sample input】8186 186 150 200 160 130 197 220【Sample output】4【Sample explanation】无 Record20min Analysis请先思考后再展开 相当于求最长上升子序列和最长下降子序列 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************int a[110];int f1[110],f2[110];//****************实现****************//****************主函数****************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; f1[i]=1; for(int j=1;j&lt;=i-1;j++) if(a[j]&lt;a[i]) f1[i]=mymax(f1[i],f1[j]+1); &#125; for(int i=n;i&gt;=1;i--) &#123; f2[i]=1; for(int j=n;j&gt;=i+1;j--) if(a[i]&gt;a[j]) f2[i]=mymax(f2[i],f2[j]+1); &#125; int ans=0; for(int i=1;i&lt;=n;i++) ans=mymax(ans,f1[i]+f2[i]-1); printf("%d",n-ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1090】合并果子]]></title>
    <url>%2Fposts%2F7e7e.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T2Luogu1090Caioj1517 Problem【Brief description】在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。【Input】包括两行，第一行是一个整数n，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai是第i种果子的数目。【Output】一个整数，也就是最小的体力耗费值。【Limited conditions】1&lt;=n&lt;=100001&lt;=ai&lt;=20000最小的体力耗费值小于2^31【Sample input】31 2 9【Sample output】15【Sample explanation】有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为 3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。 Record20min Analysis请先思考后再展开 唉没看清题目，以为是石子合并其实这道题是任意两堆合并，不在乎顺序的……所以只要每次取最小的两个，贪心即可 Code请先思考后再展开 1234567891011121314151617181920priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t; scanf("%d",&amp;t); q.push(t); &#125; int ans=0; for(int i=1;i&lt;=n-1;i++) &#123; int a=q.top();q.pop(); int b=q.top();q.pop(); ans+=a+b;q.push(a+b); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1041】传染病控制]]></title>
    <url>%2Fposts%2F5005.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T4Luogu1041Caioj1515 Problem【Brief description】研究表明，这种传染病的传播具有两种很特殊的性质；第一是它的传播途径是树型的，一个人 X 只可能被某个特定的人 Y 感染，只要 Y 不得病，或者是XY之间的传播途径被切断，则X就不会得病。第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。你的程序要针对给定的树，找出合适的切断顺序。【Input】输入格式的第一行是两个整数n和p。接下来p行，每一行有两个整数i和j，表示节点i和j间有边相连（意即，第i人和第j人之间有传播途径相连）。其中节点1是已经被感染的患者。【Output】输出总共被感染的人数【Limited conditions】1≤n≤300【Sample input】7 61 21 32 42 53 63 7【Sample output】3【Sample explanation】无 Record1h Analysis1请先思考后再展开 一开始打了个贪心，居然90？？？简易数据：10 91 21 32 42 52 63 77 88 99 10 Code1请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************struct Nod&#123; int hou; int fa; int dep,siz; bool v; Nod() &#123; hou=dep=siz=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++;e[ln].y=y; e[ln].g=p[x].hou;p[x].hou=ln;&#125;int n;vector&lt;int&gt; dp[MAXN];//****************实现****************void dfs1(int x,int fa)//计算dep、siz&#123; p[x].fa=fa; p[x].dep=p[fa].dep+1; p[x].siz=1; dp[ p[x].dep ].push_back(x); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs1(y,x); p[x].siz+=p[y].siz; &#125;&#125;void dfs2(int x)//安全&#123; p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=p[x].fa) dfs2(e[k].y);&#125;int solve()&#123; dfs1(1,0); int ans=n; for(int i=2;!dp[i].empty();i++) &#123; int t=0,sz=0; for(int j=0;j&lt;=dp[i].size()-1;j++) &#123; int x=dp[i][j]; if(p[x].v==0 and p[x].siz&gt;sz) sz=p[x].siz,t=x; &#125; dfs2(t); ans-=sz; &#125; return ans;&#125;//****************主函数****************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; printf("%d",solve());&#125; Analysis2请先思考后再展开 原来爆搜就好了QAQ Code2请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************struct Nod&#123; int hou; int fa; int dep,siz; bool v; Nod() &#123; hou=dep=siz=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++;e[ln].y=y; e[ln].g=p[x].hou;p[x].hou=ln;&#125;int n;vector&lt;int&gt; dp[MAXN];//****************实现****************void dfs1(int x,int fa)//计算dep、siz&#123; p[x].fa=fa; p[x].dep=p[fa].dep+1; p[x].siz=1; dp[ p[x].dep ].push_back(x); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs1(y,x); p[x].siz+=p[y].siz; &#125;&#125;void hit(int x,bool c)&#123; p[x].v=c; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=p[x].fa) hit(e[k].y,c);&#125;int ans=INF;void solve(int dep,int sum)&#123; ans=mymin(ans,sum); for(int i=0;i&lt;dp[dep].size();i++) &#123; int j=dp[dep][i]; if(p[j].v) continue; hit(j,1); solve(dep+1,sum-p[j].siz); hit(j,0); &#125;&#125;//****************主函数****************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs1(1,0); solve(2,n); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1089】津津的储蓄计划]]></title>
    <url>%2Fposts%2Fe897.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2004 提高组 T1Luogu1089Caioj1516 Problem【Brief description】津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20％还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100元或恰好100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。例如11月初津津手中还有83元，妈妈给了津津300元。津津预计11月的花销是180元，那么她就会在妈妈那里存200元，自己留下183元。到了11月月末，津津手中会剩下3元钱。津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20％还给津津之后，津津手中会有多少钱。【Input】包括12行数据，每行分别表示1月到12月津津的预算。【Output】一行，这一行只包含一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出-X，X表示出现这种情况的第一个月；否则输出到2004年年末津津手中会有多少钱。【Limited conditions】预算是一个小于350的非负整数【Sample input】29023028020030017034050908020060【Sample output】-7【Sample explanation】无 Record20min Analysis请先思考后再展开 模拟 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=310,MAXM=91000;const int INF=0x3f3f3f3f;//****************全局定义****************int a[13];//****************实现****************//****************主函数****************int main()&#123; int s=0,now=0; for(int i=1;i&lt;=12;i++) &#123; scanf("%d",&amp;a[i]); now+=300; now-=a[i]; if(now&lt;0) &#123; printf("%d",-i); return 0; &#125; s+=(now/100)*100; now%=100; &#125; double t=now; t+=double(s)*1.2; printf("%.0lf",t);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1006】加分二叉树]]></title>
    <url>%2Fposts%2F1339.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T3Luogu1006Caioj1535 Problem【Brief description】设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分×subtree的右子树的加分+subtree的根的分数若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；（1）tree的最高加分（2）tree的前序遍历【Input】第1行：一个整数n，为节点个数。第2行：n个用空格隔开的整数，为每个节点的分数。【Output】第1行：一个整数，为最高加分。第2行：n个用空格隔开的整数，为该树的前序遍历。【Limited conditions】n＜30分数＜100结果不会超过4,000,000,000【Sample input】55 7 1 2 10【Sample output】1453 1 2 4 5【Sample explanation】无 Record30min Analysis请先思考后再展开 经典题 Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n;int d[40];int rt[40][40];//区间根//****************实现****************int f[40][40];void treedp(int l,int r)&#123; if(f[l][r]&gt;0) return; if(l&gt;r) &#123; f[l][r]=1; return; &#125; if(l==r) &#123; f[l][r]=d[l]; rt[l][r]=l; return; &#125; for(int i=l;i&lt;=r;i++) &#123; treedp(l,i-1);treedp(i+1,r); int t=f[l][i-1]*f[i+1][r]+d[i]; if(t&gt;f[l][r]) &#123; f[l][r]=t; rt[l][r]=i; &#125; &#125;&#125;void pf(int l,int r)&#123; int mid=rt[l][r]; printf("%d ",mid); if(l&lt;=mid-1) pf(l,mid-1); if(mid+1&lt;=r) pf(mid+1,r);&#125;//****************主函数****************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i]); treedp(1,n); printf("%d\n",f[1][n]); pf(1,n);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2326】数学作业]]></title>
    <url>%2Fposts%2F34da.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2011 Day1 T1Bzoj2326Luogu3216 Problem【Brief description】给定正整数 N 和 M 要求计算 Concatenate (1 .. N) Mod M 的值，其中 Concatenate (1 ..N)是将所有正整数 1, 2, …, N 顺序连接起来得到的数。例如，N = 13, Concatenate (1 .. N)=12345678910111213.小C 想了大半天终于意识到这是一道不可能手算出来的题目，于是他只好向你求助，希望你能编写一个程序帮他解决这个问题。【Input】只有一行且为用空格隔开的两个正整数N和M，【Output】仅包含一个非负整数，表示 Concatenate (1 .. N) Mod M 的值。【Limited conditions】1≤N≤10^18且1≤M≤10^9.【Sample input】13 13【Sample output】4【Sample explanation】无 Analysis请先思考后再展开 矩阵乘法分层即可今天早上考试的签到题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll MOD;struct martix&#123; int row,col; ll m[10][10]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.m[i][j]=(c.m[i][j]+(a.m[i][k]%MOD)*(b.m[k][j]%MOD)%MOD)%MOD; return c;&#125;martix pre(int n)&#123; martix a;a.row=a.col=n; for(int i=1;i&lt;=n;i++) a.m[i][i]=1; return a;&#125;martix power(martix x,ll e)&#123; martix ans=pre(x.row); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,x); x=cheng(x,x);e&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; ll n;scanf("%lld%lld",&amp;n,&amp;MOD); martix a;a.row=a.col=3; a.m[1][1]=1;a.m[1][2]=a.m[2][2]=a.m[2][3]=a.m[3][3]=1; martix b;b.row=3;b.col=1; b.m[2][1]=b.m[3][1]=1; ll s=10; while(1) &#123; ll l=s/10ll,r=s-1; ll e=r-l+1; if(n&lt;r) e=n-l+1; martix tmp=a;tmp.m[1][1]=s%MOD;tmp=power(tmp,e); b=cheng(tmp,b); if(n&lt;s) break; s*=10; &#125; printf("%lld",b.m[1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1039】侦探推理]]></title>
    <url>%2Fposts%2F9061.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T2Luogu1039Caioj1513 Problem【Brief description】明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：证词中出现的其他话，都不列入逻辑推理的内容。明明所知道的是，他的同学中有N个人始终说假话，其余的人始终说真。现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！【Input】输入由若干行组成，第一行有三个整数，M、N和P；M是参加游戏的明明的同学数，N是其中始终说谎的人数，P是证言的总数。接下来M行，每行是明明的一个同学的名字（英文字母组成，没有空格，全部大写）。往后有P行，每行开始是某个同学的名宇，紧跟着一个冒号和一个空格，后面是一句证词，符合前表中所列格式。证词每行不会超过250个字符。输入中不会出现连续的两个空格，而且每行开头和结尾也没有空格。【Output】如果你的程序能确定谁是罪犯，则输出他的名字；如果程序判断出不止一个人可能是罪犯，则输出 Cannot Determine；如果程序判断出没有人可能成为罪犯，则输出 Impossible。【Limited conditions】1≤M≤201≤N≤M1≤P≤100【Sample input】3 1 5MIKECHARLESKATEMIKE: I am guilty.MIKE: Today is Sunday.CHARLES: MIKE is guilty.KATE: I am guilty.KATE: How are you??【Sample output】MIKE【Sample explanation】无 Record30min Analysis请先思考后再展开 真有意思的题面嘿嘿然后又去看了看数据没有极限数据是意料之中【取而代之的是恶心数据，不知道满分的都是什么人……】的了，但居然还有这个hhI love you!If there must be a deadline,I hope it is 10000 years!!!然后他的名字是拼音，翻译过来就是：曾经有一段真挚的感情。芳，在我面前，我没有珍惜。等到失去了以后，才追悔莫及。人世间最痛苦的事莫过于此。如果上天能给我一个再来一次的机会，我会对那个女孩子说三个字 好了讲正事，暴力枚举判断可行性即可就是这个输入麻烦……大小写敏感测试点#2：有一位同志，既承认自己有罪，又承认自己无罪。【然后答案居然是Impossible，辣鸡题面没说清】测试点#9：“I is not guilty.”，I是人名 woc，这道题大家别写了……虽然我已经把代码尽量精炼，依然是毒瘤题，特别是输入对了，理论上判断废话的时候，前面和后面可能会有废话，而中间重要，但没有这种数据就不打了，太恶心了这种题…… UP:弃坑了可能以后也不会填了贴一个别人的代码吧哎【灰常优质】 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;map&lt;string,int&gt; name;string s,ss;string names[25];string testimony[25][105];int num[25];int n,m,p;bool crap(string tmp)&#123; if(tmp==" I am guilty.") return 0; if(tmp==" I am not guilty.") return 0; if(tmp==" Today is Monday.") return 0; if(tmp==" Today is Tuesday.") return 0; if(tmp==" Today is Wednesday.") return 0; if(tmp==" Today is Thursday.") return 0; if(tmp==" Today is Friday.") return 0; if(tmp==" Today is Saturday.") return 0; if(tmp==" Today is Sunday.") return 0; for(int i=1;i&lt;=m;i++) if(tmp==" "+names[i]+" is guilty."||tmp==" "+names[i]+" is not guilty.") return 0; return 1;&#125;bool judge(int guilty,int day)&#123; int ans; for(int i=1;i&lt;=m;i++) &#123; ans=0; for(int j=1;j&lt;=num[i];j++) &#123; if(testimony[i][j]==" I am guilty."&amp;&amp;guilty!=i) &#123;ans++;&#125; if(testimony[i][j]==" I am not guilty."&amp;&amp;guilty==i) &#123;ans++;&#125; if(testimony[i][j]==" Today is Monday."&amp;&amp;day!=1) &#123;ans++;&#125; if(testimony[i][j]==" Today is Tuesday."&amp;&amp;day!=2) &#123;ans++;&#125; if(testimony[i][j]==" Today is Wednesday."&amp;&amp;day!=3) &#123;ans++;&#125; if(testimony[i][j]==" Today is Thursday."&amp;&amp;day!=4) &#123;ans++;&#125; if(testimony[i][j]==" Today is Friday."&amp;&amp;day!=5) &#123;ans++;&#125; if(testimony[i][j]==" Today is Saturday."&amp;&amp;day!=6) &#123;ans++;&#125; if(testimony[i][j]==" Today is Sunday."&amp;&amp;day!=7) &#123;ans++;&#125; for(int k=1;k&lt;=m;k++) &#123; if(testimony[i][j]==" "+names[k]+" is guilty."&amp;&amp;guilty!=k) &#123;ans++;&#125; if(testimony[i][j]==" "+names[k]+" is not guilty."&amp;&amp;guilty==k) &#123;ans++;&#125; &#125; &#125; if(ans!=num[i]&amp;&amp;ans!=0) return 0; &#125; return 1;&#125;int check(int guilty,int day)&#123; int ans=0; bool twice; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=num[i];j++) &#123; twice=0; if(testimony[i][j]==" I am guilty."&amp;&amp;guilty!=i) &#123;ans++;break;&#125; if(testimony[i][j]==" I am not guilty."&amp;&amp;guilty==i) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Monday."&amp;&amp;day!=1) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Tuesday."&amp;&amp;day!=2) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Wednesday."&amp;&amp;day!=3) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Thursday."&amp;&amp;day!=4) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Friday."&amp;&amp;day!=5) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Saturday."&amp;&amp;day!=6) &#123;ans++;break;&#125; if(testimony[i][j]==" Today is Sunday."&amp;&amp;day!=7) &#123;ans++;break;&#125; for(int k=1;k&lt;=m;k++) &#123; if(testimony[i][j]==" "+names[k]+" is guilty."&amp;&amp;guilty!=k) &#123;ans++;twice=1;break;&#125; if(testimony[i][j]==" "+names[k]+" is not guilty."&amp;&amp;guilty==k) &#123;ans++;twice=1;break;&#125; &#125; if(twice==1) break; &#125; if(ans!=n) for(int i=1;i&lt;=m;i++) &#123; if(num[i]==0) ans++; if(ans==n) break; &#125; return ans;&#125;int read()&#123; char c=getchar(); int ans=0; while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') &#123; ans=ans*10+c-48; c=getchar(); &#125; return ans;&#125;string gl()&#123; string sss,c; do &#123; cin&gt;&gt;c; sss=sss+" "+c; &#125; while(c[c.size()-1]!='.'&amp;&amp;c[c.size()-1]!='?'&amp;&amp;c[c.size()-1]!='!'&amp;&amp;c[c.size()-1]!=','); return sss;&#125;int main()&#123; m=read();n=read();p=read(); for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;s; name[s]=i; names[i]=s; &#125; for(int i=1;i&lt;=p;i++) &#123; cin&gt;&gt;s; s=s.substr(0,s.size()-1); ss=gl(); if(crap(ss)) continue; num[name[s]]++; testimony[name[s]][num[name[s]]]=ss; &#125; int flag=0; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=7;j++) if(check(i,j)==n&amp;&amp;judge(i,j)) &#123; if(flag!=0) &#123; cout&lt;&lt;"Cannot Determine"&lt;&lt;endl; return 0; &#125; else &#123; flag=i; break; &#125; &#125; if(flag==0) cout&lt;&lt;"Impossible"&lt;&lt;endl; else cout&lt;&lt;names[flag]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1038】神经网络]]></title>
    <url>%2Fposts%2F3ef1.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2003 提高组 T1Luogu1038Caioj1512 Problem【Brief description】在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的栗子：神经元〔编号为1）图中，X1―X3是信息输入渠道，Y1－Y2是信息输出渠道，C1表示神经元目前的状态，Ui是阈值，可视为神经元的一个内在参数。神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的栗子。兰兰规定，Ci服从公式：（其中n是网络中所有神经元的数目）公式中的Wji（可能为负值）表示连接j号神经元和i号神经元的边的权值。当 Ci 大于0时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为Ci。如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（Ci），要求你的程序运算出最后网络输出层的状态。【Input】第一行是两个整数n和p。接下来n行，每行两个整数，第i＋1行是神经元i最初状态和其阈值（Ui），非输入层的神经元开始时状态必然为0。再下面P行，每行由两个整数i，j及一个整数Wij，表示连接神经元i、j的边权值为Wij。【Output】输出文件包含若干行，每行有两个整数，分别对应一个神经元的编号，及其最后的状态，两个整数间以空格分隔。仅输出最后状态大于零的输出层神经元状态，并且按照编号由小到大顺序输出！若输出层的神经元最后状态均为 0，则输出 NULL。【Limited conditions】1≤n≤200【Sample input】5 61 01 00 10 10 11 3 11 4 11 5 12 3 12 4 12 5 1【Sample output】3 14 15 1【Sample explanation】无 Record30min Analysis请先思考后再展开 拓扑裸题坑点: 输入层c不用计算，u没用 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int MAXN=210,MAXM=51000;const int INF=0x3f3f3f3f;//****************全局定义****************struct Nod&#123; int hou; int c; int ru; bool v; Nod() &#123; hou=ru=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; e[++ln].y=y;e[ln].c=c;e[ln].g=p[x].hou; p[x].hou=ln;p[y].ru++;&#125;//****************实现****************int n;void solve()&#123; int tp=0; while(tp&lt;n) &#123; tp++; int x=-1;for(int i=1;i&lt;=n;i++) if(p[i].c&gt;0 and p[i].ru==0) &#123;x=i;break;&#125; if(x&lt;0) break; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; p[y].ru--; p[y].c+=e[k].c*p[x].c; &#125; if(p[x].hou&gt;0) p[x].c=0;//debug &#125;&#125;//****************主函数****************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d%d",&amp;p[i].c,&amp;t); if(p[i].c==0) p[i].c-=t; &#125; while(m--) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c); &#125; solve(); bool bk=0; for(int i=1;i&lt;=n;i++) if(p[i].hou==0 and p[i].c&gt;0) bk=1,printf("%d %d\n",i,p[i].c); if(bk==0) printf("NULL");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1034】矩形覆盖]]></title>
    <url>%2Fposts%2F7.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T4Luogu1034Caioj1511 Problem【Brief description】在平面上有 n 个点，每个点用一对整数坐标表示。例如：当 n=4 时，4个点的坐标分另为：p1(1,1),p2(2,2),p3(3，6),P4(0,7)，见图一。这些点可以用 k 个矩形（1&lt;=k&lt;=4）全部覆盖，矩形的边平行于坐标轴。当 k=2 时，可用如图二的两个矩形 s1，s2 覆盖，s1，s2 面积和为 4。问题是当 n 个点坐标和 k 给出后，怎样才能使得覆盖所有点的 k 个矩形的面积之和为最小。约定：覆盖一个点的矩形面积为 0；覆盖平行于坐标轴直线上点的矩形面积也为0。各个矩形必须完全分开（边线与顶点也都不能重合）。【Input】n k x1 y1 x2 y2 ……xn yn【Output】一个整数，即满足条件的最小的矩形面积之和。【Limited conditions】n&lt;=500&lt;=xi,yi&lt;=500【Sample input】4 21 12 23 60 7【Sample output】4【Sample explanation】无 Record1h Analysis1请先思考后再展开 首先手痒看了看数据，一如既往地水，连极限数据都没有一开始想着50^6枚举矩形对角点，发现很麻烦，计算量大于是又看了题解，正解太复杂，不管了……【其实正解(极角排序是计算几何的玩意)没有存在的必要，因为我测试了极限数据，灰常快】那么其实只要预设k个矩阵，枚举每个点，假设加入即可 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2018//****************头文件****************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//****************全局常量****************const int INF=0x3f3f3f3f;//****************全局定义****************int n,k;struct Pt&#123; int x,y;&#125;p[510];struct Sqr&#123; Pt a,b;//左下、右上 bool v;//初始 Sqr() &#123; v=0; &#125;&#125;sq[5];//****************实现****************bool isfg(int x,int y)&#123; if(sq[x].v==0 or sq[y].v==0) return 0; if(sq[x].a.x&gt;sq[y].b.x or sq[x].a.y&gt;sq[y].b.y) return 0; if(sq[y].a.x&gt;sq[x].b.x or sq[y].a.y&gt;sq[x].b.y) return 0; return 1;&#125;bool okay()&#123; for(int i=1;i&lt;=k;i++) for(int j=1;j&lt;=k;j++) if(i!=j and isfg(i,j)) return 0; return 1;&#125;int sum()&#123; int ans=0; for(int i=1;i&lt;=k;i++) if(sq[i].v!=0) ans+=(sq[i].b.x-sq[i].a.x)*(sq[i].b.y-sq[i].a.y); return ans;&#125;int ans=INF;void dfs(int used)&#123; if(used==n) &#123; int t=0; for(int i=1;i&lt;=k;i++) if(sq[i].v==0) return; else t+=(sq[i].b.x-sq[i].a.x)*(sq[i].b.y-sq[i].a.y); ans=mymin(ans,t); return; &#125; int x=used+1; for(int i=1;i&lt;=k;i++) &#123; Sqr tmp=sq[i]; if(sq[i].v==0) &#123; sq[i].v=1; sq[i].a=sq[i].b=p[x]; &#125; else &#123; sq[i].a.x=mymin(sq[i].a.x,p[x].x); sq[i].a.y=mymin(sq[i].a.y,p[x].y); sq[i].b.x=mymax(sq[i].b.x,p[x].x); sq[i].b.y=mymax(sq[i].b.y,p[x].y); &#125; if(okay() and sum()&lt;ans) dfs(used+1); sq[i]=tmp;//还原 &#125;&#125;//****************主函数****************int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); dfs(0); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1033】自由落体]]></title>
    <url>%2Fposts%2F19c9.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T3Luogu1033Caioj1510辣鸡题面一大堆错误 Problem【Brief description】在高为 H 的天花板上有 n 个小球，体积不计，位置分别为 0，1，2，… ，n-1。在地面上有一个小车（长为 L，高为 K，距原点距离为 S1）。已知小球下落距离计算公式为 $d=\frac{g\times t^2}{2}$ ，其中 g=10，t为下落时间。地面上的小车以速度 V 前进。小车与所有小球同时开始运动，当小球距小车的距离 &lt;= 0.0001时，即认为小球被小车接收（小球落到地面后不能被接收）。请你计算出小车能接收到多少个小球（当球落入车的尾部时，算作落入车内）。【Input】H，S1，V，L，K，n【Output】小车能接收到的小球个数【Limited conditions】1&lt;=H，S1，V，L，K，n&lt;=100000【Sample input】5.0 9.0 5.0 2.5 1.8 5【Sample output】1【Sample explanation】无 Record30min Analysis请先思考后再展开 一开始想错了……现在越来越觉得noip2017真的是太幸运了，题目比较正常这种精度题，公式很容易推错，特别是那个精度不是很懂怎么用然后比赛的时候也出不了什么强力数据 主要从最早和最晚情况考虑自由落体公式化简：$ t=\sqrt{\frac{d}{5}} $早：落到地面（底部）时间：$ a=\sqrt{\frac{H}{5}} $车头到达时间：$ b=\frac{S-(i+0.0001)}{v} $条件：$ a\geq b $晚：落到车尾（顶部）时间：$ c=\sqrt{\frac{H-K}{5}} $车尾到达时间：$ d=\frac{(S+L)-(i-0.0001)}{v} $条件：$ c\leq d $【注意很多网上代码的d都是错误的，0.0001应该是负】 Code请先思考后再展开 1234567891011121314int main()&#123; double h,s,v,l,k,n;scanf("%lf%lf%lf%lf%lf%lf",&amp;h,&amp;s,&amp;v,&amp;l,&amp;k,&amp;n); int ans=0; for(int i=0;i&lt;=n-1;i++) &#123; if( ( (s+l)-(i-0.0001) )/v &gt;= sqrt( (h-k)/5 ) and sqrt(h/5) &gt;= ( s-(i+0.0001) )/v ) ans++; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1032】字串变换]]></title>
    <url>%2Fposts%2F3d30.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T2Luogu1032Caioj1509 Problem【Brief description】已知有两个字串 A, B 及一组字串变换的规则（至多6个规则）:A1 -&gt; B1A2 -&gt; B2规则的含义为：在 A中的子串 A1 可以变换为 B1、A2 可以变换为 B2 ……例如：A＝’abcd’ B＝’xyz’变换规则为：‘abc’-&gt;’xu’‘ud’-&gt;’y’‘y’-&gt;’yz’则此时，A 可以经过一系列的变换变为 B，其变换的过程为：‘abcd’-&gt;’xud’-&gt;’xy’-&gt;’xyz’共进行了三次变换，使得 A 变换为 B。【Input】A BA1 B1A2 B2… …【Output】若在 10 步（包含 10步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出”NO ANSWER!”【Limited conditions】所有字符串长度的上限为 20。【Sample input】abcd xyzabc xuud yy yz【Sample output】3【Sample explanation】无 Record2h剪枝是灰常重要滴！ Analysis1请先思考后再展开 边跑步边想……然后最好bfs，但去重好麻烦，先打个dfs试试感觉会超时，真的太危险啦然鹅事实上set的log可以剪掉灰常多的枝 or 数据乱出，很水果然是陈年老题s stl大法好 哦有个坑点：题目是可以变换，那就不一定要全部变 一直wa啊，有一个很玄学的地方，不知有没有dalao知道？UP:原来是因为，size返回的是一个无符号数，要转化为int Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int INF=0x3f3f3f3f;//*******************全局定义****************string st,ed;string op1[10],op2[10];int f;map&lt;string,int&gt; has;//对应答案int mi,mx;//长度可行性优化//*******************实现******************void dfs(string now,int p)&#123; if(p&gt;=10) return; if( (int)now.length()+(10-p)*mi &gt; (int)ed.length() ) return; if( (int)now.length()+(10-p)*mx &lt; (int)ed.length() ) return; for(int i=1;i&lt;=f;i++) &#123; int pos=now.find(op1[i],0); while(pos&gt;=0) &#123; string tmp=now; tmp.replace(pos,op1[i].length(),op2[i]); if( !has.count(tmp) or has[tmp]&gt;p+1) has[tmp]=p+1,dfs(tmp,p+1); pos=now.find(op1[i],pos+1); &#125; &#125;&#125;//*******************主函数******************int main()&#123; cin&gt;&gt;st&gt;&gt;ed; f=1;mi=INF;mx=0; while(cin&gt;&gt;op1[f]&gt;&gt;op2[f]) &#123; mi=mymin(mi,op2[f].length()-op1[f].length()); mx=mymax(mx,op2[f].length()-op1[f].length()); f++; &#125; f--; has[st]=0; dfs(st,0); if(!has.count(ed)) printf("NO ANSWER!"); else printf("%d",has[ed]);&#125; Analysis2请先思考后再展开 然后akc教我hash，自然溢出什么的终于到最快的正解bfs了不过因为是手写的数组，空间不好控制【不明确的数据范围】 Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=100000;const int INF=0x3f3f3f3f;//*******************全局定义****************set&lt;int&gt; has;struct Str&#123; char s[300]; int ln; int ps;&#125;;Str st,ed;int sth,edh;Str op1[10],op2[10];int n;int mi,mx;//长度可行性优化//*******************实现******************int hashstr(Str s)&#123; int ans=0,t=1; for(int i=1;i&lt;=s.ln;i++) &#123; ans+=t*s.s[i]; t*=271; &#125; return ans;&#125;Str lst[MAXN];int bfs()&#123; sth=hashstr(st);edh=hashstr(ed); has.insert(sth);st.ps=0; int tou=1,wei=2;lst[tou]=st; while(tou!=wei) &#123; Str now=lst[tou++]; if(tou==MAXN) tou=1; if(now.ps&gt;=10) return 0; for(int i=1;i&lt;=n;i++) &#123; int last=0; while(1) &#123; string str=now.s+1; int t=str.find(op1[i].s+1,last); if(t&lt;0) break; str.replace(t,op1[i].ln,op2[i].s+1); last=t+1; Str nxt;strcpy(nxt.s+1,str.c_str()); nxt.ln=str.length();nxt.ps=now.ps+1; if(nxt.ln+(10-nxt.ps)*mi&gt;ed.ln) continue; if(nxt.ln+(10-nxt.ps)*mx&lt;ed.ln) continue; int hs=hashstr(nxt); if(hs==edh) return nxt.ps; if(has.count(hs)==0) &#123; has.insert(hs); lst[wei++]=nxt; if(wei==MAXN) wei=1; &#125; &#125; &#125; &#125; return 0;&#125;//*******************主函数******************int main()&#123; scanf("%s%s",st.s+1,ed.s+1); st.ln=strlen(st.s+1);ed.ln=strlen(ed.s+1); n=1;mi=INF;mx=0; while(scanf("%s%s",op1[n].s+1,op2[n].s+1)!=EOF) &#123; op1[n].ln=strlen(op1[n].s+1); op2[n].ln=strlen(op2[n].s+1); mi=mymin(mi,op2[n].ln-op1[n].ln); mx=mymax(mx,op2[n].ln-op1[n].ln); n++; &#125; n--; int t=bfs(); if(!t) printf("NO ANSWER!"); else printf("%d",t);&#125; Analysis3请先思考后再展开 其实如果不满足也可以用折半搜索（不会刻意搜索我的其他题，应该会找到些解释）懒得打了……]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1031】均分纸牌]]></title>
    <url>%2Fposts%2F24a0.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2002 提高组 T1Luogu1031Caioj1508 Problem【Brief description】有N堆纸牌，编号分别为 1，2，…… , N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。【Input】N（N 堆纸牌）A1 A2 …… An （N 堆纸牌，每堆纸牌初始数）【Output】所有堆均达到相等时的最少移动次数。【Limited conditions】1 &lt;= N &lt;= 1001 &lt;= Ai &lt;= 10000【Sample input】49 8 17 6【Sample output】3【Sample explanation】123456N=4，4堆纸牌数分别为：(1) 9 (2) 8 (3) 17 (4) 6移动3次可达到目的：从 (3) 取 4 张牌放到 (4)（9 8 13 10） -&gt; 从 (3) 取 3 张牌放到 (2)（9 11 10 10） -&gt; 从 (2) 取 1 张牌放到 (1)（10 10 10 10） Record30min Analysis1请先思考后再展开 显然我的贪心很菜 首先，显然我们要与平均数比较，所以可以直接全部减去平均数那么把方向固定，以从左到右为例，对于i，前面i-1个已经解决【不一定是顺序上的】因为只能相邻操作，才保证了这种做法的正确性，总会有与i+1交互的过程那么自己不平衡的时候，步数+1，转移不平衡即可 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************int a[110];//*******************实现****************** //*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); sum+=a[i]; &#125; sum/=n; int ans=0; for(int i=1;i&lt;=n;i++) &#123; a[i]-=sum; if(a[i]!=0) &#123; ans++; a[i+1]+=a[i]; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1027】Car的旅行路线]]></title>
    <url>%2Fposts%2Fe9ee.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T4Luogu1027Caioj1507 Problem【Brief description】又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。那么Car应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。找出一条从城市A到B的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。【Input】第一行为一个正整数n，表示有n组测试数据。每组的第一行有四个正整数s，t，A，B。S表示城市的个数，t表示飞机单位里程的价格，A，B分别为城市A，B的序号。接下来有S行，其中第I行均有7个正整数xi1，yi1，xi2，yi2，xi3，yi3，Ti，这当中的(xi1，yi1)，(xi2，yi2)，(xi3，yi3)分别是第I个城市中任意三个机场的坐标，T I为第I个城市高速铁路单位里程的价格。【Output】共有n行，每行一个数据对应测试数据。保留一位小数【Limited conditions】0&lt;=n&lt;=100&lt;S&lt;=1001&lt;=A，B&lt;=S【Sample input】13 10 1 31 1 1 3 3 1 302 5 7 4 5 2 18 6 8 8 11 6 3【Sample output】47.5【Sample explanation】 Record1h Analysis1请先思考后再展开 这就是一个复杂构图的最短路裸题属于码农题 关于矩形的第四个点，我是自己yy出来的，写了较多注释 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;double mymin(double x,double y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=410;const int INF=0x3f3f3f3f;//*******************全局定义****************struct Nod&#123; double x,y; double d; bool v; Nod() &#123; v=0; &#125;&#125;p[MAXN];double cs[MAXN];double mp[MAXN][MAXN];//*******************实现******************double dis(double ax,double ay,double bx,double by)&#123; return sqrt( (ax-bx)*(ax-bx)+(ay-by)*(ay-by) );&#125;void calc4(int x)&#123; int a=4*(x-1),b=4*(x-1)+1,c=4*(x-1)+2,d=4*(x-1)+3; double mx=(p[a].x+p[b].x)/2,my=(p[a].y+p[b].y)/2;//尝试ab double d1=dis(mx,my,p[a].x,p[a].y),d2=dis(mx,my,p[c].x,p[c].y); if( d1-d2&lt;-1e-6 or d1-d2&gt;1e-6 )//取错了，尝试ac &#123; swap(b,c); mx=(p[a].x+p[b].x)/2;my=(p[a].y+p[b].y)/2; d1=dis(mx,my,p[a].x,p[a].y),d2=dis(mx,my,p[c].x,p[c].y); if( d1-d2&lt;-1e-6 or d1-d2&gt;1e-6 )//取错了，尝试bc &#123; swap(a,c); mx=(p[a].x+p[b].x)/2;my=(p[a].y+p[b].y)/2; d1=dis(mx,my,p[a].x,p[a].y),d2=dis(mx,my,p[c].x,p[c].y); &#125; &#125; //a b c d //a c b d //b c a d //现确保a和b为对角 p[d].x=mx*2-p[c].x; p[d].y=my*2-p[c].y; //p[d].x+p[c].x=mx*2&#125;int lst[MAXN];int n;void spfa(int st)&#123; int tou=1,wei=2;lst[tou]=st; p[st].v=1;p[st].d=0; while(tou!=wei) &#123; int x=lst[tou++]; if(tou==MAXN) tou=1; for(int j=0;j&lt;=4*n-1;j++) &#123; if(p[j].d&gt;p[x].d+mp[x][j]) &#123; p[j].d=p[x].d+mp[x][j]; if(!p[j].v) &#123; p[j].v=1; lst[wei++]=j; if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125;&#125;//*******************主函数******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int st,ed;double s;scanf("%d%lf%d%d",&amp;n,&amp;s,&amp;st,&amp;ed); for(int i=1;i&lt;=n;i++) &#123; for(int t1=0;t1&lt;=2;t1++) scanf("%lf%lf",&amp;p[4*(i-1)+t1].x,&amp;p[4*(i-1)+t1].y); calc4(i);scanf("%lf",&amp;cs[i]); &#125; for(int i=0;i&lt;=4*n-1;i++) &#123; for(int j=0;j&lt;i;j++) &#123; double ts=( (i/4)==(j/4) )?cs[i/4+1]:s; mp[i][j]=mp[j][i]=dis(p[i].x,p[i].y,p[j].x,p[j].y)*ts; &#125; &#125; double ans=INF; for(int i=0;i&lt;=3;i++) &#123; for(int j=0;j&lt;=4*n-1;j++) p[j].d=INF; spfa(4*(st-1)+i); for(int j=0;j&lt;=3;j++) ans=mymin(ans,p[ 4*(ed-1)+j ].d); &#125; printf("%.2lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1026】统计单词个数]]></title>
    <url>%2Fposts%2Fd51a.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T3Luogu1026Caioj1506 Problem【Brief description】给出一个长度不超过200的由小写英文字母组成的字母串。约定：该字串以每行20个字母的方式输入，且保证每行一定为20个。要求将此字母串分成k份，且每份中包含的单词个数加起来总数最大。每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可以包含this和is，选用this之后就不能包含th。单词在给出的一个不超过6个单词的字典中。要求输出最大的个数。【Input】第一行有2个正整数p，k。p表示字串的行数；k表示分为k个部分。接下来的p行，每行均有20个字符。再接下来有一个正整数s，表示字典中单词个数。接下来的s行，每行均有一个单词。【Output】一个整数，表示划分出来的最多单词个数【Limited conditions】1≤s≤6，1&lt;k≤40【Sample input】1 3thisisabookyouareaoh4isaoksab【Sample output】7【Sample explanation】按如下方式划分字符串：this/isabookyoua/reaoh Record1h Analysis1请先思考后再展开 错误解法：kmp乱搞会wa的……【居然也就20分】数据:1 4aaaaaaaaaaaaaaaaaaaa1aaaaa 主要思路：所谓寻找字符串，那划分一定不是重点【flag】那么就先kmp查找，统计一下断点的影响量即可 但这样会减重复然后不知道怎么更正……又去膜题解了 Code1请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************char s[300];int ls;char s2[10][300];int ls2[10];//*******************实现******************int nxt[10][300];void calcnxt(int x)&#123; nxt[x][1]=0; for(int i=2;i&lt;=ls2[x];i++) &#123; int j=nxt[x][i-1]; while(j&gt;0 and s2[x][j+1]!=s2[x][i]) j=nxt[x][j]; if(s2[x][j+1]==s2[x][i]) nxt[x][i]=j+1; else nxt[x][i]=0; &#125;&#125;int a[300];bool v[300];int ans=0;void kmp(int x)&#123; int j=0; for(int i=1;i&lt;=ls;i++) &#123; while(j&gt;0 and s2[x][j+1]!=s[i]) j=nxt[x][j]; if(s2[x][j+1]==s[i]) j++; if(j==ls2[x]) &#123; int st=i-j+1; if(!v[st]) &#123; v[st]=1; for(int k=st;k&lt;=i-1;k++) a[k]++; ans++; &#125; &#125; &#125;&#125;//*******************主函数******************char ts[300];int main()&#123; int p,k;scanf("%d%d",&amp;p,&amp;k); while(p--) scanf("%s",ts),strcat(s+1,ts); ls=strlen(s+1); int t;scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++) &#123; scanf("%s",s2[i]+1); ls2[i]=strlen(s2[i]+1); calcnxt(i); kmp(i); &#125; sort(a+1,a+(ls-1)+1); for(int i=1;i&lt;=k-1;i++) ans-=a[i]; printf("%d",ans);&#125; Analysis2请先思考后再展开 居然又是dp哎好菜主要是预处理出区间的答案本做法其实灰常慢……因为匹配的时候是暴力但数据太水，而且题目居然还不说单词长度 Code2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************int ss;char s[300],s2[10][300];int ls2[10];int q[300][300];int f[300][50];//*******************实现******************int ask(int l,int r)&#123; for(int i=1;i&lt;=ss;i++) &#123; if(r-l+1&lt;ls2[i]) continue; int j=0;while(s2[i][j+1]==s[l+j] and j+1&lt;=ls2[i]) j++;//debug if(j==ls2[i]) return 1; &#125; return 0;&#125;//*******************主函数******************int main()&#123; int p,k;scanf("%d%d",&amp;p,&amp;k); for(int i=1;i&lt;=p;i++) scanf("%s",s+(i-1)*20+1); p*=20; scanf("%d",&amp;ss); for(int i=1;i&lt;=ss;i++) scanf("%s",s2[i]+1),ls2[i]=strlen(s2[i]+1); /* for(int l=1;l&lt;=p;l++) for(int r=l;r&lt;=p;r++) for(int st=l;st&lt;=r;st++) q[l][r]+=ask(st,r); */ for(int l=p;l&gt;=1;l--) for(int r=l;r&lt;=p;r++) q[l][r]=q[l+1][r]+ask(l,r); //优化 for(int i=1;i&lt;=p;i++) f[i][1]=q[1][i]; for(int bl=2;bl&lt;=k;bl++) for(int i=bl;i&lt;=p;i++) for(int j=bl-1;j&lt;=i-1;j++) f[i][bl]=mymax(f[i][bl],f[j][bl-1]+q[j+1][i]); printf("%d",f[p][k]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1025】数的划分]]></title>
    <url>%2Fposts%2F2ac6.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T2Luogu1025Caioj1505 Problem【Brief description】将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。例如:n=7,k=3,下面三种分法被认为是相同的。1，1，5；1，5，1；5，1，1；问有多少种不同的分法。【Input】n,k【Output】一个整数，即不同的分法。【Limited conditions】6&lt;n&lt;=200，2&lt;=k&lt;=6【Sample input】7 3【Sample output】4【Sample explanation】4种分法为：1,1,5；1,2,4；1,3,3；2,2,3 Record1h Analysis请先思考后再展开 较慢：dfs但加上记忆化就和dp一样了……没必要纠结 Code请先思考后再展开 123456789101112int ans=0;void dfs(int lst,int n,int k)&#123; if(k==1) &#123; ans++;return; &#125; for(int t=lst;t+(k-1)*t&lt;=n;t++) dfs(t,n-t,k-1);&#125;int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); dfs(1,n,k); printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1024】一元三次方程求解]]></title>
    <url>%2Fposts%2Ff28f.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2001 提高组 T1Luogu1024Caioj1504 Problem【Brief description】有形如：ax^3+bx^2+c^x+d=0 这样的一个一元三次方程。给出该方程中各项的系数，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt;=1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。提示：记方程f(x)=0，若存在2个数x1和x2，且x1&lt;x2，f(x1)*f(x2)&lt;0，则在(x1，x2)之间一定有一个根。【Input】4个实数A，B，C，D【Output】三个实根，并精确到小数点后2位【Limited conditions】a，b，c，d 均为实数【Sample input】1 -5 -4 20【Sample output】-2.00 2.00 5.00【Sample explanation】无 Record10min Analysis1请先思考后再展开 神题…… Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************double a,b,c,d;//*******************实现******************bool check(double x)&#123; double t=a*x*x*x+b*x*x+c*x+d; return (t&gt;=-1e-6) and (t&lt;=1e-6);&#125;//*******************主函数******************int main()&#123; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); for(int i=-10000;i&lt;=10000;i++) &#123; double t=double(i)/100; if(check(t)) printf("%.2lf ",t); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1019】单词接龙]]></title>
    <url>%2Fposts%2Ff653.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T3Luogu1019Caioj1502 Problem【Brief description】单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at 和 atide 间不能相连。【Input】第一行为一个单独的整数n表示单词数，以下n行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.【Output】只需输出以此字母开头的最长的“龙”的长度【Limited conditions】n&lt;=20【Sample input】5attouchcheatchoosetacta【Sample output】23【Sample explanation】连成的“龙”为atoucheatactactouchoose Record1h Analysis请先思考后再展开 躺床上想了半天，没什么思路无奈看正解tm居然是爆搜？？？这是提高组？？？ 合并条件： 重叠长度&gt;=1,并!=min(长度) 使用次数&lt;2 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量**************** //*******************全局定义****************char s[30][10000];int mn[30][30];int ln[30];//*******************实现******************void calc(int x,int y)&#123; for(int i=ln[x];i&gt;=1;i--) &#123; int t=1;while(t&lt;=ln[y] and i+t-1&lt;=ln[x] and s[x][i+t-1]==s[y][t]) t++; if(t&gt;ln[y]) break; if(i+t-1&gt;ln[x]) &#123; mn[x][y]=t-1; break; &#125; &#125;&#125;int n;int ans=0;int use[30];void dfs(int x,int now)&#123; ans=mymax(now,ans); for(int i=1;i&lt;=n;i++) if(use[i]&lt;2 and mn[x][i]&gt;0) &#123; use[i]++; dfs(i,now+ln[i]-mn[x][i]); use[i]--; &#125;&#125;//*******************主函数******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",s[i]+1),ln[i]=strlen(s[i]+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) calc(i,j); char c[3];scanf("%s",c); for(int i=1;i&lt;=n;i++) if(s[i][1]==c[0]) &#123; use[i]++; dfs(i,ln[i]); use[i]--; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1017】进制转换]]></title>
    <url>%2Fposts%2F375d.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T1Luogu1017Caioj1500 Problem【Brief description】我们可以用这样的方式来表示一个十进制数:将每个阿拉伯数字乘以一个以该数字所处位置的(值减1)为指数,以10为底数的幂之和的形式。例如:123可表示为 1*10^2+2*10^1+3*10^0 这样的形式。与之相似的,对二进制数来说,也可表示成每个二进制数码乘以一个以该数字所处位置的(值-1)为指数,以2为底数的幂之和的形式。一般说来,任何一个正整数R或一个负整数-R都可以被选来作为一个数制系统的基数。如果是以R或-R为基数,则需要用到的数码为 0,1,….R-1。例如,当R=7时,所需用到的数码是0,1,2,3,4,5和6,这与其是R或-R无关。如果作为基数的数绝对值超过10,则为了表示这些数码,通常使用英文字母来表示那些大于9的数码。例如对16进制数来说,用A表示10,用B表示11,用C表示12,用D表示13,用E表示14,用F表示15。在负进制数中是用-R 作为基数,例如-15(十进制)相当于110001(-2进制),并且它可以被表示为2的幂级数的和数:110001=1*(-2)^5+1*(-2)^4+0*(-2)^3+0*(-2)^2+0*(-2)^1+1*(-2)^0设计一个程序,读入一个十进制数和一个负进制数的基数,并将此十进制数转换为此负进制下的数【Input】输入文件有若干行，每行有两个输入数据。第一个是十进制数N第二个是负进制数的基数-R。【Output】输出此负进制数，若此基数超过10，则参照16进制的方式处理。【Limited conditions】-R∈{-2,-3,-4,…,-20}-32768&lt;=N&lt;=32767【Sample input】30000 -2【Sample output】11011010101110000【Sample explanation】无 Record30min Analysis请先思考后再展开 自己推把7和-7，转换成-3进制即可 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************//*******************全局定义****************//*******************实现******************char ans[110],ln=0;void putc(int t)&#123; ln++; if(t&lt;=9) ans[ln]='0'+t; else ans[ln]='A'+(t-10);&#125;//*******************主函数******************int main()&#123; int n,r;scanf("%d%d",&amp;n,&amp;r); printf("%d=",n); int now=1,nxt=r; while(n!=0) &#123; int t=n%nxt; if(t!=0) &#123; int k=t/now; k=(k+(-r))%(-r); putc( k ); n-=now*k; &#125; else putc(0); now=nxt; nxt=nxt*r; &#125; for(int i=ln;i&gt;=1;i--) putchar(ans[i]); printf("(base%d)",r);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1018】乘积最大]]></title>
    <url>%2Fposts%2F87af.html</url>
    <content type="text"><![CDATA[Source and JudgeNOIP2000 提高组 T2Luogu1018Caioj1501 Problem【Brief description】设有一个长度为N的数字串，要求使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。【Input】第一行共有2个自然数N，K第二行是一个长度为N的数字串。【Output】最大乘积【Limited conditions】6≤N≤40，1≤K≤6【Sample input】4 21231【Sample output】62【Sample explanation】无 Record30min Analysis请先思考后再展开 当年的梦魇f[i][k]=max( f[j][k-1]*(j+1~i) ) Code请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量****************//*******************全局定义****************char s[50];int f[50][8];//*******************实现******************int jh(int l,int r)&#123; int ans=0; for(int i=l;i&lt;=r;i++) ans=ans*10+s[i]-'0'; return ans;&#125;//*******************主函数******************int main()&#123; int n,K;scanf("%d%d%s",&amp;n,&amp;K,s+1); for(int i=1;i&lt;=n;i++) f[i][0]=jh(1,i); for(int k=1;k&lt;=K;k++) &#123; for(int i=k+1;i&lt;=n;i++) &#123; for(int j=k;j&lt;i;j++) &#123; f[i][k]=mymax(f[j][k-1]*jh(j+1,i),f[i][k]); &#125; &#125; &#125; printf("%d",f[n][K]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2186】【Luogu2155】沙拉公主的困惑]]></title>
    <url>%2Fposts%2F5557.html</url>
    <content type="text"><![CDATA[Source and JudgeSdoi2008Bzoj2186Luogu2155 Problem【Brief description】现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数灰常大，你只需计算出对R取模后的答案即可。R是一个质数。【Input】第一行为两个整数T，R。T表示该组中测试数据数目，R为模后面T行，每行一对整数N，M，见题目描述【Output】共T行，对于每一对N，M，输出1至N！中与M！互质的数的数量对R取模后的值【Limited conditions】R&lt;=10^9+10，T&lt;=10000，m&lt;=n1&lt;=N,M&lt;=10000000【Sample input】1 114 2【Sample output】1【Sample explanation】2^3=81+2+4+8=15 Record2h恶心数据卡常数……所以别开ll存 Analysis请先思考后再展开 首先，有这样一个我不会证明的定理：如果$gcd(x,a)=1$,则$gcd(x+k\times b,a)=1$那么如果对应这道题：如果$gcd(x,m!)=1$,则$gcd(x+k\times m!,m!)=1$而n!一定是m!的倍数，考虑把n!分成长度m!的一个个块，答案恰好变成这样的式子(有关欧拉函数请找OI之路)：$$ANS=\frac{n!}{m!} \times \varphi(m!) (\mod R)$$那么套上欧拉函数的公式$\varphi(m!)=m! \times \frac{p1-1}{p1}\times \frac{p2-1}{p2}……\times \frac{pk-1}{pk}$：$$ANS=\frac{n!}{m!}\times m!\times \Pi_{t=1}^k \frac{pt-1}{pt} (\mod R) $$ $$ ANS=n!\times \Pi_{t=1}^k \frac{pt-1}{pt} (\mod R) $$ $$ ANS=n!\times\frac{\Pi_{t=1}^k(pt-1) }{\Pi_{t=1}^k pt} (\mod R) $$ $$ ANS=n!\times \Pi_{t=1}^k(pt-1) inv(pt) (\mod R) $$ 那就成功地消除了恶心的m!，瞬间简单很多预处理n!、小于等于m的质数p的【p-1】和【p的逆元】即可（因为m!的质因数显然是在m以内的，别被吓到） 嗯补充一句【经常要考虑】：$gcd(pt,R)\neq 1$而pt和R都是质数，那就只有一种情况了：pt=R那因为$n\geq m$，只要n不处理，逆元也不处理即可相当于除以R再乘以R网上经典数据：input1 34 3output2 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXNUM=10000001;//*******************全局定义****************int MOD;//&lt;=1000000010int fac[MAXNUM],inv[MAXNUM];int p[1000000];int pos[MAXNUM];//debug//*******************实现******************int prime[1000000],pr=0;bool v[MAXNUM];void pre()&#123; inv[1]=1;fac[1]=1;p[0]=1;//debug for(int i=2;i&lt;MAXNUM;i++) &#123; inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i) %MOD; if(i!=MOD) fac[i]=1ll*fac[i-1]*i %MOD; else fac[i]=fac[i-1];//debug if(!v[i]) &#123; prime[++pr]=i; if(i!=MOD) p[pr]=1ll*p[pr-1]*(i-1)%MOD *inv[i] %MOD; else p[pr]=1ll*p[pr-1]*(i-1)%MOD;//debug &#125; pos[i]=pr; for(int j=1;j&lt;=pr;j++) &#123; if(i*prime[j]&gt;=MAXNUM) break; v[ i*prime[j] ]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;//*******************主函数******************int main()&#123; int T;scanf("%d%lld",&amp;T,&amp;MOD);pre(); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n&gt;=MOD and m&lt;MOD) &#123; printf("0\n"); continue; &#125; printf("%d\n", int(1ll*fac[n]*p[ pos[m] ]%MOD) ); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5192】【Luogu4271】New Barns]]></title>
    <url>%2Fposts%2Fdd1c.html</url>
    <content type="text"><![CDATA[Source and JudgeUsaco2018 Feb PlatinumBzoj5192Luogu4271 Problem【Brief description】每次添加一个点（形成森林）求距离这个点最远的点【Input】第一行包含一个整数Q以下Q行，每行包含一个请求。每个请求的格式都是“B p”或是“Q k”分别告诉你建造一个牛棚并与牛棚p连接，或是根据定义求从牛棚k出发最远的距离。如果p=-1，则新的牛棚不会与其他牛棚连接。否则，p是一个已经建造的牛棚的编号。牛棚编号从1开始，所以第一个被建造的谷仓是1号谷仓，第二个是2号谷仓，以此类推。【Output】对于每个距离请求输出一行。注意一个没有连接到其他牛棚的牛棚的最远距离为0【Limited conditions】1≤Q≤10^5【Sample input】7B -1Q 1B 1B 2Q 3B 2Q 2【Sample output】021【Sample explanation】(1) \ (2)–(4) /(3)对于请求1，我们建造牛棚1。对于请求2，我们询问从1出发到最远连接的牛棚的距离。由于牛棚1没有与其他牛棚连接，所以回答是0。对于请求3，我们建造牛棚2并将其与牛棚1连接。对于请求4，我们建造牛棚3并将其与牛棚2连接。对于请求5，我们询问从3出发到最远连接的牛棚的距离。在这时，最远的是牛棚1，距离为2单位。对于请求6，我们建造牛棚4并将其与牛棚2连接。对于请求7，我们询问从2出发到最远连接的牛棚的距离。所有其他三个牛棚1，3，4都与2相距相同的距离1，所以这就是我们的回答。 Record5h考试考的题目 Analysis1请先思考后再展开 好难哇splay是二叉树，不行，而且无法维护距离【结构会变】题目还是很有特性的，没必要lct吧？然后就以为是qtree4，乱搞一通，写挂了…… 然后暴力居然也写挂了是什么鬼方法1：2428ms做法1，也是比较显然的做法：每个点维护它的子树下，与他距离的最大和次大，并记录他们的来源，从而避免与x来自同一个子树而造成路径重复然后询问的时候直接向上面的祖先询问即可但是这样碰到一条链会被卡所以要点分治保证复杂度【离线后进行，注意打上现在是否可用的标记即可】 然后这个东西我考试的时候也是想过的，甚至也想过了点分治但打到一半发现不知道怎么维护因为做题太少，被qtree4毒害太深，只知道用堆……结果不知道怎么确保不会重复路径……难不成又要两个堆？麻烦死了而且没时间了……其实只要最大和次大，万一与最大重复子树就次大好了，很轻松嘛~ 哦还要注意，因为点分治的存在，树的结构改变，距离要在原树上面求 Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义****************struct Nod&#123; int hou; int dep; bool isrt; bool v; Nod() &#123; hou=dep=isrt=v=0; &#125;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXN*2];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int dad[MAXN];//*******************点分治******************int G,sum,ty[MAXN],siz[MAXN];void getrt(int x,int fa)&#123; siz[x]=1;ty[x]=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa or p[y].v) continue; getrt(y,x); siz[x]+=siz[y]; ty[x]=mymax(ty[x],siz[y]); &#125; ty[x]=mymax(ty[x],sum-siz[x]); if(ty[x]&lt;ty[G]) G=x;&#125;void divi(int x)&#123; p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(p[y].v) continue; sum=siz[y];G=0;getrt(y,x); dad[G]=x;divi(G); &#125;&#125;//*******************实现******************int bin[31],f[MAXN][31];void dfs(int x,int fa)&#123; p[x].dep=p[fa].dep+1; siz[x]=1;//因为是森林，块大小未知，用于sum f[x][0]=fa;for(int i=1;bin[i]&lt;=p[x].dep;i++) f[x][i]=f[ f[x][i-1] ][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); siz[x]+=siz[y]; &#125;&#125;int LCA(int x,int y)&#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=30;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=30;i&gt;=0;i--) if(bin[i]&lt;=p[x].dep and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int getdis(int x,int y)//树的结构改变，距离要在原树上面求&#123; return p[x].dep+p[y].dep-2*p[LCA(x,y)].dep;&#125;bool bo[MAXN];pair&lt;int,int&gt; fri[MAXN],sec[MAXN];void turnblack(int x)&#123; bo[x]=1; int v=x,lst=x;//自己也更新下 while(x&gt;0) &#123; int d=getdis(x,v); if(lst==fri[x].second) fri[x].first=mymax(fri[x].first,d); else if(lst==sec[x].second) sec[x].first=mymax(sec[x].first,d); else if(d&gt;fri[x].first) sec[x]=fri[x],fri[x]=make_pair(d,lst); else if(d&gt;sec[x].first) sec[x]=make_pair(d,lst); if(fri[x].first&lt;sec[x].first) swap(fri[x],sec[x]); lst=x;x=dad[x]; &#125;&#125;int solve(int x)&#123; int v=x,lst=x; int ans=fri[x].first;x=dad[x]; while(x&gt;0) &#123; if(bo[x]) &#123; int d=getdis(x,v); if(lst==fri[x].second) ans=mymax(ans,d+sec[x].first); else ans=mymax(ans,d+fri[x].first); &#125; lst=x;x=dad[x]; &#125; return ans;&#125;//*******************主函数******************struct Qes&#123; int op,x;&#125;qes[MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int q;scanf("%d",&amp;q); char s[10]; int n=0; for(int i=1;i&lt;=q;i++) &#123; int t;scanf("%s%d",s,&amp;t); if(s[0]=='B') &#123; qes[i].op=1; n++;qes[i].x=n; if(t&lt;0) p[n].isrt=1; else ins(n,t),ins(t,n); &#125; else qes[i].op=2,qes[i].x=t; &#125; ty[0]=INF;p[0].v=1; for(int i=1;i&lt;=n;i++) if(p[i].isrt) &#123; dfs(i,0);//求dep、siz G=0;sum=siz[i];getrt(i,0); dad[G]=0;divi(G); &#125; for(int i=1;i&lt;=q;i++) if(qes[i].op==1) turnblack(qes[i].x); else printf("%d\n",solve(qes[i].x));&#125; Analysis2请先思考后再展开 哇两百行呀真烦人不是吗？有没有更便捷的方法呢？ 对于树上的，某一点固定的，最长路径，有这样一个性质： 定义 树的直径为，树上最长路径（长度相等的话任意一条即可，对答案没有影响） 某一点固定的最长路径，其另一个端点就是 树的直径 的两个端点之一 然后如果加入一个点，新的 树的直径 的端点必定是这三个点中的两个证明不会，但找不到反例，有兴趣的反证法试试？其实好像OI很多玄学的定理主要都是用反证法的…… UP【思路from rose，作了修正】:果然是用反证法设树上直径a、b，对于当前查询节点now，假设存在一个非a、b的节点p到now的距离最大那么对于now和a的一个公共祖先也就是now和a路径上的点k，则必定也是a和b路径上的点【这里其实依然不是太完美】既然如此，必定k-p大于k-a，则p应该成为直径的端点，与非b矛盾Q.E.D【其实这个没什么好纠结的，用akc的话说，感性地认知就好了】 UP 2018.4.6：这个好像来自一个这样的性质对于直径中的任意一点，其距离树中其他点的最远距离不超过该点到达直径端点的距离。【这个还是灰常显而易见的，否则就不是端点了，rose的证明更多是搞这个】然后再补充一个：所有直径交于一点，且必定是中点类似的证明但是他有图：果然有图就是一切吗 那明确这个性质之后就很舒服了师兄和beginend是用LCT维护的……但其实根本不用，直接用根当标记就好了 Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量****************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义****************int d1[MAXN],d2[MAXN];//端点int rt[MAXN];//根int dep[MAXN];//深度int f[MAXN][21],bin[21];//*******************实现******************int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=20;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(dep[x]&gt;=bin[i] and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int DIS(int x,int y)&#123; return dep[x]+dep[y]-2*dep[LCA(x,y)];&#125;//*******************主函数******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; int q;scanf("%d",&amp;q);char s[10]; int x=0; while(q--) &#123; int t;scanf("%s%d",s,&amp;t); if(s[0]=='B') &#123; x++; if(t&lt;0) rt[x]=d1[x]=d2[x]=x,dep[x]=1; else &#123; rt[x]=rt[t];dep[x]=dep[t]+1; f[x][0]=t;for(int i=1;bin[i]&lt;=dep[x];i++) f[x][i]=f[ f[x][i-1] ][i-1]; int old=DIS(d1[rt[x]],d2[rt[x]]); if(DIS(d1[rt[x]],x)&gt;old) d2[rt[x]]=x; if(DIS(x,d2[rt[x]])&gt;old) d1[rt[x]]=x; &#125; &#125; else printf("%d\n",mymax( DIS(t,d1[rt[t]]),DIS(t,d2[rt[t]]) )); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1845】Sumdiv]]></title>
    <url>%2Fposts%2Fecf1.html</url>
    <content type="text"><![CDATA[Source and JudgeRomania OI 2002Poj1845 Problem【Brief description】给出自然数A、B，求S=A^B的所有自然数因子和【Input】A,B【Output】S模9901【Limited conditions】0&lt;=A,B&lt;=50000000【Sample input】2 3【Sample output】15【Sample explanation】2^3=81+2+4+8=15 Record2h是求积而不是求和……脑子里想着题目是求和…… Analysis请先思考后再展开 题目要的就是：$$\sum_{t|A^B} t (\mod 9901)$$那么其实就是约数和公式啦：【OI之路】02数论算法-7约数个数与和然后把A分解质因数（线性筛搞一搞），就变成了经典的等比数列求和$$p^0+p^1+p^2+…+p^a (\mod 9901)——①$$那有两种做法，一个是二分法（之前说过），以及师兄教的常规操作：$①\times (p-1)$于是我想半天，结果是什么呢？其实……这样会更容易算:$①\times p-①=p^{a+1}-p^0$然后再除回去即可$$ANS=\Pi_{k=1}^{质因数个数} \frac{p_k^{a+1}-1}{p_k-1} (\mod 9901)$$于是就简单了，快速幂加上逆元即可 哦对了再说一句之前做一道noi的dp（寿司晚宴）的时候，学会了一个套路：分解质因数的时候，预处理 sqrt(n) 的即可，因为后面的只会有一个~ 嗯还有，万一没有逆元怎么办？也就是$gcd(9901,p_k-1)=1$那已知p是素数了，也就是说$p_k-1$是9901的倍数本来希望没有，结果一打印，贼多！都怪这模数太小！怎么办？别着急，不是还有二分法吗？反正好像都是logn的算法woc其实直接二分法得了，干嘛写两个 UP 2018.8.9:其实如果没有逆元也是可以做的观察一下，如果$p_k-1$是9901的倍数，那么$p_k \mod 9901=1$所以说此时，等比数列的底数是1，可以直接计算…… 送几组数据:59407 1259407 5940720 101 113 013131 654971933 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXNUM=7100;const int MOD=9901;//*******************全局定义****************int prime[7000],pr=0;bool v[MAXNUM];//*******************实现******************void getp()&#123; for(int i=2;i&lt;MAXNUM;i++) &#123; if(!v[i]) prime[++pr]=i; for(int j=1;j&lt;=pr and i*prime[j]&lt;MAXNUM;j++) &#123; v[ i*prime[j] ]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int power(int x,int e)&#123; int ans=1;x%=MOD;//debug while(e&gt;0) &#123; if(e&amp;1) ans=(ans*x)%MOD; x=(x*x)%MOD;e&gt;&gt;=1; &#125; return ans;&#125;int A;int sum(int n)&#123; if(n==1) return A%MOD; if(n&amp;1) return ( sum(n-1)+power(A,n) )%MOD; return (1+power(A,n/2))*sum(n/2) %MOD;&#125;//*******************主函数******************int ans;void calc(int p,int ct)&#123; if( (p-1)%MOD==0 ) &#123; A=p; ans=ans*(1+sum(ct)) %MOD; &#125; else &#123; int t= (power(p,ct+1)-1+MOD)%MOD ;//小心减法 int inv=power(p-1,MOD-2); ans=ans*t%MOD *inv%MOD; &#125;&#125;int main()&#123; getp(); int a,b;scanf("%d%d",&amp;a,&amp;b); if(a&lt;=1)//debug &#123; printf("%d",a); return 0; &#125; ans=1; for(int i=1;i&lt;=pr;i++) &#123; if(a%prime[i]&gt;0) continue; int ct=0;while(a%prime[i]==0) a/=prime[i],ct++; calc(prime[i],ct*b); //calc(prime[i]%MOD,ct*b); if(a==1) break; &#125; if(a&gt;1) calc(a,b); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3240】【Luogu1397】矩阵游戏]]></title>
    <url>%2Fposts%2Fe426.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2013Bzoj3240Luogu1397 Problem【Brief description】$F[1][1]=1$$F[i][j]=a\times F[i][j-1]+b (j!=1)$$F[i][1]=c\times F[i-1][m]+d (i!=1)$输出F[n][m]除以1,000,000,007的余数。【Input】六个整数n,m,a,b,c,d【Output】F[n][m]除以1,000,000,007的余数【Limited conditions】【Sample input】3 4 1 3 2 6【Sample output】85【Sample explanation】样例中的矩阵为：1 4 7 1026 29 32 3576 79 82 85 Record2h呃我的矩阵是3乘3的，时间可能是别人的两倍以上?反正问题不大 Analysis请先思考后再展开 首先，这个n、m的大小这么奇葩，那就是有一定暗示的了（其实有的时候我就在想为啥非要搞特大、小数据范围来提示？有检验正确性能力即可）（UP：好像有人直接写十进制快速幂+常数优化搞过去了……）那么我们引用伟大的费马小定理：【OI之路】11更高级数论-1定理杂烩这个神奇玩意居然对矩阵也有效！【flag，见后文】在mod MOD（也就是1e9+7）下，设操作矩阵为A，那么$A^{1e9+6}=1 (\mod MOD)$ ，相当于单位矩阵所以对于同一行下，第m个=第m%(MOD-1)个而如果把【一行的转移+m到下一行第一个的转移】看作一个操作矩阵B，同理第n行=第n%(MOD-1)行综上所述，$f[n][m]=f[n\%(MOD-1)][m\%(MOD-1)]$ 然后我到这里就懵逼了：这么大的数字怎么存储？还要写高精度取模？？？如果你也是这么想，嗯英雄所见略同事实上，%(MOD-1)=%( (MOD-1)*10^k )，意思就是说，完全可以放到字符串里面，取一个模一下真是让人涨见识的骚操作QAQ剩下的就是推一个sb矩阵了 UP:发现自己wa了两个点【90分，其实也该满足了】？别着急我也是自信满满地提交，然后看别人题解才看到：a=1和c=1的特殊情况网上清一色“要特判”，但都没讲理由？ 首先，实验证明，我的两个操作矩阵$A^{MOD-1}\neq 1 (\mod MOD)$,事实上循环结长度是MOD为什么会出现这种情况呢？【开始解决flag】我们回顾一下，费马小定理的条件之一：gcd(A,MOD)=1但这里A是一个矩阵呀，怎么会有gcd？咳咳，别着急。前面我们直接啥也不管，以为网上题解说能就直接用了，所以才会有现在的状况 那么我先是问了下师兄，然后两人一起捣鼓半天，大概搞了个解释：注意，所有公式都是在模意义下进行我们回归到最初的公式【以行内转移举例，忽略行数，反正也就是二维】$$f[i]=a\times f[i-1]+b (\mod MOD)——①$$ 我们希望把它变成一个等比数列来搞出一个通项公式【没学过高中数学没关系，我也没学】构造一个b’使满足这个式子：$$f[i]+b’=a\times (f[i-1]+b’) (\mod MOD)——②$$ 现在通过①和②推导出这道题的$b’=\frac{b}{a-1} (a\neq1)$辣么现在就能搞出一个通项公式啦$$f[i]+b’=a^{i-1}\times (f[1]+b’) (\mod MOD)$$ 既然是等比数列，那就搞上费马小定理吧~【gcd(a,MOD)=1并没有影响，因为题目条件里面限制了a的范围】$$f[i]+\frac{b}{a-1}=a^{ (i-1)\%(MOD-1) }\times (f[1]+\frac{b}{a-1}) (\mod MOD) (a\neq1)$$ 好了，我们搞这么多有什么用呢？师兄的说法：用来给你十进制快速幂呀！啊那行之间怎么转移呢？不会呀这么说原来根本就不是同一个做法好吗。那我干嘛要写在博客上呀 仅仅因为那个$a\neq1$没错我们现在说这么多就是为了解决我们丢了10分的问题【终于回到正题了】不扯了那a=1的时候，其实就变成了一个等差数列，通项公式：$$f[i]=f[1]+b\times (i-1) (\mod MOD)$$ 然后有个东西叫欧拉函数，$\phi(x)=在1到x的正整数中与x互质的数的个数$显然在x为质数的时候，$\phi(x)=x-1$那么在我们刚才矩阵乘法的时候，循环节可以记作$p=\phi(MOD)$由此而知$f[p+1]=f[1]$【当$a\neq1$的时候，p已经算出来了，现在算a=1的情况，p未知】$$f[p+1]=f[1]+b\times p (\mod MOD)$$ 那么$b\times p=0 (\mod MOD)$而这道题中，b一不是MOD的倍数，二不是0，则$p=0 (\mod MOD)$而p肯定又不是0，所以可以考虑把p看作MOD的倍数哇那就是说$$p=MOD 【a=1】$$ $$p=\phi(MOD)=MOD-1 【Otherwise】$$ 哈哈搞定~其实我自己觉得有种东扯扯西扯扯的感觉但好歹也是有理有据的嘛总结：综上所述，我们在搞n和m的时候，分别根据a和c是否是1来决定MOD（详见代码）然后经验就是，这种有特殊条件的定理，先不要引入矩阵乘法，而是把公式搞清楚，把各种细节考虑周到再去优化【虽然这道题也就10分】 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const ll MOD=1e9+7;//*******************全局定义****************struct martix&#123; int row,col; ll m[5][5]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;//*******************实现******************martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) (c.m[i][j]+=a.m[i][k]*b.m[k][j])%=MOD; return c;&#125;martix pre()&#123; martix c;c.row=c.col=3; c.m[1][1]=c.m[2][2]=c.m[3][3]=1; return c;&#125;martix power(martix a,int e)&#123; martix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans;&#125;//*******************主函数******************char s1[1000010],s2[1000010];int main()&#123; ll mod1=MOD-1,mod2=MOD-1; scanf("%s%s",s1+1,s2+1); ll a,b,c,d;scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d); if(a==1) mod1++;if(c==1) mod2++; ll n=0;int t1=strlen(s1+1);for(int i=1;i&lt;=t1;i++) n=(n*10+s1[i]-'0')%mod1; ll m=0;int t2=strlen(s2+1);for(int i=1;i&lt;=t2;i++) m=(m*10+s2[i]-'0')%mod2; if(n==0) n=mod1;if(m==0) m=mod2; martix f1;f1.row=3;f1.col=1;f1.m[1][1]=1;f1.m[2][1]=b;f1.m[3][1]=d; martix A;A.row=3;A.col=3;A.m[1][1]=a;A.m[1][2]=1;A.m[2][2]=1;A.m[3][3]=1; martix B;B.row=3;B.col=3;B.m[1][1]=c;B.m[1][3]=1;B.m[2][2]=1;B.m[3][3]=1; A=power(A,m-1); if(n&gt;1) A=cheng( A,power(cheng(B,A),n-1) ); printf("%lld",cheng(A,f1).m[1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度3</tag>
        <tag>矩阵乘法</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu1588】Gauss Fibonacci]]></title>
    <url>%2Fposts%2F7e2f.html</url>
    <content type="text"><![CDATA[Source and JudgeDYGGHDU “Valentines Day” Open Programming Contest 2007-02-14Hdu1588Caioj1488 Problem【Brief description】g[i]=k*i+b。f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2] (i&gt;=2)求f[ g[0] ]+f[ g[1] ]+…+f[ g[n-1] ]的值，结果需要mod M【Input】多组数据四个整数k,b,n,M【Output】每行一个答案【Limited conditions】每个数不超过1,000,000,000.【Sample input】2 1 4 1002 0 4 100【Sample output】2112【Sample explanation】无 Record30min Analysis请先思考后再展开 那个。。推公式的时候注意矩阵乘法操作顺序不可调转$$f[b]+f[k+b]+f[2\times k+b]…+f[(n-1)\times k+b]$$转化为矩阵A（通常计算斐波拉契的递推矩阵，自己推）$$A^b\times f[0]+A^{k+b}\times f[0]…+A^{(n-1)\times k+b}\times f[0]$$提取公因式$A^b\times f[0]$$$( A^0+A^k…+A^{(n-1)\times k} )\times A^b\times f[0]$$令$B=A^k$$$( B^0+ B^1…+B^{n-1} )\times A^b\times f[0]$$于是就变成了一个等比数列求和问题了 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量**************** //*******************全局定义****************struct martix&#123; int row,col; ll m[5][5]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;ll MOD;//*******************实现******************martix jia(martix a,martix b)&#123; martix c; c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) (c.m[i][j]+=a.m[i][j]+b.m[i][j])%=MOD; return c;&#125;martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) (c.m[i][j]+=a.m[i][k]*b.m[k][j])%=MOD; return c;&#125;martix pre()&#123; martix c;c.row=c.col=2; c.m[1][1]=c.m[2][2]=1; return c;&#125;martix power(martix a,int e)&#123; martix ans=pre(); while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans;&#125;martix B;martix sum(int k)&#123; if(k==1) return B; if(k&amp;1) return jia(sum(k-1),power(B,k)); martix t=sum(k/2); return jia( cheng(t,power(B,k/2)),t );&#125;//*******************主函数******************int main()&#123; martix A;A.row=A.col=2;A.m[1][2]=A.m[2][1]=A.m[2][2]=1; martix f0;f0.row=2;f0.col=1;f0.m[2][1]=1; int k,b,n; while(scanf("%d%d%d%lld",&amp;k,&amp;b,&amp;n,&amp;MOD)!=EOF) &#123; B=power(A,k); printf("%lld\n",cheng( jia(sum(n-1),pre()),cheng(power(A,b),f0) ).m[1][1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3233】Matrix Power Series]]></title>
    <url>%2Fposts%2F3bd.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2007.06.03, Huang, JinsongPoj3233 题目【题目大意】给出一个n×n矩阵A和正整数k,输出S=A+A^2+A^3+…+A^k，元素模m【输入格式】多组数据。第一行正整数n,k和m。接下来n行包括n个在32,768以内的非负整数【输出格式】S【限定条件】n≤30k≤10^9m&lt;10^4【输入样例】2 2 40 11 1【输出样例】1 22 3【样例解释】无 刷题记录30min 分析请先思考后再展开 二分求等比序列和 代码请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************//*******************全局定义****************struct martix&#123; int row,col; int m[40][40]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;int MOD;//*******************实现******************martix jia(martix a,martix b)&#123; martix c; c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) (c.m[i][j]+=a.m[i][j]+b.m[i][j])%=MOD; return c;&#125;martix cheng(martix a,martix b)&#123; martix c; int n=a.row,m=a.col,p=b.col; c.row=n;c.col=p; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) (c.m[i][j]+=a.m[i][k]*b.m[k][j])%=MOD; return c;&#125;martix power(martix a,int e)&#123; martix ans=a;e--; while(e&gt;0) &#123; if(e&amp;1) ans=cheng(ans,a); a=cheng(a,a);e&gt;&gt;=1; &#125; return ans;&#125;martix s;martix sum(int k)&#123; if(k==1) return s; if(k&amp;1) return jia(sum(k-1),power(s,k)); martix t=sum(k/2); return jia( cheng(t,power(s,k/2)),t );&#125;//*******************主函数******************int main()&#123; int n,k;scanf("%d%d%d",&amp;n,&amp;k,&amp;MOD); s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;s.m[i][j]); s=sum(k); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%d ",s.m[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF946-F】Fibonacci String Subsequences]]></title>
    <url>%2Fposts%2F6a8a.html</url>
    <content type="text"><![CDATA[Source and JudgeCF946-F Problem【Brief description】定义 F(x) 为 F(x−1) 与 F(x−2) 的连接（其中 F(0)=”0”,F(1)=”1” ）。给出一个长度为n的01字符串 s ，询问 s 在 F(x) 的所有子序列中出现了多少次。【Input】第一行n和x第二行字符串s【Output】如上【Limited conditions】1≤n≤100,0≤x≤100【Sample input】2 411【Sample output】14【Sample explanation】F(4)=101101011101101 11 1 01 111 1101 11 10 011 0110 11 110好难想…… Record30min我会告诉你我看错两次题吗？ Analysis请先思考后再展开 其实就是一个裸区间dpf[i][l][r]表示F(i)的子序列中有多少个s[l,r]然后就三种情况 从左边继承，f[i-1][l][r]，次数默认1；若r=n，右边有2^{ln[i-2]}种选取方案（就是任选） 从右边继承，f[i-2][l][r]，次数默认1；若l=1，左边有2^{ln[i-1]}种选取方案（就是任选） 从两边继承，f[i-1][l][k]*f[i-2][k+1][r]，次数1 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MOD=1e9+7;const int MAXN=110;ll f[MAXN][MAXN][MAXN];ll g[MAXN];char s[MAXN];int main()&#123; int n,x;scanf("%d%d%s",&amp;n,&amp;x,s+1); for(int i=1;i&lt;=n;i++) f[s[i]=='1'][i][i]=1; g[0]=2;g[1]=2;for(int i=2;i&lt;=x;i++) g[i]=(g[i-1]*g[i-2])%MOD; for(int i=2;i&lt;=x;i++) &#123; for(int l=1;l&lt;=n;l++) &#123; for(int r=l;r&lt;=n;r++) &#123; if(r==n) f[i][l][r]=(f[i][l][r]+f[i-1][l][r]*g[i-2]%MOD)%MOD; else f[i][l][r]=(f[i][l][r]+f[i-1][l][r])%MOD; if(l==1) f[i][l][r]=(f[i][l][r]+f[i-2][l][r]*g[i-1]%MOD)%MOD; else f[i][l][r]=(f[i][l][r]+f[i-2][l][r])%MOD; for(int k=l;k&lt;=r-1;k++) f[i][l][r]=(f[i][l][r]+f[i-1][l][k]*f[i-2][k+1][r]%MOD)%MOD; &#125; &#125; &#125; printf("%lld",f[x][1][n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2002】【Luogu3203】弹飞绵羊]]></title>
    <url>%2Fposts%2F8065.html</url>
    <content type="text"><![CDATA[Source and JudgeHNOI2010Bzoj2002Luogu3203 Problem【Brief description】有n个点，一开始有n条边，点只会向比自己编号大的一个点连一条边，其中有的边（保证至少有一条）会连不到点，被弹飞。有两种操作：op=1,x :询问从x点出发，需要经过多少个点（包括x）才会被弹飞op=2,x,k:将x点连向其他点的边删掉，然后从x向x+k连一条边【Input】第一行为一个正整数n，表示点的个数。第二行n个数ki，表示第i个点向第i+ki个点连一条边，若i+ki&gt;n被弹飞。第三行为一个正整数m，表示操作的个数。以下m行，一行表示一个操作。每行开头是一个整数op，op=1时之后有一个整数x代表询问点的编号。op=2时之后有两个整数x，k代表点的编号和改变连边的距离。操作如题意。【Output】如上【Limited conditions】对于20%的数据,n,m&lt;=10000对于100%的数据,n&lt;=200000,m&lt;=100000【Sample input】41 2 1 131 12 1 11 1【Sample output】23【Sample explanation】无 Record1h打错变量了…… Analysis1请先思考后再展开 灰常不容易想出来的解法：LCT主要是因为修改操作，相当于删边和连边，而且结构改变了，所以不能树剖然后把“弹飞”形象化为点n+1但这样并没形成森林过…… Code1请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXN=210000,MAXM=210000;//*******************全局定义****************struct Nod&#123; int fa,son[2]; int siz; bool fz; Nod() &#123; fa=son[0]=son[1]=fz=0; siz=1; &#125;&#125;p[MAXN];//*******************伸展树******************void pushdown(int x)&#123; if(!p[x].fz) return; p[x].fz=0; swap(p[x].son[0],p[x].son[1]);//debug int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[lc].fz^=1; if(rc&gt;0) p[rc].fz^=1;&#125;void pushup(int x)&#123; p[x].siz=1; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].siz+=p[lc].siz; if(rc&gt;0) p[x].siz+=p[rc].siz;&#125;bool isroot(int x,int rt)&#123; return p[x].fa==rt or (p[p[x].fa].son[0]!=x and p[p[x].fa].son[1]!=x);&#125;void rotate(int x,int w)&#123; int f=p[x].fa,ff=p[f].fa; if(!isroot(f,0)) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].fa=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].fa=f; p[x].son[w]=f; p[f].fa=x; pushup(f); pushup(x);&#125;int tmp[MAXN];void splay(int x,int rt)&#123; int t=x,s=0; while(!isroot(t,rt)) tmp[++s]=t,t=p[t].fa; pushdown(t);while(s&gt;0) pushdown(tmp[s--]); while(!isroot(x,rt)) &#123; int f=p[x].fa,ff=p[f].fa; if(isroot(f,rt)) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125;&#125;//*******************LCT******************void access(int x)&#123; int lst=0; while(x&gt;0) &#123; splay(x,0); p[x].son[1]=lst; pushup(x);//debug lst=x;x=p[x].fa; &#125;&#125;void makeroot(int x)&#123; access(x); splay(x,0); p[x].fz^=1;&#125;void split(int x,int y)//y为顶&#123; makeroot(x); access(y); splay(y,0);//debug&#125;void link(int x,int y)//debug方向性&#123; makeroot(x); p[x].fa=y;&#125;void cut(int x,int y)&#123; split(x,y); p[x].fa=0; p[y].son[0]=0; pushup(y);&#125;//*******************实现******************//*******************主函数******************int now[MAXN];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;now[i]); if(i+now[i]&gt;n) now[i]=n+1-i; link(i,i+now[i]); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; int op,a,b;scanf("%d%d",&amp;op,&amp;a);a++; if(op==1) &#123; split(a,n+1); printf("%d\n",p[n+1].siz-1); &#125; else &#123; scanf("%d",&amp;b); cut(a,a+now[a]); if(a+b&gt;n) b=n+1-a;now[a]=b; link(a,a+now[a]); &#125; &#125;&#125; Analysis2请先思考后再展开 看看能否对上面的算法进行改进要不干脆就真的被弹飞吧！那就是森林了。然后发现根本不用makeroot了于是立刻又快又短！ Code2请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXN=210000,MAXM=210000;//*******************全局定义****************struct Nod&#123; int fa,son[2]; int siz; Nod() &#123; fa=son[0]=son[1]=0; siz=1; &#125;&#125;p[MAXN];//*******************伸展树******************void pushup(int x)&#123; p[x].siz=1; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].siz+=p[lc].siz; if(rc&gt;0) p[x].siz+=p[rc].siz;&#125;bool isroot(int x,int rt)&#123; return p[x].fa==rt or (p[p[x].fa].son[0]!=x and p[p[x].fa].son[1]!=x);&#125;void rotate(int x,int w)&#123; int f=p[x].fa,ff=p[f].fa; if(!isroot(f,0)) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].fa=ff; int pson=p[x].son[w]; p[f].son[1-w]=pson; if(pson&gt;0) p[pson].fa=f; p[x].son[w]=f; p[f].fa=x; pushup(f); pushup(x);&#125;void splay(int x,int rt)&#123; while(!isroot(x,rt)) &#123; int f=p[x].fa,ff=p[f].fa; if(isroot(f,rt)) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125;&#125;//*******************LCT******************void access(int x)&#123; int lst=0; while(x&gt;0) &#123; splay(x,0); p[x].son[1]=lst; pushup(x);//debug lst=x;x=p[x].fa; &#125;&#125;void linkfa(int x,int y)&#123; p[x].fa=y;&#125;void cutfa(int x)&#123; access(x); splay(x,0); p[p[x].son[0]].fa=0; p[x].son[0]=0; pushup(x);&#125;//*******************实现******************//*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(i+t&lt;=n) linkfa(i,i+t); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; int op,a,b;scanf("%d%d",&amp;op,&amp;a);a++; if(op==1) &#123; access(a); splay(a,0); printf("%d\n",p[a].siz); &#125; else &#123; scanf("%d",&amp;b);cutfa(a); if(a+b&lt;=n) linkfa(a,a+b); &#125; &#125;&#125; Analysis3请先思考后再展开 分块大法好！既然说分块是暴力的优化，先想想暴力：从后往前预处理，然后查询瞬间，修改再次从后往前那么找个【暴力与分块】的关系和【前缀和与树状数组】的关系是类似的，就是前一种查询快，但难修改。那么树状数组让两个操作的时间均衡了。分块也类似如此，设法把修改的时间缩短：对于每个位置，记录两个值：跳出这个块的步数、跳出后到了哪里。于是时间都达到了sqrt(n)了 Code3请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量****************const int MAXN=210000;//*******************全局定义****************int n;int k[MAXN];//*******************分块******************int cnt;int belg[MAXN];int bl[MAXN],br[MAXN];void block()&#123; int qn=sqrt(n);cnt=0; for(int i=1;i&lt;=n;i++) &#123; belg[i]=(i-1)/qn+1; if(belg[i-1]!=belg[i]) &#123; cnt++; br[cnt-1]=i-1; bl[cnt]=i; &#125; &#125; bl[1]=1;br[cnt]=n;&#125;//*******************实现******************int p[MAXN],c[MAXN];void change(int x)&#123; int jp=x+k[x],t=belg[x]; if(jp&gt;n) c[x]=0,p[x]=1; else if(jp&gt;br[t]) c[x]=jp,p[x]=1; else c[x]=c[jp],p[x]=p[jp]+1;&#125;//*******************主函数******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;k[i]); block(); for(int i=n;i&gt;=1;i--) change(i); int q;scanf("%d",&amp;q); while(q--) &#123; int op,a;scanf("%d%d",&amp;op,&amp;a);a++; if(op==1) &#123; int ans=0; while(a&gt;0) &#123; ans+=p[a]; a=c[a]; &#125; printf("%d\n",ans); &#125; else &#123; scanf("%d",&amp;k[a]); for(int i=a;i&gt;=bl[belg[a]];i--) change(i); &#125; &#125;&#125; 总结一下LCT：O(Big*nlogn)分块：O(n*sqrt(n))其实都不是特别好想然后Big的可怕：就算把耗时很高的makeroot去掉，也能硬生生把logn变成sqrt(n)（甚至更慢）]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>LCT</tag>
        <tag>难度2</tag>
        <tag>伸展树</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2152】【Luogu2634】聪聪可可]]></title>
    <url>%2Fposts%2F1124.html</url>
    <content type="text"><![CDATA[Source and Judge国家集训队Bzoj2152Luogu2634 Problem【Brief description】给一棵带权树，求任选两个点间路径和是3的倍数的概率【Input】输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。【Output】以既约分数的形式输出（即“a/b”的形式，其中a和b必须互质）如果概率为1，输出“1/1”【Limited conditions】n&lt;=20000【Sample input】51 2 11 3 21 4 12 5 3【Sample output】13/25【Sample explanation】13组点对分别是(1,1) (2,2) (2,3) (2,5)(3,2) (3,3) (3,4) (3,5)(4,3) (4,4) (5,2) (5,3) (5,5) Record40min Analysis请先思考后再展开 显然可以点分治，时间为nlogn 树形dp也非常显然f[x][0/1/2]表示到x，距离的余数，的点数 Code请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; int qread() &#123; int ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;;c=getchar();&#125; while(c&gt;='0' and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; const int MAX_N=21000; int hou[MAX_N]; struct Edge&#123;int y,c,g;&#125;e[MAX_N*2]; int ln=0;void ins(int x,int y,int c) &#123;e[++ln]=(Edge)&#123;y,c,hou[x]&#125;;hou[x]=ln;&#125; ll ans=0; int f[MAX_N][3];//到x，距离为0、1、2的点数 void dp(int x,int fa) &#123; f[x][0]=1; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dp(y,x); for(int a=0;a&lt;=2;a++) ans+=f[x][a]*f[y][ (6-a-e[k].c)%3 ]; for(int b=0;b&lt;=2;b++) f[x][(b+e[k].c)%3]+=f[y][b]; &#125; &#125; int gcd(int x,int y) &#123;return y==0?x:gcd(y,x%y);&#125; void main() &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;n;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c%3);ins(y,x,c%3); &#125; dp(1,0);ans=ans*2+n;//有序数对，再考虑共点 ll all=(ll)n*n; ll d=gcd(ans,all); printf("%lld/%lld",ans/d,all/d); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>难度1</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4196】【Luogu2146】软件包管理器]]></title>
    <url>%2Fposts%2F6263.html</url>
    <content type="text"><![CDATA[Source and JudgeNoi2015Bzoj4196Luogu2146 Problem【Brief description】就是给出一个n个点(0~n-1) 的有根树（根为0），和q次操作；初始时树上所有结点均为白；1、将根到x结点的所有结点置为黑，并输出这次操作有多少个元素改变了状态；2、将x结点的子树中所有结点置为白，并输出这次操作有多少个元素改变了状态；【Input】输入文件的第1行包含1个正整数n。随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,…,n−2,n−1点的父亲节点。接下来一行包含1个正整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种：Install x：表示1操作Uninstall x：表示2操作对于每个操作，输出这步操作有多少个点改变了状态。【Output】输出文件包括q行。输出文件的第i行输出1个整数，为第i步操作中改变状态的点数。【Limited conditions】n，q&lt;=100000【Sample input】70 0 0 1 1 55install 5install 6uninstall 1install 4uninstall 0【Sample output】31323【Sample explanation】一开始所有的软件包都处于未安装状态。安装5号软件包，需要安装0,1,5三个软件包。之后安装6号软件包，只需要安装6号软件包。此时安装了0,1,5,6四个软件包。卸载1号软件包需要卸载1,5,6三个软件包。此时只有0号软件包还处于安装状态。之后安装4号软件包，需要安装1,4两个软件包。此时0,1,4处在安装状态。最后，卸载0号软件包会卸载所有的软件包。 Record40min1RE边又忘记开两倍了…… Analysis请先思考后再展开 裸题首先dfs搞出来的编号，重链上是连续的，子树也是连续的于是问题主要在线段树上，要区间修改，区间查询还要返回修改量，所以记录两个值：c（-1为黑，0为混杂，1为白），b（黑点数量）即可 Code请先思考后再展开 12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1036】【Luogu2590】树的统计]]></title>
    <url>%2Fposts%2Fa490.html</url>
    <content type="text"><![CDATA[Source and JudgeZJOI2008Bzoj1036Luogu2590 Problem【Brief description】一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。操作：I. CHANGE u t : 把结点u的权值改为tII. QMAX u v: 询问从点u到点v的路径上的节点的最大权值III. QSUM u v: 询问从点u到点v的路径上的节点的权值和注意：从点u到点v的路径上的节点包括u和v本身【Input】输入文件的第一行为一个整数n，表示节点的个数。接下来n–1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。接下来一行n个整数，第i个整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。【Output】对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。【Limited conditions】1&lt;=n&lt;=30000，0&lt;=q&lt;=200000；中途操作中保证每个节点的权值w在-30000到30000之间。【Sample input】41 22 34 14 2 1 312QMAX 3 4QMAX 3 3QMAX 3 2QMAX 2 3QSUM 3 4QSUM 2 1CHANGE 1 5QMAX 3 4CHANGE 3 6QMAX 3 4QMAX 2 4QSUM 3 4【Sample output】412210656516【Sample explanation】无（良心数据） Record30min Analysis请先思考后再展开 裸题 Code请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量****************const int MAXN=31000,MAXM=61000;//*******************全局定义****************//*******************线段树******************struct Seg&#123; int l,r; int lc,rc; int sum,mx;&#125;s[MAXN*2];int cnt=0;int build(int l,int r)&#123; int t=++cnt; s[t].l=l;s[t].r=r; s[t].sum=s[t].mx=0; if(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; s[t].lc=build(l,mid); s[t].rc=build(mid+1,r); &#125; else s[t].lc=s[t].rc=0; return t;&#125;void change(int x,int pos,int c)&#123; if(s[x].l==s[x].r) &#123; s[x].sum=s[x].mx=c; return; &#125; int mid=(s[x].l+s[x].r)&gt;&gt;1; int lc=s[x].lc,rc=s[x].rc; if(pos&lt;=mid) change(lc,pos,c); else change(rc,pos,c); s[x].sum=s[lc].sum+s[rc].sum; s[x].mx=mymax(s[lc].mx,s[rc].mx);&#125;int asksum(int x,int l,int r)&#123; if(s[x].l==l and s[x].r==r) return s[x].sum; int mid=(s[x].l+s[x].r)&gt;&gt;1; int lc=s[x].lc,rc=s[x].rc; if(r&lt;=mid) return asksum(lc,l,r); if(l&gt;mid) return asksum(rc,l,r); return asksum(lc,l,mid)+asksum(rc,mid+1,r);&#125;int askmx(int x,int l,int r)&#123; if(s[x].l==l and s[x].r==r) return s[x].mx; int mid=(s[x].l+s[x].r)&gt;&gt;1; int lc=s[x].lc,rc=s[x].rc; if(r&lt;=mid) return askmx(lc,l,r); if(l&gt;mid) return askmx(rc,l,r); return mymax( askmx(lc,l,mid),askmx(rc,mid+1,r) );&#125;//*******************邻接表******************struct Nod&#123; int hou; int fa; int dep,tot; int tp,son;&#125;p[MAXN];struct Edge&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;void dfs1(int x,int fa)&#123; p[x].fa=fa;p[x].dep=p[fa].dep+1; p[x].tot=1;p[x].son=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; dfs1(y,x); p[x].tot+=p[y].tot; if(p[y].tot&gt;p[p[x].son].tot) p[x].son=y; &#125;&#125;//*******************树链剖分****************int ys[MAXN];int id=0;void dfs2(int x,int tp)&#123; ys[x]=++id; p[x].tp=tp; if(p[x].son&gt;0) dfs2(p[x].son,tp); for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==p[x].son or y==p[x].fa) continue; dfs2(y,y); &#125;&#125;//dep小，编号小int solve2(int a,int b)&#123; int ans=-40000; while(p[a].tp!=p[b].tp) &#123; int ta=p[a].tp,tb=p[b].tp; if(p[ta].dep&lt;p[tb].dep) swap(a,b),swap(ta,tb); ans=mymax(ans, askmx(1,ys[ta],ys[a]) ); a=p[ta].fa; &#125; if(p[a].dep&gt;p[b].dep) swap(a,b); return mymax(ans, askmx(1,ys[a],ys[b]) );&#125;int solve3(int a,int b)&#123; int ans=0; while(p[a].tp!=p[b].tp) &#123; int ta=p[a].tp,tb=p[b].tp; if(p[ta].dep&lt;p[tb].dep) swap(a,b),swap(ta,tb); ans+=asksum(1,ys[ta],ys[a]); a=p[ta].fa; &#125; if(p[a].dep&gt;p[b].dep) swap(a,b); return ans+asksum(1,ys[a],ys[b]);&#125;//*******************主函数******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; p[0].dep=0;p[0].tot=0;dfs1(1,0); dfs2(1,1); build(1,n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); change(1,ys[i],t); &#125; int Q;scanf("%d",&amp;Q);char ch[10]; while(Q--) &#123; int a,b;scanf("%s%d%d",ch,&amp;a,&amp;b); if(ch[0]=='C') change(1,ys[a],b);//CHANGE if(ch[1]=='M') printf("%d\n",solve2(a,b));//QMAX if(ch[1]=='S') printf("%d\n",solve3(a,b));//QSUM &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1003】【Luogu1772】物流运输]]></title>
    <url>%2Fposts%2F90dd.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2006NOI导刊2010提高（01）Bzoj1003Luogu1772 题目【题目大意】物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是—件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本尽可能地小。【输入格式】第一行是四个整数n(l≤n≤100)、m(l≤m≤20)、K和e。n表示货物运输所需天数，m表示码头总数，K表示每次修改运输路线所需成本，e表示航线条数。接下来e行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编号以及航线长度(&gt;0)。其中码头A编号为1，码头B编号为m。单位长度的运输费用为1。航线是双向的。再接下来一行是一个整数d，后面的d行每行是三个整数P(1&lt;P&lt;m)，a，b(1≤a≤b≤n)。表示编号为P的码头从第a天到第b天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一条从码头A到码头B的运输路线。【输出格式】包括了一个整数表示最小的总成本。总成本=n天运输路线长度之和+K*改变运输路线的次数。【限定条件】30%的数据中N和M均不超过650%的数据中N和M至少有一个数不超过8100%的数据中N和M均不超过100【输入样例】5 5 10 81 2 11 3 31 4 22 3 22 4 43 4 13 5 24 5 242 2 33 1 13 3 34 4 5【输出样例】32【样例解释】上图依次表示第1至第5天的情况，阴影表示不可用的码头。前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)*3+(3+2)*2+10=32。 刷题记录30min1AC小心爆int 分析请先思考后再展开 好巧妙！枚举天数区间，狂跑最短路……然后进行灰常简单的dp即可快！狠！准！ 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=30,MAXM=800;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct Nod&#123; int hou; int d; bool v; bool in; bool ck[110]; Nod() &#123; hou=0; memset(ck,0,sizeof(ck)); &#125;&#125;p[MAXN];struct Edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************实现*******************int m;int lst[MAXN];int spfa(int st,int ed)&#123; for(int i=1;i&lt;=m;i++) &#123; p[i].d=INF;p[i].in=1; for(int j=st;j&lt;=ed;j++) if(p[i].ck[j]) &#123; p[i].in=0; break; &#125; &#125; p[1].v=1;p[1].d=0; int tou=1,wei=2;lst[1]=1; while(tou!=wei) &#123; int x=lst[tou++];if(tou==MAXN) tou=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].in and p[y].d&gt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; lst[wei++]=y; if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; &#125; return p[m].d;&#125;//*******************主函数******************int f[110];int main()&#123; int n,K,e;scanf("%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;e); while(e--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; int P;scanf("%d",&amp;P); while(P--) &#123; int t,x,y;scanf("%d%d%d",&amp;t,&amp;x,&amp;y); for(int i=x;i&lt;=y;i++) p[t].ck[i]=1; &#125; for(int i=1;i&lt;=n;i++) &#123; int t=spfa(1,i); if(t==INF) f[i]=INF; else f[i]=t*i;//debug 爆int for(int j=1;j&lt;=i-1;j++) &#123; t=spfa(j+1,i);//debug if(t!=INF) f[i]=mymin(f[i],f[j]+K+spfa(j+1,i)*(i-j)); &#125; &#125; printf("%d",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1037】【Luogu2592】生日聚会]]></title>
    <url>%2Fposts%2F4e5e.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2008Bzoj1037Luogu2592 题目【题目大意】今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：对于任意连续的一段，男孩与女孩的数目之差不超过k。很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题……假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。【输入格式】共3个整数，分别为男孩数目n, 女孩数目m, 常数k【输出格式】题中要求的答案【限定条件】对于30%的数据，n,m≤20；对于100%的数据，n,m≤150，k≤20。【输入样例】1 2 1【输出样例】1【样例解释】无 刷题记录30min1AC 分析请先思考后再展开 别人眼中的水题……网上题解可能都懒得说什么了，于是我一开始并没有理解。在我的美妙构想中，dp式长这样：f[q][w]，觉得男女生差距哪些自己算不就好了？然鹅，这并没有考虑到，我们要求的条件是针对任意一段的差。然后，我们在dp中，假设做到了第i-1个要得出第i个，那么新增加了哪些段呢（因为之前的段已经保证合法性了）？显然就是i的所有后缀那么新增加两个维度变成f[q][w][a][b]来存储任意长度的后缀的男女最大差，以此来作为约束条件。 代码请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018//*******************头文件******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MOD=12345678;//*******************全局变量*******************int f[310][160][30][30];//*******************实现*******************//*******************主函数******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); f[0][0][0][0]=1;if(n&gt;m) swap(n,m); for(int i=0;i&lt;=n+m-1;i++) &#123; for(int j=0;j&lt;=n and j&lt;=i;j++) &#123; for(int a=0;a&lt;=k;a++)//男 &#123; for(int b=0;b&lt;=k;b++)//女 &#123; if(f[i][j][a][b]==0) continue;//超级快 if(a&lt;k and j&lt;n)//男 &#123; f[i+1][j+1][a+1][mymax(b-1,0)]+=f[i][j][a][b]; f[i+1][j+1][a+1][mymax(b-1,0)]%=MOD; &#125; if(b&lt;k and i-j&lt;m)//女 &#123; f[i+1][j][mymax(a-1,0)][b+1]+=f[i][j][a][b]; f[i+1][j][mymax(a-1,0)][b+1]%=MOD; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int a=0;a&lt;=k;a++) for(int b=0;b&lt;=k;b++) &#123; ans+=f[n+m][n][a][b]; ans%=MOD; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2298】【Luogu2523】problem c]]></title>
    <url>%2Fposts%2F3d19.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2302Luogu2523 题目【题目大意】给n个人安排座位，先给每个人一个1~n的编号，设第i个人的编号为ai（不同人的编号可以相同），接着从第一个人开始，大家依次入座，第i个人来了以后尝试坐到ai，如果ai被占据了，就尝试ai+1，ai+1也被占据了的话就尝试ai+2，……，如果一直尝试到第n个都不行，该安排方案就不合法。然鹅有m个人的编号已经确定(他们或许贿赂了你的上司…)，你只能安排剩下的人的编号，求有多少种合法的安排方案。由于答案可能很大，只需输出其除以M后的余数即可。【输入格式】第一行一个整数T，表示数据组数对于每组数据，第一行有三个整数，分别表示n、m、M若m不为0，则接下来一行有m对整数，p1、q1，p2、q2 ,…, pm、qm，其中第i对整数pi、qi表示第pi个人的编号必须为qi【输出格式】对于每组数据输出一行，若是有解则输出YES，后跟一个整数表示方案数mod M，注意，YES和数之间只有一个空格，否则输出NO【限定条件】1≤T≤10，1≤n≤300，0≤m≤n，2≤M≤10^9，1≤pi、qi≤n 且保证pi互不相同。【输入样例】24 3 101 2 2 1 3 110 3 88827 9 2 9 5 10【输出样例】YES 4NO【样例解释】无 刷题记录30min 分析请先思考后再展开 好难啊赶脚这种东西感觉完全想不出来好吧 首先，一个显然的不合法情况：编号&lt;=i的人少于i个（后面人太多了，冲突）然后具体人的编号是完全不重要的，递推的时候乘上组合数就可以了。然后用一个num[i]记录，已经确定的编号为i的人的个数然后用sum[i]表示num[i]的前缀和，特别的是sum[0]=n-m，表示所有未决定的在极端情况下相当于0，这样sum[i]又多了一个意义：编号&lt;=i的人 最多有多少设f[i][j]表示编号&lt;=i的人，有j个的方案数（同理，i&lt;=j），用k表示编号=i的个数那么，k最小当然就是num[i]，最大则是j-(i-1)，因为sum[i-1]&gt;=i-1然后我们这一轮新选择（除去已经固定的）有num[i]个，总共是sum[i]-num[i]-(j-k)所以得出方程(i=1~n,j=i~sum[i])：$$f[i][j]=\sum_{k=num[i]}^{j-i+1} f[i-1][j-k]\times C_{sum[i]-num[i]-(j-k)}^{k-num[i]}$$时间复杂度$O(Tn^3)$ upd 2019.1.29:一开始看错题+把组合数放外面耗费了些时间这就是道sb题……只要记得不能用答案判无解，dp的话随便dp就行了，上面那个说这么多其实很好理解 代码请先思考后再展开 以前代码太丑了，放新的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair int MOD; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;&#125; int sum(int x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;return x;&#125; const int MAX_N=310; int tot[MAX_N]; int C[MAX_N][MAX_N]; int f[MAX_N][MAX_N]; void main() &#123; int T;scanf("%d",&amp;T); while(T--) &#123; bool GG=0; int n,m;scanf("%d%d%d",&amp;n,&amp;m,&amp;MOD); C[0][0]=1; for(int i=1;i&lt;MAX_N;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=sum(C[i-1][j-1],C[i-1][j]); &#125; memset(tot,0,sizeof tot); while(m--) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); tot[b]++; &#125; for(int i=1;i&lt;=n;i++) tot[i]+=tot[i-1]; for(int i=1;i&lt;=n;i++) if(tot[n]-tot[i-1]&gt;n-i+1) GG=1; memset(f,0,sizeof f);f[0][0]=1; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;=n;j++) if(f[i][j]&gt;0) &#123; int tmp=tot[i+1]-tot[i]; for(int now=0;now&lt;=n-j-(tot[n]-tot[i]);now++) add(f[i+1][j+tmp+now],(ll)f[i][j]*C[n-j-(tot[n]-tot[i])][now]%MOD); &#125; if(GG) puts("NO"); else printf("YES %d\n",f[n][n]); &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2298】【Luogu2519】problem a]]></title>
    <url>%2Fposts%2Ff583.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2298Luogu2519 题目【题目大意】一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)。【输入格式】第一行一个整数n，接下来n行每行两个整数，第i+1行的两个整数分别代表ai、bi【输出格式】一个整数，表示最少有几个人说谎【限定条件】1≤n≤1000000≤ai、bi≤n【输入样例】32 00 22 2【输出样例】1【样例解释】无 刷题记录1h 分析请先思考后再展开 假话=n-真话，最少假话=最多真话 定位可能的区间[ai+1,n-bi]为[li,ri]，直接跳过l&gt;r的情况（显然的假话） 将所有区间排序，从而获得有哪些是相同的[li,ri]，合并为一个块 给这个块定义一个价值vi：最大可能人数（如果比ri-li+1多，多余的忽略，显然的假话） 开始dp。设f[i]表示到当前块的真话最大值然后二分查找，得到编号最大（最优秀，因为f是前缀max的）且rj&lt;li的j，f[i]=max(f[i-1],f[j]+vi) ANS=n-f[块数]时间复杂度O(nlogn) upd 2019.1.29：上面说的太乱了转化为求最多真话给每个人一个区间[bi+1,ai-1] 这个区间相当于=然后转化为每个人在区间内选一个数，然后每个人互不重叠而且最后选出的区间不能有除了重合外的重叠，因为区间之间是&lt; 这题可以n做的，桶排+顺便处理每个r的lst提供组数据：32 21 02 0ans=2 代码请先思考后再展开 新的代码，不过没写桶排1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; // #define pr pair&lt;int,int&gt; // #define FR first // #define SE second // #define MP make_pair const int MAX_N=110000; struct Nod&#123;int l,r,w;&#125;p[MAX_N],p2[MAX_N]; bool cmp(Nod a,Nod b) &#123;return a.r&lt;b.r or (a.r==b.r and a.l&lt;b.l);&#125; int f[MAX_N],lst[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n); int tot=0; for(int i=1;i&lt;=n;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(b+1&lt;=n-a) p[++tot]=(Nod)&#123;b+1,n-a,1&#125;; &#125; sort(p+1,p+tot+1,cmp); int tot2=1;p2[1]=p[1]; for(int i=2;i&lt;=tot;i++) if(p[i].l!=p[i-1].l or p[i].r!=p[i-1].r) p2[++tot2]=p[i]; else p2[tot2].w=min(p2[tot2].w+1,p2[tot2].r-p2[tot2].l+1); for(int r=1,now=0;r&lt;=n;r++) &#123; lst[r]=lst[r-1]; while(now+1&lt;=tot2 and p2[now+1].r==r) &#123; now++; f[now]=max(f[now-1],f[lst[p2[now].l-1]]+p2[now].w); lst[r]=now; &#125; &#125; printf("%d",n-f[tot2]); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4069】【Luogu3646】巴厘岛的雕塑]]></title>
    <url>%2Fposts%2Fa4aa.html</url>
    <content type="text"><![CDATA[来源和评测点Apio2015 Bali SculpturesBzoj4069Luogu3646Uoj110 题目【题目大意】给出一些有序的值，在连续的情况下进行分组，并且a&lt;=组的数量&lt;=b求最小的 所有（组的和）的按位或值。【输入格式】输入的第一行包含三个用空格分开的整数N,A,B第二行包含N个用空格分开的整数。【输出格式】输出一行一个数，表示最小的按位或值。【限定条件】子任务1 （9 分）1&lt;=N&lt;=201&lt;=A&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000子任务2 （16 分）1&lt;=N&lt;=501&lt;=A&lt;=B&lt;=min{20,N}0&lt;=Yi&lt;=10子任务3 （21 分）1&lt;=N&lt;=100A=11&lt;=B&lt;=N0&lt;=Yi&lt;=20子任务4 （25 分）1&lt;=N&lt;=1001&lt;=A&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000子任务5 （29 分）1&lt;=N&lt;=2000A=11&lt;=B&lt;=N0&lt;=Yi&lt;=1000000000【输入样例】6 1 38 1 2 1 5 4【输出样例】11【样例解释】分为2组，(8,1,2)和(1,5,4)，它们的和是 (11) 和 (10)，最终优美度是 (11 OR 10)=11，不难验证，这也是最终优美度的最小值。 刷题记录1h 分析请先思考后再展开 显然，直接写dp是不行的，因为区间小并不代表最终小。既然是按位或，可以考虑数位dp。然后区间静态求和，前缀和是不能少滴。 然后网上看到一句话： 对于数位极值问题，应该贪心地优先从高位开始考虑，极小值优先0，极大值优先1 然后就可以愉快地考虑dp了：假设现在在努力地把右数第k位变成0，那么我们就要尽量让所有和的第k位为0。并且前面的已经解决，用tmp表示现在已经能变成0的位置（所以最后输出答案就是tot-tmp） 然后f[i][p]表示前面i个数分p段能否第k位是0（状压），然后n^2来常规dp即可转移条件：( (sum[i]-sum[j])&amp;tmp )==0 （也就是tmp为1的地方这一段的和必须是0，否则前功尽弃）那么这个复杂度是O(60*n^3)的，而最后一个子任务是2000，会TLE然后发现这一次，A=1，那么怎么利用这个条件呢？考虑贪心一波：因为现在的限制只有B，那么当然是段数越小，成功率越高。设g[i]表示前i个数最小分多少段能第k位是0成功变成O(60*n^2) upd 2019.3.29:一年后回来看，发现这是一道sb题……把新的代码换了上去值得一提的是，这份代码你把task2里面的check，包括return删除，可以得到82的好成绩qwq也就是说每次都return了我希望的值，我也不知道为什么 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;// #include&lt;unordered_map&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void writeln(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;ll,ll&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=1e1+2; const ll MOD=1e13; void add(int &amp;x,int y) &#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; int n,L,R; ll a[2100],bin[50]; namespace task1 &#123; const int MAX_N=2100; int f[MAX_N]; bool check(ll mask) &#123; memset(f,0x3f,sizeof f);f[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) if( ((a[i]-a[j])&amp;mask)==0 ) chmin(f[i],f[j]+1); return f[n]&lt;=R; &#125; &#125;; namespace task2 &#123; const int MAX_N=110; bool f[MAX_N][MAX_N]; bool check(ll mask) &#123; memset(f,0,sizeof f);f[0][0]=1; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=R;k++) for(int j=0;j&lt;i;j++) if( ((a[i]-a[j])&amp;mask)==0 and f[j][k-1] ) &#123;f[i][k]=1;break;&#125; for(int i=L;i&lt;=R;i++) if(f[n][i]) return 1; return 0; &#125; &#125;; void main() &#123; bin[0]=1;for(int i=1;i&lt;=41;i++) bin[i]=bin[i-1]&lt;&lt;1; n=qread();L=qread();R=qread(); for(int i=1;i&lt;=n;i++) a[i]=a[i-1]+qread(); ll ans=0; for(int i=40;i&gt;=0;i--) &#123; if(L==1 and task1::check(ans|bin[i])) ans|=bin[i]; else if(L!=1 and task2::check(ans|bin[i])) ans|=bin[i]; &#125; write((bin[41]-1)^ans); &#125;&#125;;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4197】【Luogu2150】寿司晚宴]]></title>
    <url>%2Fposts%2Fbe34.html</url>
    <content type="text"><![CDATA[来源和评测点Noi2015Bzoj4197Loj2131Uoj129Luogu2150 题目【题目大意】为了庆祝NOI的成功开幕，主办方为大家准备了一场寿司晚宴。小G和小W作为参加NOI的选手，也被邀请参加了寿司晚宴。在晚宴上，主办方为大家提供了n−1种不同的寿司，编号1,2,3,……,n-1，其中第种寿司的美味度为i+1（即寿司的美味度为从2到n）。现在小G和小W希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小G品尝的寿司种类中存在一种美味度为x的寿司，小W品尝的寿司中存在一种美味度为y的寿司，而x与y不互质。现在小G和小W希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数p取模）。注意一个人可以不吃任何寿司。【输入格式】第1行包含2个正整数n，p中间用单个空格隔开，表示共有n种寿司，最终和谐的方案数要对p取模。【输出格式】输出一行包含1个整数，表示所求的方案模p的结果。【限定条件】2≤n≤5000&lt;p≤1000000000【输入样例】100 100000000【输出样例】3107203【样例解释】无 刷题记录2h1WA1AC以后有膜数的问题，出现减法一定要小心！可能原本正数，膜完再减就变成负数了！ 分析请先思考后再展开 又膜了题解，还特别不好理解…… 首先明确：选择了一种寿司，其实是选择了一些质因数。那么继续面向数据编程，2~n的数，最多包含一个质因数是大于$\sqrt{n}$的而在这之下的质因数个数只有8个：2,3,5,7,11,13,17,19那么是可以用256个状态表示每个数的组成的（注意！！质因数的数量是完全不重要的，也就是说我们记录的只是集合！）那剩下那个大质因数（没有的话用1表示）怎么处理呢？因为这个质因数只能选择一个人，那么以这个排一次序，相同的这个只能选择一个人，看作是一个块（如果没有，则视为不同的块） 那么开始推公式： 定义（在同一个块中）：$$f[s1][s2]=两个人的这种状态下，合法方案的数量$$$$g1[s1][s2]表示两个人的这种状态下，并且这一块的质因数选择第一个或者不选的合法方案的数量$$$$g2[s1][s2]表示两个人的这种状态下，并且这一块的质因数选择第二个或者不选的合法方案的数量$$ 计算1) 一个新的块开始$$g1[s1][s2]=g2[s1][s2]=f[s1][s2]（相当于不选）$$2) 像采药一样倒着dp来避免后效性$$g[s|j]+=f[s]（状态的包含）$$3) 一个块结束（因为不选的部分两边都重复了）$$f[s1][s2]=g1[s1][s2]+g2[s1][s2]-f[s1][s2]$$ 然后自己注意一下合法状态的判断就好了，都是位运算 这道题最巧妙的地方在于对大质因数的处理，以及对状态压缩的洞察力。 代码请先思考后再展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=510,MAXS=300;const int PRIME[8]=&#123;2,3,5,7,11,13,17,19&#125;;//*******************全局定义*******************int bin[10];struct Num&#123; int bit; int left;&#125;a[MAXN];bool cmp(Num a,Num b) &#123;return a.left&lt;b.left;&#125;//*******************实现*******************ll MOD;ll Mod(ll x) &#123; return (x%MOD+MOD)%MOD;&#125;int fuk(int &amp;x)&#123; int ans=0; for(int i=0;i&lt;8;i++) &#123; if(x%PRIME[i]==0) &#123; ans+=bin[i]; while(x%PRIME[i]==0) x/=PRIME[i]; &#125; &#125; return ans;&#125;//*******************主函数*******************ll f[MAXN][MAXN];ll g1[MAXN][MAXN],g2[MAXN][MAXN];int main()&#123; bin[0]=1;for(int i=1;i&lt;=8;i++) bin[i]=bin[i-1]&lt;&lt;1; int n;scanf("%d%lld",&amp;n,&amp;MOD); for(int now=2;now&lt;=n;now++) a[now].left=now,a[now].bit=fuk(a[now].left); sort(a+2,a+n+1,cmp); f[0][0]=1;int tot=bin[8]-1; for(int i=2;i&lt;=n;i++) &#123; if(i==2 or a[i].left==1 or a[i-1].left!=a[i].left) &#123; memcpy(g1,f,sizeof(f)); memcpy(g2,f,sizeof(f)); &#125; for(int s1=tot;s1&gt;=0;s1--) for(int s2=tot;s2&gt;=0;s2--) &#123; if( (s1&amp;s2)!=0 ) continue;//debug if( (a[i].bit&amp;s2)==0 ) g1[s1|a[i].bit][s2]=(g1[s1|a[i].bit][s2]+f[s1][s2])%MOD; if( (s1&amp;a[i].bit)==0 ) g2[s1][s2|a[i].bit]=(g2[s1][s2|a[i].bit]+f[s1][s2])%MOD; &#125; if(i==n or a[i].left==1 or a[i].left!=a[i+1].left) &#123; for(int s1=0;s1&lt;=tot;s1++) for(int s2=0;s2&lt;=tot;s2++) if( (s1&amp;s2)==0 ) f[s1][s2]=Mod(g1[s1][s2]+g2[s1][s2]-f[s1][s2]); &#125; &#125; int ans=0; for(int s1=0;s1&lt;=tot;s1++) for(int s2=0;s2&lt;=tot;s2++) if( (s1&amp;s2)==0 )//debug ans=(ans+f[s1][s2])%MOD; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1131】【Luogu3160】时态同步]]></title>
    <url>%2Fposts%2F2e88.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2007Bzoj1060Luogu1131 题目【题目大意】小Q在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字1,2,3….进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。激励电流在导线上的传播是需要花费时间的，对于每条边e，激励电流通过它需要的时间为te，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小Q有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用多少次道具才可使得所有的“终止节点”时态同步？【输入格式】第一行包含一个正整数N，表示电路板中节点的个数。第二行包含一个整数S，为该电路板的激发器的编号。接下来N-1行，每行三个整数a,b,t。表示该条导线连接节点a与节点b，且激励电流通过这条导线需要t个单位时间【输出格式】仅包含一个整数V，为小Q最少使用的道具次数【限定条件】对于40%的数据，N≤1000对于100%的数据，N≤500000对于所有的数据，te≤1000000【输入样例】311 2 11 3 3【输出样例】2【样例解释】无 刷题记录30min 分析请先思考后再展开 sb题中午睡觉无聊想的 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;//*******************全局定义*******************struct nod&#123; int hou; int fa; ll dep,mx; nod() &#123; hou=dep=mx=0; &#125;&#125;p[MAXN];struct edge&#123; int y,g; ll c;&#125;e[MAXN*2];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************实现*******************void dfs1(int x,int fa)&#123; p[x].fa=fa;p[x].mx=p[x].dep; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==fa) continue; p[y].dep=p[x].dep+e[k].c; dfs1(y,x); p[x].mx=mymax(p[x].mx,p[y].mx); &#125;&#125;ll mx;ll ans=0;void dfs2(int x,ll inc)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y==p[x].fa) continue; ll d=mx-(p[y].mx+inc); if(d&gt;0) &#123; ans+=d; dfs2(y,inc+d); &#125; else dfs2(y,inc); &#125;&#125;//*******************主函数*******************int main()&#123; int n,st;scanf("%d%d",&amp;n,&amp;st); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; dfs1(st,0); mx=p[st].mx; dfs2(st,0); printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2064】分裂]]></title>
    <url>%2Fposts%2Fdf4.html</url>
    <content type="text"><![CDATA[来源和评测点和谐社会模拟赛Bzoj2064 题目【题目大意】给定一个初始集合和目标集合，有两种操作：1.合并集合中的两个元素，新元素为两个元素之和 2.分裂集合中的一个元素，得到的两个新元素之和等于原先的元素。要求用最小次数使初始集合变为目标集合，求最小次数。【输入格式】第一行一个数n1，表示当时的元素量，接下来n1个数分别表示各元素的值。 第二行一个数n2，表示现在的元素量，接下来n2个数分别表示各元素的值。【输出格式】一行一个数表示最小次数。【限定条件】对于30%的数据，n1,n2&lt;=6对于100%的数据，n1,n2&lt;=10，每个数&lt;=50【输入样例】1 63 1 2 3【输出样例】2【样例解释】无 刷题记录30min1AC 分析请先思考后再展开 首先，本着面向数据编程的观点，我们发现数据范围灰常小！那么有基本上两种可能： 一般的算法难以解决的问题 状压dp看起来好像后面这个比较靠谱呀，因为这个题目好像不算太恶心但是压什么呢？通常都是选和不选的01但这道题不是选不选的问题呀，元素不是不变的于是我的思路一度卡顿…… 算了，还是先观察题目吧，看看能不能转化模型？ 精简题意（我上面已经精简了） 考虑题目要求的是最小次数，虽然dp和贪心差别很大，但先考虑一下极端情况：1) 最坏情况(n-1)+(m-1)=n+m-2，也就是全部加起来再分开2) 如果稍微好一点，恰好有两部分对应和相等，那么合并和分离就都减少了一次也就是(n-2)+(m-2)=n+m-43) 那么如果有k部分对应相等，显然次数就是n+m-2*k4) 用最好情况验证一下，次数是0,那么k=n=m，n+m-2*k=0 哇这下子就好办了！求出一个最大的k就好了。更好的是，求最大的k，根本就不用真的去合并、分割于是祭出状态压缩大法！用二进制表示选取状态。$f[s1][s2]$表示集合1和集合2的子集s1和s2的最大ksum[s]表示状态s的和$f[s1][s2]=max(f[s1^i][s2^j])+bool(sum[s1]==sum[s2])$ 以上就是网上普遍的解法了，然鹅我有幸又看到一篇文章他的方法也挺巧妙的，主要是简化上面的方程（复杂度不变）首先，sum数组要开两个，有点麻烦，因为两个状态都是一起用的，考虑状态全部合二为一（最大长度从10变20）然后集合1是正数，集合2是负数，那么如果sum[s]=0表示和相同然后为了避免冲突，sum不能乱算（挺巧妙的）：$sum[s]=sum[lowbit(s)]+sum[s-lowbit(s)]$然后f也可以把状态合二为一 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************int bin[26];int f[MAXN],sum[MAXN];//*******************实现*******************inline int lowbit(int x) &#123;return x&amp;(-x);&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=25;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m; scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++) sum[bin[i-1]]=read(); scanf("%d",&amp;m);for(int i=1;i&lt;=m;i++) sum[bin[n+i-1]]=-read(); int tot=bin[n+m]-1; for(int s=1;s&lt;=tot;s++) &#123; int t=lowbit(s);sum[s]=sum[t]+sum[s^t]; for(int j=1;j&lt;=n+m;j++) if(s&amp;bin[j-1]) f[s]=mymax(f[s],f[s^bin[j-1]]); if(sum[s]==0) f[s]++; //s的和对应，则为后面作贡献 &#125; printf("%d",n+m-2*f[tot]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1801】【Luogu2051】中国象棋]]></title>
    <url>%2Fposts%2Fdc53.html</url>
    <content type="text"><![CDATA[来源和评测点Ahoi2009 Day2Bzoj1801Luogu2051 题目【题目大意】在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。【输入格式】一行包含两个整数N，M，之间由一个空格隔开。【输出格式】总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。【限定条件】30%的数据中N和M均不超过650%的数据中N和M至少有一个数不超过8100%的数据中N和M均不超过100【输入样例】1 3【输出样例】7【样例解释】除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有2*2*2-1=7种方案。 刷题记录1h 分析请先思考后再展开 唉我的dp真的菜，打算多做点这道题的状态表示也不是太好想： 列的顺序是无关紧要的 显然每一行、列只能放0~2个棋子那么什么是重要的呢？0~2，这个状态量好像很少，但怎么表示呢？既然顺序不重要，那重要的自然就是内容了，而且内容只有三种情况那我们可以把每一列分类：0个为一类，1个为一类，2个为一类而且这三类的总和是m 想到了这个，基本上问题就迎刃而解了考虑dp状态的转移，以行来递推，f[i][q][w]表示前i行，有q列是有1个棋子的，w列是有2个棋子的，那么当然1个棋子的有(m-q-w)个 什么也不放，状态量有1个，状态值f[i-1][j][k] 放1个在原本棋子数量为0的列，状态量有m-(j-1)-k个，状态值f[i-1][j-1][k] 放1个在原本棋子数量为1的列，状态量有j+1个，状态值f[i-1][j+1][k-1] 放2个在原本棋子数量为0的列，状态量有C(m-(j-1)-k,2)个，状态值f[i-1][j-2][k] 放2个在原本棋子数量为0、1的列，状态量有(m-j-(k-1))*j个，状态值[i-1][j][k-1] 放2个在原本棋子数量为1的列，状态量有C(j+1,2)个，状态值f[i-1][j+2][k-2]出现了组合数呀！n还算挺大的怎么办?之前就卡这里了发现都是选取2个，所以不需要用阶乘的公式了hh直接n*(n-1)/2，爽 代码请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MOD=9999973;//*******************全局定义*******************int f[110][110][110];//*******************实现*******************ll getf(int i,int q,int w)&#123; if(i&lt;0 or q&lt;0 or w&lt;0) return 0; return f[i][q][w];&#125;int C2(int x)&#123; return x*(x-1)&gt;&gt;1;&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); int ans=0;f[0][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int q=0;q&lt;=m;q++) &#123; for(int w=0;w+q&lt;=m;w++) &#123; f[i][q][w]=f[i-1][q][w]; f[i][q][w]=( f[i][q][w]+getf(i-1,q-1,w)*(m-(q-1)-w)%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q+1,w-1)*(q+1)%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q-2,w)*C2(m-(q-2)-w)%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q,w-1)*(m-q-(w-1))%MOD*q%MOD )%MOD; f[i][q][w]=( f[i][q][w]+getf(i-1,q+2,w-2)*C2(q+2)%MOD )%MOD; if(i==n) ans=(ans+getf(i,q,w))%MOD; &#125; &#125; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1827】【Luogu2986】【Bzoj3743】奶牛大集会]]></title>
    <url>%2Fposts%2F4b22.html</url>
    <content type="text"><![CDATA[来源和评测点USACO2010 MAR GoldGreat Cow GatheringBzoj1827Luogu2986 双倍经验：Coci2015 KampBzoj3743 题目【题目大意】给出n个点，由n-1条边连接ai和bi，长度为li，形成一棵树，每个点有ci个奶牛。现在要选一个点，使其他点的奶牛到这里距离×数量之和最小。【输入格式】第一行：一个整数N。第二到N+1行：第i+1行有一个整数Ci第N+2到2*N行：第i+N+1行有3个整数：Ai,Bi和Li。【输出格式】最小的距离×数量之和【限定条件】1&lt;=N&lt;=100,0001&lt;=Ai&lt;=N1&lt;=Bi&lt;=N0&lt;=Ci&lt;=1,0001&lt;=Li&lt;=1,000【输入样例】5110021 3 12 3 23 4 34 5 3【输出样例】15【样例解释】 刷题记录30min忘记开long long，WA了一发 分析请先思考后再展开 这道题真心水啊，给之前被dp虐惨的我找回一点点信心……首先一看就是一棵树，那除了树形dp还能是什么~然后用a表示来自父亲的费用，b表示来自儿子的费用a还要容斥一下，还好有样例……$$a_top=(size[rt]-size[x])\times L_fa$$ $$a_brother=b[fa]-b[x]-size[b]\times L_son$$ $$a[x]=a[fa]+a_top+a_brother$$ $$b[x]=\sum b[son]+size[x]\times L_son$$ 然后就是因为方向不同，所以要dfs两次复杂度O(2n)，这n比较小，主要是这出题人把边搞大了 代码请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; ll a,b; ll size; int fa; nod() &#123; fa=hou=a=b=size=0; &#125;&#125;p[MAXN];struct edge&#123; int y,g; ll c;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************实现*******************void dfs1(int x,int fa)//自底向上&#123; p[x].fa=fa; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs1(y,x); p[x].size+=p[y].size; p[x].b+=p[y].b+p[y].size*e[k].c; &#125;&#125;int n;ll ans=ll(INF)*ll(INF);void dfs2(int x)//自上而下&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==p[x].fa) continue; ll top=(p[1].size-p[y].size)*e[k].c; ll brother=p[x].b-p[y].b-p[y].size*e[k].c; p[y].a=p[x].a+top+brother; ans=mymin(ans,p[y].a+p[y].b); dfs2(y); &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].size); for(int i=1;i&lt;=n-1;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); &#125; dfs1(1,0); dfs2(1); ans=mymin(ans,p[1].b); printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1904】King's Quest]]></title>
    <url>%2Fposts%2Ffc.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1904Caioj1149 题目【题目大意】给出n个男生（2000以内），在保证存在完备匹配的条件下，给出一些男生喜欢的女生的信息（20w以内），那么本着有福同享的观点，求出每个男生“应该喜欢”的女生的编号。“应该喜欢”的定义：任选其中一个来与对应男生匹配，其他的男生依然能够找到匹配对象。（可以理解为，每一个都能作为一条强制匹配的边）【输入格式】第一行一个整数n(1&lt;=n&lt;=2000).下来n行，每行第一个数ki表示第i只男生喜欢的女生数目，下来ki只女生的编号。所有ki的总和不超过 200000。【输出格式】输出每个男生可以匹配的女生的编号（从小到大输出），且其他男生和女生依然能一一匹配。【输入样例】42 1 22 1 22 2 32 3 4【输出样例】1 21 234 刷题记录30min 分析题目相当于求所有可能在完美匹配中的边 CommonAnts的解释：建（二分图的）增广路DAG 同一侧的两个点i,j，从i到j连一条有向边，当且仅当存在另一侧的点k使得ik在匹配上,kj不在 那么一条当前不在最大匹配上的边可能在最大匹配上，当且仅当它在一条以某个未匹配点为终点的路径上（这个题是完美匹配，不存在这种情况），或者对应的某条边在增广路图的环上 所以只要判这条未匹配边对应的边是不是在某个SCC里就好了 代码1（CommonAnts版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=2100,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int belg,dfn,low; bool v; nod() &#123; v=dfn=hou=0; &#125;&#125;p[2*MAXN];struct edge&#123; int x,y,g; int fs; edge() &#123; fs=0; &#125;&#125;e[MAXM*3];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************强连通*******************int n;int cnt,id;int sta[3*MAXN],top;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y;if(y&gt;n) continue;//debug if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].low==p[x].dfn) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0;p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************匈牙利*******************int chw[MAXN],match[MAXN];int ti;bool findmatch(int x)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(chw[y]&lt;ti) &#123; chw[y]=ti; if(match[y]==0 or findmatch(match[y])) &#123; match[y]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int ans[MAXN],as;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(t--) &#123; int y;scanf("%d",&amp;y); ins(i,n+y); &#125; &#125; memset(chw,0,sizeof(chw)); for(ti=1;ti&lt;=n;ti++) findmatch(ti); for(int i=1;i&lt;=n;i++) &#123; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(y&lt;=0) continue;//debug if(match[y]!=i)//失败的边 &#123; ins(match[y],i); e[k].fs=ln; &#125; &#125; &#125; cnt=0;id=0;top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) &#123; as=0; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(e[k].fs&gt;0)//失败的边 &#123; int xx=e[e[k].fs].x,yy=e[e[k].fs].y; if(p[xx].belg==p[yy].belg) ans[++as]=y; &#125; if(y&gt;0 and match[y]==i) ans[++as]=y;//成功的边 &#125; sort(ans+1,ans+as+1); printf("%d ",as);for(int j=1;j&lt;=as;j++) printf("%d ",ans[j]); printf("\n"); &#125;&#125; 代码2（自己版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=2100,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int belg,dfn,low; bool v; nod() &#123; v=dfn=hou=0; &#125;&#125;p[2*MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************强连通*******************int cnt,id;int sta[2*MAXN],top;void tarjan(int x)&#123; p[x].dfn=p[x].low=++id; sta[++top]=x;p[x].v=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].low==p[x].dfn) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0;p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************匈牙利*******************int n;int chw[MAXN],match[MAXN];int ti;bool findmatch(int x)&#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y-n; if(chw[y]&lt;ti) &#123; chw[y]=ti; if(match[y]==0 or findmatch(match[y])) &#123; match[y]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int ans[MAXN],as;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(t--) &#123; int y;scanf("%d",&amp;y); ins(i,n+y); &#125; &#125; memset(chw,0,sizeof(chw)); for(ti=1;ti&lt;=n;ti++) findmatch(ti); for(int i=1;i&lt;=n;i++) ins(n+i,match[i]); cnt=0;id=0;top=0; for(int i=1;i&lt;=2*n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=n;i++) &#123; as=0; for(int k=p[i].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[i].belg==p[y].belg) ans[++as]=y-n; &#125; sort(ans+1,ans+as+1); printf("%d ",as);for(int j=1;j&lt;=as;j++) printf("%d ",ans[j]); printf("\n"); &#125;&#125; 更新于2018.9.10今天是教师节，然而完全不想去看初中的老师…… 说正事，这道题现在看来就是求可行边相关的介绍，请前往oi之路中的二分图一章，有对lyd的做法的注解]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3679】数字之积]]></title>
    <url>%2Fposts%2F304d.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3679 题目【题目大意】一个数x各个数位上的数之积记为f(x) （不含前导零）求[L,R)中满足0&lt;f(x)&lt;=n的数的个数。【输入格式】第一行一个数n第二行两个数L、R【输出格式】一个数，即满足条件的数的个数【限定条件】0&lt;L&lt;R&lt;10^18,n&lt;=10^9【输入样例】519 22【输出样例】1【样例解释】无 刷题记录30min 分析请先思考后再展开 首先，按照题解的说法以2、3、5、7这些质因数组成的，int范围内的大概只有几千个，所以可以记录下来，排个序，搞个前缀和，然后用这个乘积来递推。 然后就是经典的套路了：先不考虑前导零的问题预处理然后处理位数&lt;M的情况，然后再一位位处理位数=M的情况即可 注意这一题因为是乘积，碰到0就要退出。 代码请先思考后再展开 网上很多奇奇怪怪的代码呀反正我这次尽全力优化了时间并且清晰易懂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************ll r2[40],r3[40],r5[40],r7[40],r10[40];ll f[20][10000];int cnt;int g[10000];//*******************实现*******************int num[20],ln;ll dp(ll x,int n)&#123; ll xx=x;ln=0; while(xx&gt;0) num[++ln]=int(xx%10),xx/=10; ll ans=0,pst=1; for(int i=ln;i&gt;=1;i--) for(int k=1;k&lt;=cnt;k++) ans+=f[i][k];//位数&lt;ln for(int i=ln;i&gt;=1;i--) &#123; int now=num[i]; for(int k=1;k&lt;=cnt;k++) for(int j=1;j&lt;now;j++) if(pst*ll(j)*ll(g[k])&lt;=ll(n)) ans+=f[i][k];//位数=ln pst*=ll(now); if(!pst or pst&gt;ll(n)) return ans;//无贡献 &#125; return ans+(pst&lt;=ll(n));//最后这个是无法统计的x自己&#125;//*******************主函数*******************int main()&#123; memset(f,0,sizeof(f)); r2[0]=r3[0]=r5[0]=r7[0]=r10[0]=1;//debug for(int i=1;i&lt;=35;i++) r2[i]=r2[i-1]*2; for(int i=1;i&lt;=25;i++) r3[i]=r3[i-1]*3; for(int i=1;i&lt;=18;i++) r5[i]=r5[i-1]*5; for(int i=1;i&lt;=15;i++) r7[i]=r7[i-1]*7; for(int i=1;i&lt;=19;i++) r10[i]=r10[i-1]*10; int n;ll a,b;scanf("%d%lld%lld",&amp;n,&amp;a,&amp;b); cnt=0; for(int i=0;i&lt;=35;i++) for(int j=0;j&lt;=25;j++) for(int x=0;x&lt;=18;x++) for(int y=0;y&lt;=15;y++) &#123; ll k=r2[i]*r3[j]*r5[x]*r7[y]; if(0&lt;k and k&lt;=ll(n)) g[++cnt]=k; else break;//剪枝 &#125; sort(g+1,g+1+cnt);//有序性 f[1][1]=1; for(int i=1;i&lt;=19;i++) &#123; for(int k=1;k&lt;=cnt;k++) &#123; if(f[i-1][k]==0) continue;//剪枝 for(int j=1;j&lt;=9;j++) &#123; ll ss=ll(g[k])*ll(j);if(ss&gt;ll(n)) break;//剪枝 int pos=lower_bound(g+1,g+1+cnt,int(ss))-g;//其实只是懒得打二分查找 f[i][pos]+=f[i-1][k]; &#125; &#125; &#125; //[a,b) //[a,b-1] printf("%lld",dp(b-1,n)-dp(a-1,n));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1833】【Luogu2602】数字计数]]></title>
    <url>%2Fposts%2F9f3.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2010 Day1Bzoj1833Luogu2602 题目【题目大意】给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。【输入格式】输入文件中仅包含一行两个整数a、b，含义如上所述。【输出格式】输出文件中包含一行10个整数，分别表示0-9在[a,b]中出现了多少次。【限定条件】30%的数据中，a&lt;=b&lt;=10^6；100%的数据中，a&lt;=b&lt;=10^12。【输入样例】1 99【输出样例】9 20 20 20 20 20 20 20 20 20【样例解释】无 刷题记录1h 分析请先思考后再展开 暴力好像30吧虽然数位dp的特征还是很明显的感觉这题还是挺难的，特别不好想当然核心思想依然是忽略前导零来预处理dp，最后分类讨论得出结果。f[i]表示0~10^{i-1}的出现次数（不忽略前导零，所以都一样） 好像计算“包含i”的数字量会更难？总而言之，这道题理解容易，写出来难，很多细节所以最好看完题解，打完一次后全部删掉再打一次哦 代码请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************ll oct[15];ll f[15];ll ans[10];//*******************实现*******************int num[15],ln;void dp(ll x,int fg)&#123; ll ret=x;ln=0; while(x&gt;0) num[++ln]=x%10,x/=10; //总位数&lt;m for(int i=1;i&lt;=ln-1;i++)//总位数 for(int j=0;j&lt;=9;j++)//首位 ans[j]+=(f[i-1]*9+(j&gt;0)*oct[i-1])*fg; //0特殊处理，因为不能放在首位 //总位数=m，逐个解决 for(int i=ln;i&gt;=1;i--) &#123; ret-=num[i]*oct[i-1]; //当前最高位不是上限，自己的数量 for(int j=(i==ln);j&lt;=num[i]-1;j++) ans[j]+=oct[i-1]*fg;//仅在首位 //当前最高位不是上限，后面的数量 for(int j=0;j&lt;=9;j++) ans[j]+=( (num[i]-(i==ln))*f[i-1] )*fg;//0(1)~num[i]-1 //当前最高位是上限，即剩余部分 ans[num[i]]+=(ret+1)*fg;//0~ret &#125;&#125;//*******************主函数*******************int main()&#123; memset(f,0,sizeof(f)); oct[0]=1; for(int i=1;i&lt;=13;i++) &#123; f[i]=oct[i-1]+f[i-1]*10;//首位+非首位 oct[i]=oct[i-1]*10; &#125; ll a,b;scanf("%lld%lld",&amp;a,&amp;b); dp(b,1);dp(a-1,-1); for(int i=0;i&lt;=9;i++) printf("%lld ",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1026】【Luogu2657】windy数]]></title>
    <url>%2Fposts%2F4670.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2009 Day1Bzoj1026Luogu2657 题目【题目大意】windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？【输入格式】包含两个整数，A B。【输出格式】一个整数【限定条件】1&lt;=A&lt;=B&lt;=2000000000【输入样例】25 50【输出样例】20【样例解释】无 刷题记录20min1AC 分析数位dp入门题分类讨论即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************//*******************全局定义*******************int c[11],ln;int f[11][10];//*******************实现*******************int dp()&#123; int ans=0; for(int i=1;i&lt;=ln-1;i++)//首位0 for(int j=1;j&lt;=9;j++)//非首位 ans+=f[i][j]; for(int i=1;i&lt;=c[ln]-1;i++) ans+=f[ln][i];//首位1 for(int i=ln-1;i&gt;=1;i--)//首位2的次位 &#123; for(int j=0;j&lt;=c[i]-1;j++) &#123; if(myabs(c[i+1]-j)&gt;=2) ans+=f[i][j]; &#125; if(myabs(c[i+1]-c[i])&lt;2) break;//剪枝，后面都是0 if(i==1) ans++;//b &#125; return ans;&#125;int solve(int x)&#123; ln=0; while(x&gt;0) &#123; c[++ln]=x%10; x/=10; &#125; return dp();&#125;//*******************主函数*******************int main()&#123; memset(f,0,sizeof(f)); int a,b;scanf("%d%d",&amp;a,&amp;b); for(int i=0;i&lt;=9;i++) f[1][i]=1; for(int i=2;i&lt;=10;i++) for(int x=0;x&lt;=9;x++) for(int y=0;y&lt;=9;y++) if(myabs(x-y)&gt;=2) f[i][x]+=f[i-1][y]; printf("%d",solve(b)-solve(a-1));&#125; UP 2018.8.28:写了个记忆化搜索的版本好写好理解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int MAX_N=30; const int INF=0x3f3f3f3f; int myabs(int x) &#123;return x&gt;0?x:-x;&#125; int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; int f[15][10]; bool v[15][10]; int num[15]; int calc(int ln,int lst,bool prezero,bool mask) &#123; if(ln==0) return 1; if(!mask and !prezero and v[ln][lst]) return f[ln][lst]; int tot=0,mx=mask?num[ln]:9; for(int now=0;now&lt;=mx;now++) if(prezero or myabs(lst-now)&gt;=2) tot+=calc(ln-1,now,prezero and now==0,mask and now==mx); if(!mask and !prezero) v[ln][lst]=1,f[ln][lst]=tot; return tot; &#125; int solve(int x) &#123; int n=0;while(x&gt;0) num[++n]=x%10,x/=10; return calc(n,0,1,1); &#125; void main() &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); printf("%d",solve(b)-solve(a-1)); &#125;&#125;;int main()&#123; mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1087】【Luogu1896】互不侵犯]]></title>
    <url>%2Fposts%2Ff44c.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2005Bzoj1087Luogu1896 题目【题目大意】在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。【输入格式】只有一行，包含两个数N，K【输出格式】方案数【限定条件】1&lt;=N&lt;=9,0&lt;=K&lt;=N*N【输入样例】3 2【输出样例】16【样例解释】无 刷题记录1h记得开long long 分析状态dp，虽然看起来打表也可以拿不少分？压缩每一行的状态，合法性：(s&amp;(s&gt;&gt;1))==0行转移合法性：(s1&amp;(s2&gt;&gt;1))==0 and (s1&amp;(s2&lt;&lt;1))==0 and (s1&amp;s2)==0 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************ll f[10][1000][100];//debugint state[1000],stc[1000];//*******************实现*******************int calc(int s)&#123; int t=0; while(s&gt;0) &#123; if( (s&amp;1)==1 ) t++; s=s&gt;&gt;1; &#125; return t;&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); int st=0; for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++) if( (i&amp;(i&lt;&lt;1))==0 ) &#123; state[++st]=i; stc[st]=calc(i); f[1][i][stc[st]]=1; &#125; for(int i=2;i&lt;=n;i++)//行数 for(int j1=1;j1&lt;=st;j1++)//前状态 for(int j2=1;j2&lt;=st;j2++)//后状态 &#123; int s1=state[j1],s2=state[j2]; if( (s2&amp;s1)==0 and (s2&amp;(s1&lt;&lt;1))==0 and (s2&amp;(s1&gt;&gt;1))==0 )//转移合法性 &#123; int k1=stc[j1],k2=stc[j2]; for(int b=k1;b+k2&lt;=k;b++)//前棋子总数 f[i][s2][b+k2]+=f[i-1][s1][b]; &#125; &#125; ll ans=0; for(int i=1;i&lt;=st;i++) ans+=f[n][state[i]][k]; printf(BIGN,ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1911】【Luogu3628】特别行动队]]></title>
    <url>%2Fposts%2F8530.html</url>
    <content type="text"><![CDATA[来源和评测点APIO2010Bzoj1911Luogu3628 题目【题目大意】【输入格式】【输出格式】【限定条件】【输入样例】4-1 10 -202 2 3 4【输出样例】9【样例解释】无 刷题记录1h1AC 分析不等式一定要注意负数的时候要变号！ 1.化简dp公式f[i]=f[j]+a×sqr(sum[i]-sum[j])+b×(sum[i]-sum[j])+c 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求大，所以f[j1]+a×sqr(sum[i]-sum[j1])+b×(sum[i]-sum[j1])&lt;=f[j2]+a×sqr(sum[i]-sum[j2])+b×(sum[i]-sum[j2])——-①现在要证明对于t(t&gt;i)，j2同样优于j1即证明f[j1]+a×sqr(sum[t]-sum[j1])+b×(sum[t]-sum[j1])&lt;=f[j2]+a×sqr(sum[t]-sum[j2])+b×(sum[t]-sum[j2])——-① 为了从①证明②，两式取差（注意a&lt;0）即 sqr(sum[t]-sum[j1])-sqr(sum[i]-sum[j1])&gt;=sqr(sum[t]-sum[j2])-sqr(sum[i]-sum[j2])即 -2×sum[t]×sum[j1]-2×sum[i]×sum[j1]&gt;=-2×sum[t]×sum[j1]-2×sum[i]×sum[j1]即 (sum[i]+sum[t])×sum[j1]&lt;=(sum[i]+sum[t])×sum[j2]即 sum[j1]&lt;=sum[j2]这是显而易见的，故②得证 所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j1]-2a×sum[i]×sum[j1]+a×sqr(sum[j1])-b×sum[j1]&lt;=f[j2]-2a×sum[i]×sum[j2]+a×sqr(sum[j2])-b×sum[j2]f[j1]-f[j2]+a×sqr(sum[j1])-b×sum[j1]-a×sqr(sum[j2])+b×sum[j2]&lt;=2×a×sum[i]×(sum[j1]-sum[j2])(f[j1]-f[j2])+a×sqr(sum[j1])-a×sqr(sum[j2])-b×sum[j1]+b×sum[j2]&lt;=2×a×sum[i]×(sum[j1]-sum[j2])((f[j1]-f[j2])+a×sqr(sum[j1])-a×sqr(sum[j2])-b×sum[j1]+b×sum[j2]) / (sum[j1]-sum[j2]) &gt;= 2×a×sum[i]满足则j2更优 那么把状态变成点( sum[j],f[j]+a×sqr(sum[j])-b×sum[j] ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将2×a×sum[i]理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;double mysqr(double x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=1000010;const int INF=0x3f3f3f3f;const double eps=1e-7;//*******************全局定义*******************int n;double a,b,c;double sum[MAXN];double f[MAXN];//*******************实现*******************double X(int x)&#123; return 2.0*a*sum[x];&#125;double Y(int x)&#123; return f[x]+a*mysqr(sum[x])-b*sum[x];&#125;double slop(int x,int y)&#123; return ( Y(x)-Y(y) )/( X(x)-X(y) );&#125;int g[MAXN];void solve()&#123; int tou=1,wei=1; for(int i=1;i&lt;=n;i++) &#123; while(tou&lt;wei and slop(g[tou],g[tou+1])&lt;=sum[i]) tou++; int j=g[tou]; f[i]=f[j]+a*mysqr(sum[i]-sum[j])+b*(sum[i]-sum[j])+c; while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%lf%lf%lf",&amp;n,&amp;a,&amp;b,&amp;c); for(int i=1;i&lt;=n;i++) &#123; double t;scanf("%lf",&amp;t); sum[i]=sum[i-1]+t; &#125; solve(); printf("%.0lf",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1835】【Luogu2605】基站选址]]></title>
    <url>%2Fposts%2Fedb5.html</url>
    <content type="text"><![CDATA[来源和评测点ZJOI2010 Day1Bzoj1835Luogu2605 题目【题目大意】有N个村庄坐落在一条直线上，第i(i&gt;1)个村庄距离第1个村庄的距离为Di。需要在这些村庄中建立不超过K个通讯基站，在第i个村庄建立基站的费用为Ci。如果在距离第i个村庄不超过Si的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第i个村庄没有被覆盖，则需要向他们补偿，费用为Wi。现在的问题是，选择基站的位置，使得总费用最小。【输入格式】第一行包含两个整数N,K，含义如上所述。第二行包含N-1个整数，分别表示D2,D3,…,DN ，这N-1个数是递增的。第三行包含N个整数，表示C1,C2,…CN。第四行包含N个整数，表示S1,S2,…,SN。第五行包含N个整数，表示W1,W2,…,WN。【限定条件】40%的数据中，N&lt;=500；100%的数据中，K&lt;=N，K&lt;=100，N&lt;=20000，Wi&lt;=10000，Ci&lt;=10000Di&lt;=1000000000，Si&lt;=1000000000【输出格式】仅一个整数，表示最小的总费用。【输入样例】3 21 22 3 21 1 010 20 30【输出样例】4【样例解释】无 刷题记录2h1AC 分析不得不说，这道题的思路灰常神 F[m][i]表示已经放置了m个基站，第m个基站放置在第i个村庄第i个村庄及之前的村庄的总最少花费(包括建立基站的花费和赔偿的花费),转移的时候,F[m][i]=min(F[m-1][j]+cost(j,i))+c[i]cost(j,i)表示在点j和点i各建立一个基站，j和i之间不建立基站时，j和i之间需要的总赔偿。 省空间首选vector，用于存储每个点被哪些点依赖，用于更新外层枚举m，然后每次循环才重构，避免后效性 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000;const int INF=0x3f3f3f3f;//*******************全局定义*******************int d[MAXN],c[MAXN],s[MAXN],w[MAXN];int st[MAXN],ed[MAXN];int f[MAXN];vector&lt;int&gt; fd[MAXN];//快速查找，省空间首选//*******************线段树*******************struct nod&#123; int l,r; int lc,rc; int mi,lz;&#125;m[2*MAXN];int cnt;int build(int l,int r)&#123; int t=++cnt; m[t].l=l;m[t].r=r;m[t].lz=0; if(l==r) m[t].mi=f[l];//初始cost=0 else &#123; int mid=(l+r)&gt;&gt;1; m[t].lc=build(l,mid); m[t].rc=build(mid+1,r); m[t].mi=mymin(m[m[t].lc].mi,m[m[t].rc].mi); &#125; return t;&#125;void update(int x)&#123; if(m[x].lz==0) return; int lc=m[x].lc,rc=m[x].rc; m[lc].mi+=m[x].lz;m[lc].lz+=m[x].lz; m[rc].mi+=m[x].lz;m[rc].lz+=m[x].lz; m[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(l&gt;r) return;//debug if(m[x].l==l and m[x].r==r) &#123; m[x].mi+=c; m[x].lz+=c; return; &#125; update(x); int mid=(m[x].l+m[x].r)/2,lc=m[x].lc,rc=m[x].rc; if(r&lt;=mid) change(lc,l,r,c); else if(l&gt;mid) change(rc,l,r,c); else change(lc,l,mid,c),change(rc,mid+1,r,c); m[x].mi=mymin(m[m[x].lc].mi,m[m[x].rc].mi);//debug&#125;int ask(int x,int l,int r)&#123; if(l&gt;r) return 0;//debug if(m[x].l==l and m[x].r==r) return m[x].mi; update(x); int mid=(m[x].l+m[x].r)/2,lc=m[x].lc,rc=m[x].rc; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); return mymin(ask(lc,l,mid),ask(rc,mid+1,r)); &#125;//*******************实现*******************int n,k;void dp()&#123; int tmp=0; for(int i=1;i&lt;=n;i++)//prepare &#123; f[i]=tmp+c[i]; for(int j=0;j&lt;fd[i].size();j++) tmp+=w[fd[i][j]]; //现在刚刚好，那么以后就成了负担 &#125; int ans=f[n]; for(int i=2;i&lt;=k;i++) &#123; cnt=0;build(1,n); for(int i=1;i&lt;=n;i++) &#123; f[i]=ask(1,1,i-1)+c[i];//最优继承 for(int k=0;k&lt;fd[i].size();k++) &#123; int x=fd[i][k]; change(1,1,st[x]-1,w[x]); //现在刚刚好，那么以后就成了负担 &#125; &#125; ans=mymin(ans,f[n]); &#125; printf("%d",ans);&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=2;i&lt;=n;i++) scanf("%d",&amp;d[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;s[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); n++;k++;//此点必选，用于统计答案 d[n]=INF;w[n]=INF;c[n]=0; for(int i=1;i&lt;=n;i++) &#123; int l=lower_bound(d+1,d+1+n,d[i]-s[i])-d; int r=lower_bound(d+1,d+1+n,d[i]+s[i])-d; if(d[r]&gt;d[i]+s[i]) r--; st[i]=l;ed[i]=r; fd[ed[i]].push_back(i); &#125; dp();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>线段树</tag>
        <tag>难度3</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1597】【Luogu1010】土地购买]]></title>
    <url>%2Fposts%2Fc717.html</url>
    <content type="text"><![CDATA[来源和评测点Usaco2008 Mar GoldBzoj1597LuogucCaioj1140 题目【题目大意】有N块长方形的土地，每块土地的价格是它的面积，但FJ可以同时购买多块土地。这些土地的价格是它们最大的长乘以它们最大的宽, 但是土地的长宽不能交换。如果FJ买一块3×5的地和一块5×3的地，则他需要付5×5=25。FJ希望买下所有的土地，但是他发现分组来买这些土地可以节省经费。他需要你帮助他找到最小的经费。【输入格式】第1行一个整数N。下来N行。第i+1行包含两个数，分别为第i块土地的长和宽。【限定条件】(1 &lt;= N &lt;= 50,000每块土地的长宽满足1&lt;=宽&lt;=1,000,000;1&lt;=长&lt;=1,000,000)【输出格式】求最小的可行费用。【输入样例】4100 115 1520 51 100【输出样例】500【样例解释】FJ分3组买这些土地:第一组:100×1,第二组1×100,第三组20×5 和 15×15。每组的价格分别为100,100,300, 总共500 刷题记录30min 分析灰常妙的一点：使用排序进行除杂（被完全覆盖的土地可以被忽略）神奇的一幕出现了，可以实现长递增，宽递减（主要是题目特性）于是就可以瞬间获得区间打包的费用！ 想通这个以后接下来就甚至比上一题还简单了部分省略 1.化简dp公式a[i]=长 b[i]=宽f[i]=min(f[j]+a[i]*b[j+1]) 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求小，所以假设f[j2]+a[i]*b[j2+1]&lt;=f[j1]+a[i]*b[j1+1]——————-①是否f[j2]+a[t]*b[j2+1]&lt;=f[j1]+a[t]*b[j1+1]——————-②为了从①证明②，两式取差得证所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j2]+a[i]*b[j2+1]&lt;=f[j1]+a[i]*b[j1+1](f[j2]-f[j1])/(b[j1+1]-b[j2+1])&lt;=a[i]满足则j2更优 那么把状态变成点( b[j],f[j] ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将a[]理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=51000;//*******************全局定义*******************struct nod&#123; double a,b;&#125;p[MAXN];bool cmp(nod a,nod b)&#123; return (a.a&lt;b.a) or (a.a==b.a and a.b&lt;b.b);&#125;double f[MAXN];//*******************实现*******************double X(int x)&#123; return p[x].b;&#125;double Y(int x)&#123; return f[x];&#125;double slop(int x,int y)&#123; return ( Y(y)-Y(x) )/( X(x+1)-X(y+1) );&#125;int tp;int g[MAXN];void solve()&#123; int tou=1,wei=1; for(int i=1;i&lt;=tp;i++) &#123; while(tou&lt;wei and slop(g[tou+1],g[tou])&lt;=p[i].a) tou++; int j=g[tou]; f[i]=f[j]+p[i].a*p[j+1].b; while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;=slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;p[i].a,&amp;p[i].b); sort(p+1,p+1+n,cmp); tp=1; for(int i=2;i&lt;=n;i++) &#123; while(tp&gt;0 and p[tp].b&lt;=p[i].b) tp--; p[++tp]=p[i]; &#125; solve(); printf("%.0lf",f[tp]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>斜率优化</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1010】【Luogu3195】玩具装箱]]></title>
    <url>%2Fposts%2Fdae0.html</url>
    <content type="text"><![CDATA[来源和评测点HNOI2008Bzoj1010Luogu3195Caioj1138 题目【题目大意】P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci。为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.【输入格式】第一行输入两个整数N，L.接下来N行输入Ci.【限定条件】1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7【输出格式】输出最小费用【输入样例】5 434214【输出样例】1【样例解释】无 刷题记录1h 分析1.化简dp公式sum[i]=sum[i-1]+c[i]f[i]=选择物品i后1~i最小花费f[i]=f[j]+sqr(sum[i]-sum[j]+i-(j+1)-l)f[i]=f[j]+sqr(sum[i]+i-sum[j]-j-1-l)设s[i]=sum[i]+i,L=l+1f[i]=f[j]+sqr(s[i]-s[j]-L) 2.证明决策单调性假设j1&lt;j2&lt;i已知对于i，j2优于j1，本题追求小，所以f[j2]+sqr(s[i]-s[j2]-L)&lt;f[j1]+sqr(s[i]-s[j1]-L)——————-①现在要证明对于t(t&gt;i)，j2同样优于j1，易得s[t]=s[i]+v即证明f[j2]+sqr(s[i]-s[j2]-L+v)&lt;f[j1]+sqr(s[i]-s[j1]-L+v)———② 为了从①证明②，两式取差证明 2*(s[i]-s[j2]-L)*v+v*v&lt;=2*(s[i]-s[j1]-L)*v+v*v 即可即 -2*s[j2]*v&lt;=-2*s[j1]*v即 s[j2]&gt;=s[j1]这是显而易见的，故②得证 所以这次如果选了j2，j1将没有任何用处，可淘汰 3.确定比较状态优劣的斜率方程只能用于相邻的状态比较斜率=(y1-y2)/(x1-x2) f[j2]+sqr(s[i]-s[j2]-L)&lt;f[j1]+sqr(s[i]-s[j1]-L)[ (f[j2]+s[j2]*s[j2])-(f[j1]+s[j1]*s[j1]) ]/[ s[j2]-s[j1] ] &lt; 2*(s[i]-L)满足则j2更优 那么把状态变成点( s[j],f[j]+sqr(s[j]) ) 4.单调队列维护满足: 相邻斜率不递减故形状为一个向下的凸壳（形如丿字） 一、去头（两者比较）将2*(s[i]-L)理解为i给出的标杆，假如“头与头后一个斜率”小于标杆，意味着后一个更优秀，将头剔除 二、继承从当前最优秀的头继承 三、铺垫与维护（三者比较）将当前状态放入队列，并两两比较删除无用状态，保证相邻斜率不递减删除正确性证明：对于a和b的斜率x&lt;=b和c的斜率y被删除的末尾，在（末尾前一个，末尾，当前状态）中必定不是最优状态，因为斜率必定不如他们哪怕是这种极端情况： ○ ○○斜率越大，则越靠近标杆，也就意味着后面这个越优秀（虽然在小于标杆的时候依然是前面的优秀，但我这里的意思是同样的前者下，后者1会比后者2更优秀）斜率为0意味着同样优秀，那么当然是后面的更好了总而言之，斜率越小越优秀 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=51000;//*******************全局定义*******************int n;double L;double sum[MAXN],s[MAXN];double f[MAXN];//*******************实现*******************double X(int x)&#123; return s[x];&#125;double Y(int x)&#123; return f[x]+mysqr(s[x]);&#125;double slop(int x,int y)&#123; return ( Y(x)-Y(y) )/( X(x)-X(y) );&#125;int g[MAXN];void solve()&#123; int tou=1,wei=1;g[1]=0;f[0]=0; for(int i=1;i&lt;=n;i++) &#123; while(tou&lt;wei and slop(g[tou],g[tou+1])&lt;=2*(s[i]-L)) tou++; int j=g[tou];f[i]=f[j]+mysqr(s[i]-s[j]-L); while(tou&lt;wei and slop(g[wei-1],g[wei])&gt;slop(g[wei],i)) wei--; g[++wei]=i; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%lf",&amp;n,&amp;L);L+=1.0; for(int i=1;i&lt;=n;i++) &#123; double t;scanf("%lf",&amp;t); sum[i]=sum[i-1]+t; s[i]=sum[i]+i; &#125; solve(); printf("%.0lf",f[n]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>斜率优化</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2823】Sliding Window]]></title>
    <url>%2Fposts%2Fe1c7.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2006.04.28, IkkiPoj2823Caioj1172 题目【题目大意】给定一个n个数的数列，从左至右输出每个长度为m的数列段内的最大数何最小数。【输入格式】第一行两个整数n和m，下来给出n个整数。【限定条件】1&lt;=n&lt;=200000,m&lt;=n【输出格式】第一行表示每连续m个数的最大值。第二行表示每连续m个数的最小值。【输入样例】8 31 3 -1 -3 5 3 6 7【输出样例】-1 -3 -3 -3 3 33 3 5 5 6 7【样例解释】无 刷题记录30min5WA1AC 分析裸题 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll; //*******************全局常量*******************const int MAXN=1100000;//*******************全局定义*******************int n,k;int a[MAXN];struct nod&#123; int s,p;&#125;g1[MAXN],g2[MAXN];//*******************实现*******************int f1[MAXN],f2[MAXN];void dp()&#123; int tou1=1,wei1=0; int tou2=1,wei2=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); while(tou1&lt;=wei1 and g1[wei1].s&gt;=t) wei1--; while(tou2&lt;=wei2 and g2[wei2].s&lt;=t) wei2--; g1[++wei1].s=t;g1[wei1].p=i; g2[++wei2].s=t;g2[wei2].p=i; while(tou1&lt;=wei1 and g1[tou1].p+k-1&lt;i) tou1++; while(tou2&lt;=wei2 and g2[tou2].p+k-1&lt;i) tou2++; if(i&gt;=k) &#123; f1[i]=g1[tou1].s; f2[i]=g2[tou2].s; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;k); dp(); for(int i=k;i&lt;=n;i++) printf("%d ",f1[i]);printf("\n"); for(int i=k;i&lt;=n;i++) printf("%d ",f2[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1079】【Luogu2476】着色方案]]></title>
    <url>%2Fposts%2F968.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2008 Day2Bzoj1079Luogu2476 题目【题目大意】有n个木块排成一行，从左到右依次编号为1~n。你有k种颜色的油漆，其中第i种颜色的油漆足够涂ci个木块。所有油漆刚好足够涂满所有木块，即c1+c2+…+ck=n。相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。【输入格式】第一行为一个正整数k，第二行包含k个整数c1, c2, … , ck。【限定条件】50%的数据满足：1&lt;=k&lt;=5,1&lt;=ci&lt;=3100%的数据满足：1&lt;=k&lt;=15,1&lt;=ci&lt;=5【输出格式】输出一个整数，即方案总数模1,000,000,007的结果。【输入样例】101 1 2 2 3 3 4 4 5 5【输出样例】85937576【样例解释】无 刷题记录2h 分析1不愧是十年前的题目，连暴力分都给50 代码11234567891011121314151617181920212223242526272829303132333435363738394041//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MOD=1000000007;//*******************全局定义*******************int a[76];int n,k;int c[20];//*******************实现*******************int ans=0;void dfs(int x)&#123; if(x&gt;n) &#123; ans=(ans+1)%MOD; return; &#125; for(int i=1;i&lt;=k;i++) &#123; if(a[x-1]==i or c[i]&lt;=0) continue; a[x]=i; c[i]--; dfs(x+1); c[i]++; &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) scanf("%d",&amp;c[i]),n+=c[i]; dfs(1); printf("%d",ans);&#125; 分析2不得不说这道题灰常好想设i是现在的颜色，从j颜色而来$$F[x][i]=\sum_{j=1}^{k} F[x-1][j] (i!=j)$$那么通常而言，上面的这个约束条件要转化为一个操作矩阵然后把F[x]变成一个矩阵，m[i][1]表示用颜色i的方案数那么$$ANS=\sum_{i=1}^{k} F[n].m[i][1]$$是不是找到窍门了？ 老规矩，F[].m[i][1]=A[][]*F[].m[j][1]所以A[i][j]，也就是说当j可以到i的时候，A[i][j]=1 那么A^t表示跳转了t次，长度为t+1，最后变成颜色j的方案量 我说的有没有道理？ 有个屁！第i种颜色的油漆足够涂ci个木块？？？？？我真的是做矩阵做疯了，居然还自以为找到了感觉……这种限制显然是矩阵乘法无法解决的事实证明省选题不能小瞧啊，连续两次了 重新写dp方程f[a][b][c][d][e][f][g][h][i][j][k][l][m][n][o]这是一个5^15的dp，显然是不可行的，空间、代码复杂度都过大那么观察题目的特性：既然只要求方案数，那么在不考虑“不相邻”的条件下，对于剩余t次的两种颜色其实是等效的，于是就从5^15变成了15^5：f[a][b][c][d][e]接下来考虑特殊条件其实也很简单：多开一维，记录这一段的前一个是什么类型的颜色当前一个是b，那么现在它变成了a，用a的时候-1即可然后可以理解为从前往后确定 代码21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll; //*******************全局常量*******************const int MOD=1000000007;//*******************全局定义*******************ll f[6][16][16][16][16][16];bool bk[6][16][16][16][16][16];//*******************实现*******************ll dp(int first,int a,int b,int c,int d,int e)&#123; if(bk[first][a][b][c][d][e]) return f[first][a][b][c][d][e]; if(a+b+c+d+e==0) return 1; ll t=0; if(a&gt;0) t+=(a-(first==2))*dp(1,a-1,b,c,d,e)%MOD; if(b&gt;0) t+=(b-(first==3))*dp(2,a+1,b-1,c,d,e)%MOD; if(c&gt;0) t+=(c-(first==4))*dp(3,a,b+1,c-1,d,e)%MOD; if(d&gt;0) t+=(d-(first==5))*dp(4,a,b,c+1,d-1,e)%MOD; if(e&gt;0) t+=e*dp(5,a,b,c,d+1,e-1)%MOD; bk[first][a][b][c][d][e]=1; return f[first][a][b][c][d][e]=t%MOD;&#125;//*******************主函数*******************int s[6];int main()&#123; memset(bk,0,sizeof(bk)); int k;scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) &#123; int t; scanf("%d",&amp;t); s[t]++; &#125; printf(BIGN,dp(0,s[1],s[2],s[3],s[4],s[5]));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1875】【Luogu2151】HH去散步]]></title>
    <url>%2Fposts%2F3469.html</url>
    <content type="text"><![CDATA[来源和评测点SDOI2009 Day1Bzoj1875Luogu2151 题目【题目大意】HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间内，走过一定的距离。但是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多少种散步的方法。现在给你学校的地图（假设每条路的长度都是一样的都是1），问长度为t，从给定地点A走到给定地点B共有多少条符合条件的路径【输入格式】第一行：五个整数N，M，t，A，B。N表示学校里的路口的个数M表示学校里的 路的条数t表示HH想要散步的距离A表示散步的出发点B则表示散步的终点。接下来M行每行一组Ai，Bi，表示从路口Ai到路口Bi有一条路。数据保证Ai ！= Bi,但不保证任意两个路口之间至多只有一条路相连接。路口编号从0到N -1。同一行内所有数据均由一个空格隔开，行首行尾没有多余空格。没有多余空行。答案模45989。【限定条件】N≤20，M≤60，t≤2^30，0≤A,B【输出格式】一行，表示答案。【输入样例】4 5 3 0 00 10 20 32 13 2【输出样例】4【样例解释】无 刷题记录30min3WA1AC 分析不能立刻走回头路!没理解这句话还以为是煞笔题…… 首先，考虑dp方程，用边去推导（主要是因为不能立刻走回头路，而且有重边，这都主要跟边有关系）$f[i][k]=\sum f[j][k2] (k:j=&gt;i,k!=oth[k2])$那么因为t灰常大，但是这个【上一条边】是与以后决策无关的所以引入矩阵乘法，利用快速幂加速 设起始边i，终止边j构造t=1的初始矩阵A当$y[i]=x[j]$,i连接j,且$i!=oth[j]$则$A[j][i]=1$ 为什么是反的？考虑矩阵乘法的定义，以及我们通常用的列向量：$A[][]\times st[i][1]=ed[j][1]$发现必须是$A[j][i]$ 这个判断矩乘的方法是我自己想的，好像网上也没人这样用。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;//*******************全局常量*******************const int MAXN=150;const int MOD=45989;//*******************全局定义*******************struct Martix&#123; int row,col; int m[MAXN][MAXN]; Martix(int r=0,int c=0) &#123; row=r;col=c; memset(m,0,sizeof(m)); &#125;&#125;;//*******************实现*******************Martix one(int row)&#123; Martix ans(row,row); for(int i=1;i&lt;=row;i++) ans.m[i][i]=1; return ans;&#125;Martix mul(Martix a,Martix b)&#123; Martix c(a.row,b.col); for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) for(int k=1;k&lt;=a.col;k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%MOD)%MOD; return c;&#125;Martix power(Martix a,int e)&#123; Martix ans=one(a.row); while(e&gt;0) &#123; if(e&amp;1) ans=mul(ans,a); a=mul(a,a);e&gt;&gt;=1; &#125; return ans;&#125;struct Edge&#123; int x,y,oth;&#125;e[MAXN];int ln=0;void ins(int x,int y)&#123; e[++ln]=(Edge)&#123;x,y,ln+1&#125;; e[++ln]=(Edge)&#123;y,x,ln-1&#125;;&#125;//*******************主函数*******************int main()&#123; int n,m,t,st,ed;scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;t,&amp;st,&amp;ed); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; Martix stm(ln,1);for(int k=1;k&lt;=ln;k++) stm.m[k][1]=(e[k].x==st); Martix A(ln,ln); for(int k1=1;k1&lt;=ln;k1++) for(int k2=1;k2&lt;=ln;k2++) A.m[k2][k1]=(e[k1].oth!=k2 and e[k1].y==e[k2].x); Martix edm=mul(power(A,t-1),stm); int ans=0; for(int k=1;k&lt;=ln;k++) if(e[k].y==ed) ans=(ans+edm.m[k][1])%MOD; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2330】【Luogu3275】糖果]]></title>
    <url>%2Fposts%2Fcc92.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2011 Day1Bzoj2330Luogu3275 题目【题目大意】幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。【输入格式】输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字X，A，B。如果X=1，表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2，表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3，表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4，表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5，表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果；【限定条件】N&lt;=100000,K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N【输出格式】输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。【输入样例】5 71 1 22 3 24 4 13 4 55 4 52 3 54 5 1【输出样例】11【样例解释】d[1]=d[2]d[3]&lt;d[2]d[4]&gt;d[1]d[4]&gt;=d[5]d[4]&lt;=d[5]d[3]&lt;d[5]d[5]&gt;d[1] 刷题记录1.5h吃了屎一样难受！居然输出的时候忘记打else了！ 分析具体跑最长路还是最短路，其实都没有问题下文以最长路为例 a=ba&gt;=b+0,ins(b,a,0)a&lt;=b+0,b&gt;=a+0,ins(a,b,0) aa,b&gt;=a+1,ins(a,b,1) a&gt;=ba&gt;=b+0,ins(b,a,0) a&gt;ba&gt;=b+1,ins(b,a,1) a&lt;=bb&gt;=a+0,ins(a,b,0)为了判断是否存在正环，不得不用spfa最后，我们找到了满足不等式组的一组解为了求出答案要求的最小，将最小值平移到1即可 up 2018.9.1其实有可能，数据强行卡spfa可以自己加上酸辣粉优化 正规做法是找题目性质，发现边权都是0或者1所以可以考虑直接判断是否存在正环（用tarjan，强连通内必须没有1边）没有的话，可以在缩点后的dag上直接拓扑来最短路 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct nod&#123; int hou; int ru,d; bool v; nod() &#123; hou=0; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************queue&lt;int&gt; lst;bool spfa(int st,int n)&#123; for(int i=1;i&lt;=n;i++)//debug &#123; p[i].v=1; p[i].ru=1; p[i].d=1; lst.push(i); &#125; while(!lst.empty()) &#123; int x=lst.front();lst.pop();p[x].v=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].d&lt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; lst.push(y); p[y].ru++; if(p[y].ru&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); bool bk=0; while(k--) &#123; int op,a,b;scanf("%d%d%d",&amp;op,&amp;a,&amp;b); if(op==1) ins(a,b,0),ins(b,a,0); if(op==2) &#123;ins(a,b,1);if(a==b) bk=1;&#125; if(op==3) ins(b,a,0); if(op==4) &#123;ins(b,a,1);if(a==b) bk=1;&#125; if(op==5) ins(a,b,0); &#125; if(bk or !spfa(0,n)) printf("-1"); else//debug &#123; long long all=0; for(int i=1;i&lt;=n;i++) all+=p[i].d; printf("%lld",all); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3683】Priest John's Busiest Day]]></title>
    <url>%2Fposts%2F632.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Founder Monthly Contest – 2008.08.31, Dagger and FacerPoj3683 题目【题目大意】John是小镇唯一的牧师，他希望参加n个婚礼，每个婚礼计划在Si~Ti举行婚礼。婚礼有个仪式必须要John参加，但他不能同时参加两个仪式。仪式时间是Si~Si+Di或者Ti-Di~Ti。请替John安排他的日程表题意强调：一个仪式8:30结束，另一个8:30开始，不算冲突【输入格式】第一行整数n(1≤n≤1000)接下来n行，表示Si,Ti和Di（Si&lt;=Ti，Di&lt;=Ti-Si）Si和Ti的格式是hh:mm【输出格式】如果无解，输出NO否则输出YES,并且接下来n行，每行表示他参加的仪式时间。要按照每个婚礼的输入的顺序输出！（因为这是spj嘛）本题有特判。【输入样例】208:00 09:00 3008:15 09:00 20【输出样例】YES08:00 08:3008:40 09:00 刷题记录2h1AC做题 做得好慢啊本来抱着MLE的想法提交的，结果很小嘛~ 分析第一次做要输出方案的2-SAT，感觉好繁琐就是跟着伟大的神教程做得：csdn-jarjingx 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************//*******************全局定义*******************int cnt;//*******************强连通*******************struct nod&#123; int dfn,low; int belg; bool v; int hou; int st,ed;&#125;p[2100];struct edge&#123; int x,y,g;&#125;e[4100000];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int sta[2100],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************实现定义*******************int hread(void)&#123; int h,m; scanf("%d:%d",&amp;h,&amp;m); return h*60+m;&#125;void hwrite(int tm)&#123; int a=tm/60; if(a&lt;10) printf("0%d:",a); else printf("%d:",a); int b=tm%60; if(b&lt;10) printf("0%d ",b); else printf("%d ",b);&#125;struct nod2&#123; int hou; int ru; int oth; int tag;&#125;pt[2100];struct edge2&#123; int y,g;&#125;eg[4100000];int ln2;void ins2(int x,int y)&#123; ln2++; eg[ln2].y=y; eg[ln2].g=pt[x].hou; pt[x].hou=ln2;&#125;//*******************拓扑*******************int fs,ss[2100];void topsort(int x)&#123; ss[++fs]=x;pt[x].ru=-1; for(int k=pt[x].hou;k&gt;0;k=eg[k].g) &#123; int y=eg[k].y; pt[y].ru--; if(pt[y].ru==0) topsort(y); &#125;&#125;//*******************实现*******************bool okay(int x,int y)&#123; if(p[x].st&gt;p[y].st) swap(x,y); return p[x].ed&lt;=p[y].st;&#125;int getoth(int x) &#123;return x&amp;1?x+1:x-1;&#125;void dfs(int x)&#123; pt[x].tag=-1; for(int k=pt[x].hou;k&gt;0;k=eg[k].g) &#123; int y=eg[k].y; if(pt[y].tag==0) dfs(y); &#125;&#125;bool solve(int n)&#123; ln=cnt=top=id=0; for(int i=1;i&lt;=2*n;i++) &#123; p[i].dfn=0; p[i].v=0; p[i].hou=0; &#125; for(int i=1;i&lt;=2*n;i++) for(int j=i+1;j&lt;=2*n;j++) if(!okay(i,j)) &#123; ins(i,getoth(j)); ins(j,getoth(i)); &#125; for(int i=1;i&lt;=2*n;i++) if(p[i].dfn==0) tarjan(i); ln2=0; for(int i=1;i&lt;=cnt;i++) &#123; pt[i].hou=0; pt[i].ru=0; pt[i].tag=0; &#125; for(int i=1;i&lt;=n;i++) &#123; int fx=p[2*i-1].belg,fy=p[2*i].belg; if(fx==fy) return 0; else &#123; pt[fx].oth=fy; pt[fy].oth=fx; &#125; &#125; for(int i=1;i&lt;=ln;i++) &#123; int x=e[i].x,y=e[i].y; int fx=p[x].belg,fy=p[y].belg; if(fx!=fy) ins2(fy,fx),pt[fx].ru++;//反边 &#125; fs=0; for(int i=1;i&lt;=cnt;i++) if(pt[i].ru==0) topsort(i); for(int i=1;i&lt;=cnt;i++) &#123; int x=ss[i]; if(pt[x].tag==0) &#123; pt[x].tag=1; dfs(pt[x].oth); &#125; &#125; printf("YES\n"); for(int i=1;i&lt;=2*n;i++) if(pt[p[i].belg].tag==1) hwrite(p[i].st),hwrite(p[i].ed),printf("\n"); return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int s=hread(),t=hread(),d;scanf("%d",&amp;d); p[2*i-1].st=s;p[2*i-1].ed=s+d; p[2*i].st=t-d;p[2*i].ed=t; &#125; if(!solve(n)) printf("NO");&#125; other solution from lydUP 2018.9.6:具体方法参考更新后的2-sat教程]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度2</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3207】Panda's Trick]]></title>
    <url>%2Fposts%2F9ebb.html</url>
    <content type="text"><![CDATA[来源和评测点Poj3207 题目【题目大意】在一个圆上，有n个点（0~n-1），m条边，边可以在圆内或圆外（圆内即线段）保证每个点最多和一条边相连判断能否每条边不相交【输入格式】第一行n和m（n≤1000, m≤500）接下来m行，a和b表示连边【输出格式】如果不重合，输出panda is telling the truth…否则输出the evil panda is lying again【输入样例】4 20 13 2【输出样例】panda is telling the truth… 刷题记录20min 分析2-SAT显然：如果两条边在圆内相交，则在圆外也一定相交于是就产生了两种情况，并且会有互斥关系，套上模板即可对了，因为建图出来的是双向边，用并查集也是没毛病的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=1100000;//*******************全局定义*******************int cnt;struct nod&#123; int dfn,low; int belg; bool v; int hou;&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int st[MAXM],ed[MAXM];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); ln=id=top=cnt=0; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y);x++,y++; st[i]=mymin(x,y);ed[i]=mymax(x,y); &#125; for(int i=1;i&lt;=2*m;i++) &#123; p[i].dfn=0; p[i].hou=0; p[i].belg=0; p[i].v=0; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) if(st[i]&lt;st[j] and st[j]&lt;ed[i] and ed[i]&lt;ed[j]) &#123; ins(2*i,2*j-1); ins(2*j-1,2*i); ins(2*j,2*i-1); ins(2*i-1,2*j); &#125; for(int i=1;i&lt;=2*m;i++) if(p[i].dfn==0) tarjan(i); bool bk=0; for(int i=1;i&lt;=m;i++) if(p[2*i-1].belg==p[2*i].belg) bk=1; if(bk) printf("the evil panda is lying again"); else printf("panda is telling the truth...");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1405】聚会]]></title>
    <url>%2Fposts%2F46fd.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1405 题目【题目大意】n对夫妻参加一个聚会，每对夫妻只有1人可以列席。在2n个人中，某些人之间有矛盾,夫妻之间不会有矛盾。有矛盾的2个人不会同时出现在聚会上。问有没有可能会有n个人同时列席？【输入格式】第一行：一个正整数n(1&lt;=n&lt;=1000)，表示有n对夫妻被邀请第一行：一个正整数m(m&lt;(n-1)*(n-1))，表示有m对矛盾关系接下来的m行，每行四个正整数A1,A2,C1,C2。A1,A2分别表示夫妻的编号。C1,C2表示矛盾者是妻子还是丈夫，0表示妻子，1表示丈夫多组数据，当n=0时结束【输出格式】如果存在这种情况，输出YES；否则输出NO【输入样例】210 1 1 10【输出样例】YES 刷题记录20min1WA1AC 分析2-SAT裸题 代码12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1997】Planar]]></title>
    <url>%2Fposts%2Fc3c1.html</url>
    <content type="text"><![CDATA[来源和评测点Hnoi2010Bzoj1997 题目【题目大意】【输入格式】【输出格式】【输入样例】26 91 41 51 62 42 52 63 43 53 61 4 2 5 3 65 51 22 33 44 55 11 2 3 4 5【输出样例】NOYES 刷题记录30min2TLE(空间开小)2AC(有bug) 分析神奇的平面图定理：m&lt;=3*n+6（不然空间会爆的，其他就很简单啦）之前说过，如果两条边在圆内相交，则在圆外也一定相交那么哈密顿回路是可以拉成一个圆的 对了，因为建图出来的是双向边，用并查集也是没毛病的。 嗯这题除了空间上的问题，也算是独立完成了吧…… UP 2018.9.10:这里用到的公式可以前往oi之路的定理杂烩查看详细信息 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1300,MAXM=1500000;//*******************全局定义*******************int cnt;struct nod&#123; int dfn,low; int belg; bool v; int hou;&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y); if(p[y].v==1) p[x].low=mymin(p[x].low,p[y].low); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].v=0; p[t].belg=cnt; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int st[MAXM],ed[MAXM];int ptd[MAXN];bool solve(int n,int m)&#123; if(m&gt;3*n+6) return 1; memset(p,0,sizeof(p)); ln=id=top=cnt=0; for(int i=1;i&lt;=m;i++) &#123; st[i]=ptd[st[i]]; ed[i]=ptd[ed[i]]; if(st[i]&gt;ed[i]) swap(st[i],ed[i]); if( st[i]+1==ed[i] or (st[i]==n and ed[i]==1)) &#123; st[i]=st[m]; ed[i]=ed[m]; m--; i--; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=i+1;j&lt;=m;j++) &#123; if( (st[i]&lt;st[j] and st[j]&lt;ed[i] and ed[i]&lt;ed[j])or (st[j]&lt;st[i] and st[i]&lt;ed[j] and ed[j]&lt;ed[i]) ) &#123; ins(2*i,2*j-1); ins(2*j-1,2*i); ins(2*j,2*i-1); ins(2*i-1,2*j); &#125; &#125; &#125; for(int i=1;i&lt;=2*m;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=m;i++) if(p[2*i-1].belg==p[2*i].belg) return 1; return 0;&#125;int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;st[i],&amp;ed[i]); for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); ptd[t]=i; &#125; if(solve(n,m)) printf("NO\n"); else printf("YES\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF19E】【Bzoj4424】Fairy]]></title>
    <url>%2Fposts%2F59cc.html</url>
    <content type="text"><![CDATA[来源和评测点CF19EBzoj4424 题目【题目大意】给定n个点，m条边的无向图，可以从图中删除一条边，问删除哪些边可以使图变成一个二分图。（补充：只能是每次一条）【输入格式】第1行包含两个整数n，m。分别表示点数和边数。第2到m+1行每行两个数x，y表示有一条（x,y）的边。【输出格式】输出第一行一个整数，表示能删除的边的个数。接下来一行按照从小到大的顺序输出边的序号。【输入样例】4 41 21 32 43 4【输出样例】41 2 3 4 刷题记录3h 分析首先，确保理解题意无误后，各种画图探究二分图的性质发现所谓二分图，就是不能有奇数环 长姿势：对于一个图，可以考虑建立dfs序树，将边分为生成树边和返祖边（回边）从而对于环或者之类的东西一目了然（因为树是没有环的） 然后在这里：DaD3zZ它提到了单返祖边，但我并不觉得返祖边数量有任何影响所以他的意思应该是，程序设计的时候，因为是建立dfs序树，所以只能处理单返祖边？ 说说我的看法：1.如果没有奇数环，那么输出所有边，因为这样都可以符合要求2.1)必须删除的是奇数环的公共边，否则还会有奇数环剩余2.2)不能是任何一个偶环的部分，否则会产生新的奇数环引用几张图片，大家思考一下：呃外站图片，懒得下载下来了，如果哪天csdn炸了(其实几率不大)或者文章删除了，评论即可。 打上标记输出即可注意可能会有重边和负环，而且不一定连通。负环：看作奇数环即可重边：看作返祖边即可连通：没进入过的进入即可反正就是别太操心特殊情况，然后排除掉，要一视同仁~ 写下来详细说说怎么dp吧（开始涉及细节了，想独立思考的请跳过）先区分树边和返祖边，然后枚举返祖边判断环的奇偶性（有返祖边就有环）如果奇数环个数=0，直接输出全部然后结束程序。否则，如果是返祖边，如果奇数环=1，那么可以，否则显然就不是奇数环的公公共边了。然后计算每条树边被多少个奇数环包含，从而判断是否是公共边接下来用点来标记网上好像没人说，但想半天后忽然发现，接下来这个其实类似于树上差分！（解释一下，树上差分大概就是其他位置的树上前缀和不变）每个点上面的odd、ever分别表示它的父亲树边在多少个偶数、奇数环中回溯的时候再转移到边上，这样避免了处理双向边的繁琐，最后按顺序枚举输出。 最后的最后，补充一个降低代码复杂的方法，因为我们在建树的时候建立的是双向边，令ln=1，然后这样建边的时候同一条边的编号一个是奇数一个是偶数，可以用异或处理了，而且除以2后就合并了。 真的是最后了，因为是双向建边，可以向下的时候不能是（标记为不是返祖边），而是（标记为树边）应该挺好理解的~ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=1000010;//*******************全局定义*******************struct road&#123; int x,y; int odd,even;//奇、偶 bool sb;//树边&#125;rd[MAXN];struct nod&#123; int hou; int dep; int odd,even;//奇、偶&#125;p[MAXN];struct edge&#123; int y,g;&#125;e[MAXN*2];int ln=1;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************bool v[MAXN];void dfs1(int x,int dep)&#123; p[x].dep=dep;v[x]=1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(v[y]==0) &#123; dfs1(y,dep+1); rd[k/2].sb=1; &#125; &#125;&#125;void dfs2(int x)&#123; v[x]=1;//debug for(int k=p[x].hou;k&gt;0;k=e[k].g) if(rd[k/2].sb=1) &#123; int y=e[k].y; if(v[y]==1) continue;//debug dfs2(y); p[x].odd+=p[y].odd; p[x].even+=p[y].even;//树上前缀和 rd[k/2].odd=p[y].odd; rd[k/2].even=p[y].even; &#125;&#125;//*******************主函数*******************int ans[MAXN];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;rd[i].x,&amp;rd[i].y); rd[i].odd=rd[i].even=rd[i].sb=0; ins(rd[i].x,rd[i].y);ins(rd[i].y,rd[i].x); &#125; memset(v,0,sizeof(v)); for(int i=1;i&lt;=n;i++) if(v[i]==0) dfs1(i,1); int cnt=0;//奇数环个数 for(int i=1;i&lt;=m;i++) if(rd[i].sb==0) &#123; int x=rd[i].x,y=rd[i].y; if(p[x].dep&gt;p[y].dep) swap(x,y); if( (p[y].dep-p[x].dep)%2==1 ) p[x].even--,p[y].even++;//偶数环 else p[x].odd--,p[y].odd++,cnt++,rd[i].odd=1;//奇数环，特别处理一下返祖边 &#125; if(cnt==0) &#123; printf("%d\n",m); for(int i=1;i&lt;=m;i++) if(i&lt;m) printf("%d ",i); else printf("%d\n",i); return 0; &#125; memset(v,0,sizeof(v)); for(int i=1;i&lt;=n;i++) if(v[i]==0) dfs2(i); int ansn=0; for(int i=1;i&lt;=m;i++) &#123; if(rd[i].sb)//树边 &#123; if(rd[i].even==0 and rd[i].odd==cnt) ans[++ansn]=i; &#125; else//返祖边特判 &#123; if(rd[i].odd==cnt) ans[++ansn]=i; &#125; &#125; printf("%d\n",ansn); for(int i=1;i&lt;=ansn;i++) if(i&lt;ansn) printf("%d ",ans[i]); else printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj4520】K远点对]]></title>
    <url>%2Fposts%2F673d.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj4520 题目【题目大意】已知平面内N个点的坐标，求欧氏距离下的第K远点对。【输入格式】输入文件第一行为用空格隔开的两个整数N，K。接下来N行，每行两个整数X,Y，表示一个点的坐标。1&lt;=N&lt;=100000，1&lt;=K&lt;=100，K&lt;=N*(N−1)/2，0&lt;=X,Y&lt;2^31。【输出格式】出文件第一行为一个整数，表示第K远点对的距离的平方（一定是个整数）。【输入样例】10 50 00 11 01 12 02 11 20 23 03 1【输出样例】9 刷题记录20min 分析kdtree，k固定因为每个距离维护了两次，用2*k大小的小根堆维护，相当于维护了前k个值，并且堆顶正是第k个 长姿势：对于k确定的第k大，用一个堆维护会灰常方便 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ll;//严格来说这样才对ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=110000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; ll d[2];//自己 ll mi[2],mx[2];//管理区间 int son[2];//左右区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;ll getdis(int t,ll x,ll y)//估价最好情况&#123; return mymax(mysqr(p[t].mi[0]-x),mysqr(p[t].mx[0]-x))+ mymax(mysqr(p[t].mi[1]-y),mysqr(p[t].mx[1]-y));&#125;//*******************实现*******************int root;int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=d;nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(ll x,ll y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tmp=cmp(p[f],p[t]); if(p[f].son[tmp]==0) &#123; p[f].son[tmp]=t; break; &#125; f=p[f].son[tmp]; &#125; &#125;&#125;priority_queue&lt; ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q;void ask(int t,ll x,ll y)&#123; ll dis=mysqr(p[t].d[0]-x)+mysqr(p[t].d[1]-y); if(dis!=0 and dis&gt;q.top()) q.pop(),q.push(dis); int lc=p[t].son[0],rc=p[t].son[1]; ll f[2]; f[0]=(lc&gt;0)?getdis(lc,x,y):0; f[1]=(rc&gt;0)?getdis(rc,x,y):0; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&gt;q.top()) ask(p[t].son[tmp],x,y); if(f[1-tmp]&gt;q.top()) ask(p[t].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); while(q.size()&lt;2*k) q.push(0); for(int i=1;i&lt;=n;i++) ask(root,p[i].d[0],p[i].d[1]); printf("%lld",q.top());&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1941】Hide and Seek]]></title>
    <url>%2Fposts%2F87ed.html</url>
    <content type="text"><![CDATA[来源和评测点Sdoi2010Bzoj1941 题目【题目大意】小猪iPig在PKU刚上完了无聊的猪性代数课，天资聪慧的iPig被这门对他来说无比简单的课弄得灰常寂寞。为了消除寂寞感，他决定和他的好朋友giPi（鸡皮）玩一个更加寂寞的游戏—捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。一番寂寞的剪刀石头布后，他们决定iPig去捉giPi。由于他们都很熟悉PKU的地形了，所以giPi只会躲在PKU内n个隐秘地点，显然iPig也只会在那n个地点内找giPi。游戏一开始，他们选定一个地点，iPig保持不动，然后giPi用30秒的时间逃离现场（显然，giPi不会呆在原地）。然后iPig会随机地去找giPi，直到找到为止。由于iPig很懒，所以他到总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。由于iPig现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig告诉了你PKU的n个隐秘地点的坐标，请你编程求出iPig的问题。【输入格式】第一行输入一个整数N 第2~N+1行，每行两个整数X，Y，表示第i个地点的坐标【输出格式】一个整数，为距离差的最小值。【输入样例】40 01 00 11 1【输出样例】1 刷题记录30min1AC 分析kdtree暴力枚举即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int d[2];//自己 int son[2];//左右区间 int mi[2],mx[2];//管理区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];int root;//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;int getdis(int t,int x,int y,int op)//最近&#123; if(op==0) &#123; int ans=0;//在内部 if(x&lt;p[t].mi[0]) ans+=p[t].mi[0]-x;//左 if(p[t].mx[0]&lt;x) ans+=x-p[t].mx[0];//右 if(p[t].mx[1]&lt;y) ans+=y-p[t].mx[1];//上 if(y&lt;p[t].mi[1]) ans+=p[t].mi[1]-y;//下 return ans; &#125; else &#123; return mymax(myabs(x-p[t].mx[0]),myabs(x-p[t].mi[0]))+ mymax(myabs(y-p[t].mx[1]),myabs(y-p[t].mi[1])); &#125; &#125;//*******************实现*******************int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2;D=d; nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int ans;void ask(int now,int x,int y,int op)&#123; int dis=myabs(p[now].d[0]-x)+myabs(p[now].d[1]-y);//自身 if(dis!=0) &#123; if(op==0) ans=mymin(ans,dis); else ans=mymax(ans,dis); &#125; int f[2],lc=p[now].son[0],rc=p[now].son[1]; if(op==0) &#123; f[0]=lc?getdis(lc,x,y,op):INF; f[1]=rc?getdis(rc,x,y,op):INF; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&lt;ans) ask(p[now].son[tmp],x,y,op); if(f[1-tmp]&lt;ans) ask(p[now].son[1-tmp],x,y,op); &#125; else &#123; f[0]=lc?getdis(lc,x,y,op):0; f[1]=rc?getdis(rc,x,y,op):0; bool tmp=(f[1]&gt;=f[0]); if(f[tmp]&gt;ans) ask(p[now].son[tmp],x,y,op); if(f[1-tmp]&gt;ans) ask(p[now].son[1-tmp],x,y,op); &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); int mi=INF; for(int i=1;i&lt;=n;i++) &#123; ans=0; ask(root,p[i].d[0],p[i].d[1],1); int t=ans;ans=INF; ask(root,p[i].d[0],p[i].d[1],0); mi=mymin(mi,t-ans); &#125; printf("%d",mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1206】最近点对]]></title>
    <url>%2Fposts%2Fa1d3.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1206 题目【题目大意】给出n个点的坐标，求最近两点间的距离。【输入格式】第一行一个整数n(2≤n≤50000)。下来n行，每行两个实数x和y表示点坐标。【输出格式】一行一个实数，表示最近两点间的距离（保留4位小数）。【输入样例】50 00 55 05 52 0【输出样例】2.0000 刷题记录30min1WA1AC 分析kdtree记得开long long 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;ll mymax(ll x,ll y) &#123;return x&gt;y?x:y;&#125;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mysqr(ll x) &#123;return x*x;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; ll d[2];//自己 ll mi[2],mx[2];//管理区间 int son[2];//左右区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;ll getdis(int t,ll x,ll y)//估价最好情况&#123; ll xx=mymax(0,p[t].mi[0]-x)+mymax(0,x-p[t].mx[0]); ll yy=mymax(0,y-p[t].mx[1])+mymax(0,p[t].mi[1]-y); return xx*xx+yy*yy;&#125;//*******************实现*******************int root;int build(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)/2; D=d;nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(ll x,ll y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tmp=cmp(p[f],p[t]); if(p[f].son[tmp]==0) &#123; p[f].son[tmp]=t; break; &#125; f=p[f].son[tmp]; &#125; &#125;&#125;ll ans;void ask(int t,ll x,ll y)&#123; ll dis=mysqr(p[t].d[0]-x)+mysqr(p[t].d[1]-y); /*if(dis==0) return;//自身 ans=mymin(ans,dis);*/ if(dis!=0) ans=mymin(ans,dis); //UP: caioj神水数据，一看就是错的 int lc=p[t].son[0],rc=p[t].son[1]; ll f[2]; f[0]=(lc&gt;0)?getdis(lc,x,y):INF; f[1]=(rc&gt;0)?getdis(rc,x,y):INF; bool tmp=(f[1]&lt;=f[0]); if(f[tmp]&lt;ans) ask(p[t].son[tmp],x,y); if(f[1-tmp]&lt;ans) ask(p[t].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0); ans=INF; for(int i=1;i&lt;=n;i++) ask(root,p[i].d[0],p[i].d[1]); printf("%.4lf",sqrt(double(ans)));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2648】【Bzoj2716】SJY摆棋子]]></title>
    <url>%2Fposts%2F5728.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2648Bzoj2716 题目【题目大意】在一个棋盘上，有N个黑色棋子。他每次要么放到棋盘上一个黑色棋子，要么放上一个白色棋子。如果是白色棋子，他会找出距离这个白色棋子最近的黑色棋子。此处的距离是 曼哈顿距离 即(|x1-x2|+|y1-y2|) 。现在给出N&lt;=500000个初始棋子和M&lt;=500000个操作。对于每个白色棋子，输出距离这个白色棋子最近的黑色棋子的距离。同一个格子可能有多个棋子。【输入格式】第一行两个数 N M以后N行，每行两个数x y（原题面错误）以后M行，每行3个数 t x y如果t=1 那么放下一个黑色棋子如果t=2 那么放下一个白色棋子【输出格式】对于每个T=2 输出一个最小距离【输入样例】2 31 12 32 1 21 3 32 4 2【输出样例】12 刷题记录1h4WA1AC 分析kdtree 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;//*******************全局常量*******************const int MAXN=1100000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int d[2];//自己 int son[2];//左右区间 int mi[2],mx[2];//管理区间 nod() &#123; son[0]=son[1]=0; &#125;&#125;p[MAXN];int root;//*******************kdtree*******************int D;bool cmp(nod a,nod b)&#123; return (a.d[D]&lt;b.d[D]) or (a.d[D]==b.d[D] and a.d[1-D]&lt;b.d[1-D]);&#125;void update(int f,int x)&#123; p[f].mi[0]=mymin(p[f].mi[0],p[x].mi[0]);p[f].mx[0]=mymax(p[f].mx[0],p[x].mx[0]); p[f].mi[1]=mymin(p[f].mi[1],p[x].mi[1]);p[f].mx[1]=mymax(p[f].mx[1],p[x].mx[1]);&#125;int getdis(int t,int x,int y)//估价最好情况&#123; int ans=0;//在内部 if(x&lt;p[t].mi[0]) ans+=p[t].mi[0]-x;//左 if(p[t].mx[0]&lt;x) ans+=x-p[t].mx[0];//右 if(p[t].mx[1]&lt;y) ans+=y-p[t].mx[1];//上 if(y&lt;p[t].mi[1]) ans+=p[t].mi[1]-y;//下 /* 神TM复制的时候忘记改x为y，然后居然水了无数点 ans=mymax(p[t].mi[0]-x,0)+mymax(x-p[t].mx[0],0)+ mymax(p[t].mi[1]-y,0)+mymax(y-p[t].mx[1],0);*/ return ans;&#125;//*******************实现*******************int build(int l,int r,int d)&#123; if(l&gt;r) return 0;//debug int mid=(l+r)/2;D=d;//debug nth_element(p+l,p+mid,p+r+1,cmp);//尽量平衡 p[mid].mi[0]=p[mid].mx[0]=p[mid].d[0]; p[mid].mi[1]=p[mid].mx[1]=p[mid].d[1]; if(l&lt;=mid-1) p[mid].son[0]=build(l,mid-1,1-d),update(mid,p[mid].son[0]); if(mid+1&lt;=r) p[mid].son[1]=build(mid+1,r,1-d),update(mid,p[mid].son[1]); return mid;&#125;int cnt;void insert(int x,int y)&#123; int t=++cnt; p[t].d[0]=p[t].mi[0]=p[t].mx[0]=x; p[t].d[1]=p[t].mi[1]=p[t].mx[1]=y; if(root==0) root=t; else &#123; int f=root; for(D=0;1;D=1-D) &#123; update(f,t); int tx=!cmp(p[t],p[f]); if(p[f].son[tx]==0) &#123; p[f].son[tx]=t; break; &#125; f=p[f].son[tx]; &#125; &#125;&#125;int ans;void ask(int now,int x,int y)&#123; ans=mymin(ans,myabs(p[now].d[0]-x)+myabs(p[now].d[1]-y));//自身 int f[2],lc=p[now].son[0],rc=p[now].son[1]; f[0]=lc?getdis(lc,x,y):INF; f[1]=rc?getdis(rc,x,y):INF; bool tmp=!(f[0]&lt;=f[1]); if(f[tmp]&lt;ans) ask(p[now].son[tmp],x,y); if(f[1-tmp]&lt;ans) ask(p[now].son[1-tmp],x,y);&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].d[0],&amp;p[i].d[1]); root=build(1,n,0);cnt=n; while(m--) &#123; int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(op==1) insert(x,y); else ans=INF,ask(root,x,y),printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1051】受欢迎的牛]]></title>
    <url>%2Fposts%2Fc794.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj1051 题目【题目大意】每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。【输入格式】第一行两个数N,M。接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B）N&lt;=10000,M&lt;=50000【输出格式】一个数，即有多少头牛被所有的牛认为是受欢迎的。【输入样例】3 31 22 12 3【输出样例】1 刷题记录30min1WA1AC 分析一开始还乱想到差分约束…… 引用1：由题可得，受欢迎的奶牛只有可能是图中唯一的出度为零的强连通分量中的所有奶牛，所以若出现两个以上出度为0的强连通分量则不存在明星奶牛，因为那几个出度为零的分量的爱慕无法传递出去。那唯一的分量能受到其他分量的爱慕同时在分量内相互传递，所以该分量中的所有奶牛都是明星 引用2：在有向图中，如果有且仅有一个点的出度为0 （没有指向其他点的边），那么该点可以被所有点遍历到；反之，该图中没有可以被所有点遍历到的点。在有向图中，如果一个点可以被所有点遍历到，那么这个点的出度为0。可用反证法证明。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000,MAXM=51000;//*******************全局定义*******************int size[MAXN];int cnt;struct nod&#123; int hou; int dfn,low; bool v; int belg;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; size[cnt]++; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int out[MAXN];int main()&#123; int T=1;//scanf("%d",&amp;T); while(T--) &#123; memset(p,0,sizeof(p)); memset(size,0,sizeof(size)); cnt=ln=id=0; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); memset(out,0,sizeof(out)); for(int i=1;i&lt;=ln;i++) &#123; int x=p[e[i].x].belg,y=p[e[i].y].belg; if(x!=y) out[x]++; &#125; int b=0,ans; for(int i=1;i&lt;=cnt;i++) if(out[i]==0) b++,ans=size[i]; if(b!=1) printf("0\n"); else printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu2767】Proving Equivalences]]></title>
    <url>%2Fposts%2F1075.html</url>
    <content type="text"><![CDATA[来源和评测点Hdu2767显然我没看懂原题目……Caioj1148 题目【题目大意】给出一个有向图有n个点和m条有向边，问加上最少的边，使它成为一个强连通图。（什么是强连通图：任意两个点都能连通的）【输入格式】第一行一个整数N（1≤N≤100）表示下来有N组数据。每组数据第一行为两个整数n(1≤n≤20000)和m(0≤m≤50000)，表示n个点和m条有向边。下来m行，每行两个整数x和y，表示一条x到y的有向边(1≤x,y≤n且x!=y)。【输出格式】每组数据输出一行，一个整数，表示最少需要添加的有向边的数目。【输入样例】24 03 21 21 3【输出样例】42 刷题记录30min1RE7WA2AC 分析缩点后，统计max（入度=0，出度=0）即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=21000,MAXM=51000;//*******************全局定义*******************int cnt;struct nod&#123; int hou; int dfn,low; bool v; int belg;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top;int id;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int in[MAXN],out[MAXN];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(p,0,sizeof(p)); cnt=ln=id=0; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); ins(x,y); &#125; top=0; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); if(cnt==1)//debug &#123; printf("0\n"); continue; &#125; memset(in,0,sizeof(in)); memset(out,0,sizeof(out)); for(int i=1;i&lt;=ln;i++) &#123; int x=p[e[i].x].belg,y=p[e[i].y].belg; if(x!=y) &#123; out[x]++; in[y]++; &#125; &#125; int a=0,b=0; for(int i=1;i&lt;=cnt;i++) &#123; if(in[i]==0) a++; if(out[i]==0) b++; &#125; printf("%d\n",mymax(a,b)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1023】Victoria的舞会3]]></title>
    <url>%2Fposts%2Fa373.html</url>
    <content type="text"><![CDATA[来源和评测点Vijos1023 题目【题目大意】Victoria准备邀请n个已经确定的人，可是问题来了：这n个人每一个人都有一个小花名册，名册里面写着他能够通知到的人的名字。比如说在A的人名单里写了B，那么表示A能够通知到B；但是B的名单里不见的有A，也就是说B不见得通知到A。Victoria觉得需要确定自己需要通知多少个人m，能够实际将所有人n都通知到。并求出一种方案以确定m的最小值是多少。注意：自己的名单里面不会有自己的名字。Victoria可以自身通知到所有n个人。【输入格式】第一行一个数n。接下来n行，每i+1行表示编号为i的人的小花名册名单，名单以0结束。1&lt;=n&lt;=200。【输出格式】仅一行，如无解则输出‘NO’；否则输出最小的k的值。【输入样例】18011 000016 014 00002 13 0011 07 006 000【输出样例】14 刷题记录30min1WA1AC 分析强连通分量裸题缩点后，统计入度=0即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210,MAXM=41000;//*******************全局定义*******************int cnt=0;int ru[MAXN];struct nod&#123; int hou; int dfn,low; bool v; int belg; nod() &#123; hou=0; dfn=0; v=0; &#125;&#125;p[MAXN];struct edge&#123; int x,y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].x=x; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int sta[MAXN],top=0;int id=0;void tarjan(int x)&#123; sta[++top]=x;p[x].v=1; p[x].dfn=p[x].low=++id; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) tarjan(y),p[x].low=mymin(p[x].low,p[y].low); else if(p[y].v) p[x].low=mymin(p[x].low,p[y].dfn); &#125; if(p[x].dfn==p[x].low) &#123; cnt++; while(1) &#123; int t=sta[top--]; p[t].belg=cnt; p[t].v=0; if(t==x) break; &#125; &#125;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; while(1) &#123; int x;scanf("%d",&amp;x); if(x==0) break; ins(i,x); &#125; &#125; for(int i=1;i&lt;=n;i++) if(p[i].dfn==0) tarjan(i); for(int i=1;i&lt;=ln;i++) &#123; int x=e[i].x,y=e[i].y; if(p[x].belg==p[y].belg) continue; ru[p[y].belg]++; &#125; int ans=0; for(int i=1;i&lt;=cnt;i++) if(ru[i]==0) ans++;//debug printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1094】关系运算图]]></title>
    <url>%2Fposts%2Fe843.html</url>
    <content type="text"><![CDATA[来源和评测点Vijos1094 题目【题目大意】给出一有向图，图中每条边都被标上了关系运算符‘&lt;’,‘&gt;’,‘=’。现在要给图中每个顶点标上一个大于等于0,小于等于k的某个整数使所有边上的符号得到满足。若存在这样的k，则求最小的k，若任何k都无法满足则输出NO。例如下表中最小的k为2。结点1&gt;结点2结点2&gt;结点3结点2&gt;结点4结点3=结点4如果存在这样的k，输出最小的k值；否则输出‘NO’。【输入格式】共二行，第一行有二个空格隔开的整数n和m。n表示G的结点个数，m表示G的边数，其中1&lt;=n&lt;=1000, 0&lt;=m&lt;=10000。全部结点用1到n标出，图中任何二点之间最多只有一条边，且不存在自环。第二行共有3m个用空格隔开的整数，第3i-2和第3i-1（1&lt;=i&lt;=m）个数表示第i条边的顶点。第3i个数表示第i条边上的符号，其值用集合{-1，0，1}中的数表示：-1表示‘&lt;’, 0 表示‘=’, 1表示‘&gt;’。【输出格式】仅一行，如无解则输出‘NO’；否则输出最小的k的值。【输入样例】4 41 2 -1 2 3 0 2 4 -1 3 4 -1【输出样例】2 刷题记录30min4WA2AC 分析d[i]&lt;d[j]d[i]&lt;=d[j]-1ins(j,i,-1) d[i]=d[j]ins(j,i,0)ins(j,i,0) d[i]&gt;d[j]d[i]&gt;=d[j]+1d[j]&lt;=d[i]-1ins(i,j,-1) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=1100,MAXM=21000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; int v; int r; int d; nod() &#123; hou=v=r=0; d=INF; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int n,m;int mx=0,mi=0;int lst[MAXN];bool spfa(int st)&#123; int top=0; lst[++top]=st; p[st].v=1;p[st].r=1;p[st].d=0; while(top&gt;0) &#123; int x=lst[top--]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].d&gt;p[x].d+e[k].c) &#123; p[y].d=p[x].d+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n) return 0; lst[++top]=y; &#125; &#125; &#125; p[x].v=0; &#125; return 1;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(p[i].r==0) if(!spfa(i)) return 0; for(int i=1;i&lt;=n;i++) mi=mymin(mi,p[i].d); return 1;&#125;//*******************主函数*******************int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); if(c&lt;0) ins(y,x,-1); if(c==0) ins(x,y,0),ins(y,x,0); if(c&gt;0) ins(x,y,-1); &#125; if(!check()) printf("NO"); else printf("%d",-mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1716】差分约束4整数区间]]></title>
    <url>%2Fposts%2F75d0.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1716Caioj1403 题目【题目大意】给出n个区间，每个区间内至少有两个数被选中，问最少需要选出多少个数【输入格式】第一行：一个整数n(1&lt;=n&lt;=10000)接下来n行：每行两个数a,b(0&lt;=a&lt;b&lt;=10000)，表示一个区间的开始点和结束点【输出格式】第一行：一个整数，表示最少选出多少个数若出现了负环，只需要输出”-1”（不包含括号）【输入样例】43 62 40 24 7【输出样例】4 刷题记录30min无数TLE caioj真的恶心不用栈并且全部放入而是用队列或者spfa全优化都过不了-1的一个点 分析s[b]-s[a-1]&gt;=22&lt;=s[b]-s[a-1]s[a-1]&lt;=s[b]-2 s[i]-s[i-1]&lt;=1s[i]&lt;=s[i-1]+1 s[i]-s[i-1]&gt;=0s[i-1]&lt;=s[i] ans:s[mx]-s[mi] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=MAXN-1;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; for(int i=1;i&lt;=n;i++) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); a++;b++;//debug ins(b,a-1,-2); mi=mymin(mi,a-1);mx=mymax(mx,b); &#125; for(int i=mi+1;i&lt;=mx;i++) &#123; ins(i-1,i,1); ins(i,i-1,0); &#125; if(spfa(mx,mx-mi+1)) printf("%d",p[mx].s-p[mi].s); else printf("-1");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1402】差分约束3消息可靠吗]]></title>
    <url>%2Fposts%2F3a06.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1402 题目【题目大意】给出n个点和m条约束信息。信息表述为(P a b c)表示a在b北方距离c单位的位置，或者(V a b)表示a在b的北方。问是否可能存在符合以上m个要求的点【输入格式】第一行：两个整数n和m,(0&lt;n&lt;=1000),(1&lt;=M&lt;=100000)接下来m行：每行输入(P a b c)或者(V a b)，意思如上所示多组数据，当n=0时结束【输出格式】若存在这样的点则输出”Reliable”（不包含括号），不存在输出”Unreliable”（不包含括号）【输入样例】3 4P 1 2 1P 2 3 1V 1 3P 1 3 15 5V 1 2V 2 3V 3 4V 4 5V 3 50【输出样例】UnreliableReliable 刷题记录30min6TLE1WA1AC 分析p1s[a]-s[b]&lt;=cs[a]&lt;=s[b]+cp2s[a]-s[b]&gt;=cc&lt;=s[a]-s[b]s[b]&lt;=s[a]-cvs[a]&gt;s[b]s[a]&gt;=s[b]+1s[b]&lt;=s[a]-1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000,MAXM=310000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m; while(scanf("%d",&amp;n) and n&gt;0) &#123; scanf("%d",&amp;m); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=MAXN-1;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; bool bk=1; for(int i=1;i&lt;=m;i++) &#123; int a,b;scanf("%s%d%d",s,&amp;a,&amp;b); if(s[0]=='P') &#123; int c;scanf("%d",&amp;c); if(a==b and c&gt;0) bk=0; ins(b,a,c);ins(a,b,-c); &#125; else &#123; if(a==b) bk=0; ins(a,b,-1); &#125; mi=mymin(mi,mymin(a,b)); mx=mymax(mx,mymax(a,b)); &#125; if(bk and check()) printf("Reliable\n"); else printf("Unreliable\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF#469Div2-C】Zebras]]></title>
    <url>%2Fposts%2F8404.html</url>
    <content type="text"><![CDATA[来源和评测点Codeforces Round #469 (Div.2)CF#469Div2-C 题目【题目大意】Zebra:0和1交替出现，开头结尾都是0。给出字符串，分割成子序列（不一定连续），必须每一个都是Zebra【输入格式】只有一行，01字符串无解输出-1【约束条件】长度不超过200000【输出格式】有spj第一行子序列个数每行开头，当前子序列长度，然后是由哪些位置组成以上按照从小到大排序【输入样例】0010100【输出样例】33 1 3 43 2 5 61 7 刷题记录1h1WA1TLE比完赛后1RE1AC 分析我打了个很丑的暴力，然后是一个个子序列寻找的，超慢然后根本没考虑过可以跑一遍过重点是STL的妙用，确保正确性，同时动态空间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************char s[200010];vector&lt;int&gt; f[200010];set&lt;int&gt; s0,s1;int n,m;//*******************实现*******************bool solve()&#123; for(int i=1;i&lt;=n;i++) &#123; if(s[i]=='0') &#123; if(s1.empty()) &#123; f[++m].push_back(i); s0.insert(m); &#125; else &#123; int x=*s1.begin(); f[x].push_back(i); s1.erase(x); s0.insert(x); &#125; &#125; else &#123; if(s0.empty()) return 0; int x=*s0.begin(); f[x].push_back(i); s0.erase(x); s1.insert(x); &#125; &#125; if(!s1.empty()) return 0; return 1;&#125;void output()&#123; printf("%d\n",m); for(int i=1;i&lt;=m;i++) &#123; printf("%d ",f[i].size()); for(int j=0;j&lt;=f[i].size()-1;j++) printf("%d ",f[i][j]); printf("\n"); &#125;&#125;//*******************主函数*******************int main()&#123; scanf("%s",s+1); n=strlen(s+1);m=0; if(solve()) output(); else printf("-1\n");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1364】差分约束2国王]]></title>
    <url>%2Fposts%2F34e8.html</url>
    <content type="text"><![CDATA[来源和评测点Poj1364Caioj1401 题目【题目大意】给出不超过n的数和m个关系。然后给出ai,bi，接着输入gt或者lt，最后给出di。它们分别表示从a[ai]开始a[ai]+a[ai+1]+…+a[ai+bi]这些数的和小于(lt)di或大于(gt)di。问是否存在满足m个关系的数列【输入格式】第一行：两个整数n和m(0&lt;n&lt;=100),(0&lt;m&lt;=100)接下来m行：每行输入ai,bi,gt或者lt,di多组数据，当n=0时结束【输出格式】若存在这样的数列则输出”lamentable kingdom”（不包含引号），否则输出”successful conspiracy”（不包含引号）。【输入样例】4 21 2 gt 02 2 lt 21 21 0 gt 01 0 lt 00【输出样例】lamentable kingdomsuccessful conspiracy 刷题记录20min 分析lt:s[a+b]-s[a-1]&lt;ds[a+b]-s[a-1]&lt;=d-1s[a+b]&lt;=s[a-1]+d-1gt:s[a+b]-s[a-1]&gt;ds[a+b]-s[a-1]&gt;=d+1d+1&lt;=s[a+b]-s[a-1]s[a-1]&lt;=s[a+b]-d-1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int lst[MAXN];bool spfa(int st,int n)&#123; int tou=1,wei=2; p[st].s=0;p[st].v=1; lst[tou]=st;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;n-1) return 0; lst[wei++]=y;if(wei==MAXN) wei=1; &#125; &#125; &#125; p[x].v=0; tou++;if(tou==MAXN) tou=1; &#125; return 1;&#125;int mi,mx;bool check()&#123; for(int i=mi;i&lt;=mx;i++) if(p[i].r==0) if(!spfa(i,mx-mi+1)) return 0; return 1;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m; while(scanf("%d",&amp;n) and n&gt;0) &#123; scanf("%d",&amp;m); mx=-INF;mi=INF;ln=0; for(int i=0;i&lt;=n;i++) &#123; p[i].hou=0; p[i].r=p[i].v=0; p[i].s=INF; &#125; for(int i=1;i&lt;=m;i++) &#123; int a,b,d;scanf("%d%d%s%d",&amp;a,&amp;b,s,&amp;d); if(s[0]=='l') ins(a-1,a+b,d-1); else ins(a+b,a-1,-d-1); mi=mymin(mi,a-1);mx=mymax(mx,a+b); &#125; if(check()) printf("lamentable kingdom\n"); else printf("successful conspiracy\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1400】差分约束1区间]]></title>
    <url>%2Fposts%2Fa10d.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1400 题目【题目大意】给出n个区间，每个整数区间ai~bi中至少有ci个点。求整个区间中最少的点数【输入格式】第一行：一个整数n(1&lt;=n&lt;=50000)接下来n行每行三个整数ai,bi,ci（0&lt;=ai&lt;=bi&lt;=50000）,（1&lt;=ci&lt;=bi-ai+1）【输出格式】一个整数，表示整个区间中最少有多少个点【输入样例】53 7 38 10 36 8 11 3 110 11 1【输出样例】6 刷题记录20min 分析令s[i]=1~i的数量约束条件：s[i]-s[i-1]&gt;=0s[i]-s[i-1]&lt;=1s[b]-s[a-1]&gt;=c对应最短路中的松弛操作即d[j]&lt;=d[i]+c[k] ins(i,j,c[k])现在条件变成s[i-1]&lt;=s[i] ins(i,i-1,0)s[i]&lt;=s[i-1]+1 ins(i-1,i,1)s[a-1]&lt;=s[b]-c ins(b,a-1,-c)以前让d[i]最小现在让s[i]最小 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=51000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int hou; bool v; int r; int s; nod() &#123; hou=r=v=0; s=INF; &#125;&#125;p[MAXN];struct edge&#123; int y,c,g;&#125;e[MAXN*3];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y; e[ln].c=c; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************int mi=INF,mx=-INF;int lst[MAXN];bool spfa()&#123; int tou=1,wei=2; p[mx].s=0;p[mx].v=1; lst[tou]=mx;//边是从高往低建的 while(tou!=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].s&gt;p[x].s+e[k].c) &#123; p[y].s=p[x].s+e[k].c; if(p[y].v==0) &#123; p[y].v=1; p[y].r++; if(p[y].r&gt;mx-mi) return 0;//n-1=mx-mi+1-1 lst[wei++]=y; if(wei==MAXN) wei=1; &#125; &#125; &#125; tou++;p[x].v=0; if(tou==MAXN) tou=1; &#125; return 1;&#125;//*******************主函数*******************int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(b,a-1,-c); mi=mymin(mi,a-1);mx=mymax(mx,b); &#125; for(int i=mi+1;i&lt;=mx;i++) &#123; ins(i-1,i,1); ins(i,i-1,0); &#125; if(spfa()) printf("%d\n",p[mx].s-p[mi].s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3932】【Luogu3168】任务查询系统]]></title>
    <url>%2Fposts%2F9028.html</url>
    <content type="text"><![CDATA[来源和评测点CQOI2015Bzoj3932Luogu3168 题目【题目大意】电脑有n个任务需要执行，任务i在si到ei时正在工作，优先级为p给m个询问，每个询问给出一个时间点xi和一个数ki。问在xi这个时间点时，所有正在工作的任务中优先级从小到大排列，前ki个的优先级之和是多少【输入格式】输入文件第一行包含两个空格分开的正整数m和n，分别表示任务总数和时间范围。接下来m行，每行包含三个空格分开的正整数Si、Ei和Pi(Si&lt;=Ei)，描述一个任务。接下来n行，每行包含四个空格分开的整数Xi、Ai、Bi和Ci，描述一次查询。查询的参数Ki需要由公式 Ki=1+(Ai*Pre+Bi) mod Ci计算得到。其中Pre表示上一次查询的结果，对于第一次查询，Pre=1。1&lt;=m,n,Si,Ei,Ci&lt;=100000，0&lt;=Ai,Bi&lt;=100000，1&lt;=Pi&lt;=10000000，Xi为1到n的一个排列【输出格式】输出共n行，每行一个整数，表示查询结果。【输入样例】4 31 2 62 3 31 3 23 3 43 1 3 21 1 3 42 2 4 3【输出样例】2811 刷题记录分析把每一秒看作一个操作来可持续化好吧其实就是有着权值线段树的前缀和 然鹅，这题居然不卡暴力……基于【面向数据编程】和【以题目为导向】，暂时就不写正解了，精A飘过 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int qread1(void)&#123; char c=getchar();int d=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') d=d*10+c-'0',c=getchar(); return d;&#125;ll qread2(void)&#123; char c=getchar();ll d=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') d=d*10+c-'0',c=getchar(); return d;&#125;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************struct nod&#123; int a,b; ll c;&#125;p[MAXN];bool operator &lt; (nod x,nod y)&#123; return x.c&lt;y.c;&#125;//*******************实现*******************//*******************主函数*******************int main()&#123; int m,n;scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) p[i].a=qread1(),p[i].b=qread1(),p[i].c=qread2(); sort(p+1,p+1+m); ll pre=1; for(int i=1;i&lt;=n;i++) &#123; int x=qread1();ll a=qread2(),b=qread2(),c=qread2(); ll k=1+(a*pre+b)%c;pre=0; for(int i=1,j=0;i&lt;=m and j&lt;k;i++) if(p[i].a&lt;=x and x&lt;=p[i].b) pre+=p[i].c,j++; printf("%lld\n",pre); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj5072】小A的树]]></title>
    <url>%2Fposts%2F8843.html</url>
    <content type="text"><![CDATA[来源和评测点Lydsy十月月赛Bzoj5072 题目【题目大意】给出一棵n个点的树，每个点有黑白两种颜色。q次询问，每次询问给出x和y，问能否选出一个x个点的连通子图，使得其中黑点数目为y。【输入格式】第一行一个正整数T 表示数据组数。对于每一组数据，第一行有两个用空格隔开的正整数，分别是n 和q，表示树的节点数和询问次数。接下来n-1 行，每行两个用空格隔开的正整数ui和vi，表示ui和vi间有一条边相连。接下来一行有n 个用空格隔开的整数b1,b2,…bn，其中若bi=0，则表示第i个点为白色，否则为黑色。接下来q 行，每行两个用空格隔开的整数和，意义如Problem Statement中描述的x和y。T&lt;=5,n&lt;=5000,q&lt;=10^51&lt;=ui,vi&lt;=n,1&lt;=xi&lt;=n,0&lt;=yi&lt;=n,yi&lt;=xi【输出格式】对于每一组数据，输出q行，每行为“YES”或者“NO”（不含双引号），表示对于给定的和，能否满足小A 的要求。每相邻两组数据的输出之间空一行。【输入样例】19 44 11 51 23 23 66 76 89 60 1 0 1 0 0 1 0 13 27 34 09 5【输出样例】YESYESNONO第一组数据中，可以取子图{6,7,9}。第一组数据中，可以取子图{1,2,3,4,5,6,7,8}。而在第三、四组数据中，不存在符合题意的子图。 刷题记录1h2WA1AC 分析首先，我不会算时间复杂度，别人说是N^2然后有一个结论，我也不会证明，但随便举了个栗子，自以为是比较坏的情况就是：给出一棵树，在某个固定大小的连通块中，如果可以有最少L,最大R个黑点，则之间的也一定可以实现。栗子：R=L+2,m=L+1然后减少2白，增加2黑（删除2白和1黑+添加3黑=减少2白，增加2黑）那么也可以减少1白，增加1黑（删除1白和1黑+添加2黑=减少1白，增加1黑）那我觉得应该结论是对的……然后dp的时候注意一下后效性就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=5100;//*******************全局定义*******************struct nod&#123; int hou; bool cl; int tot;&#125;p[MAXN];int l[MAXN][MAXN],r[MAXN][MAXN];struct edge&#123; int y,g;&#125;e[MAXN*2];int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************实现*******************void dfs(int x,int fa)&#123; p[x].tot=1;l[x][1]=r[x][1]=p[x].cl; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y==fa) continue; dfs(y,x); for(int i=p[x].tot;i&gt;=1;i--)//debug后效性 &#123; for(int j=p[y].tot;j&gt;=1;j--)//debug后效性 &#123; l[x][i+j]=mymin(l[x][i+j],l[x][i]+l[y][j]); r[x][i+j]=mymax(r[x][i+j],r[x][i]+r[y][j]); &#125; &#125; p[x].tot+=p[y].tot; &#125; for(int i=1;i&lt;=p[x].tot;i++) &#123; l[0][i]=mymin(l[0][i],l[x][i]); r[0][i]=mymax(r[0][i],r[x][i]); &#125;&#125;//*******************主函数*******************int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(l,63,sizeof(l)); memset(r,-63,sizeof(r)); int n,q;scanf("%d%d",&amp;n,&amp;q); ln=0;for(int i=1;i&lt;=n;i++) p[i].hou=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].cl); dfs(1,0); while(q--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(l[0][x]&lt;=y and y&lt;=r[0][x]) printf("YES\n"); else printf("NO\n"); &#125; printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3226】校门外的区间]]></title>
    <url>%2Fposts%2Fef13.html</url>
    <content type="text"><![CDATA[来源和评测点Sdoi2008Bzoj3226 从小白的角度解释本题 题目【题目大意】5种运算维护集合S(S初始为空)并最终输出S5种运算如下：U T：S、T并集I T：S、T交集D T：S独有C T：T独有S T：S独有 交 T独有【输入格式】输入共M行。每行的格式为X T，用一个空格隔开，X表示运算的种类，T为一个区间123450≤a≤b≤65535，1≤M≤70000**【输出格式】**共一行，即集合S，每个区间后面带一个空格。若S为空则输出&quot;empty set&quot;。**【输入样例】** U [1,5]D [3,3]S [2,4]C (1,5)I (2,3]12345678910111213141516**【输出样例】**(2,3) &lt;/p&gt;## 刷题记录1h3WA1PE1AC## 分析挺考验逻辑关系能力的首先，区间都是连续的。然后先消除区间表达法的多样性，可以考虑用t表示t/2，这样把区间统一转化，例如(2,5)变成```[2.5,4.5]```也就是```[5,9] 然后各种操作逐个击破U 区间1I 独有0D 区间0C 区间取反，其余0S 区间取反 各种max，min乱搞线段树维护就好了 格式错误的话，是因为我以为打空格的同时换行，当时就想为什么这么奇怪，原来不用换行。 然后WA的话，就是【可能我的方式太古怪了】除了打修改的时候删掉翻转外，【因为我是用父亲c更新儿子c的】，所以如果翻转之前有修改标记而且是统一的（不是-1），那么就不用往下打标记了 然后我的答案统计方式好像很独特啊，网上那些方法我看不懂…… 最后最后就是，无数次忘记，翻转标记要用异或更新。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************struct seg&#123; int l,r; int lc,rc; int c;//-1,0,1 bool tg1,tg2;&#125;p[310000];//*******************实现*******************int ln=0;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].c=0; p[t].tg1=p[t].tg2=0; if(l&lt;r) &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; else p[t].lc=p[t].rc=0; return t;&#125;void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[lc].c==p[rc].c) p[x].c=p[lc].c; else p[x].c=-1;&#125;void maketg1(int x,int c)&#123; p[x].c=c; p[x].tg1=1; p[x].tg2=0;&#125;void maketg2(int x)&#123; if(p[x].c&gt;=0) p[x].c=1-p[x].c; if( !(p[x].tg1==1 and p[x].c&gt;=0) ) p[x].tg2^=1;//debug&#125;void pushdown(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[x].tg1&gt;0) &#123; p[x].tg1=0; if(lc&gt;0) maketg1(lc,p[x].c); if(rc&gt;0) maketg1(rc,p[x].c); &#125; if(p[x].tg2&gt;0) &#123; p[x].tg2=0; if(lc&gt;0) maketg2(lc); if(rc&gt;0) maketg2(rc); &#125;&#125;void change1(int x,int l,int r,int c)&#123; if(x==0 or l&gt;r) return; if(p[x].l==l and p[x].r==r) &#123; maketg1(x,c); return; &#125; pushdown(x); int mid=(p[x].l+p[x].r)/2; int lc=p[x].lc,rc=p[x].rc; if(r&lt;=mid) change1(lc,l,r,c); else if(l&gt;mid) change1(rc,l,r,c); else change1(lc,l,mid,c),change1(rc,mid+1,r,c); update(x);&#125;void change2(int x,int l,int r)&#123; if(x==0 or l&gt;r) return; pushdown(x);//debug if(p[x].l==l and p[x].r==r) &#123; maketg2(x); return; &#125; int mid=(p[x].l+p[x].r)/2; int lc=p[x].lc,rc=p[x].rc; if(r&lt;=mid) change2(lc,l,r); else if(l&gt;mid) change2(rc,l,r); else change2(lc,l,mid),change2(rc,mid+1,r); update(x);&#125;bool bk=0;void output(int a,int b)&#123; bk=1; if(a%2==0) printf("[%d,",a/2); else printf("(%d,",a/2); if(b%2==0) printf("%d] ",b/2); else printf("%d) ",b/2+1);&#125;int ll=-2,rr=-2;void ask(int x)&#123; if(x==0) return; if(p[x].c==1) &#123; int a=p[x].l,b=p[x].r; if(a&gt;rr+1) &#123; if(ll&gt;=0) output(ll,rr); ll=a; &#125; rr=b; &#125; if(p[x].c==-1) &#123; pushdown(x); ask(p[x].lc); ask(p[x].rc); &#125;&#125;//*******************主函数*******************int main()&#123; build(0,140000); //build(0,10); char s[5],c1,c2;int a,b; while(scanf("%s %c%d,%d%c",s,&amp;c1,&amp;a,&amp;b,&amp;c2)!=EOF and s[0]!='e') &#123; a*=2;if(c1=='(') a++; b*=2;if(c2==')') b--; if(s[0]=='U') &#123; change1(1,a,b,1); &#125; if(s[0]=='I') &#123; change1(1,0,a-1,0); change1(1,b+1,140000,0); //change1(1,b+1,10,0); &#125; if(s[0]=='D') &#123; change1(1,a,b,0); &#125; if(s[0]=='C') &#123; change1(1,0,a-1,0); change2(1,a,b); change1(1,b+1,140000,0); //change1(1,b+1,10,0); &#125; if(s[0]=='S') &#123; change2(1,a,b); &#125; &#125; ask(1);if(ll&gt;=0) output(ll,rr); if(bk==0) printf("empty set");&#125;/*U 区间1I 其余0D 区间0C 区间取反，其余0S 区间取反*/]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2733】【Luogu3224】永无乡]]></title>
    <url>%2Fposts%2F6053.html</url>
    <content type="text"><![CDATA[来源和评测点HNOI2012Bzoj2733Luogu3224 题目【题目大意】永无乡包含n座岛，编号从1到n，每座岛都有自己的独一无二的重要度，按照重要度可以将这n座岛排名，名次用1到n来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛a出发经过若干座（含0座）桥可以到达岛b，则称岛a和岛b是连通的。现在有两种操作：B x y 表示在岛x与岛y之间修建一座新桥。Q x k 表示询问当前与岛x连通的所有岛中第k重要的是哪座岛，即所有与岛x连通的岛中重要度排名第k小的岛是哪座，请你输出那个岛的编号。【输入格式】输入文件第一行是用空格隔开的两个正整数 n 和 m，分别 表示岛的个数以及一开始存在的桥数。接下来的一行是用空格隔开的 n 个数，依次描述从岛 1 到岛 n 的重要度排名。随后的 m 行每行是用空格隔开的两个正整数 ai 和 bi，表示一开始就存 在一座连接岛 ai 和岛 bi 的桥。后面剩下的部分描述操作，该部分的第一行是一个正整数 q，表示一共有 q 个操作，接下来的 q 行依次描述每个操作，操作的格式如上所述，以大写字母 Q 或B 开始，后面跟两个不超过 n 的正整数，字母与数字以及两个数字之间用空格隔开。对于 20%的数据 n≤1000,q≤1000对于 100%的数据 n≤100000,m≤n，q≤300000【输出格式】对于每个 Q x k 操作都要依次输出一行，其中包含一个整数，表示所询问岛屿的编号。如果该岛屿不存在，则输出-1。【输入样例】5 14 3 2 5 11 27Q 3 2Q 2 1B 2 3B 1 5Q 2 1Q 2 4Q 2 3【输出样例】-12512 刷题记录1h1AC 分析并查集维护连通性权值线段树维护数量来找大小类似主席树的合并跑得还是很快的，至于别的解法，不管了就算被卡，在考场上也是很优秀的算法，因为代码复杂度很低 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000;//*******************全局定义*******************struct nod&#123; int lc,rc; int c;&#125;p[21*MAXN];int rt[MAXN];//*******************线段树*******************int ln=0;void change(int &amp;x,int l,int r,int pos)&#123; if(x==0) &#123; x=++ln; p[x].c=0; p[x].lc=p[x].rc=0; &#125; p[x].c++; if(l==r) return; int mid=(l+r)/2; if(pos&lt;=mid) change(p[x].lc,l,mid,pos); else change(p[x].rc,mid+1,r,pos);&#125;void merg(int x,int &amp;y)&#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; p[y].c+=p[x].c; merg(p[x].lc,p[y].lc); merg(p[x].rc,p[y].rc);&#125;int find(int x,int l,int r,int k)&#123; if(k==0 or k&gt;p[x].c) return 0; if(l==r) return l; int mid=(l+r)/2,lc=p[x].lc; if(k&lt;=p[lc].c) return find(p[x].lc,l,mid,k); return find(p[x].rc,mid+1,r,k-p[lc].c);&#125;//*******************并查集*******************int fa[MAXN];int findfa(int x)&#123; if(fa[x]==x) return x; return fa[x]=findfa(fa[x]);&#125;void join(int x,int y)&#123; int fx=findfa(x),fy=findfa(y); if(fx!=fy) &#123; fa[fx]=fy; merg(rt[fx],rt[fy]); &#125;&#125;//*******************主函数*******************int id[MAXN],id2[MAXN];int main()&#123; memset(rt,0,sizeof(rt)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;id[i]); fa[i]=i;id2[id[i]]=i; change(rt[i],1,n,id[i]); &#125; id2[0]=-1; while(m--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); join(a,b); &#125; int q;scanf("%d",&amp;q); while(q--) &#123; char s[20];int a,b; scanf("%s%d%d",s,&amp;a,&amp;b); if(s[0]=='B') join(a,b); else printf("%d\n",id2[ find(rt[ findfa(a) ],1,n,b) ]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1500】【Luogu2042】维修数列]]></title>
    <url>%2Fposts%2Fd303.html</url>
    <content type="text"><![CDATA[来源和评测点NOI2005Bzoj1500Luogu2042Caioj1136 题目【题目大意】请写一个程序，要求维护一个数列，支持以下 6 种操作：请注意，格式栏 中的下划线‘_’表示实际输入文件中的空格【输入格式】输入的第1 行包含两个数N 和M(M ≤20000)，N 表示初始时数列中数的个数，M表示要进行的操作数目。第2行包含N个数字，描述初始时的数列。以下M行，每行一条命令，格式参见问题描述中的表格。任何时刻数列中最多含有500000个数，数列中任何一个数字均在[-1000,1000]内。插入的数字总数不超过4000000个，输入文件大小不超过20MBytes。【输出格式】对于输入数据中的GET-SUM和MAX-SUM操作，向输出文件依次打印结果，每个答案（数字）占一行。【输入样例】9 82 -6 3 5 1 -5 -3 6 3GET-SUM 5 4MAX-SUMINSERT 8 3 -5 7 2DELETE 12 1MAKE-SAME 3 3 2REVERSE 3 6GET-SUM 5 4MAX-SUM【输出样例】-110110 刷题记录9h12WA1AC 分析https://www.luogu.org/blog/IAmHellWord/solution-p2042 总结而言，这道题比序列操作相比多了添加、翻转和删除，于是也就从线段树变成了伸展树如果不会翻转的话可以看看文艺平衡树 这次依然是刚开始没有头绪，去膜了上面那个题解，但其实也不过如此，优化一下空间复杂度就好了。 或许是综合性强吧，然后年份也比较早，也是一道比较骚的数据结构题具体做法我就不造轮子了，上面那个真的不错，我重写也不过如此 代码1无语了答案正确但灰常慢的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int son[2],f; int d;//debug int lmx,rmx;//用于更新 int mx; int sum; int c; int tg1,tg1n; int tg2; nod() &#123; son[0]=son[1]=f=0; lmx=rmx=mx=0; sum=d=0;c=0; tg1=tg2=0; &#125;&#125;p[MAXN];void clear(int x)&#123; p[x].son[0]=p[x].son[1]=p[x].f=0; p[x].lmx=p[x].rmx=p[x].mx=0; p[x].sum=p[x].d=0; p[x].c=0; p[x].tg1=p[x].tg2=0;&#125;//*******************Splay*******************void pushdown(int x)&#123; if(x==0) return; int lc=p[x].son[0],rc=p[x].son[1]; if(p[x].tg1) &#123; p[x].tg1=0;p[x].tg2=0; p[x].d=p[x].tg1n; p[x].sum=p[x].c*p[x].tg1n; if(p[x].tg1n&lt;0) &#123; p[x].mx=p[x].tg1n; p[x].lmx=p[x].rmx=0;//debug &#125; else p[x].lmx=p[x].rmx=p[x].mx=p[x].sum; p[lc].tg1=p[rc].tg1=1; p[lc].tg1n=p[rc].tg1n=p[x].tg1n; p[lc].tg2=p[rc].tg2=0; &#125; if(p[x].tg2) &#123; p[x].tg2=0; swap(p[x].lmx,p[x].rmx); swap(p[x].son[0],p[x].son[1]); pushdown(lc);pushdown(rc); p[lc].tg2^=1;p[rc].tg2^=1;//debug &#125;&#125;void update(int x)//关键debug&#123; if(x==0) return; if(p[0].mx!=0 or p[0].sum!=0) printf("error!"); int lc=p[x].son[0],rc=p[x].son[1]; pushdown(lc);pushdown(rc); p[x].c=p[lc].c+1+p[rc].c; p[x].sum=p[lc].sum+p[x].d+p[rc].sum; p[x].lmx=mymax(p[lc].lmx,p[lc].sum+p[x].d); if(rc&gt;0) p[x].lmx=mymax(p[x].lmx,p[lc].sum+p[x].d+p[rc].lmx); p[x].rmx=mymax(p[rc].rmx,p[x].d+p[rc].sum); if(lc&gt;0) p[x].rmx=mymax(p[x].rmx,p[lc].rmx+p[x].d+p[rc].sum); p[x].mx=p[x].d; if(lc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[lc].mx),p[lc].rmx+p[x].d ); if(rc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[rc].mx),p[x].d+p[rc].lmx ); if(lc&gt;0 and rc&gt;0) p[x].mx=mymax( p[x].mx,p[lc].rmx+p[x].d+p[rc].lmx );&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int lst[MAXN];void splay(int x,int rt)&#123; int t=0,i=x; while(p[i].f!=rt) lst[++t]=i,i=p[i].f; lst[++t]=rt; while(t&gt;0) pushdown(lst[t--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(rt==ff) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findbyrk(int rk)&#123; int x=root; while(1) &#123; pushdown(x);//!!! int lc=p[x].son[0]; if(rk&lt;=p[lc].c) x=lc; else if(rk&gt;p[lc].c+1) rk-=p[lc].c+1,x=p[x].son[1];//debug else break; &#125; splay(x,0); return x;&#125;//*******************动态分配*******************queue&lt;int&gt; q;int cnt;int getid()&#123; int t; if(!q.empty()) t=q.front(),q.pop(); else t=++cnt; return t;&#125;void del(int x)&#123; if(x==0) return; del(p[x].son[0]); del(p[x].son[1]); q.push(x);clear(x);&#125;//*******************建树*******************int nm[MAXN];int build(int l,int r,int f)//借鉴线段树&#123; if(l&gt;r) return 0; int t=getid(); p[t].f=f;p[t].tg1=p[t].tg2=0; if(l==r) &#123; p[t].son[0]=p[t].son[1]=0;p[t].c=1; p[t].d=p[t].lmx=p[t].rmx=p[t].mx=p[t].sum=nm[l];//debug &#125; else &#123; int mid=(l+r)/2; p[t].d=nm[mid];//debug p[t].son[0]=build(l,mid-1,t); p[t].son[1]=build(mid+1,r,t); update(t); &#125; return t;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf("%d",&amp;nm[i]); nm[1]=0;nm[n+2]=0;//!!! p[0].lmx=p[0].rmx=-INF;//debug cnt=0;root=build(1,n+2,0); while(m--) &#123; scanf("%s",s); if(s[0]=='I')//INSERT &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1后 for(int i=1;i&lt;=ct;i++) scanf("%d",&amp;nm[i]); int l=findbyrk(k+1),r=findbyrk(k+2); splay(l,r);//debug p[l].son[1]=build(1,ct,l); update(l);update(r); &#125; if(s[0]=='D')//DELETE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug del(p[l].son[1]);//debug p[l].son[1]=0; update(l);update(r); &#125; if(s[2]=='K')//MAKE-SAME &#123; int k,ct,num;scanf("%d%d%d",&amp;k,&amp;ct,&amp;num);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug p[p[l].son[1]].tg1=1;p[p[l].son[1]].tg1n=num; splay(p[l].son[1],0); &#125; if(s[0]=='R')//REVERSE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug if(p[p[l].son[1]].tg1==0) &#123; p[p[l].son[1]].tg2=1; splay(p[l].son[1],0); &#125; &#125; if(s[0]=='G')//GET-SUM &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct if(ct==0) &#123;printf("0\n");continue;&#125; int l=findbyrk(k),r=findbyrk(k+ct+1);//debug splay(l,r);//debug pushdown(p[l].son[1]); printf("%d\n",p[p[l].son[1]].sum); &#125; if(s[2]=='X')//MAX-SUM &#123; int l=findbyrk(1),r=findbyrk(p[root].c);//debug splay(l,r);//debug pushdown(p[l].son[1]); printf("%d\n",p[ p[l].son[1] ].mx); &#125; &#125;&#125; 代码2AC代码，改了标记原本是自己也没有更新现在是自己已经更新其实也不是太快啦洛谷3896ms大视野7128 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=510000;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct nod&#123; int son[2],f; int d;//debug int lmx,rmx;//用于更新 int mx; int sum; int c; bool tg1,tg2; nod() &#123; son[0]=son[1]=f=0; lmx=rmx=mx=0; sum=d=0;c=0; tg1=tg2=0; &#125;&#125;p[MAXN];void clear(int x)&#123; p[x].son[0]=p[x].son[1]=p[x].f=0; p[x].lmx=p[x].rmx=p[x].mx=0; p[x].sum=p[x].d=0; p[x].c=0; p[x].tg1=p[x].tg2=0;&#125;//*******************Splay*******************void maketg1(int x,int d)&#123; p[x].d=d;p[x].sum=p[x].c*d; if(p[x].d&lt;0) p[x].lmx=p[x].rmx=p[x].mx=d; else p[x].lmx=p[x].rmx=p[x].mx=p[x].sum; p[x].tg1=1;&#125;void maketg2(int x)//debug&#123; swap(p[x].lmx,p[x].rmx); swap(p[x].son[0],p[x].son[1]); p[x].tg2^=1;&#125;void pushdown(int x)&#123; if(x==0) return; int lc=p[x].son[0],rc=p[x].son[1]; if(p[x].tg1) &#123; p[x].tg1=0; if(lc&gt;0) maketg1(lc,p[x].d); if(rc&gt;0) maketg1(rc,p[x].d); &#125; if(p[x].tg2) &#123; p[x].tg2=0; if(lc&gt;0) maketg2(lc); if(rc&gt;0) maketg2(rc); &#125;&#125;void update(int x)//关键debug&#123; if(x==0) return; if(p[0].mx!=0 or p[0].sum!=0) printf("error!"); int lc=p[x].son[0],rc=p[x].son[1]; p[x].c=p[lc].c+1+p[rc].c; p[x].sum=p[lc].sum+p[x].d+p[rc].sum; p[x].lmx=mymax(p[lc].lmx,p[lc].sum+p[x].d); if(rc&gt;0) p[x].lmx=mymax(p[x].lmx,p[lc].sum+p[x].d+p[rc].lmx); p[x].rmx=mymax(p[rc].rmx,p[x].d+p[rc].sum); if(lc&gt;0) p[x].rmx=mymax(p[x].rmx,p[lc].rmx+p[x].d+p[rc].sum); p[x].mx=p[x].d; if(lc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[lc].mx),p[lc].rmx+p[x].d ); if(rc&gt;0) p[x].mx=mymax( mymax(p[x].mx,p[rc].mx),p[x].d+p[rc].lmx ); if(lc&gt;0 and rc&gt;0) p[x].mx=mymax( p[x].mx,p[lc].rmx+p[x].d+p[rc].lmx );&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson&gt;0) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int lst[MAXN];void splay(int x,int rt)&#123; int t=0,i=x; while(p[i].f!=rt) lst[++t]=i,i=p[i].f; lst[++t]=rt; while(t&gt;0) pushdown(lst[t--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(rt==ff) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findbyrk(int rk)&#123; int x=root; while(1) &#123; pushdown(x);//!!! int lc=p[x].son[0]; if(rk&lt;=p[lc].c) x=lc; else if(rk&gt;p[lc].c+1) rk-=p[lc].c+1,x=p[x].son[1];//debug else break; &#125; splay(x,0); return x;&#125;//*******************动态分配*******************queue&lt;int&gt; q;int cnt;int getid()&#123; int t; if(!q.empty()) t=q.front(),q.pop(); else t=++cnt; return t;&#125;void del(int x)&#123; if(x==0) return; del(p[x].son[0]); del(p[x].son[1]); q.push(x);clear(x);&#125;//*******************建树*******************int nm[MAXN];int build(int l,int r,int f)//借鉴线段树&#123; if(l&gt;r) return 0; int t=getid(); p[t].f=f;p[t].tg1=p[t].tg2=0; if(l==r) &#123; p[t].son[0]=p[t].son[1]=0;p[t].c=1; p[t].d=p[t].lmx=p[t].rmx=p[t].mx=p[t].sum=nm[l];//debug &#125; else &#123; int mid=(l+r)/2; p[t].d=nm[mid];//debug p[t].son[0]=build(l,mid-1,t); p[t].son[1]=build(mid+1,r,t); update(t); &#125; return t;&#125;//*******************主函数*******************char s[20];int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf("%d",&amp;nm[i]); nm[1]=0;nm[n+2]=0;//!!! p[0].lmx=p[0].rmx=-INF;//debug cnt=0;root=build(1,n+2,0); while(m--) &#123; scanf("%s",s); if(s[0]=='I')//INSERT &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1后 for(int i=1;i&lt;=ct;i++) scanf("%d",&amp;nm[i]); int l=findbyrk(k+1),r=findbyrk(k+2); splay(l,r);//debug p[l].son[1]=build(1,ct,l); update(l);update(r); &#125; if(s[0]=='D')//DELETE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug del(p[l].son[1]);//debug p[l].son[1]=0; update(l);update(r); &#125; if(s[2]=='K')//MAKE-SAME &#123; int k,ct,num;scanf("%d%d%d",&amp;k,&amp;ct,&amp;num);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug maketg1(p[l].son[1],num); splay(p[l].son[1],0); &#125; if(s[0]=='R')//REVERSE &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug maketg2(p[l].son[1]); splay(p[l].son[1],0); &#125; if(s[0]=='G')//GET-SUM &#123; int k,ct;scanf("%d%d",&amp;k,&amp;ct);//k+1~k+ct if(ct==0) &#123;printf("0\n");continue;&#125; int l=findbyrk(k),r=findbyrk(k+ct+1); splay(l,r);//debug printf("%d\n",p[p[l].son[1]].sum); &#125; if(s[2]=='X')//MAX-SUM &#123; int l=findbyrk(1),r=findbyrk(p[root].c);//debug splay(l,r);//debug printf("%d\n",p[ p[l].son[1] ].mx); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1858】【Luogu2572】序列操作]]></title>
    <url>%2Fposts%2Fcf34.html</url>
    <content type="text"><![CDATA[来源和评测点SCOI2010Bzoj1858Luogu2572 题目【题目大意】lxhgww最近收到了一个01序列，序列里面包含了n个数，这些数要么是0，要么是1，现在对于这个序列有五种变换操作和询问操作：0 a b 把[a,b]区间内的所有数全变成01 a b 把[a,b]区间内的所有数全变成12 a b 把[a,b]区间内的所有数全部取反，也就是说把所有的0变成1，把所有的1变成03 a b 询问[a,b]区间内总共有多少个14 a b 询问[a,b]区间内最多有多少个连续的1对于每一种询问操作，lxhgww都需要给出回答，聪明的程序员们，你们能帮助他吗？【输入格式】输入数据第一行包括2个数，n和m，分别表示序列的长度和操作数目第二行包括n个数，表示序列的初始状态接下来m行，每行3个数，op, a, b，（0&lt;=op&lt;=4，0&lt;=a&lt;=b&lt;n）表示对于区间[a, b]执行标号为op的操作【输出格式】对于每一个询问操作，输出一行，包括1个数，表示其对应的答案【输入样例】10 100 0 0 1 1 0 1 0 1 11 0 23 0 52 2 24 0 40 3 62 3 74 2 81 0 50 5 63 3 9【输出样例】5265 分析本题最重要的只有一点，相通了这个，再注意一下细节就好了。这也是难点：如何解决最长连续的问题呢？考虑用线段树维护区间信息：lmx,rmx,mx,sumlmx和rmx用于在区间合并的时候更新mx，保证正确性。然后就是一些细节问题了，例如标记的传递与先后处理顺序。 最后提醒一句，因为本人老是忘记：反转标记是用xor来修改的还有就是我居然忘记要双倍空间了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=210000;//debug//*******************全局定义*******************struct info&#123; int sum;//个数 int lmx,rmx;//边缘最长连续，合并用 int mx;//最长连续 int all;//长度 info() &#123; lmx=mx=rmx=0; sum=all=0; &#125;&#125;;struct seg&#123; int l,r,mid; int lc,rc; bool tg1,tg1n,tg2; info f[2];&#125;p[MAXN];//*******************info*******************info merg(info a,info b)&#123; info c; c.sum=a.sum+b.sum;c.all=a.all+b.all; c.lmx=a.lmx;if(c.lmx==a.all) c.lmx+=b.lmx; c.rmx=b.rmx;if(c.rmx==b.all) c.rmx+=a.rmx; c.mx=mymax(a.mx,b.mx);c.mx=mymax(c.mx,a.rmx+b.lmx); return c;&#125;void setall(info &amp;a)&#123; a.mx=a.lmx=a.rmx=a.sum=a.all;&#125;void setno(info &amp;a)&#123; a.mx=a.lmx=a.rmx=a.sum=0;&#125;//*******************接口*******************void update(int x)&#123; int lc=p[x].lc,rc=p[x].rc; if(p[x].tg1) &#123; p[x].tg1=0; bool b=p[x].tg1n; setall(p[x].f[b]); setno(p[x].f[!b]); p[lc].tg1=p[rc].tg1=1; p[lc].tg1n=p[rc].tg1n=b; p[lc].tg2=p[rc].tg2=0; &#125; if(p[x].tg2) &#123; p[x].tg2=0; swap(p[x].f[0],p[x].f[1]); update(lc);update(rc);//确保不冲突 p[lc].tg2^=1;p[rc].tg2^=1;//debug,总是忘记 &#125;&#125;int cnt;bool cl[MAXN];int build(int l,int r)&#123; int t=++cnt; p[t].l=l;p[t].r=r; if(l&lt;r) &#123; p[t].mid=(l+r)/2; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); p[t].f[0]=merg(p[p[t].lc].f[0],p[p[t].rc].f[0]); p[t].f[1]=merg(p[p[t].lc].f[1],p[p[t].rc].f[1]); &#125; else &#123; bool b=cl[l]; p[t].f[0].all=p[t].f[1].all=1; setall(p[t].f[b]);setno(p[t].f[!b]); &#125; p[t].tg1=p[t].tg2=0; return t;&#125;void change(int x,int l,int r,bool b)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].tg1=1; p[x].tg1n=b; p[x].tg2=0; return; &#125; update(x); int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) change(lc,l,r,b); else if(l&gt;mid) change(rc,l,r,b); else change(lc,l,mid,b),change(rc,mid+1,r,b); update(lc);update(rc);//debug p[x].f[0]=merg(p[lc].f[0],p[rc].f[0]); p[x].f[1]=merg(p[lc].f[1],p[rc].f[1]);&#125;void opposite(int x,int l,int r)&#123; update(x); if(p[x].l==l and p[x].r==r) &#123; p[x].tg2=1; return; &#125; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) opposite(lc,l,r); else if(l&gt;mid) opposite(rc,l,r); else opposite(lc,l,mid),opposite(rc,mid+1,r); update(lc);update(rc);//debug p[x].f[0]=merg(p[lc].f[0],p[rc].f[0]); p[x].f[1]=merg(p[lc].f[1],p[rc].f[1]);&#125;info ask(int x,int l,int r)&#123; update(x); if(p[x].l==l and p[x].r==r) return p[x].f[1]; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); return merg( ask(lc,l,mid),ask(rc,mid+1,r) );&#125;//*******************主函数*******************int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;cl[i]); cnt=0;build(1,n); while(m--) &#123; int op,a,b;scanf("%d%d%d",&amp;op,&amp;a,&amp;b); a++;b++; if(op==0) change(1,a,b,0); if(op==1) change(1,a,b,1); if(op==2) opposite(1,a,b); if(op==3) &#123; info t=ask(1,a,b); printf("%d\n",t.sum); &#125; if(op==4) &#123; info t=ask(1,a,b); printf("%d\n",t.mx); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3343】教主的魔法]]></title>
    <url>%2Fposts%2Fc57c.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3343 题目【题目大意】教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L,R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高）CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。WD巨懒，于是他把这个回答的任务交给了你。【输入格式】第1行为两个整数N、Q。Q为问题数与教主的施法数总和。第2行有N个正整数，第i个数代表第i个英雄的身高。第3到第Q+2行每行有一个操作：（1）若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。（2）若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。对30%的数据，N≤1000，Q≤1000。对100%的数据，N≤1000000，Q≤3000，1≤W≤1000，1≤C≤1,000,000,000。【输出格式】对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。【输入样例】5 31 2 3 4 5A 1 5 4M 3 5 1A 1 5 4【输出样例】23【样例解释】原先5个英雄身高为1、2、3、4、5，此时[1, 5]间有2个英雄的身高大于等于4。教主施法后变为1、2、4、5、6，此时[1, 5]间有3个英雄的身高大于等于4。 分析普普通通的分块，该说的代码里面有。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************定义*******************int a[1100000],b[1100000],ad[1100000],bk[1100000];//a是原本，b是有序int bl[11000],br[11000];int n,m;//*******************实现*******************void reset(int x)&#123; int ll=bl[x],rr=br[x]; for(int i=ll;i&lt;=rr;i++) b[i]=a[i]; sort(b+ll,b+rr+1);&#125;int find(int x,int c)&#123; int l=bl[x],r=br[x],ans=bl[x]-1;//ans表示最后一个比w小的 while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(b[mid]&lt;c) l=mid+1,ans=mid; else r=mid-1; &#125; return br[x]-ans;&#125;void change(int x,int y,int c)&#123; int ex=bk[x],ey=bk[y]; if(ex==ey) &#123; for(int i=x;i&lt;=y;i++) a[i]+=c; reset(ex); return; &#125; for(int i=x;i&lt;=br[ex];i++) a[i]+=c;reset(ex); for(int i=bl[ey];i&lt;=y;i++) a[i]+=c;reset(ey); //修改完后立即重构，从而降低时间复杂度 //每次两个，即使很多次也胜过一次查询时更新 for(int i=ex+1;i&lt;=ey-1;i++) ad[i]+=c;&#125;int ask(int x,int y,int c)&#123; int ex=bk[x],ey=bk[y],ans=0; if(ex==ey) &#123; for(int i=x;i&lt;=y;i++) if(a[i]+ad[ex]&gt;=c) ans++; return ans; &#125; for(int i=x;i&lt;=br[ex];i++) if(a[i]+ad[ex]&gt;=c) ans++; for(int i=bl[ey];i&lt;=y;i++) if(a[i]+ad[ey]&gt;=c) ans++; for(int i=ex+1;i&lt;=ey-1;i++) ans+=find(i,c-ad[i]); return ans;&#125;//*******************主函数*******************char s[10];int main(int argc, char *argv[])&#123; int q;scanf("%d%d",&amp;n,&amp;q); m=sqrt(n)*2.0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); bk[i]=(i-1)/m+1; &#125; int cnt=n/m; for(int i=1;i&lt;=cnt;i++) &#123; bl[i]=(i-1)*m+1; br[i]=i*m; reset(i); &#125; if(n%m&gt;0) &#123; cnt++; bl[cnt]=br[cnt-1]+1; br[cnt]=n; reset(cnt); &#125; while(q--) &#123; int a,b,c;scanf("%s%d%d%d",s,&amp;a,&amp;b,&amp;c); if(s[0]=='M') change(a,b,c); else printf("%d\n",ask(a,b,c)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1018】【Luogu4246】堵塞的交通]]></title>
    <url>%2Fposts%2F184e.html</url>
    <content type="text"><![CDATA[来源和评测点SHOI2008Bzoj1018Luogu4246 题目【题目大意】给定一张2*n的网格图，多次改变某条边是否可用，多次查询某两个点是否连通【输入格式】第一行只有一个整数C，表示网格的列数。接下来若干行，每行为一条交通信息，以单独的一行“Exit”作为结束。我们假设在一开始所有的道路都是堵塞的。我们保证 C小于等于100000，信息条数小于等于100000。【输出格式】对于每个查询，输出一个“Y”或“N”。【输入样例】2Open 1 1 1 2Open 1 2 2 2Ask 1 1 2 2Ask 2 1 2 2Exit【输出样例】YN 分析其实刚看到这题就觉得LCT然鹅，这并不是树，只好放弃看到行数是2，但一直想不到好办法于是背着良心膜了波题解 居然是线段树！首先假设询问的时候，只和两个点之间的边有关搞一个结构体，里面存有以下信息：h[2][2]表示四个端点的连通性（横、斜着）lb,rb表示上下节点的连通性（竖着）合并的话自己想，常数级别然后考虑两边，如果[1,L]两个右端点连通，等效于[L,R]两个左端点连通如果[R+1,c]两个左端点连通，等效于[L,R]两个右端点连通 目前见过最有意思的线段树题目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************//*******************全局定义*******************struct nod//连通性信息&#123; bool lb,rb;//竖 bool h[2][2];//横、斜 nod() &#123; lb=rb=0; memset(h,0,sizeof(h)); &#125;&#125;;struct seg//线段树节点&#123; int l,r; int lc,rc; nod f; bool tp,bm;//mid和mid+1之间的信息&#125;p[410000];//*******************接口*******************nod merg(nod a,int tp,int bm,nod b)&#123; nod c; c.lb=a.lb or (a.h[0][0] and tp and b.lb and bm and a.h[1][1]); c.rb=b.rb or (b.h[0][0] and tp and a.rb and bm and b.h[1][1]); for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) &#123; c.h[i][j] =a.h[i][0] and tp and b.h[0][j];//上面走 c.h[i][j]|=a.h[i][1] and bm and b.h[1][j];//下面走 &#125; return c;&#125;int cnt;int build(int l,int r)&#123; int t=++cnt; p[t].l=l;p[t].r=r; p[t].tp=p[t].bm=0; if(l&lt;r) &#123; int mid=(l+r)/2; p[t].lc=build(l,mid); p[t].rc=build(mid+1,r); &#125; else p[t].f.h[0][0]=p[t].f.h[1][1]=1;//单点横向必定可以 return t;&#125;void change(int x,int x1,int y1,int x2,int y2,bool b)&#123; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(x1==x2 and y1==mid)//横着，正好中间 &#123; if(x1==0) p[x].tp=b; else p[x].bm=b; p[x].f=merg(p[lc].f,p[x].tp,p[x].bm,p[rc].f); return; &#125; if(p[x].l==p[x].r)//其他单点 &#123; p[x].f.h[0][1]=p[x].f.h[1][0]=p[x].f.lb=p[x].f.rb=b; //tp、bm不需要，作为单点用不到 return; &#125; if(y1&lt;=mid) change(lc,x1,y1,x2,y2,b); else change(rc,x1,y1,x2,y2,b); p[x].f=merg(p[lc].f,p[x].tp,p[x].bm,p[rc].f);&#125;nod ask(int x,int L,int R)&#123; int lc=p[x].lc,rc=p[x].rc,mid=(p[x].l+p[x].r)/2; if(p[x].l==L and p[x].r==R) return p[x].f; if(R&lt;=mid) return ask(lc,L,R); if(L&gt;mid) return ask(rc,L,R); return merg(ask(lc,L,mid),p[x].tp,p[x].bm,ask(rc,mid+1,R));&#125;//*******************主函数*******************char s[20];int main()&#123; int n;scanf("%d",&amp;n); cnt=0;build(1,n); while(1) &#123; scanf("%s",s);if(s[0]=='E') break; int x1,y1,x2,y2;scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(y1&gt;y2) swap(x1,x2),swap(y1,y2);x1--;x2--; if(s[0]=='A') &#123; nod a,b,c; a=ask(1,1,y1);b=ask(1,y1,y2);c=ask(1,y2,n); if(a.rb) b.lb=1;if(c.lb) b.rb=1; bool bk=0; for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) if(b.h[i][j]) if( (i==x1 or b.lb)and(j==x2 or b.rb) ) bk=1; if(bk) printf("Y\n"); else printf("N\n"); &#125; if(s[0]=='O') change(1,x1,y1,x2,y2,1); if(s[0]=='C') change(1,x1,y1,x2,y2,0); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3897】【Vijos1194】Domino]]></title>
    <url>%2Fposts%2F9f71.html</url>
    <content type="text"><![CDATA[来源和评测点Poj2663Vijos1194Caioj1487 题目【题目大意】问用1*2的多米诺骨牌填满m*n的矩阵有多少种方案，结果需要mod p。【输入格式】仅一行，有三个整数，m(m&lt;=5)，n(n&lt;2^31)，p(p&lt;=10^9+7)。【输出格式】输出方案数，结果需要mod p。【输入样例】3 2 5【输出样例】3 分析以下内容在参考网上题解后手打，补充了很多网上题解根本没有提及或者含糊不清的问题，有疑问可评论。 我们先从m=3入手，找到普遍解考虑用二进制表示一列的状态，然后从右往左填充，每次填充一列可以发现问题恰好转化为了：从111开始恰好n步回到111的方案数（显然考场上我是想不出来的，构思的时候细节很多）这时候只要找到方案间的边到底是怎么建立的，然后套上矩阵乘法即可，参考之前的多少条路呢 规则一：不能在第二列竖着放实现：前后方案的状态值，或操作的结果=111解释：因为假如有一个位置或结果是0，而又成功填充了一列，那么显然是竖着放了 规则二：能达到实现：前后方案的状态值，与操作的结果，不会有“连续奇数个”1解释：连续奇数个1意味着非法，因为原本状态值中连续奇数个1，不能添加竖着的domino，也没有其他办法，所以无法达到。 注意，我们构造边的时候其实有个原则（依然想不到）：如果面对某种局面只有一个地方能放置，也就是方案数不变，那么要将它压缩起来 至于为啥全都是双向边，逻辑上我讲不清，但从实现上看，两个状态的先后对得到可达矩阵结果没有影响，所以有对称性（m[i][j]==m[j][i]）不过因为状态太少，没有剪枝的必要 然后规则二的可行结果比较少，手工枚举后如下：00000 000011 300110 601100 1201111 1511000 2411011 2711110 30搞一个常量数组就好，就8个 然后，来个遗言：看到pascal用longint没问题，然后调试了一个小时……珍惜生命，请用longlong 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;//*******************全局常量*******************//*******************全局定义*******************struct martix&#123; ll m[40][40]; martix() &#123; memset(m,0,sizeof(m)); &#125;&#125;;//这次的矩阵从0开始int mx;ll MOD;//*******************接口*******************martix cheng(martix a,martix b)&#123; martix c; for(int i=0;i&lt;=mx;i++) for(int j=0;j&lt;=mx;j++) for(int k=0;k&lt;=mx;k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%MOD)%MOD; return c;&#125;martix power(martix a,int e)&#123; martix ans;for(int i=0;i&lt;=mx;i++) ans.m[i][i]=1; while(e&gt;0) &#123; if(e%2==1) ans=cheng(ans,a); a=cheng(a,a);e/=2; &#125; return ans;&#125;//*******************主函数*******************bool f[40];int main()&#123; f[0]=f[3]=f[6]=f[12]=f[15]=f[24]=f[27]=f[30]=1; int m,n;scanf("%d%d%lld",&amp;m,&amp;n,&amp;MOD);mx=(1&lt;&lt;m)-1; martix a; for(int i=0;i&lt;=mx;i++) for(int j=0;j&lt;=mx;j++) a.m[i][j]=( (i|j)==mx ) and f[i&amp;j]; printf("%lld",power(a,n).m[mx][mx]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度3</tag>
        <tag>矩阵乘法</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打鼹鼠]]></title>
    <url>%2Fposts%2F554a.html</url>
    <content type="text"><![CDATA[来源和评测点毒瘤出题人不一定能用的luogu链接 题目【题目大意】鼹鼠一共在仓库中打了n个洞（用1至n编号），在这n个洞中，有些洞之间是连通的，你可以花费一定的时间从连通的一个洞口处跑到另一个洞口处，然鹅有些洞之间由于货物的堆放等原因并不是连通的，也就是你并不能直接从不连通的一个洞口处跑到另一个洞口处。（但所有的连通关系都是双向的）当你在某一时刻正好在某个洞旁时，如果正好这个洞中有一只出现在洞口处，你就可以用手中的武器（一把大锤）消灭这支鼹鼠，当你在某一时刻停留在某个洞穴处并使用大锤时，该洞当前出现的所有鼹鼠都将被消灭。你有t秒的时间来进行消灭鼹鼠的战斗，你也知道在这t秒内鼹鼠每次出现的时间和位置。那么，你最多能消灭多少只鼹鼠呢？为了尽可能多的消灭鼹鼠，dd_engi为你提供了一种超级武器：如果你在某个特定时刻在某个洞口处使用这个超级武器的话，那么这个洞以及与它直接有边相连的所有洞中此刻出现的鼹鼠都会被消灭掉。然鹅，这个超级武器只能使用一次。你需要编程求出的就是：用或者不用这个超级武器，你分别能消灭多少只鼹鼠？注意：你可以不用完你所给的时间，而且可以有一些时间你并没有来回跑动而是仅仅停在某个洞的旁边。一些题目没有将清楚的要点：1.注意是用超级武器杀死直接相连的，我看错然后从100=&gt;02.只要你某个时刻在那里，就可以杀死所有当时在那里的鼹鼠3.时间可能有0，坐标编号没有04.一开始在哪里任意【输入格式】第一行为三个用空格隔开的整数n、m、t，分别表示鼹鼠洞的个数和连通的边数以及你的时间t。以下m行，每行有三个用空格隔开的整数i、j、k，表示编号i、j的两个鼹鼠洞是双向连通的，从一个运动到另一个需要花费的时间为k。以下每行有三个用空格隔开的整数，第一个整数表示描述的这些鼹鼠将于第几秒末出现，第二个整数表示描述的这些鼹鼠出现的洞的编号，第三个整数表示这次将会出现的鼹鼠的数量。以三个整数0表示输入的结束。输入文件的结尾是一个回车/换行符。【输出格式】只需输出两个用空格隔开的整数，分别表示用和不用超级武器能消灭的最多鼹鼠数。最后以一个回车/换行符结尾。【输入样例】3 2 101 2 12 3 21 1 12 2 23 3 34 1 42 3 34 2 26 1 48 2 310 2 29 1 17 1 53 2 28 1 80 0 0【输出样例】32 29 分析其实是一道灰常简单的dp一开始写了个dfs，我不确定时间复杂度是否相同注意我上面说的要点就好了然后被第一条坑惨了，还用了并查集沾沾自喜…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************实现*******************struct pt&#123; int f[1100]; int hou; pt() &#123; memset(f,0,sizeof(f)); hou=0; &#125;&#125;p[110];struct rod&#123; int y,c,g;&#125;e[21000];int ln=0;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125;//*******************主函数*******************int f[1100][110][2];int ff[1100][110];int main()&#123; int n,m,T;scanf("%d%d%d",&amp;n,&amp;m,&amp;T); for(int i=1;i&lt;=n;i++) ins(i,i,1); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,c); join(x,y); &#125; int a,b,c; while(scanf("%d%d%d",&amp;a,&amp;b,&amp;c)!=EOF) &#123; if(a==0 and b==0 and c==0) break; p[b].f[a]+=c; fal[fa[b]][a]+=c; &#125; int mx1=0,mx2=0; memset(f,0,sizeof(f)); memset(ff,0,sizeof(ff)); for(int t=1;t&lt;=T;t++) &#123; for(int x=1;x&lt;=n;x++) &#123; for(int k=p[x].hou;k&gt;0;k=e[k].g) ff[t][x]+=p[e[k].y].f[t];//包括自己 for(int k=p[x].hou;k&gt;0;k=e[k].g)//包括自己 &#123; int y=e[k].y,c=e[k].c; if(t-c&lt;0) continue; f[t][x][0]=mymax(f[t][x][0],f[t-c][y][0]+p[x].f[t]); f[t][x][1]=mymax(f[t][x][1],f[t-c][y][1]+p[x].f[t]); //f[t][x][1]=mymax(f[t][x][1],f[t-c][y][0]+ff[t][x]); f[t][x][1]=mymax(f[t][x][1],f[t-c][y][0]+fal[fa[x]][t]); &#125; mx1=mymax(mx1,f[t][x][1]),mx2=mymax(mx2,f[t][x][0]); &#125; &#125; printf("%d %d\n",mx1,mx2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3897】【Bzoj2709】迷宫花园]]></title>
    <url>%2Fposts%2Fab3c.html</url>
    <content type="text"><![CDATA[来源和评测点Poj3897Bzoj2709Bzoj的在分析1，Poj的在分析2 题目【题目大意】普通得甚至有些二逼的矮穷挫少年——Dios，不可避免地遇到了他生命中的劫数，白富美少女 Nyution。但是按照正常的校园故事的发展，Nyution 是无论如何不会喜欢上各方面条件都差到不行的 Dios 的。不过，Dios 还是面对 Nyution 颤抖着说出了那三个字。Nyution既不想过分地让 Dios 伤心，又不想接受她根本看不上的 Dios，于是决定让 Dios 走一个建在她家后院里的迷宫花园——如果 Dios 能很快地从起点走到终点，证明他的聪明才智，Nyution就答应他的表白。当然 Nyution 敢这么说肯定是有准备的。Nyution 的花园可以看做一个迷宫，在迷宫内部有起点和终点。Dios 要从起点走到终点，并且他只能选择前后左右四个方向行走，而且显然不能走到篱笆上，也不能走出迷宫的边界。Nyution 经过仔细的调查发现，Dios 移动到相邻格子的耗时肯定是 1。同时，Nyution 将在 Dios 的挑战开始前，通过进行适当的路面调整，使 Dios 在南北方向（数据中的上下方向）的移动时间由 1 变成实数v 。首先，Nyution不能让 Dios 过快地到达终点，这样她就得接受表白；其次，Nyution 也不想让 Dios 开了小宇宙之后还是过慢地到达终点，这样显得她在刁难 Dios。最后她确定了一个实数 L ——就是最坏情况（也就是 Dios 最神勇威武耗时最短的情况）下，Dios 将花费 L 的时间由起点到达终点。但是 Nyution 显然不会求此时的v 值，于是她找到了一向以算法达人著称的你。你当然不会拒绝白富美 Nyution 的请求，决定帮她算出此时的v 。由于 Nyution 不仅是白富美同时也是三好学生，所以她肯定不会给你一个无解的任务。并且，Nyution 的迷宫中一定没有水平的从起点到终点的通路。【输入格式】输入文件包含多个测试点。第一行包含一个整数，表示测试点的数目。每个测试点的第一行包含实数 L 和两个整数 R ,C 。 L 的含义如上， R 表示 Nyution 的花园南北方向的长度，C 表示花园东西方向的长度。之后 R 行为花园的描述，每行包含C 个字符。其中空格（ASCII 码为 32）代表空地，S 代表起点，E 代表终点，# 代表篱笆。显然，起点和终点都是空地。对于 20% 的数据，满足1&lt;=R,C&lt;=10对于另外 20% 的数据，保证答案v 的小数部分为 0对于 100% 的数据，满足1&lt;=R,C&lt;=100 ，保证0&lt;=v&lt;10【输出格式】对于每组测试数据，在单独的一行内输出v 的值，保留 5 位小数。【输入样例】22.5 4 5######S ## E######21 13 12#############S## #E## ## # # ## # # # #### # # # ## # # # ## ## # # ### # # # #### # # # ### # # # ## ## # ## # #############【输出样例】0.500000.21053 分析1然后是好题，这是因为这道题把最短路拓展了，希望大家和我一样，经过这个学会灵活变化，而不要太死脑筋因为这道题可以不去建边的，一开始我还想着把所有边dfs建好，边值自己变化，后来akc提醒才发现没必要 代码11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const double eps=1e-8;//*******************全局定义*******************struct nod&#123; int x,y; nod() &#123;&#125; nod(int xx,int yy) &#123;x=xx,y=yy;&#125;&#125;;//*******************接口*******************double midv;int n,m;int stx,sty;int edx,edy;bool mp[110][110];double d[110][110];queue&lt;nod&gt; q;bool b[110][110];double spfa()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) d[i][j]=0x3f3f3f3f,b[i][j]=0; while(!q.empty()) q.pop(); d[stx][sty]=0;b[stx][sty]=1;q.push( nod(stx,sty) ); while(!q.empty()) &#123; nod tp=q.front();int xx=tp.x,yy=tp.y; for(int i=0;i&lt;=3;i++) &#123; int tx,ty; if(i==0) tx=xx-1,ty=yy;if(i==1) tx=xx+1,ty=yy; if(i==2) tx=xx,ty=yy-1;if(i==3) tx=xx,ty=yy+1; if(tx&lt;1 or tx&gt;n or ty&lt;1 or ty&gt;m or !mp[tx][ty]) continue; double rc=(i&lt;2)?midv:1; if(d[tx][ty]&gt;d[xx][yy]+rc) &#123; d[tx][ty]=d[xx][yy]+rc; if(b[tx][ty]==0) &#123; b[tx][ty]=1; q.push( nod(tx,ty) ); &#125; &#125; &#125; q.pop();b[xx][yy]=0; &#125; return d[edx][edy];&#125;//*******************主函数*******************char s[110];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; double L;scanf("%lf%d%d",&amp;L,&amp;n,&amp;m);gets(s+1);//debug for(int i=1;i&lt;=n;i++) &#123; gets(s+1);//debug for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='#') mp[i][j]=0; else mp[i][j]=1; if(s[j]=='S') stx=i,sty=j; if(s[j]=='E') edx=i,edy=j; &#125; &#125; double l=0,r=10,ans=0;//debug -1 while(r-l&gt;eps)//最后l==r即r-l==0 &#123; midv=(l+r)/2; if(spfa()&lt;=L+eps) ans=midv,l=midv+eps;//spfa()&lt;=L else r=midv-eps; &#125; printf("%.5lf\n",ans); &#125;&#125; 分析2POJ也差不多。。已经用注释表明区别了 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;//*******************全局常量*******************const double eps=1e-8;//*******************全局定义*******************struct nod&#123; int x,y; nod() &#123;&#125; nod(int xx,int yy) &#123;x=xx,y=yy;&#125;&#125;;//*******************接口*******************double midv;int n,m;int stx,sty;int edx,edy;bool mp[110][110];double d[110][110];queue&lt;nod&gt; q;bool b[110][110];double spfa()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) d[i][j]=0x3f3f3f3f,b[i][j]=0; while(!q.empty()) q.pop(); d[stx][sty]=0;b[stx][sty]=1;q.push( nod(stx,sty) ); while(!q.empty()) &#123; nod tp=q.front();int xx=tp.x,yy=tp.y; for(int i=0;i&lt;=3;i++) &#123; int tx,ty; if(i==0) tx=xx-1,ty=yy;if(i==1) tx=xx+1,ty=yy; if(i==2) tx=xx,ty=yy-1;if(i==3) tx=xx,ty=yy+1; if(tx&lt;1 or tx&gt;n or ty&lt;1 or ty&gt;m or !mp[tx][ty]) continue; double rc=(i&lt;2)?midv:1; if(d[tx][ty]&gt;d[xx][yy]+rc) &#123; d[tx][ty]=d[xx][yy]+rc; if(b[tx][ty]==0) &#123; b[tx][ty]=1; q.push( nod(tx,ty) ); &#125; &#125; &#125; q.pop();b[xx][yy]=0; &#125; return d[edx][edy];&#125;//*******************主函数*******************char s[110];int main()&#123; int T;scanf("%d",&amp;T); for(int tt=1;tt&lt;=T;tt++) &#123; double L; //scanf("%lf%d%d",&amp;L,&amp;n,&amp;m); scanf("%lf%d",&amp;L,&amp;n); gets(s+1);//debug for(int i=1;i&lt;=n;i++) &#123; gets(s+1);//debug m=strlen(s+1); for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='#') mp[i][j]=0; else mp[i][j]=1; if(s[j]=='S') stx=i,sty=j; if(s[j]=='E') edx=i,edy=j; &#125; &#125; double l=0,r=10,ans=0;//debug -1 while(r-l&gt;eps)//最后l==r即r-l==0 &#123; midv=(l+r)/2.0; if(spfa()&lt;=L+eps) ans=midv,l=midv+eps;//spfa()&lt;=L else r=midv-eps; &#125; printf("Case #%d: %.3lf%%\n",tt,ans*100.0); //printf("%.5lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花园]]></title>
    <url>%2Fposts%2Fb112.html</url>
    <content type="text"><![CDATA[来源和评测点某场比赛，没拿到数据意会吧 题目【题目大意】【输入格式】【输入样例】5 810 20 30 40 501 21 33 43 5Q 2 5 10C 2 21Q 3 4 21C 6 22Q 1 7 28C 5 20Q 2 5 20Q 2 0 9【输出样例】12031 分析1这是加密前的操作Q 2 5 10C 3 20Q 2 5 20C 4 20Q 3 5 30C 5 20Q 2 5 20Q 1 3 10咳咳先来个清新脱俗的暴力（50分）主要是因为T太大，想不到好方法 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Zory-2018//*******************头文件*******************#pragma once#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct pt&#123; int cl; int hou; int dep; int fa; pt() &#123; hou=0; &#125;&#125;p[MAXN];struct rod&#123; int y,g;&#125;e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************接口*******************void dfs(int x)&#123; p[x].dep=p[ p[x].fa ].dep+1; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa) p[y].fa=x,dfs(y); &#125;&#125;//*******************主函数*******************char s[10];int main()&#123; int n,q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i].cl); for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1); int lans=0; while(q--) &#123; int x,y,t;scanf("%s%d",s,&amp;x);x=x^lans; if(s[0]=='C') &#123; scanf("%d",&amp;t); t=t^lans; p[x].cl=t; &#125; else &#123; scanf("%d%d",&amp;y,&amp;t); y=y^lans;t=t^lans; int ans=0; if(p[x].dep&lt;p[y].dep) swap(x,y); while(p[x].dep!=p[y].dep) &#123; if(p[x].cl==t) ans++; x=p[x].fa; &#125; while(x!=y) &#123; if(p[x].cl==t) ans++; if(p[y].cl==t) ans++; x=p[x].fa;y=p[y].fa; &#125; if(p[x].cl==t) ans++; lans=ans; printf("%d\n",ans); &#125; &#125;&#125; 分析2那么有请Rose大佬登场……对于离散化，我也想到了map，但之后就不会了他一语点醒了我，先%%% 先对颜色进行离散化，最坏情况下100000树链剖分维护结构，然后线段树动态开点，最坏情况下就一条链，然后不存在的节点点值就是0，修改操作的时候维护线段树，询问操作的时候就调用对应线段树查询，空间理论上最坏情况下100000*20，最好情况下也是100000*20但因为删除等，还是会有损耗 以上就是大致思路了嗯因为这道题算比较难的数据结构了，我加上了大量注释 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;//*******************全局常量*******************const int MAXN=110000,MAXM=210000;//*******************全局定义*******************struct pt&#123; int cl;//离散化后的值 int hou; int dep,tot; int fa,son,tp;&#125; p[MAXN];//逻辑上 很多棵线段树//实际上 为了动态开点 只有一个下标 用rt分配struct rod&#123; int y,g;&#125; e[MAXM];int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;//*******************线段树*******************int rt[MAXN];//rt[经过离散化的值]=根节点struct mg&#123; int lc,rc; int c;&#125; sf[MAXN*30];int len=0;//类似于主席树，每次都是增加删除一条链void change(int &amp;x,int l,int r,int p,int z)&#123; if(x==0) x=++len;//新节点 sf[x].c+=z; if(l==r) return; int mid=(l+r)/2; if(p&lt;=mid) change(sf[x].lc,l,mid,p,z); else change(sf[x].rc,mid+1,r,p,z);&#125;int ask(int x,int l,int r,int fl,int fr)&#123; if(x==0) return 0;//减少空间支出 if(l==fl and r==fr) return sf[x].c; int mid=(l+r)/2; if(fr&lt;=mid) return ask(sf[x].lc,l,mid,fl,fr); if(fl&gt;mid) return ask(sf[x].rc,mid+1,r,fl,fr); return ask(sf[x].lc,l,mid,fl,mid)+ask(sf[x].rc,mid+1,r,mid+1,fr);&#125;//*******************树链剖分*******************void dfs(int x)&#123; p[x].tot=1;p[x].son=0; p[x].dep=p[ p[x].fa ].dep+1; for(int k=p[x].hou; k&gt;0; k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa) &#123; p[y].fa=x; dfs(y); p[x].tot+=p[y].tot; if(p[y].tot&gt;p[p[x].son].tot) p[x].son=y; &#125; &#125;&#125;int nln=0;int nb[MAXN];void dfs2(int x,int tp)&#123; nb[x]=++nln;p[x].tp=tp; if(p[x].son&gt;0) dfs2(p[x].son,tp);//debug for(int k=p[x].hou; k&gt;0; k=e[k].g) &#123; int y=e[k].y; if(y!=p[x].fa and y!=p[x].son) dfs2(y,y);//debug &#125;&#125;//*******************接口*******************int n;map&lt;int,int&gt; mp;//key=大数字 元素=离散化后的值int cnt=0;int newcol(int col)&#123; if(mp[col]==0) return mp[col]=++cnt; return mp[col];&#125;//*******************主函数*******************char s[10];int main()&#123; int q;scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; int tc;scanf("%d",&amp;tc); p[i].cl=newcol(tc); &#125; for(int i=1; i&lt;=n-1; i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; p[1].fa=0;dfs(1); dfs2(1,1); for(int i=1;i&lt;=n;i++) change(rt[ p[i].cl ],1,n,nb[i],1); int lans=0; while(q--) &#123; int x,y,col; scanf("%s%d",s,&amp;x);x=x^lans; if(s[0]=='C') &#123; scanf("%d",&amp;col);col=col^lans; change(rt[ p[x].cl ],1,n,nb[x],-1); p[x].cl=newcol(col); change(rt[ p[x].cl ],1,n,nb[x],1); &#125; else &#123; scanf("%d%d",&amp;y,&amp;col); y=y^lans;col=mp[col^lans]; int ans=0; while(p[x].tp!=p[y].tp) &#123; if(p[p[x].tp].dep&lt;p[p[y].tp].dep) swap(x,y); ans+=ask(rt[col],1,n,nb[ p[x].tp ],nb[ x ]); x=p[p[x].tp].fa; &#125; if(p[x].dep&lt;p[y].dep) swap(x,y); lans=ans+ask(rt[col],1,n,nb[y],nb[x]); printf("%d\n",lans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>难度3</tag>
        <tag>好题</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu2157】多少条路呢]]></title>
    <url>%2Fposts%2Fc65d.html</url>
    <content type="text"><![CDATA[来源和评测点小黑2008信息工程学院集训队——选拔赛Hdu2157Caioj1485 题目【题目大意】给定一个有向图，有n个点，m条边。求A点到B点恰好经过k条边的方案数（可走重复边）【输入格式】输入数据有多组，每组第一行有两个整数，n（1&lt;=n&lt;=20)，m(m&lt;=100)，表示有n个点，m条边，点的编号为0~n-1。接下来m行，每行有两个整数，x，y，表示x点能到y点。接下的一行有一个整数，t(1&lt;=t&lt;=100)，表示有t组询问。接着的t行，每行有三个整数，A，B，k(k&lt;20)，表示问你从A点到B点恰好经过k条边的方案数，由于可能方案数灰常大，所以只要计算方案数mod 1000.当n，m为0时，输入结束。【输出格式】输出每次询问的方案数(记得要对1000取模)【输入样例】4 40 10 21 32 320 3 20 3 33 60 11 00 22 01 22 121 2 10 1 30 0【输出样例】2013 分析这道题还是灰常有趣的考虑邻接矩阵的自乘因为有0的话必定无法对结果矩阵作出贡献，所以结果矩阵f[i,j]的值必定是f[i,k]后f[k,j]的总方案数（也就是k=2的情况）那么同理，k的其他情况就是邻接矩阵的k次幂 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=35;//*******************全局定义*******************struct matrix&#123; int row,col; int p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************int mod=1000;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j])%mod; c.row=n;c.col=p; return c;&#125;//*******************主函数*******************int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; if(n==0 and m==0) break; matrix f[20];f[1].row=f[1].col=n; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); f[1].p[x+1][y+1]=1; &#125; for(int i=2;i&lt;=19;i++) f[i]=cheng(f[1],f[i-1]); for(int i=1;i&lt;=n;i++) f[0].p[i][i]=1;//debug int t;scanf("%d",&amp;t); while(t--) &#123; int x,y,k;scanf("%d%d%d",&amp;x,&amp;y,&amp;k); printf("%d\n",f[k].p[x+1][y+1]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1067】守望者的烦恼]]></title>
    <url>%2Fposts%2Fc439.html</url>
    <content type="text"><![CDATA[来源和评测点杜杜我爱你Vijos1067Caioj1485 题目【题目大意】有n个格子，从入口出发（注意，入口不是第一个格子，要另外计算),需要走到最后一个格子（即出口，第n个格子）。每走一步可选择走过1~k个格子，求能走到出口的方案数。【输入格式】仅一行，含有两个整数k(1&lt;=k&lt;=10)，n(1&lt;=n&lt;=2^31-1)【输出格式】输出方案数mod 7777777的值【输入样例】2 4【输出样例】5 分析首先想dp,f[i]=sigma(p=i-k~i-1)[f[p]]然后因为n太大，考虑加速列向量(k+1)/*1,表示近几个f的值，然后推导出一个操作矩阵表示把列向量往前推并计算出最后一个值，然后把这个操作矩阵快速幂n-k-1次即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=20;//*******************全局定义*******************typedef long long ll;struct matrix&#123; int row,col; ll p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************ll mod=7777777;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]%mod+a.p[i][k]*b.p[k][j]%mod)%mod; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c;c.row=c.col=fn; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int k,n;scanf("%d%d",&amp;k,&amp;n); matrix f;f.row=k+1;f.col=k+1; for(int i=1;i&lt;=k;i++) f.p[i][i+1]=1; for(int i=2;i&lt;=k+1;i++) f.p[k+1][i]=1; matrix ans;ans.row=k+1;ans.col=1; for(int i=1;i&lt;=k+1;i++) &#123; if(i&lt;=k) ans.p[i][1]=1;//一步跳过来 for(int j=1;j&lt;=i-1;j++) ans.p[i][1]=(ans.p[i][1]+ans.p[j][1])%mod; &#125; if(n&lt;=k)//debug &#123; printf("%lld",ans.p[n][1]); return 0; &#125; ans=cheng(power(f,n-k-1),ans); printf("%lld",ans.p[k+1][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu1962】Fibonacci数列]]></title>
    <url>%2Fposts%2F53d.html</url>
    <content type="text"><![CDATA[来源和评测点Luogu1962Caioj1484 题目【题目大意】给定n，求第n个Fibonacci数mod 10^9+7的值。注意第一个Fibonacci数为1【输入格式】仅一个整数n【输出格式】输出结果【输入样例】10【输出样例】5 分析一题比一题水 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=110;//*******************全局定义*******************typedef long long ll;struct matrix&#123; int row,col; ll p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************ll mod=1000000007;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j]%mod)%mod; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=(a.p[i][j]+b.p[i][j])%mod; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,ll e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; ll n;scanf("%lld",&amp;n); if(n==1) &#123; printf("1");return 0; &#125; if(n==2) &#123; printf("1");return 0; &#125; matrix f;f.row=2;f.col=2; f.p[1][2]=1;f.p[2][1]=1;f.p[2][2]=1; f=power(f,n-2); matrix ans;ans.row=2;ans.col=1; ans.p[1][1]=1;ans.p[2][1]=1; ans=cheng(f,ans); printf("%lld",ans.p[2][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1483】成群的细菌]]></title>
    <url>%2Fposts%2F34dd.html</url>
    <content type="text"><![CDATA[来源和评测点IPSC 2003 Problem H《算法艺术与信息学竞赛》207页（2.1代数方法和模型，[例题5]细菌，版次不同可能页码有偏差）Caioj1483 题目【题目大意】n个培养皿排成一个圈，每个里面都有一些细菌。培养皿逆时针编号为1,2,…,n，第i个培养皿里有许多个细菌。细菌不停地活动着，它们有可能会进行六种操作：d i 0，表示第i个培养皿的所有细菌都死亡。r i k，表示第i个培养皿的每个细菌分裂成k个。c i j，表示把第j个培养皿的所有细菌复制到第i个培养皿。t i j，表示把第j个培养皿的所有细菌转移到第i个培养皿。s i j，表示交换第i和第j两个培养皿的细菌。m 0 0，表示每个培养皿的细菌都同时转移到它逆时针的下一个培养皿。一旦某个培养皿里有超过s个细菌，每s个细菌会合在一起进化成一个高级组织而脱离培养皿，这些细菌重复的执行着m条命令（编号为0,1,…,m-1），即第X时刻执行第X mod m条命令。问在第t时刻执行命令后，每个培养皿各有多少个细菌？已知初始的时候每个培养皿恰好有一个细菌。【输入格式】第一行，有四个整数，n(n&lt;=100),m(m&lt;=20),t(t&lt;=10^9),s(s&lt;=10^9+7)。接下来m行，每行包括一个字符和两个整数，表示命令的详细信息。【输出格式】仅一行，输出第t时刻时，每个培养皿的细菌个数。末尾没有空格，但有回车。【输入样例】8 6 11 7r 3 5c 5 3d 2 0m 0 0t 6 4s 1 3【输出样例】1 0 0 0 0 4 4 1 分析和上一题差不多，没什么好说的 代码12]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3233】Matrix_Power_Series]]></title>
    <url>%2Fposts%2Ffb98.html</url>
    <content type="text"><![CDATA[来源和评测点POJ Monthly–2007.06.03, Huang, JinsongPoj3233Caioj1481 题目【题目大意】给定一个n行n列的矩阵A，求A+A^2+A^3+…+A^k的结果，并且输出的每个数都mod m【输入格式】第一行含有3个整数n(n≤30),k(k≤10^9) and m(m&lt;10^4)接下来n行表示输入的矩阵。【输出格式】输出结果矩阵【输入样例】2 2 40 11 1【输出样例】1 22 3 分析k灰常大，暴力显然会T设P(t)=A+A^2+….+A^t而P(t*2)=P(t)+A^t/*P(t)也就是说可以二分求解，一下变成O(logk)，灰常快 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局定义*******************struct matrix&#123; int row,col; int p[40][40]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************int MOD;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+(a.p[i][k]*b.p[k][j])%MOD)%MOD; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=(a.p[i][j]+b.p[i][j])%MOD; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;matrix powsum(matrix a,int e)&#123; if(e==1) return a; if(e%2==1) return jia(powsum(a,e-1),power(a,e)); matrix t=powsum(a,e/2); return jia(t,cheng(power(a,e/2),t));&#125;//*******************主函数*******************int main()&#123; int n,k;scanf("%d%d%d",&amp;n,&amp;k,&amp;MOD); matrix s;s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;s.p[i][j]); matrix ans=powsum(s,k); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%d ",ans.p[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vijos1049】送给圣诞夜的礼品]]></title>
    <url>%2Fposts%2Fe353.html</url>
    <content type="text"><![CDATA[来源和评测点Vivian SnowVijos1049Caioj1482 题目【题目大意】有n个数，也就是说初始序列为1,2,3…nm种置换方式（有m行），每行有n个数字，这些数字互不相同而且每个数字都在1到n之间。置换操作方式为设这一行操作的第i个数字为a[i],那么就把原来序列中的第a[i]个数放到新的序列的第i的位置上，然后组成一个新的序列。从第一种置换方式开始操作，一直到最后一种操作，重复上面的操作方式。当最后一种操作结束后，组成了的序列又按照第一种来操作，一直循环下去，直到一共操作了k次为止【输入格式】第一行三个数，n（1&lt;=n&lt;=100)，m(1&lt;=m&lt;=10)和k(1&lt;=k&lt;=2^31-1)接下来m行，每行有n个数【输出格式】一行，一共有n个数，表示最终序列。n个数之间用一个空格隔开，行尾没有空格，需要回车。【输入样例】7 5 86 1 3 7 5 2 43 2 4 5 6 7 17 1 3 4 5 2 65 6 7 3 1 2 42 7 3 4 6 1 5【输出样例】2 4 6 3 5 1 7 分析真心简单把m个操作的每个操作变成一个操作矩阵这m个矩阵相乘，然后快速幂k次，与原始矩阵相乘即可 哦对了，记得因为不满足交换律，结合顺序必须依照原本的顺序如果是列向量的话，就是越左越晚 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=110;//*******************全局定义*******************struct matrix&#123; int row,col; int p[MAXN][MAXN]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************matrix c[20];//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]+=a.p[i][k]*b.p[k][j]; c.row=n;c.col=p; return c;&#125;matrix jia(matrix a,matrix b)&#123; matrix c;c.row=a.row;c.col=a.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) c.p[i][j]=a.p[i][j]+b.p[i][j]; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a);//a*c也行 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k); matrix s;s.row=n;s.col=1;for(int i=1;i&lt;=n;i++) s.p[i][1]=i; matrix f=pre(n); for(int i=1;i&lt;=m;i++) &#123; c[i].row=c[i].col=n; for(int j=1;j&lt;=n;j++) &#123; int t; scanf("%d",&amp;t); c[i].p[j][t]=1; &#125; f=cheng(c[i],f); &#125; int a=k/m,b=k%m; matrix ans=power(f,a); for(int i=1;i&lt;=b;i++) ans=cheng(c[i],ans);//补上多余 ans=cheng(ans,s);//注意顺序 for(int i=1;i&lt;=n;i++) printf("%d ",ans.p[i][1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1480】矩阵无限方]]></title>
    <url>%2Fposts%2Fbfe0.html</url>
    <content type="text"><![CDATA[来源和评测点Caioj1480 题目【题目大意】给定一个n行n列的矩阵A，求出A^x的结果，输出的每个数都mod 10^9+7【输入格式】第一行含有两个整数n(1&lt;=n&lt;=10),x(x&lt;=2^31-1)。接下来n行表示这个矩阵。【输出格式】输出结果矩阵，每行n个数之间用一个空格隔开，行尾没有空格，需要回车【输入样例】2 31 35 2【输出样例】61 66110 83 分析显而易见的裸题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;typedef long long ll;//*******************全局常量*******************const ll MOD=1000000007;//*******************全局定义*******************struct matrix&#123; int row,col; ll p[20][20]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]=(c.p[i][j]+(a.p[i][k]*b.p[k][j])%MOD)%MOD; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;matrix power(matrix a,int e)&#123; matrix c=pre(a.row); while(e&gt;0) &#123; if(e%2==1) --e,c=cheng(c,a); //a*c也行，有的博客误导人啊 //因为快速幂中c其实只是好几个a，再多个a罢了 a=cheng(a,a);e/=2; &#125; return c;&#125;//*******************主函数*******************int main()&#123; int n,x;scanf("%d%d",&amp;n,&amp;x); matrix s;s.row=s.col=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%lld",&amp;s.p[i][j]); matrix ans=power(s,x); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%lld ",ans.p[i][j]); printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Nyoj298】点的变换]]></title>
    <url>%2Fposts%2Fe629.html</url>
    <content type="text"><![CDATA[来源和评测点Nyoj298Caioj1479 题目【题目大意】平面上有不超过10000个点，坐标都是已知的现在可能对所有的点做以下几种操作：详见输入格式操作的次数不超过1000000次，求最终所有点的坐标。提示：如果程序中用到PI的值，可以用acos(-1.0)获得。【输入格式】测试数据的第一行是两个整数N,M，分别表示点的个数与操作的个数(N&lt;=10000,M&lt;=1000000)随后的一行有N对数对，每个数对的第一个数表示一个点的x坐标，第二个数表示y坐标，这些点初始坐标大小绝对值不超过100。随后的M行，每行代表一种操作，行首是一个字符：首字符如果是M,则表示平移操作，该行后面将跟两个数x,y，表示把所有点按向量(x,y)平移;首字符如果是X，则表示把所有点相对于X轴进行上下翻转;首字符如果是Y，则表示把所有点相对于Y轴进行左右翻转;首字符如果是S，则随后将跟一个数P,表示坐标放大P倍;首字符如果是R，则随后将跟一个数A,表示所有点相对坐标原点逆时针旋转一定的角度A(单位是度)【输出格式】每行输出两个数，表示一个点的坐标(对结果四舍五入到小数点后1位，输出一位小数位）点的输出顺序应与输入顺序保持一致【输入样例】2 51.0 2.0 2.0 3.0XYM 2.0 3.0S 2.0R 180【输出样例】-2.0 -2.00.0 0.0 分析首先，假如对每个点一个个进行操作的话，O(NM)显然会超时那怎么办呢？题目中每个操作都是对所有点而言的，也就是所有点都要经过各种操作那么考虑用矩阵乘法加速，把每个操作对应的矩阵推导出来就好了这样有什么好处呢？矩阵乘法不是更慢吗？答案：可以先将所有操作化为一个灰常复杂的操作O(M)，再每个点乘一次就好O(N)，共计O(M+N)提示：由于不满足交换律，所以顺序不能变 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;//*******************全局常量*******************const int MAXN=11000;const double PI=acos(-1.0);//*******************全局定义*******************struct matrix&#123; int row,col; double p[5][5]; matrix() &#123; memset(p,0,sizeof(p)); &#125;&#125;;//*******************全局变量*******************matrix pt[MAXN],c[5],ss;//*******************实现*******************matrix cheng(matrix a,matrix b)&#123; matrix c; int n=a.row,m=a.col,p=b.col; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=m;k++) c.p[i][j]+=a.p[i][k]*b.p[k][j]; c.row=n;c.col=p; return c;&#125;matrix pre(int fn)&#123; matrix c; for(int i=1;i&lt;=fn;i++) c.p[i][i]=1; c.row=c.col=fn; return c;&#125;//*******************主函数*******************char s[5];int main()&#123; //横坐标加a，纵坐标加b c[0].p[1][1]=1;c[0].p[2][2]=1; c[0].p[3][3]=1;c[0].row=c[0].col=3; //把所有点相对于X轴进行上下翻转 c[1].p[1][1]=1;c[1].p[2][2]=-1; c[1].p[3][3]=1;c[1].row=c[1].col=3; //把所有点相对于Y轴进行左右翻转 c[2].p[1][1]=-1;c[2].p[2][2]=1; c[2].p[3][3]=1;c[2].row=c[2].col=3; //坐标放大P倍 c[3].p[3][3]=1;c[3].row=c[3].col=3; //所有点相对坐标原点逆时针旋转一定的角度A(单位是度) c[4].p[3][3]=1;c[4].row=c[4].col=3; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; pt[i].row=3;pt[i].col=1;pt[i].p[3][1]=1; scanf("%lf%lf",&amp;pt[i].p[1][1],&amp;pt[i].p[2][1]); &#125; ss=pre(3); while(m--) &#123; scanf("%s",s); if(s[0]=='M') &#123; double a,b;scanf("%lf%lf",&amp;a,&amp;b); c[0].p[1][3]=a;c[0].p[2][3]=b; ss=cheng(c[0],ss);//不可调换，操作越晚越左 &#125; if(s[0]=='X') ss=cheng(c[1],ss); if(s[0]=='Y') ss=cheng(c[2],ss); if(s[0]=='S') &#123; double p;scanf("%lf",&amp;p); c[3].p[1][1]=p;c[3].p[2][2]=p; ss=cheng(c[3],ss); &#125; if(s[0]=='R') &#123; double a;scanf("%lf",&amp;a); double rad=PI/180.0*a;//转弧度 c[4].p[1][1]=cos(rad);c[4].p[1][2]=-sin(rad); c[4].p[2][1]=sin(rad);c[4].p[2][2]=cos(rad); ss=cheng(c[4],ss); &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; pt[i]=cheng(ss,pt[i]); printf("%.1lf %.1lf\n",pt[i].p[1][1],pt[i].p[2][1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDKOI2018日志&游记]]></title>
    <url>%2Fposts%2F676d.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>赛事</tag>
        <tag>GDKOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1325】Machine Schedule]]></title>
    <url>%2Fposts%2F7392.html</url>
    <content type="text"><![CDATA[来源和评测点Beijing 2002Poj1325 题目【题目大意】有两部机器A和B。A机器有n种工作模式0，1，2，3，……n-1，总共n种。B机器有m种工作模式0，1，2，3，……m-1，总共m种。有k个任务，每个任务可以在 A机器的某个模式 或者 B机器的某个模式中完成。A和B机器开始时都默认在0模式，要选择其他模式就要重启一次。求完成k个任务至少需要重启多少次机器。最后以0结束。输出最少重启机器的次数。【输入格式】第一行三个整数n,m,k(0&lt;n,m&lt;100,0&lt;k&lt;1000），下来k行，每行三个数p，x，y，第一个表示第p个任务，后面两个，表示该任务可以在A机器的x模式完成，或者可以选择B机器的y模式完成该任务。【输出格式】一个整数，为最少重启机器的次数。【输入样例】5 5 100 1 11 1 22 1 33 1 44 2 15 2 26 2 37 2 48 3 39 4 30【输出样例】3 分析请先仔细看题，然后思考。 其实数据的输入形式很多时候就给出了提示，例如这道题中，每个任务与A、B分别有两个可能，与点、边之间的关系灰常像。而要求最少的重启机器次数，显然最好能一个模式做多几个任务，使用过的模式数量之和就是答案。而机器只有两个，又可以联想到二分图匹配。 综上所述，构图如下：把A、B看作两个集合，模式看作点，任务看作边，每个任务连接两个点，最后通过匈牙利算法计算出最大匹配对数，根据定理得到最小点覆盖。 不过……这题目是卡邻接表的么？TLE了改成邻接矩阵就0ms了怀疑数据有超级多重边。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100,MAXM=1000;//*******************全局定义*******************/*struct pt&#123; int hou;&#125;p[2*MAXN];struct rod&#123; int y,g;&#125;e[MAXM];*///*******************实现*******************/*int ln;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;*///*******************接口*******************int n,m,k;int ask[MAXN];int match[MAXN];bool mp[MAXN][MAXN];int t;bool findmuniu(int x)&#123; //for(int k=p[x].hou;k&gt;0;k=e[k].g) for(int i=1;i&lt;=m;i++) &#123; if(mp[x][i]==0) continue; //int i=e[k].y; if(ask[i]&lt;t) &#123; ask[i]=t; if(match[i]==0 or findmuniu(match[i])) //C++中的or逻辑关系，左边true则不会执行右边的语句 &#123; match[i]=x; return 1; &#125; &#125; &#125; return 0;&#125;//*******************主函数*******************int main()&#123; while(scanf("%d",&amp;n) and n!=0) &#123; memset(ask,0,sizeof(ask)); memset(match,0,sizeof(match)); //ln=0;for(int i=1;i&lt;=n+m;i++) p[i].hou=0; memset(mp,0,sizeof(mp)); scanf("%d%d",&amp;m,&amp;k); for(int i=1;i&lt;=k;i++) &#123; int t,a,b; scanf("%d%d%d",&amp;t,&amp;a,&amp;b); //ins(a,n+b); mp[a][b]=1; &#125; int ans=0; for(t=1;t&lt;=n;t++) ans+=findmuniu(t); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1901】Dynamic Rankings]]></title>
    <url>%2Fposts%2F8705.html</url>
    <content type="text"><![CDATA[来源和评测点Author: XIN, TaoSource: Online Contest of Christopher’s AdventureBzoj1901Zju2112 多组数据Luogu2617Caioj1442 题目【题目大意】给n(1&lt;=n&lt;=50000)个数字，进行m(1&lt;=m&lt;=10000)次操作，有两种操作：Q l r k：询问l到r第k小的数。C x k：改变第x个数的值为k。【输入格式】第一行为n和m。接下来一行n个数。接下来m行为m个操作。【输出格式】遇到Q操作就输出。【输入样例】25 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 35 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 3【输出样例】3636 分析建议先阅读本文：【OI之路】06树-6主席树 可持续线段树（主席树）套树状数组 修改操作：原本的add是直接+1，现在考虑添加参数o，表示c要加上o然后先把原本数字删掉，添加新数字即可。但这样修改一个就要修改后面的全部，所以像许多其他题目一样，经典的带修改时用树状数组代替前缀和。 询问操作：也有些不同，因为统计左边部分时，用的只是某一层的值，所以用getsum时，引入函数turn来转向效果更佳~ 然鹅，Zoj死都SF，调了一整天，狂对拍，狂检查，都无济于事，又放弃了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=51000,MAXM=11000;//*******************全局定义*******************int n;int ust[MAXN];int rx;//离散化后最大值//*******************主席树*******************struct nod&#123; int c; int lc,rc;&#125;p[MAXN*17];int rt[MAXN];int cnt;void add(int &amp;x,int l,int r,int pos,int c)&#123; if(x==0) x=++cnt; p[x].c+=c; if(l==r) return;//debug int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos,c); else add(p[x].rc,mid+1,r,pos,c);&#125;//*******************树状数组*******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void change(int x,int p,int c)&#123; while(x&lt;=n) &#123; add(rt[x],1,rx,p,c); x+=lowbit(x); &#125;&#125;int lsum(int x)&#123; int sum=0; while(x&gt;=1) &#123; sum+=p[ p[ust[x]].lc ].c; x-=lowbit(x); &#125; return sum;&#125;//*******************实现******************int now[MAXN];void solve1(int x,int k)&#123; change(x,now[x],-1); now[x]=k; change(x,now[x],1);&#125;void turn(int x,int tn)&#123; while(x&gt;=1) &#123; if(tn==0) ust[x]=rt[x]; if(tn&lt;0) ust[x]=p[ ust[x] ].lc; if(tn&gt;0) ust[x]=p[ ust[x] ].rc; x-=lowbit(x); &#125;&#125;int ask(int x,int y,int l,int r,int k)//l、r锁定&#123; if(l==r) return l; int lm=lsum(y)-lsum(x); int mid=(l+r)/2; if(k&lt;=lm) &#123; turn(x,-1);turn(y,-1); return ask(x,y,l,mid,k); &#125; else &#123; turn(x,1);turn(y,1); return ask(x,y,mid+1,r,k-lm); &#125;&#125;int solve2(int x,int y,int k)&#123; turn(x-1,0);turn(y,0);//初始化 return ask(x-1,y,1,rx,k);&#125;//*******************离散化*******************struct Qes&#123; int op; int x,y,k;&#125;q[MAXM];int num[MAXN+MAXM];//原值struct Lsh&#123; int x,id,z;&#125;a[MAXN+MAXM];bool cmp(Lsh a,Lsh b) &#123;return a.x&lt;b.x;&#125;void lsh(int all)&#123; sort(a+1,a+all+1,cmp); rx=0;a[0].x=-666;//debug for(int i=1;i&lt;=all;i++) &#123; if(a[i-1].x!=a[i].x) num[++rx]=a[i].x; if(a[i].id&lt;=n) a[a[i].id].z=rx; else q[a[i].id-n].k=rx; &#125;&#125;//*******************主函数******************char s[5];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(rt,0,sizeof(rt)); int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=cnt;i++) p[i].c=p[i].lc=p[i].rc=0; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].x),a[i].id=i; int qs=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); if(s[0]=='C') &#123; q[i].op=0; scanf("%d%d",&amp;q[i].x,&amp;q[i].k); qs++; a[n+qs].x=q[i].k; a[n+qs].id=n+i; &#125; else &#123; q[i].op=1; scanf("%d%d%d",&amp;q[i].x,&amp;q[i].y,&amp;q[i].k); &#125; &#125; lsh(n+qs); cnt=0; for(int i=1;i&lt;=n;i++) change(i,a[i].z,1),now[i]=a[i].z; for(int i=1;i&lt;=m;i++) &#123; if(q[i].op==0) solve1(q[i].x,q[i].k); else printf("%d\n",num[ solve2(q[i].x,q[i].y,q[i].k) ]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>主席树</tag>
        <tag>莫队</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3196】【Luogu3380】二逼平衡树]]></title>
    <url>%2Fposts%2Fd7e9.html</url>
    <content type="text"><![CDATA[来源和评测点Tyvj1730Bzoj3196Luogu3380Caioj1135 题目【题目大意】您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：1.查询k在区间内的排名2.查询区间内排名为k的值3.修改某一位值上的数值4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)5.查询k在区间内的后继(后继定义为大于x，且最小的数)【输入格式】第一行两个数 n,m 表示长度为n的有序序列和m个操作第二行有n个数，表示有序序列下面有m行，opt表示操作标号若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继【输出格式】对于操作1,2,4,5各输出一行，表示查询结果【输入样例】9 64 2 2 1 9 4 0 1 12 1 4 33 4 102 1 4 31 2 5 94 3 9 55 2 8 5【输出样例】24349 分析1其他伸展树 第一次树套树，第一次代码行数300+ 线段树关键字：位置关系伸展树关键字：大小关系 n=m=50000，num=100000000logn=16，lognum=27建树2n颗，nlogn个节点，时间nlogn 接下来分析几个操作：1.查排名，(区间logn)*(前驱logn)=256，（每个完整子区间中k的排名-1）之和+12.找数字，(二分lognum)*(区间logn)*(后继logn)=6912，调用操作1，二分数字，验证3.改数字，2*(深度logn)*(伸展操作logn)=512，删除，添加4.5.前驱后继，(区间logn)*(前驱后继logn)=256，每个完整子区间中k的前驱后继的极值总时间：极限200000000即3s 从线段树的角度看：每个区间一个线段树从Splay的角度看：所有的Splay都挂在超级根节点Root上，注意我采取某些手段避免了Root向下认儿子 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=50000+10;const int NUL=-1;const int Root=0;const int INF=0x7fffffff;//*******************Splay1-基础操作*******************struct pt&#123; int son[2],f; int d; int n,c; pt() &#123; son[0]=son[1]=f=NUL; &#125;&#125;p[30*MAXN];int ln=0;void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc!=NUL) p[x].c+=p[lc].c; if(rc!=NUL) p[x].c+=p[rc].c;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; if(ff!=Root) &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; if(xson!=NUL) p[xson].f=f; p[f].son[1-w]=xson; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;void add(int d,int f)&#123; ln++; p[ln].d=d;p[ln].f=f; p[ln].n=p[ln].c=1; p[ln].son[0]=p[ln].son[1]=NUL; if(f!=Root) &#123; if(d&lt;p[f].d) p[f].son[0]=ln; else p[f].son[1]=ln; &#125;&#125;//*******************Splay2-与根有关*******************int root[2*MAXN];void splay(int r,int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==Root) root[r]=x;&#125;int findip(int r,int d)&#123; int x=root[r]; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(d&lt;p[x].d) &#123; if(lc!=NUL) x=lc; else break; &#125; else &#123; if(rc!=NUL) x=rc; else break; &#125; &#125; return x;&#125;void ins(int r,int d)&#123; if(root[r]==NUL) &#123; add(d,Root); root[r]=ln; &#125; else &#123; int x=findip(r,d); if(p[x].d==d) &#123; p[x].n++; splay(r,x,Root); &#125; else &#123; add(d,x); splay(r,ln,Root); &#125; &#125;&#125;void del(int r,int d)&#123; int x=findip(r,d); if(p[x].d!=d) return; splay(r,x,Root); if(p[x].n&gt;1) &#123; p[x].n--; update(x); &#125; else &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==NUL and rc==NUL) &#123; root[r]=NUL; &#125; else if(lc!=NUL and rc==NUL) &#123; root[r]=lc; p[lc].f=Root; &#125; else if(lc==NUL and rc!=NUL) &#123; root[r]=rc; p[rc].f=Root; &#125; else &#123; int w=lc;while(p[w].son[1]&gt;0) w=p[w].son[1]; splay(r,w,x);root[r]=w;p[w].f=Root; p[w].son[1]=rc;p[rc].f=w; update(w); &#125; &#125;&#125;int findQ(int r,int d)&#123; int x=findip(r,d);splay(r,x,Root); if(p[x].d&gt;=d and p[x].son[0]!=NUL) &#123; x=p[x].son[0]; while(p[x].son[1]!=NUL) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return p[x].d; return -INF;&#125;int findH(int r,int d)&#123; int x=findip(r,d);splay(r,x,Root); if(p[x].d&lt;=d and p[x].son[1]!=NUL) &#123; x=p[x].son[1]; while(p[x].son[0]!=NUL) x=p[x].son[0]; &#125; if(p[x].d&gt;d) return p[x].d; return INF;&#125;int findbf(int r,int d)//更小的&#123; int x=findip(r,d);splay(r,x,Root); int lc=p[x].son[0]; if(p[x].d==d) return p[ (lc==NUL)?0:lc ].c; if(p[x].d&gt;d and lc!=NUL) &#123; x=lc; while(p[x].son[1]!=NUL) x=p[x].son[1]; &#125; if(p[x].d&lt;d) &#123; splay(r,x,Root);lc=p[x].son[0]; return p[ (lc==NUL)?0:lc ].c+p[x].n; &#125; else return 0;&#125;//*******************线段树*******************int num[MAXN];struct mg&#123; int l,r; int lc,rc;&#125;s[2*MAXN];int len=0;int build(int l,int r)&#123; int t=++len;s[t].l=l;s[t].r=r; for(int i=l;i&lt;=r;i++) ins(t,num[i]); //把t作为根节点的下标 if(l==r) s[t].lc=s[t].rc=NUL; else &#123; int mid=(l+r)/2; s[t].lc=build(l,mid); s[t].rc=build(mid+1,r); &#125; return t;&#125;void change(int x,int pos,int yd,int d)//改数字&#123; del(x,yd);ins(x,d); if(s[x].l==s[x].r) return; int mid=(s[x].l+s[x].r)/2; if( pos&lt;=mid ) change(s[x].lc,pos,yd,d); else change(s[x].rc,pos,yd,d);&#125;//*******************接口*******************int solve1(int x,int l,int r,int d)//查排名&#123; if(s[x].l==l and s[x].r==r) return findbf(x,d); int lc=s[x].lc,rc=s[x].rc,mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve1(lc,l,r,d); if(l&gt;mid) return solve1(rc,l,r,d); return solve1(lc,l,mid,d)+solve1(rc,mid+1,r,d);&#125;int solve2(int l,int r,int k)//找数字&#123; int ll=0,rr=100000000,ans=-1; //满足运用二分的条件，因为数字与排名成正比 while(ll&lt;=rr) &#123; int mid=(ll+rr)/2,rk=solve1(1,l,r,mid)+1; if(rk&lt;=k) ans=mid,ll=mid+1; else rr=mid-1; &#125; return ans;&#125;int solve4(int x,int l,int r,int d)//前驱&#123; if(s[x].l==l and s[x].r==r) &#123; int t=findQ(x,d); return (t==NUL)?0:t; &#125; int lc=s[x].lc,rc=s[x].rc,mid=mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve4(lc,l,r,d); if(l&gt;mid) return solve4(rc,l,r,d); return mymax( solve4(lc,l,mid,d),solve4(rc,mid+1,r,d) );&#125;int solve5(int x,int l,int r,int d)//后继&#123; if(s[x].l==l and s[x].r==r) &#123; int t=findH(x,d); return (t==NUL)?0x3f3f3f3f:t; &#125; int lc=s[x].lc,rc=s[x].rc,mid=(s[x].l+s[x].r)/2; if(r&lt;=mid) return solve5(lc,l,r,d); if(l&gt;mid) return solve5(rc,l,r,d); return mymin( solve5(lc,l,mid,d),solve5(rc,mid+1,r,d) );&#125;//*******************主函数*******************int main()&#123; memset(root,NUL,sizeof(root)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); build(1,n); while(m--) &#123; int op;scanf("%d",&amp;op); if(op==3) &#123; int pos,d;scanf("%d%d",&amp;pos,&amp;d); change(1,pos,num[pos],d);num[pos]=d; &#125; else &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); if(op==1) printf("%d\n",solve1(1,l,r,k)+1); if(op==2) printf("%d\n",solve2(l,r,k)); if(op==4) printf("%d\n",solve4(1,l,r,k)); if(op==5) printf("%d\n",solve5(1,l,r,k)); &#125; &#125;&#125; 分析2然鹅Bzoj的评论里面有这样几句话：“用平衡树的都是二逼青年”“有智慧的长者都写主席树”so，依旧被D飞赶紧复习一波主席树 哦补充一下，我在打的时候突然想到一个问题：假如r的lowbit覆盖了l-1,那么它不就会turn两次了？后来经提醒发现，这种turn两次的情况理论上虽然是错的，但因为他们都是被覆盖两次的，所以求前缀和的时候刚好抵消了…… 优点就是少了一百行……，速度还快了三倍！ 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207//Zory-2018//*******************主函数******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#ifdef WIN32#define BIGN "%I64d"#else#define BIGN "%lld"#endifusing namespace std;typedef long long ll;//*******************全局常量*******************const int MAXN=50010,MAXM=50010;const int INF=0x7fffffff;//*******************全局定义*******************int n;int rx;int num[MAXN+MAXM];int now[MAXN];//*******************主席树******************struct Nod&#123; int c; int lc,rc; Nod() &#123;c=lc=rc=0;&#125;&#125;p[MAXN*20*10];int rt[MAXN];int ust[MAXN];int cnt=0;void add(int &amp;x,int l,int r,int pos,int c)&#123; if(!x) x=++cnt; p[x].c+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(p[x].lc,l,mid,pos,c); else add(p[x].rc,mid+1,r,pos,c);&#125;//*******************树状数组******************int lowbit(int x) &#123;return x&amp;(-x);&#125;void change(int x,int pos,int c)&#123; while(x&lt;=n) &#123; add(rt[x],1,rx,pos,c); x+=lowbit(x); &#125;&#125;int getlsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ p[ust[x]].lc ].c; x-=lowbit(x); &#125; return s;&#125;int getsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ust[x]].c; x-=lowbit(x); &#125; return s;&#125;int getrsum(int x)&#123; int s=0; while(x&gt;=1) &#123; s+=p[ p[ust[x]].rc ].c; x-=lowbit(x); &#125; return s;&#125;void turn(int x,int tn)&#123; while(x&gt;=1) &#123; if(tn==0) ust[x]=rt[x]; if(tn==-1) ust[x]=p[ ust[x] ].lc; if(tn==1) ust[x]=p[ ust[x] ].rc; x-=lowbit(x); &#125;&#125;//*******************实现******************struct Qes&#123; int op; int x,y,k;&#125;q[MAXM];int qian;int ask1(int x,int y,int l,int r,int k)&#123; if(l==r) return qian; int mid=(l+r)&gt;&gt;1; if(k&lt;=mid) &#123; turn(x-1,-1);turn(y,-1); return ask1(x,y,l,mid,k); &#125; else &#123; qian+=getlsum(y)-getlsum(x-1); turn(x-1,1);turn(y,1); return ask1(x,y,mid+1,r,k); &#125;&#125;int solve1(int l,int r,int k)//k在区间内的排名&#123; turn(l-1,0);turn(r,0); qian=0; return ask1(l,r,1,rx,k)+1;&#125;int ask2(int x,int y,int l,int r,int k)&#123; if(l==r) return num[l]; int ls=getlsum(y)-getlsum(x-1); int mid=(l+r)&gt;&gt;1; if(k&lt;=ls) &#123; turn(x-1,-1);turn(y,-1); return ask2(x,y,l,mid,k); &#125; else &#123; turn(x-1,1);turn(y,1); return ask2(x,y,mid+1,r,k-ls); &#125;&#125;int solve2(int l,int r,int k)//区间内排名为k的值&#123; turn(l-1,0);turn(r,0); return ask2(l,r,1,rx,k);&#125;void solve3(int pos,int k)//修改&#123; change(pos,now[pos],-1); now[pos]=k; change(pos,now[pos],1);&#125;int solve4(int l,int r,int k)//查询k在区间内的前驱，没有则-INF&#123; int t=solve1(l,r,k)-1; if(t==0) return -INF; return solve2(l,r,t);&#125;int solve5(int l,int r,int k)//查询k在区间内的后继，没有则INF&#123; int t=solve1(l,r,k+1)-1; if(t==(r-l+1)) return INF; return solve2(l,r,t+1);&#125;//*******************离散化******************struct Lsh&#123; int x,id,z;&#125;a[MAXN+MAXM];bool cmp(Lsh a,Lsh b) &#123;return a.x&lt;b.x;&#125;void lsh(int all)&#123; sort(a+1,a+all+1,cmp); rx=0;a[0].x=-INF; for(int i=1;i&lt;=all;i++) &#123; if(a[i-1].x!=a[i].x) num[++rx]=a[i].x;//debug if(a[i].id&lt;=n) a[a[i].id].z=rx; else q[a[i].id-n].k=rx; &#125;&#125;//*******************主函数******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].x),a[i].id=i; int all=n; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;q[i].op,&amp;q[i].x); if(q[i].op==2) scanf("%d%d",&amp;q[i].y,&amp;q[i].k); else &#123; all++; if(q[i].op!=3) scanf("%d",&amp;q[i].y); scanf("%d",&amp;a[all].x); a[all].id=n+i; &#125; &#125; lsh(all); for(int i=1;i&lt;=n;i++) now[i]=a[i].z,change(i,now[i],1); for(int i=1;i&lt;=m;i++) &#123; if(q[i].op==1) printf("%d\n",solve1(q[i].x,q[i].y,q[i].k)); if(q[i].op==2) printf("%d\n",solve2(q[i].x,q[i].y,q[i].k)); if(q[i].op==3) solve3(q[i].x,q[i].k); if(q[i].op==4) printf("%d\n",solve4(q[i].x,q[i].y,q[i].k)); if(q[i].op==5) printf("%d\n",solve5(q[i].x,q[i].y,q[i].k)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>莫队</tag>
        <tag>线段树</tag>
        <tag>伸展树</tag>
        <tag>树套树</tag>
        <tag>难度3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WZK的减肥计划]]></title>
    <url>%2Fposts%2Ff8f3.html</url>
    <content type="text"><![CDATA[来源和评测点NOIP2009 赛前集训（CZYZ2009 暑假集训提高组 5） 题目【题目大意】有 n 种食品可供 WZK 选择，每种物品都有给定的价格，卡路里和拥有数量，选出一些食品使得总卡路里大于要求量且最小，如果有多种组合满足条件， 则取价格最小的。【输入格式】第一行为两个整数 n(0&lt;n&lt;=100)，k（0&lt;k&lt;=10^5）分别表示物品个数和一天消耗的最少卡路里。接下来n行每行 3 个整数，costi，mi，cali（0&lt; costi,1&lt;=mi&lt;=100,cali&lt;10^6）分别表示价格，数量和所含卡路里。输入数据保证合法、有解。【输出格式】满足条件的总卡路里和总价格，中间用一个空格隔开。注意：保证答案的总卡路里小于 10^5，总价格小于 10^8。【输入样例】5 1010 2 65 1 96 1 69 1 65 1 9【输出样例】12 15 分析话说今天生日耶，刷个卡~ 注意，逻辑上答案应该是可以何要求值（原题为WZK的需求量）一样的，但题目确实要求大于，机房许多大佬都错了，就是因为这个，暴0时间复杂度nk，应该这个才是正解，虽然数据水体现不出来注意现在更像多重背包了重点：c也就是使用量只跟物品有关，考试时以为实现不出来 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int a,int b) &#123;return a&lt;b?a:b;&#125;int f[100010],c[100010];int main()&#123; freopen("plan.in","r",stdin); freopen("plan.out","w",stdout); memset(f,63,sizeof(f)); f[0]=0;int mi=100000; int n,k;scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)//100 &#123; memset(c,0,sizeof(c));//c=在这个物品下，f对应的物品使用量 int cost,m,cal;scanf("%d%d%d",&amp;cost,&amp;m,&amp;cal); for(int j=0;j&lt;=k;j++)//100000 &#123; if(c[j]&lt;m) &#123; int ca=j+cal; if(ca&gt;k and ca&lt;mi) mi=ca; if(f[j]+cost&lt;f[ca]) &#123; c[ca]=c[j]+1; f[ca]=f[j]+cost; &#125; &#125; &#125; &#125; printf("%d %d\n",mi,f[mi]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3224】普通平衡树]]></title>
    <url>%2Fposts%2Fe070.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3224Codevs4543Caioj1130 题目【题目大意】写一种数据结构来维护一些数，其中需要提供以下操作：1. 插入数字x2. 删除数字x(若有多个相同的数，应只删除一个)3. 查询数字x的排名(若有多个相同的数，因输出最小的排名)4. 查询排名为x的数5. 求数字x的前驱(前驱定义为小于x，且最大的数)6. 求数字x的后继(后继定义为大于x，且最小的数)【输入格式】第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号1&lt;=opt&lt;=6 n&lt;=100000 所有数字均在-2*10^9到2*10^9内【输出格式】对于操作3,4,5,6每行输出一个数，表示对应答案【输入样例】81 101 201 303 204 22 105 256 -1【输出样例】2202020 分析【OI之路】06树-4伸展树的模版 核心思路在于：对于某节点，左子树是关键字（在这道题中是大小关系）比该节点大的，右子树比该节点小接着在保证这个平衡（中序遍历保持不变）的情况下，进行各种操作 旋转Rotate 旋转到某节点下Splay网上的一段话: 在实际情况中，90%的访问发生在10%的数据上。因此，我们可以重构树的结构，使得被经常访问的节点朝树根的方向移动。尽管这会引入额外的操作，但是经常被访问的节点被移动到了靠近根的位置，因此，对于这部分节点，我们可以很快的访问。这样，就能使得平摊复杂度为logN。伸展树就是基于这一原理。 很多细节可以考虑大量注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100000;const int Nul=-1;//空节点const int Root=0;//超级根//**********************定义*************************struct pt&#123; int son[2],f; int d;//值 int c,n;//n是同值个数，c是管理节点数（包括自己） pt() &#123; son[0]=son[1]=f=Nul;//debug &#125;&#125;p[2*MAXN];//***********************基本操作***********************void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc!=Nul) p[x].c+=p[lc].c; if(rc!=Nul) p[x].c+=p[rc].c;&#125;int ln=0;void add(int d,int f)&#123; ln++; p[ln].d=d;p[ln].f=f; p[ln].c=p[ln].n=1; p[ln].son[0]=p[ln].son[1]=Nul; if(f&gt;0)//debug &#123; if(d&lt;p[f].d) p[f].son[0]=ln; else p[f].son[1]=ln; &#125;&#125;int root=Nul;//真实根int findip(int d)&#123; int x=root; while(p[x].d!=d) &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(d&lt;p[x].d) &#123; if(lc!=Nul) x=lc; else break; &#125; else &#123; if(rc!=Nul) x=rc; else break; &#125; &#125; return x;&#125;//有同值返回该点，否则某叶子节点void rotate(int x,int w)//w=0 x的父亲成为x的左孩子&#123; int f=p[x].f,ff=p[f].f; if(ff&gt;0)//debug &#123; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; &#125; p[x].f=ff; int xson=p[x].son[w]; p[f].son[1-w]=xson; if(xson!=Nul) p[xson].f=f; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;void splay(int x,int rt)//x成为rt的孩子&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; //x不能连续跳两次，灰常容易变成链（由树退化成链表） if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==Root) root=x;&#125;//***********************功能************************void inc(int d)&#123; if(root==Nul) &#123; add(d,Root); root=ln; &#125; else &#123; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; splay(x,Root); //在里面自动进行了update //询问前n不重要 &#125; else &#123; add(d,x); splay(ln,Root); //据说：90%的访问发生在10%的数据上 &#125; &#125;&#125;void del(int d)&#123; int x=findip(d); if(p[x].d!=d) return; splay(x,Root); if(p[x].n&gt;1) &#123; p[x].n--; update(x); &#125; else &#123; int lc=p[x].son[0],rc=p[x].son[1]; if(lc==Nul and rc==Nul) &#123; ln=0;root=Nul; &#125; else if(lc==Nul and rc!=Nul) &#123; root=rc; p[root].f=Root; &#125; else if(lc!=Nul and rc==Nul) &#123; root=lc; p[root].f=Root; &#125; else &#123; int k=lc; while(p[k].son[1]!=Nul) k=p[k].son[1]; splay(k,x);root=k;p[k].f=Root; p[k].son[1]=rc;p[p[x].son[1]].f=k; update(k);//debug &#125; &#125;&#125;int askrank(int d)&#123; int x=findip(d); if(p[x].d!=d) return -1; splay(x,Root); int lc=p[x].son[0],lcc=(lc==Nul)?0:p[lc].c;//debug return lcc+1;&#125;int asknum(int rk)&#123; int x=root; while(1) &#123; if(rk&gt;p[x].c) return -1; int lc=p[x].son[0],lcc=(lc==Nul)?0:p[lc].c; if(rk&lt;=lcc) x=lc; else if(rk&gt;lcc+p[x].n) rk-=lcc+p[x].n,x=p[x].son[1]; else break; &#125; splay(x,Root); return p[x].d;&#125;int findQ(int d)&#123; int x=findip(d);splay(x,Root); if(p[x].d&gt;=d and p[x].son[0]!=Nul) &#123; x=p[x].son[0]; while(p[x].son[1]&gt;0) x=p[x].son[1]; &#125; if(p[x].d&lt;d) return p[x].d; return -1;&#125;int findH(int d)&#123; int x=findip(d);splay(x,Root); if(p[x].d&lt;=d and p[x].son[1]!=Nul) &#123; x=p[x].son[1]; while(p[x].son[0]&gt;0) x=p[x].son[0]; &#125; if(p[x].d&gt;d) return p[x].d; return -1;&#125;//***********************************************int main()&#123; int n;scanf("%d",&amp;n); while(n--) &#123; int opx,x;scanf("%d%d",&amp;opx,&amp;x); if(opx==1) inc(x); if(opx==2) del(x); if(opx==3) printf("%d\n",askrank(x)); if(opx==4) printf("%d\n",asknum(x)); if(opx==5) printf("%d\n",findQ(x)); if(opx==6) printf("%d\n",findH(x)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Ural1028】【Vijos1066】弱弱的战壕]]></title>
    <url>%2Fposts%2F5d1d.html</url>
    <content type="text"><![CDATA[来源和评测点Problem Author: Pavel ZaletskyProblem Source: Ural Collegiate Programming Contest ‘99Ural1028Vijos1066 题目【题目大意】永恒和mx正在玩一个即时战略游戏，名字嘛~~恕本人记性不好，忘了。mx在他的基地附近建立了n个战壕，每个战壕都是一个独立的作战单位，射程可以达到无限。但是，战壕有一个弱点，就是只能攻击它的左下方，说白了就是横纵坐标都不大于它的点（mx：“我的战壕为什么这么菜”ToT）。这样，永恒就可以从别的地方进攻摧毁战壕，从而消灭mx的部队。战壕都有一个保护范围，同它的攻击范围一样，它可以保护处在它左下方的战壕。所有处于它保护范围的战壕都叫做它的保护对象。这样，永恒就必须找到mx的战壕中保护对象最多的点，从而优先消灭它。现在，由于永恒没有时间来计算，所以拜托你来完成这个任务：给出这n个战壕的坐标xi、yi，要你求出保护对象个数为0，1，2……n-1的战壕的个数。【输入格式】第一行，一个正整数n（1&lt;=n&lt;=15000）接下来n行，每行两个数xi,yi，代表第i个点的坐标（1&lt;=xi,yi&lt;=32000）注意：可能包含多重战壕的情况（即有数个点在同一坐标）【输出格式】输出n行，分别代表保护对象为0，1，2……n-1的战壕的个数。【输入样例】51 15 17 13 35 5【输出样例】12110 分析做做难度不大但有所创新的题目还是挺好的先排序一遍确保形如这样123* - **** ****** ***** *** 按顺序处理就保证了y更小接着用树状数组维护x的前缀和即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=15000;//*******************全局定义*******************struct pt&#123; int x,y;&#125;p[MAXN+10];//*******************接口*******************int lowbit(int x) &#123;return x&amp;-x;&#125;int s[32000+10];void add(int f)&#123; while(f&lt;=32001) &#123; s[f]+=1; f+=lowbit(f); &#125;&#125;int ask(int r)&#123; int sum=0; while(r&gt;0) &#123; sum+=s[r]; r-=lowbit(r); &#125; return sum;&#125;//*******************主函数*******************bool cmp(pt a,pt b)&#123; if(a.y==b.y) return a.x&lt;=b.x; return a.y&lt;=b.y; /* * - **** ***** * ***** *** */&#125;int ans[MAXN+10];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p+1,p+1+n,cmp); for(int i=1;i&lt;=n;i++) &#123; ans[ask(p[i].x+1)]++; add(p[i].x+1); &#125; for(int i=0;i&lt;=n-1;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1012】最大数]]></title>
    <url>%2Fposts%2F5f48.html</url>
    <content type="text"><![CDATA[来源和评测点JSOI2008数据Bzoj1012 题目【题目大意】现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。2、 插入操作。语法：A n 功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个数。【输入格式】第一行两个整数，M和D，其中M表示操作的个数(M &lt;= 200,000)，D如上文中所述，满足D在longint内。接下来M行，查询操作或者插入操作。【输出格式】对于每一个询问操作，输出一行。该行只有一个数，即序列中最后L个数的最大数。【输入样例】5 100A 96Q 1A 97Q 1Q 2【输出样例】969396 分析1看似插入是Splay，其实结构并没有变化。加上区间查询，考虑线段树，建树的时候保留空位就好了。 代码11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************** Problem: 1012 User: Zory Language: C++ Result: Accepted Time:1076 ms Memory:10196 kb****************************************************************/ //Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;//*******************全局常量*******************const int MAXN=200000;//*******************全局定义*******************struct pt&#123; int l,r,mid; int lc,rc; int mx;&#125;p[MAXN*2+10];//*******************线段树*******************void change(int x,int pf,int c)&#123; if(p[x].l==p[x].r) &#123; p[x].mx=c; return; &#125; int lc=p[x].lc,rc=p[x].rc; if(pf&lt;=p[x].mid) change(lc,pf,c); else change(rc,pf,c); p[x].mx=mymax(p[lc].mx,p[rc].mx);&#125;int ask(int x,int l,int r)&#123; if(p[x].l==l and p[x].r==r) return p[x].mx; int lc=p[x].lc,rc=p[x].rc; int mid=p[x].mid; if(r&lt;=mid) return ask(lc,l,r); else if(l&gt;mid) return ask(rc,l,r); else return mymax( ask(lc,l,mid),ask(rc,mid+1,r) );&#125;//*******************接口*******************int ln=0;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].mid=(l+r)/2; p[t].mx=0; if(l==r) p[t].lc=p[t].rc=-1; else &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;//*******************主函数*******************char s[5];int main()&#123; int m,D;scanf("%d%d",&amp;m,&amp;D); build(1,m);int len=0,t=0; while(m--) &#123; int a;scanf("%s%d",s,&amp;a); if(s[0]=='Q') &#123; t=ask(1,len-a+1,len); printf("%d\n",t); &#125; else change(1,++len,(a+t)%D); &#125;&#125; 分析2然后看到了六个月前的代码，原来暴力还更快…… 代码21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/************************************************************** Problem: 1012 User: Zory Language: C++ Result: Accepted Time:468 ms Memory:2384 kb****************************************************************/ #include&lt;cstdio&gt;//#include&lt;cstdlib&gt;//#include&lt;cstring&gt;//#include&lt;cctype&gt;//#include&lt;cmath&gt;//#include&lt;ctime&gt;//#include&lt;queue&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;//#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;//*******************实现*******************char s[5];int a[200010],mx[200010];int main(int argc, char *argv[])&#123; int m,p;scanf("%d%d",&amp;m,&amp;p); int len=0,k=0; for(int i=1;i&lt;=m;i++) &#123; int t; scanf("%s %d",s,&amp;t); if(s[0]=='A') &#123; a[++len]=(t+k)%p; for(int j=len;j;j--) if(mx[j]&lt;a[len]) mx[j]=a[len]; else break;//剪枝 &#125; else printf("%d\n",k=mx[len-t+1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CZYZ2009暑假集训提高组6】盟军敢死队]]></title>
    <url>%2Fposts%2F310b.html</url>
    <content type="text"><![CDATA[来源和评测点CZYZ2009暑假集训提高组6 题目【题目大意】仓库是一个 m*n的矩形区域， 每一格用一个字符来描述：“.” 代表空地; “#”代表墙或障碍物;“^”, “v”(小写), “&lt;”, “&gt;”四个字符分别表示正向 NSWE 四个方向看的敌人。敌人总是保持固定不动并朝着一个方向看，从这个方向一直延伸直到边界或障碍物的区域是他的视线范围，如果一个敌人没有在任何人的视线范围之内，敢死队员就可以消灭他。你不能消灭一个正在另一个活着的敌人视线范围内的敌人，否则你就会被发现，后果不堪设想。一个敌人不会成为遮挡视线的障碍物。【输入格式】输入数据的第一行是用空格分开的两个整数 n,m ，分别表示仓库的长和宽。接下来有 n行，每行 m个字符，是仓库的描述。100%的数据中，1&lt;=m, n&lt;=6090%的数据中，敌人数不超过 10100%的数据中，敌人数不超过 15【输出格式】如果能够成功消灭所有敌人，输出消灭所有敌人的不同顺序的数量，否则输出“Impossible” （不含引号）。【输入样例1】2 2&gt;^#^【输出样例1】2【输入样例2】1 3&gt;.&lt;【输出样例2】Impossible 分析挺好的状压题注释很详细“一看数据范围就知道是状压”话说有的人一看就觉得是暴力，其实也有道理事实上时间是压着过去的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//**********************************************struct pr&#123; int x,y; int tr;&#125;p[20];int pn;bool rd[20][20];//i能否看到j//**********************************************int mp[100][100];//**********************************************int f[1&lt;&lt;15];//状态方案数bool chw[20][1&lt;&lt;15];//j状态下能否杀i//状态用二进制表示，1就是死了//**********************************************char s[100];int bin[21];int main()&#123; pn=0;memset(rd,0,sizeof(rd));memset(chw,0,sizeof(chw)); bin[1]=1;for(int i=2;i&lt;=20;i++) bin[i]=bin[i-1]&lt;&lt;1; //稍微改了一下，不是2^i而是对应第i个敌人 int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=m;j++) &#123; if(s[j]=='.') mp[i][j]=1; else if(s[j]=='#') mp[i][j]=0; else &#123; pn++;p[pn].x=i;p[pn].y=j; mp[i][j]=10+pn; if(s[j]=='^') p[pn].tr=2; if(s[j]=='v') p[pn].tr=3; if(s[j]=='&lt;') p[pn].tr=4; if(s[j]=='&gt;') p[pn].tr=5; &#125; &#125; &#125; for(int i=1;i&lt;=pn;i++) &#123; int x=p[i].x,y=p[i].y; while(1) &#123; if(p[i].tr==2) x--;if(p[i].tr==3) x++; if(p[i].tr==4) y--;if(p[i].tr==5) y++; if(mp[x][y]==0 or x&lt;=0 or y&lt;=0 or x&gt;n or y&gt;m) break; if(mp[x][y]&gt;10) rd[i][mp[x][y]-10]=1; &#125; &#125; int full=(1&lt;&lt;pn)-1;//圆满状态 for(int i=1;i&lt;=pn;i++)//被看者 &#123; for(int j=0;j&lt;=full;j++)//状态 &#123; if( (j&amp;bin[i])!=0 ) continue;//已经死了 bool bk=1; for(int k=1;k&lt;=pn;k++)//看者 &#123; if( (j&amp;bin[k])==0 and i!=k ) bk=!rd[k][i]; if(!bk) break; &#125; chw[i][j]=bk; &#125; if(chw[i][0]) f[bin[i]]++;//单杀 &#125; for(int i=0;i&lt;=full;i++) for(int j=1;j&lt;=pn;j++) if((i&amp;bin[j])!=0 and chw[j][i^bin[j]]==1)//任杀 f[i]+=f[i^bin[j]]; if(f[full]&gt;0) printf("%d",f[full]); else printf("Impossible");&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>状压dp</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CZYZ2009暑假集训提高组6】魔兽争霸]]></title>
    <url>%2Fposts%2Fc201.html</url>
    <content type="text"><![CDATA[来源和评测点CZYZ2009暑假集训提高组6 题目【题目大意】小 x 正在销魂地玩魔兽他正控制着死亡骑士和 n个食尸鬼(编号 1～n)去打猎死亡骑士有个魔法，叫做“死亡缠绕” ，可以给食尸鬼补充 HP战斗过程中敌人会对食尸鬼实施攻击，食尸鬼的 HP 会减少小 x 希望随时知道自己部队的情况， 即 HP 值第 k 多的食尸鬼有多少 HP， 以便决定如何施放魔法请同学们帮助他:)小 x 向你发出 3种信号： （下划线在输入数据中表现为空格）A_i_a 表示敌军向第 i 个食尸鬼发出了攻击，并使第 i 个食尸鬼损失了 a 点 HP，如果它的 HP&lt;=0,那么这个食尸鬼就死了(Undead 也是要死的„„)。敌军不会攻击一个已死的食尸鬼。C_i_a 表示死亡骑士向第i 个食尸鬼放出了死亡缠绕，并使其增加了a点HP。 HP 值没有上限。死亡骑士不会向一个已死的食尸鬼发出死亡缠绕Q_k 表示小 x 向你发出询问【输入格式】第一行，一个正整数 n以后 n个整数 表示 n个食尸鬼的初始 HP 值接着一个正整数 m以下 m行 每行一个小 x 发出的信号40%的数据 n&lt;=3000 m&lt;=500070%的数据 n&lt;=8000 m&lt;=10000100%的数据 n&lt;=30000 m&lt;=5000090%的数据随机生成食尸鬼 HP 没有上限数据保证任意时刻食尸鬼的 HP 值在 longint范围内数据保证 A 和 C 命令中的食尸鬼是活着的输入数据中没有多余空格、换行【输出格式】对于小 x 的每个询问， 输出 HP 第 k 多的食尸鬼有多少 HP，如果食尸鬼总数不足 k 个，输出-1。每个一行数。最后一行输出一个数：战斗结束后剩余的食尸鬼数【输入样例】51 2 34 510Q 2A 4 6C 1 4Q 2A 2 1A 3 3A 1 3Q 4C 2 10Q 1【输出样例】45-1113 分析这道题还是挺有趣的利用了Splay的灵活性当时是比赛吧，写了200+行感觉思路完全是错的因为节点编号会换，差点心态爆炸想放弃冷静一想，毕竟是人发明的东西，那就可以改造我是用了一个数组存储对应的真实编号（后来看别人的代码，其实存着每个HP就好了……） 难度并不算太大，就不讲什么了，看代码吧 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=80000;int hh[MAXN+10];//**********************************************struct pt&#123; int son[2],f; int d,c,n; pt() &#123; son[0]=son[1]=-1; f=0; d=0; c=n=1; &#125;&#125;p[MAXN+10];//**********************************************void update(int x)&#123; p[x].c=p[x].n; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c; if(rc&gt;0) p[x].c+=p[rc].c;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; int xson=p[x].son[w]; if(xson&gt;0) p[xson].f=f; p[f].son[1-w]=xson; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; p[x].f=ff; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;void splay(int x,int rt)&#123; while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(ff==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findip(int d)&#123; int x=root; while(p[x].d!=d) &#123; if(d&gt;p[x].d) &#123; int lc=p[x].son[0]; if(lc&lt;0) return x; x=lc; &#125; else &#123; int rc=p[x].son[1]; if(rc&lt;0) return x; x=rc; &#125; &#125; return x;&#125;int len;void add(int f,int d)&#123; len++;p[len].f=f; p[len].son[0]=p[len].son[1]=-1; p[len].c=p[len].n=1;p[len].d=d; if(d&gt;p[f].d) p[f].son[0]=len; else p[f].son[1]=len;&#125;void addnum(int hk,int d)&#123; if(root==0) &#123; root=++len;p[len].f=0; p[len].son[0]=p[len].son[1]=-1; p[len].c=p[len].n=1;p[len].d=d; hh[hk]=len;// &#125; else &#123; int x=findip(d); if(p[x].d==d) &#123; p[x].n++; update(x); hh[hk]=x;// &#125; else &#123; add(x,d); update(x); hh[hk]=len;// &#125; splay(x,0); &#125;&#125;void del(int d)&#123; int x=findip(d); if(p[x].n&gt;1) &#123; p[x].n--; update(x); splay(x,0); &#125; else &#123; splay(x,0); if(p[x].son[0]==-1 and p[x].son[1]==-1) &#123; len=0;root=0; &#125; else if(p[x].son[0]&gt;0 and p[x].son[1]==-1) &#123; root=p[x].son[0]; p[root].f=0; &#125; else if(p[x].son[0]==-1 and p[x].son[1]&gt;0) &#123; root=p[x].son[1]; p[root].f=0; &#125; else &#123; int k=p[x].son[0]; while(p[k].son[1]&gt;0) k=p[k].son[1]; p[k].son[1]=p[x].son[1]; p[p[x].son[0]].f=0; p[p[x].son[1]].f=k; update(k);splay(k,0); &#125; &#125;&#125;//**********************************************int asknum(int k)&#123; int x=root; if(k&gt;p[x].c) return -1; while(x&gt;0) &#123; int lc=p[x].son[0]; int lcc=lc&gt;0?p[lc].c:0; if(k&lt;=lcc) x=lc; else if(k&gt;lcc+p[x].n) k-=lcc+p[x].n,x=p[x].son[1]; else &#123; splay(x,0); return p[x].d; &#125; &#125; return -2;&#125;void solve1(int k,int a)//-&#123; int d=p[ hh[k] ].d; del(d); if(d-a&gt;0) addnum(k,d-a);&#125;void solve2(int k,int a)//+&#123; int d=p[ hh[k] ].d; del(d); addnum(k,d+a);&#125;//**********************************************char s[10];int main()&#123; len=0;root=0; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int t; scanf("%d",&amp;t); addnum(i,t); &#125; int m;scanf("%d",&amp;m); while(m--) &#123; int a;scanf("%s%d",s,&amp;a); if(s[0]=='Q') printf("%d\n",asknum(a)); else &#123; int b;scanf("%d",&amp;b); if(s[0]=='A') solve1(a,b); else solve2(a,b); &#125; &#125; printf("%d",p[root].c);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3223】文艺平衡树]]></title>
    <url>%2Fposts%2F77a.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3223Codevs3303Caioj1134 题目【题目大意】写一种数据结构，来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4]的话，结果是5 2 3 4 1【输入格式】第一行为n,mn表示初始序列有n个数，这个序列依次是(1,2……n-1,n)m表示翻转操作次数，接下来m行每行两个数[l,r]数据保证 1&lt;=l&lt;=r&lt;=n（n,m &lt; =100000）【输出格式】输出一行n个数字，表示原始序列经过m次变换后的结果【输入样例】5 31 31 31 4【输出样例】4 3 2 1 5 分析这道题建议自己多出几个小数据检验主要就是利用伸展树这种比较灵活的数据结构来维护数列中序遍历就是当前的状态通过标记实现翻转 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000;//*******************全局定义*******************struct pt&#123; int son[2],f; int c; bool fz; pt() &#123; c=0;fz=0; son[0]=son[1]=f=-1; &#125;&#125;p[MAXN+10];//*******************伸展树*******************void update(int x)&#123; p[x].c=1; int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[x].c+=p[lc].c; if(rc&gt;0) p[x].c+=p[rc].c;&#125;void rev(int x)&#123; if(p[x].fz==0) return;p[x].fz=0; swap(p[x].son[0],p[x].son[1]); int lc=p[x].son[0],rc=p[x].son[1]; if(lc&gt;0) p[lc].fz^=1; if(rc&gt;0) p[rc].fz^=1;&#125;void rotate(int x,int w)&#123; int f=p[x].f,ff=p[f].f; int pson=p[x].son[w]; if(pson&gt;0) p[pson].f=f; p[f].son[1-w]=pson; if(p[ff].son[0]==f) p[ff].son[0]=x; else if(p[ff].son[1]==f) p[ff].son[1]=x; p[x].f=ff; p[x].son[w]=f; p[f].f=x; update(f); update(x);&#125;int root;int t[MAXN+10];void splay(int x,int rt)&#123; int s=0,i=x; while(p[i].f!=rt) t[++s]=i,i=p[i].f; t[++s]=rt; while(s&gt;0) rev(t[s--]); while(p[x].f!=rt) &#123; int f=p[x].f,ff=p[f].f; if(p[f].f==rt) &#123; if(p[f].son[0]==x) rotate(x,1); else if(p[f].son[1]==x) rotate(x,0); &#125; else &#123; if(p[ff].son[0]==f and p[f].son[0]==x) rotate(f,1),rotate(x,1); else if(p[ff].son[0]==f and p[f].son[1]==x) rotate(x,0),rotate(x,1); else if(p[ff].son[1]==f and p[f].son[0]==x) rotate(x,1),rotate(x,0); else if(p[ff].son[1]==f and p[f].son[1]==x) rotate(f,0),rotate(x,0); &#125; &#125; if(rt==0) root=x;&#125;int findrank(int rk)&#123; int x=root; while(x&gt;0) &#123; rev(x); int lcc=p[x].son[0]&lt;0?0:p[p[x].son[0]].c; if(rk&lt;=lcc) x=p[x].son[0]; else if(rk==lcc+1) return x; else x=p[x].son[1],rk-=lcc+1; &#125;&#125;//*******************接口*******************int n;void buildtree()&#123; root=1; p[n].f=n-1;update(n); for(int i=n-1;i&gt;=1;i--) &#123; p[i].f=i-1; p[i].son[1]=i+1; update(i); &#125; p[0].son[1]=1;&#125;void solve(int l,int r)&#123; if(l==1 and r==n) &#123; p[root].fz^=1; &#125; else if(l==1 and r&lt;n) &#123; int y=findrank(r+1); splay(y,0); p[p[y].son[0]].fz^=1; &#125; else if(l&gt;1 and r==n) &#123; int x=findrank(l-1); splay(x,0); p[p[x].son[1]].fz^=1; &#125; else &#123; int x=findrank(l-1); int y=findrank(r+1); splay(x,0); splay(y,x); p[p[y].son[0]].fz^=1; &#125;&#125;void pf(int x)&#123; if(x&lt;0) return; rev(x); pf(p[x].son[0]); printf("%d ",x); pf(p[x].son[1]);&#125;//*******************主函数*******************int main()&#123; int m;scanf("%d%d",&amp;n,&amp;m); buildtree(); while(m--) &#123; int l,r;scanf("%d%d",&amp;l,&amp;r); if(l&gt;r) swap(l,r);solve(l,r); &#125; pf(root);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu2867】大广场Big Square]]></title>
    <url>%2Fposts%2F4b65.html</url>
    <content type="text"><![CDATA[来源和评测点USACO06 NOVLuogu2867 题目【题目大意】农民 John 的牛参加了一次和农民 Bob 的牛的竞赛。他们在区域中画了一个N乘N 的正方形点阵，两个农场的牛各自占据了一些点。当然不能有两头牛处于同一个点。农场的目标是用自己的牛作为4个顶点，形成一个面积最大的正方形(不必须和边界平行) 。除了 Bessie 以外，FJ其他的牛都已经放到点阵中去了，要确定bessie放在哪个位置，能使得农民约翰的农场得到一个最大的正方形(Bessie不是必须参与作为正方形的四个顶点之一)。【输入格式】第一行是N接下来是一个N乘N的矩阵，字符解释:‘J’ John 的牛,‘B’ Bob 的牛,‘*‘ 空点。数据保证至少一个空点【输出格式】面积，如果没有就输出0【输入样例】6J*J*********J***J*********B*********【输出样例】4 分析随便用暴力做，居然过了……难点就是已知对角线上两个点求出正方形另外两个点 膜师兄时大概用了高中向量的知识，但也挺好理解的，就是“固定方向固定距离”？ 假如有两个点$(a,b)和(c,d)$，把他们作为对角线先计算出中点$(mx=\frac{a+c}{2},my=\frac{b+d}{2})$计算出两点间向量$(fx=\frac{a-c}{2},fy=\frac{b-d}{2})$向量反转，另外两点分别为$(qx=mx+(-fy),qy=my+(fx))和(mx+(fy),my+(-fx))$面积则是$( \sqrt{ (a-qx)^2+(b-qy)^2 })^2=(a-qx)^2+(b-qy)^2$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=150;struct nod&#123; int x,y;&#125;p[MAXN*MAXN];//已经使用的点int ptn=0;//数量int mp[MAXN][MAXN];int n;//判断x是不是整数y，我随便打的。。不是很严谨bool dint(double x,int y)&#123; double ty=y; return ty-0.001&lt;=x and x&lt;=ty+0.001;//在大致区间内&#125;int ans=0;void solve()&#123; for(int i=1;i&lt;=ptn;i++) &#123; for(int j=1;j&lt;=i-1;j++)//枚举互为对角线的点 &#123; double a=p[i].x,b=p[i].y;//点1 double c=p[j].x,d=p[j].y;//点2 double mx=(a+c)/2.0,my=(b+d)/2.0;//中点 double fx=(a-c)/2.0,fy=(b-d)/2.0;//向量 double qx=mx+(-fy),qy=my+(fx); if(qx&lt;1 or qx&gt;n) continue;if(qy&lt;1 or qy&gt;n) continue; double wx=mx+(fy),wy=my+(-fx); if(wx&lt;1 or wx&gt;n) continue;if(wy&lt;1 or wy&gt;n) continue; //理论做法：取中间向量，并应用在中点上 //由于初三还没正式学向量，不严谨 if(qx==wx and qy==wy) continue; int ax=int(qx+0.5),ay=int(qy+0.5);//注意四舍五入 int bx=int(wx+0.5),by=int(wy+0.5); if(!dint(qx,ax)) continue;//不是整点 if(!dint(qy,ay)) continue;//不是整点 if(!dint(wx,bx)) continue;//不是整点 if(!dint(wy,by)) continue;//不是整点 int qm=mp[ax][ay],wm=mp[bx][by];//状态 if(qm==1 or wm==1) continue;//被占用 if(qm==0 and wm==0) continue;//贝西只有一个…… double sq=(a-qx)*(a-qx)+(b-qy)*(b-qy);//面积 ans=mymax(sq,ans); &#125; &#125;&#125;char s[MAXN];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; if(s[j]=='*') mp[i][j]=0; if(s[j]=='B') mp[i][j]=1; if(s[j]=='J') &#123; ptn++; p[ptn].x=i;p[ptn].y=j; mp[i][j]=2; &#125; &#125; &#125; solve(); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu3005】槽的游戏The Trough Game]]></title>
    <url>%2Fposts%2F1444.html</url>
    <content type="text"><![CDATA[来源和评测点USACO10 DECLuogu3005 题目【题目大意】农夫约翰在谷仓里藏起来了N（1&lt;=N&lt;=20）个槽，并且他已经把其中的一些装上了食物。贝西以“在这个表里（表由贝西提供）有多少个槽里有食物？”的形式问了M（1&lt;=M&lt;=100）个问题。现在，贝西想知道，哪几个槽里有食物？【输入格式】第一行是N、M后面M行，每行一个长度为N的01串，表示一个询问是否包含这个槽然后是一个数字，表示回答【输出格式】如果可行，输出长度为N的01串，表示槽的状态如果没有满足的方案，输出’IMPOSSIBLE’如果方案不唯一，输出’NOT UNIQUE’【输入样例】4 41000 10110 11001 10011 1【输出样例】1010 分析1这题一看数据输入输出就想到矩阵乘法提问（m×n）（只有0、1）真实（n×1）（只有0、1）回答（m×1）假如提问*真实=回答，则可行，然后暴力搜索枚举出真实状况，然鹅这只能拿60分 代码1这是TLE的，供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct matrix&#123; int row,col; int a[120][120]; matrix() &#123; memset(a,0,sizeof(a)); &#125;&#125;;matrix cheng(matrix a,matrix b)&#123; matrix c; c.row=a.row;c.col=b.col; for(int i=1;i&lt;=c.row;i++) for(int j=1;j&lt;=c.col;j++) for(int k=1;k&lt;=a.col;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j]; return c;&#125;bool same(matrix a,matrix b)&#123; if(a.row!=b.row) return 0; if(a.col!=b.col) return 0; for(int i=1;i&lt;=a.row;i++) for(int j=1;j&lt;=a.col;j++) if(a.a[i][j]!=b.a[i][j]) return 0; return 1;&#125;int n,m;matrix a,b,c,d,ans;bool ero;void dfs(int x)&#123; if(ero) return; if(x&gt;n) &#123; d=cheng(a,b); if(same(c,d)) &#123; if(ans.row&gt;0) ero=1; else ans=b; &#125; return; &#125; b.a[x][1]=0;dfs(x+1); b.a[x][1]=1;dfs(x+1);&#125;char s[30];int main()&#123; ero=0; scanf("%d%d",&amp;n,&amp;m); a.row=m;a.col=n; b.row=n;b.col=1; c.row=m;c.col=1; for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) a.a[i][j]=s[j]-'0'; scanf("%d",&amp;c.a[i][1]); &#125; dfs(1); if(ero) printf("NOT UNIQUE"); else if(ans.row==0) printf("IMPOSSIBLE"); else for(int i=1;i&lt;=n;i++) printf("%d",ans.a[i][1]);&#125; 分析2接下来考虑剪枝：根据提问中最后一个需要的槽状态排序（所以一旦决定了那个槽，就能验证是否满足这个提问），从而边枚举边乘，达到剪枝目的 注意因为排序内容比较多，我手写了一个二分排序 A了之后忽然想到可以预处理出每添加一个槽状态所能多判断的提问区间，每次判断哪些区间的提问就好了，这样时间复杂度会少灰常多。然鹅我懒得改了，所以代码里面是从1到最后的 至于什么高斯消元……并不会 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,m;int a[110][30],b[30],c[110];int lt[110];//提问需要最末尾槽状态int ans[30];bool ha=0;bool ero;bool cheng(int x)//被我改良后的矩阵乘法，x是确定了的槽编号&#123; int i=1; while(lt[i]&lt;=x and i&lt;=m)//区间限制 &#123; int t=0; for(int k=1;k&lt;=x;k++) t+=a[i][k]*b[k]; if(t!=c[i]) return 0; i++; &#125; return 1;&#125;void dfs(int x)&#123; if(ero) return;//多个答案 if(x&gt;1 and !cheng(x-1)) return;//边做边判断 if(x&gt;n) &#123; if(ha&gt;0) ero=1; else &#123;memcpy(ans,b,sizeof(b));ha=1;&#125; return; &#125; b[x]=0;dfs(x+1); b[x]=1;dfs(x+1);&#125;void sort2(int l,int r)//手写二分排序&#123; int x=l,y=r,mid=lt[(l+r)&gt;&gt;1]; while(x&lt;=y) &#123; while(lt[x]&lt;mid and x&lt;m) x++; while(lt[y]&gt;mid and y&gt;1) y--; if(x&gt;y) break; swap(lt[x],lt[y]);//都要交换 swap(a[x],a[y]); swap(c[x],c[y]); x++;y--; &#125; if(l&lt;y) sort2(l,y); if(x&lt;r) sort2(x,r);&#125;char s[30];int main()&#123; ero=0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; a[i][j]=s[j]-'0'; if(a[i][j]==1) lt[i]=j;//记录 &#125; scanf("%d",&amp;c[i]); &#125; sort2(1,m); dfs(1); if(ero) printf("NOT UNIQUE"); else if(ha==0) printf("IMPOSSIBLE"); else for(int i=1;i&lt;=n;i++) printf("%d",ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>矩阵乘法</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1783】【Luogu2975】轮流Taking Turns]]></title>
    <url>%2Fposts%2F5323.html</url>
    <content type="text"><![CDATA[来源和评测点USACO10JANLuogu2975Bzoj1783 题目【题目大意】两头奶牛Bessi和Dessie走过一条路吃草，共n（n&lt;=700,000）个格子，第i个格子有重量为Wi（1&lt;=Wi&lt;=2,000,000,000）的草，两牛轮流走，一旦某头牛走过了一格，那么这格的草再也不可能被任一头奶牛吃，每格的草只能被吃一次，所以两头牛只能往后走。Bessi先走，每头牛每次都往最终自己能吃到最多草的格子走（若有多个格子则选择第一个能吃到最多草的格子），他们都知道对方也想吃到最多的草，问最后Bessi和Dessie各吃到的草的重量。【输入格式】第一行一个正整数n（n&lt;=700,000）接下来有n行，第i+1行是Wi（1&lt;=Wi&lt;=2,000,000,000）【输出格式】答案【输入样例】617591038【输出样例】27 17 分析类似博弈，倒退dpf[i]=从i到n最大收益id[i]=达到f[i]用了的干草堆最后编号 对于干草堆i，存在两种选择：1)用i，id[i]=i,f[i]=w[i]+f[id[i+1]+1] 即本堆干草+舍弃f[i+1]后最大收益2)不用i，id[i]=id[i+1],f[i]=f[i+1] 代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll w[710000],f[710000],id[710000];int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); f[n]=w[n];id[n]=n;f[n+1]=0; for(int i=n-1;i&gt;=1;i--) &#123; if(w[i]+f[id[i+1]+1]&gt;=f[i+1]) &#123; f[i]=w[i]+f[id[i+1]+1]; id[i]=i; &#125; else &#123; f[i]=f[i+1]; id[i]=id[i+1]; &#125; &#125; printf("%lld %lld",f[1],f[id[1]+1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
        <tag>好题</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Luogu3113】马拉松赛跑Marathon]]></title>
    <url>%2Fposts%2F134e.html</url>
    <content type="text"><![CDATA[来源和评测点USACO14DEC GoldLuogu3113 题目【题目大意】N个点的路线(1&lt;=N&lt;=100,000)，必须按顺序经过。询问特定的子路线需要多长时间才能跑完，其中的子路线是从完整路线的检查点中截取的的连续子序列。牛可能会选择在任何时候跳过一个检查点，但不允许在子路线中跳过第一个或最后一个点可能修改点的坐标由于该课程设置在市中心的街道网络中，两个点之间的距离(x1,y1)和(x2,y2)是由|x1-x2|+|y1-y2|得出的。【输入格式】第一行N和Q (1&lt;=Q&lt;=100,000).下面N行 每个点的坐标(x,y)，大小范围是-1000..1000下面Q行 每行一个操作“U I X Y” 修改 点I (1&lt;=I&lt;= N) 的坐标为(X, Y).“Q I J” 询问从I到J的最短距离（可以跳过除起点、终点外的其他点）(I &lt;= J)【输出格式】每个Q输出距离值【输入样例】5 5-4 4-5 -3-1 5-3 40 5Q 1 5U 4 0 1U 4 -1 1Q 2 4Q 1 4【输出样例】1188 分析使用线段树维护两个完全不同的信息。值1是每个节点到上一个节点的距离值2是每个节点被忽略后的收益（一般是负数）维护值1的和、值2的最小值 每次修改影响两个值1，三个值2 信息的维护用线段树达到log，树状数组则比较麻烦 玄学AC之本来线段树不忽略编号1，wa几个点都是个位数级别差异后来想着顺便加速（因为编号1从来不用），结果AC如果有人知道，可以在讨论区评论一下 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll myabs(ll x) &#123;return x&gt;0?x:-x;&#125;ll mymin(ll x,ll y) &#123;return x&lt;y?x:y;&#125;const int MAXN=110000;int n;struct nod&#123; int l,r,mid,lc,rc; ll s,mi;//分别维护值1的和、值2的最小值&#125;s[MAXN*2];int ln=0;int build(int l,int r)&#123; int t=++ln; s[t].l=l;s[t].r=r;s[t].mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; s[t].lc=build(l,s[t].mid); s[t].rc=build(s[t].mid+1,r); &#125; return t;&#125;void change1(int w,int x,ll c)&#123; if(s[w].l==s[w].r) &#123; s[w].s=c; return; &#125; int lc=s[w].lc,rc=s[w].rc; if(x&lt;=s[w].mid) change1(lc,x,c); else change1(rc,x,c); s[w].s=s[lc].s+s[rc].s;&#125;void change2(int w,int x,ll c)&#123; if(s[w].l==s[w].r) &#123; s[w].mi=c; return; &#125; int lc=s[w].lc,rc=s[w].rc; if(x&lt;=s[w].mid) change2(lc,x,c); else change2(rc,x,c); s[w].mi=mymin(s[lc].mi,s[rc].mi);&#125;ll ask1(int w,int l,int r)&#123; if(s[w].l==l and s[w].r==r) return s[w].s; int lc=s[w].lc,rc=s[w].rc; if(r&lt;=s[w].mid) return ask1(lc,l,r); if(l&gt;s[w].mid) return ask1(rc,l,r); return ask1(lc,l,s[w].mid)+ask1(rc,s[w].mid+1,r);&#125;ll ask2(int w,int l,int r)&#123; if(l&gt;r) return 0; if(s[w].l==l and s[w].r==r) return s[w].mi; int lc=s[w].lc,rc=s[w].rc; if(r&lt;=s[w].mid) return ask2(lc,l,r); if(l&gt;s[w].mid) return ask2(rc,l,r); return mymin(ask2(lc,l,s[w].mid),ask2(rc,s[w].mid+1,r));&#125;//值1是每个节点到上一个节点的距离//值2是每个节点被忽略后的收益（一般是负数）int xx[MAXN],yy[MAXN];ll get(int x,int sf)//与往前sf个节点的距离&#123; return myabs(xx[x]-xx[x-sf])+myabs(yy[x]-yy[x-sf]);&#125;ll p[MAXN];//顺便存储值char ss[10];int main()&#123; int q;scanf("%d%d",&amp;n,&amp;q); build(1,n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;xx[i],&amp;yy[i]); if(i==1) continue; change1(1,i-1,p[i]=get(i,1)); &#125; for(int i=2;i&lt;=n-1;i++) change2(1,i-1,get(i+1,2)-p[i]-p[i+1]); while(q--) &#123; scanf("%s",ss); if(ss[0]=='Q') &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); printf("%lld\n",ask1(1,x+1-1,y-1)+ask2(1,x+1-1,y-1-1)); &#125; else &#123; int a;scanf("%d",&amp;a); scanf("%d%d",&amp;xx[a],&amp;yy[a]); //修改值1两处 change1(1,a-1,p[a]=get(a,1)); change1(1,a+1-1,p[a+1]=get(a+1,1)); //对应值2三处 change2(1,a-1-1,get(a,2)-p[a-1]-p[a]); change2(1,a-1,get(a+1,2)-p[a]-p[a+1]); change2(1,a+1-1,get(a+2,2)-p[a+1]-p[a+2]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Zjoi2014】力]]></title>
    <url>%2Fposts%2F1db5.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj3527loj2200Caioj1451 题目【题目大意】给出n个数qi，给出Fj的定义如下：令Ei=Fi/qi，求Ei【输入格式】第一行一个整数n接下来n行每行输入一个数，第i行表示qin≤1000000&lt;qi&lt;1000000000【输出格式】n行，第i行输出Ei。与标准答案误差不超过1e-2即可。【输入样例1】3124.44513547.265135789.147852【输出样例1】-1994.552-5664.703578.376【输入样例2】54006373.88518415375036.4357591717456.4691448514941.0049121410681.345880【输出样例2】-16838672.6933439.7937509018.5664595686.88610903040.872 分析其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 这道题还是挺有难度的基本思路：逐步化简公式转化为卷积的形式从而能用FFT解决下标统一从0开始，翻转时也会用到$$题目要求：F_i=\sum_{i &lt; k} \frac{q_i q_k}{(i-k)^2}-\sum_{i &gt; k} \frac{q_i q_k}{(k-i)^2}$$ $$而E_i=\frac{F_i}{q_i}$$ $$显而易见E_i=\sum_{i &lt; k} \frac{q_k}{(i-k)^2}-\sum_{i &gt; k} \frac{q_k}{(k-i)^2}$$ $$明确界限E_i=\sum_{k=0}^{i-1} \frac{q_k}{(i-k)^2}-\sum_{k=i+1}^{n-1} \frac{q_k}{(k-i)^2}$$ $$设A_t=q_t,B_t=\frac{1}{t^2}(精髓1)$$ $$E_i=\sum_{k=0}^{i-1} A_k B_{i-k}-\sum_{k=i+1}^{n-1} A_k B_{k-i}$$ $$设B_0=0(小细节)，这样前面的式子就和卷积一样了，重点放后面$$ $$E_i=\sum_{k=0}^{i} A_k B_{i-k}-\sum_{k=i}^{n-1} A_k B_{k-i}$$ 考虑 $A’*t=A*{n-1-t}$,$B’_t=B_t$(精髓2，看作是倒过来的卷积，所以翻转一下)$$E_i=\sum_{k=0}^{i} A_k B_{i-k}-\sum_{k=0}^{n-i-1} A’*k B’*{(n-i-1)-i}$$ $$E_i=FFT1(i)-FFT2(n-i-1)$$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Zory-2018#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#ifdef DEBUGconst int LOCAL=1;#elseconst int LOCAL=0;#endifnamespace mine&#123; typedef long long ll; const int INF=0x3f3f3f3f; const double PI=acos(-1); const int MAX_N=4*110000; struct Cp &#123; double a,b; Cp(double c=0,double d=0) &#123;a=c,b=d;&#125; Cp operator + (Cp t) &#123;return Cp(a+t.a,b+t.b);&#125; Cp operator - (Cp t) &#123;return Cp(a-t.a,b-t.b);&#125; Cp operator * (Cp t) &#123;return Cp(a*t.a-b*t.b,a*t.b+b*t.a);&#125; &#125;; struct Fft &#123; Cp w[MAX_N]; void getw(int n,int f) &#123; w[0]=Cp(1,0);w[1]=Cp(cos(PI*2*f/n),sin(PI*2*f/n)); for(int i=2;i&lt;n;i++) w[i]=w[i-1]*w[1]; &#125; int R[MAX_N]; void pre(int n) &#123; int lg=log2(n); R[0]=0;for(int i=1;i&lt;n;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)+((i&amp;1)&lt;&lt;(lg-1)); &#125; void solve(Cp *a,int n,int f) &#123; for(int i=0;i&lt;n;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int ln=1;ln&lt;=n/2;ln&lt;&lt;=1)//合并前 &#123; getw(ln*2,f); for(int st=0;st&lt;n;st+=2*ln) for(int k=0;k&lt;ln;k++) &#123; Cp x=a[st+k],y=w[k]*a[st+ln+k]; a[st+k]=x+y;a[st+ln+k]=x-y; &#125; &#125; &#125; &#125;fft; void FFT(Cp *a,Cp *b,Cp *c,int ln) &#123; fft.solve(a,ln,1);fft.solve(b,ln,1); for(int i=0;i&lt;ln;i++) c[i]=a[i]*b[i]; fft.solve(c,ln,-1);for(int i=0;i&lt;ln;i++) c[i].a/=ln; &#125; double q[MAX_N]; Cp A[MAX_N],B[MAX_N],ans[MAX_N]; void main() &#123; int n;scanf("%d",&amp;n);for(int i=0;i&lt;n;i++) scanf("%lf",&amp;q[i]); int ln=1;while(ln&lt;(n-1)+(n-1)+1) ln&lt;&lt;=1; fft.pre(ln); for(int i=0;i&lt;n;i++) A[i]=Cp(q[i],0); B[0]=Cp();for(int i=1;i&lt;n;i++) B[i]=Cp(1.0/i/i,0); FFT(A,B,ans,ln); for(int i=0;i&lt;ln;i++) A[i]=Cp(),B[i]=Cp(); for(int i=0;i&lt;n;i++) A[i]=Cp(q[n-1-i],0); B[0]=Cp(0,0);for(int i=1;i&lt;n;i++) B[i]=Cp(1.0/i/i,0); FFT(A,B,A,ln); for(int i=0;i&lt;n;i++) printf("%.3lf\n",ans[i].a-A[n-i-1].a); &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu4609】3-idiots]]></title>
    <url>%2Fposts%2Fb4ff.html</url>
    <content type="text"><![CDATA[来源和评测点2013 Multi-University Training Contest 1Hdu4609Caioj1454 题目【题目大意】有T组数据每组数据给出n条线段，问任意取三条，可以组成三角形的概率【输入格式】开头一行输入T（T&lt;=100）下来T组数据，每组数据第一行输入一个n（3&lt;=n&lt;=10^5）第二行输入n个数，表示n条线段线段长度（1&lt;=n&lt;=10^5）【输出格式】每组数据输出一个数p表示可以组成三角形的概率保留七位小数【输入样例】241 3 3 442 3 3 4【输出样例】0.50000001.0000000 分析其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 大致思路：计算出两条边的和，枚举第三边表示能和它搭配的数量，经过去重后，除以总组合数就是概率 两边之和：FFT，参考另外几道简单点的题去重1：两边之和不能是来自同一条边去重2：两边有一条比第三边大，另一个小去重3：两边都比第三边大去重4：两边有任何一条=第三边（去重2、3、4后剩下的就是两边都比第三边小的情况） 输入的是q[i]，$A(q[i])=是q[i]的数量$NUM(i)表示两边之和=i的情况个数，用去重1$$NUM(i)=\frac{ A^2(i)-B(i) }{2}$$ 去重2、3、4利用排序，并用前缀和SUM获得区间和$ ANS(i)=SUM(rn-1)-SUM(q[i]) $$ 去重2：ANS(i)-=i\times (n-i-1) $$ 去重3：ANS(i)-=\frac{ (n-i-2)\times (n-i-1) }{2} $$ 去重4：ANS(i)-=n-1 $$$tot=\frac{ n\times (n-1)\times (n-2) }{2}$$ 答案就是$$\frac{ \sum_{i=0}^{n-1} ANS(i) }{tot}$$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct complex&#123; double r,i; complex() &#123; r=i=0.0; &#125; complex(double rr,double ii) &#123; r=rr;i=ii; &#125; complex operator + (complex b) &#123; return complex(r+b.r,i+b.i); &#125; complex operator - (complex b) &#123; return complex(r-b.r,i-b.i); &#125; complex operator * (complex b) &#123; return complex(r*b.r-i*b.i,r*b.i+i*b.r); &#125;&#125;;const int MAXN=100000*4;const double PI=acos(-1.0);int R[MAXN+10];void FFT(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int l=1;l&lt;=n/2;l*=2) &#123; complex w1( cos(op*PI/l),sin(op*PI/l) ); for(int j=0;j&lt;=n-1;j+=l*2) &#123; complex wk(1.0,0.0); for(int k=0;k&lt;=l-1;k++,wk=wk*w1) &#123; complex x=a[j+k],y=wk*a[j+l+k]; a[j+k]=x+y; a[j+l+k]=x-y; &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//http://www.cnblogs.com/kuangbin/archive/2013/07/24/3210565.html//http://acm.HDU.edu.cn/showproblem.php?pid=4609//http://blog.csdn.net/rose_max/article/details/77370572complex A[MAXN+10],A2[MAXN+10],B[MAXN+10];int q[MAXN+10];double NUM[MAXN+10];double SUM[MAXN+10];int main()&#123; int T;scanf("%d",&amp;T); while(T--) &#123; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); memset(SUM,0,sizeof(SUM)); int n;scanf("%d",&amp;n);int mx=0; for(int i=0;i&lt;=n-1;i++) &#123; scanf("%d",&amp;q[i]); A[q[i]].r++; B[q[i]*2].r++; if(q[i]&gt;mx) mx=q[i]; &#125; sort(q,q+n); int rn=1,rm=(mx)+(mx)+1,l=0; while(rn&lt;rm) rn*=2,l++; for(int i=0;i&lt;=rn-1;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(l-1) ); FFT(A,rn,1); for(int i=0;i&lt;=rn-1;i++) A2[i]=A[i]*A[i]; FFT(A2,rn,-1); for(int i=0;i&lt;=rn-1;i++) NUM[i]=(A2[i].r-B[i].r)/2.0; for(int i=0;i&lt;=rn-1;i++) SUM[i]=SUM[i-1]+NUM[i]; double ans=0; for(int i=0;i&lt;=n-1;i++)//第三边 &#123; ans+=SUM[rn-1]-SUM[q[i]]; ans-=double(i)*double(n-i-1);//一大一小 ans-=double(n-i-2)*double(n-i-1)/2;//两大 ans-=n-1;//某边=第三边 &#125; double tot=double(n)*double(n-1)*double(n-2)/6.0; printf("%.7lf\n",ans/tot); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj3771】Triple]]></title>
    <url>%2Fposts%2Fdf74.html</url>
    <content type="text"><![CDATA[来源和评测点Zjoi2014Bzoj3771Caioj1451 题目【题目大意】我们讲一个悲伤的故事。从前有一个贫穷的樵夫在河边砍柴。这时候河里出现了一个水神，夺过了他的斧头，说：“这把斧头，是不是你的？”樵夫一看：“是啊是啊！”水神把斧头扔在一边，又拿起一个东西问：“这把斧头，是不是你的？”樵夫看不清楚，但又怕真的是自己的斧头，只好又答：“是啊是啊！”水神又把手上的东西扔在一边，拿起第三个东西问：“这把斧头，是不是你的？”樵夫还是看不清楚，但是他觉得再这样下去他就没法砍柴了。于是他又一次答：“是啊是啊！真的是！”水神看着他，哈哈大笑道：“你看看你现在的样子，真是丑陋！”之后就消失了。樵夫觉得很坑爹，他今天不仅没有砍到柴，还丢了一把斧头给那个水神。于是他准备回家换一把斧头。回家之后他才发现真正坑爹的事情才刚开始。水神拿着的的确是他的斧头。但是不一定是他拿出去的那把，还有可能是水神不知道怎么偷偷从他家里拿走的。换句话说，水神可能拿走了他的一把，两把或者三把斧头。樵夫觉得今天真是倒霉透了，但不管怎么样日子还得过。他想统计他的损失。樵夫的每一把斧头都有一个价值，不同斧头的价值不同。总损失就是丢掉的斧头价值和。他想对于每个可能的总损失，计算有几种可能的方案。注意：如果水神拿走了两把斧头a和b，(a,b)和(b,a)视为一种方案。拿走三把斧头时，(a,b,c),(b,c,a),(c,a,b),(c,b,a),(b,a,c),(a,c,b)视为一种方案。【输入格式】第一行是整数N，表示有N把斧头。接下来n行升序输入N个数字Ai，表示每把斧头的价值。所有数据满足：Ai&lt;=40000【输出格式】若干行，按升序对于所有可能的总损失输出一行x y，x为损失值，y为方案数。【输入样例】44 5 6 7【输出样例】4 15 16 18 19 110 111 212 113 114 115 117 118 119 1 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 Triple这道题的精华是容斥先推荐一下同学的博客，相当严谨科学他和我的思路不同，属于两种不同的角度我的思路可能有些乱啊，因为其实是在别人不停点醒才想到的，并不断完善 题意：给出价格各不相同（这很重要）的一些斧头，每次选一、二、三个，将所有方案统计起来，按价格输出，注意选的是组合不是排列。考虑分解成子问题。 选一个先解决选一个的情况。设$q_i$表示第i个斧头的价格。再设$A(q_i)=1$则$Ans[i]+=A(q_i)$原因就是每个斧头选自己，很好理解的 选两个答案是$A^2(q_i)$吗？先想想这个式子怎么来的：将A想成多项式的系数系数（原本1）相乘就是方案数相乘指数（价格）相加就是花费相加 然鹅，仔细考虑，发现不完整，因为会有违法情况违法1：第i项和第i项相乘，应该被忽略的违法2：第i、j项乘积和第j、i项乘积重复对于违法1，设$B(2q_i)=1$，$A^2(q_i)-B(q_i)$对于违法2，解决违法一后除以2即可综上所述，$Ans[i]+=\frac { A^2(q_i)-B(q_i) }{2}$ 选三个依照选两个的思路，先计算出$A^3(q_i)$违法1：aab aba baa违法2：abc acb bac bca cab cba对于违法1，设$AB()=A() \times B()，C(q_i \times 3)=1$，答案就是$A^3(q_i)-3AB(q_i)+2C(i)$（因为B是相当于选了两个相同的，所有三个中两个相同情况都应去除）但假如b=a，也就是aaa，那就不能减3个而是一个，用C补回差值对于违法2，解决违法一后除以6即可综上所述，$Ans[i]+=\frac { A^3(q_i)-3AB(q_i)+2C(i) }{6}$ 总结与提醒0次项系数是0，所以$A^3(q_i)$必定是选了三个$Ans[i]=A(q_i)+\frac{A^2(q_i)-B(q_i)}{2}+\frac { A^3(q_i)-3AB(q_i)+2C(i) }{6}$ 对于多项式乘积，使用FFT计算，综合复杂度$\Theta(nlogn)$ 嗯我知道我的灰常不严谨啦~总而言之就是这样 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=300000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;int R[MAXN+10];void fft(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************主函数*******************complex A[MAXN+10],B[MAXN+10],C[MAXN+10];complex A2[MAXN+10],AB[MAXN+10],A3[MAXN+10];double ans[MAXN+10];int main()&#123; //-------------读入------------- int n;scanf("%d",&amp;n); int mx=0; for(int i=0;i&lt;=n-1;i++) &#123; int t;scanf("%d",&amp;t);if(t&gt;mx) mx=t; A[t].r=1;B[2*t].r=1;C[3*t].r=1; &#125; //-------------准备------------- int sn=1,lg=0; while(sn&lt;mx*3+1) sn*=2,lg++; for(int i=0;i&lt;=sn-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(lg-1) ); //nlogn翻转二进制 //-------------计算------------- for(int i=0;i&lt;=sn-1;i++) ans[i]=(A[i].r)-(B[i].r/2.0)+(C[i].r/3.0);//先把A、B、C搞定 fft(A,sn,1);fft(B,sn,1); for(int i=0;i&lt;=sn-1;i++) A2[i]=A[i]*A[i],AB[i]=A[i]*B[i],A3[i]=A2[i]*A[i]; fft(A2,sn,-1);fft(AB,sn,-1);fft(A3,sn,-1); //-------------综合------------- for(int i=0;i&lt;=sn-1;i++) &#123; ans[i]+=(A2[i].r/2.0)+(A3[i].r/6.0)-(AB[i].r/2.0); int t2=ans[i]+0.5; if(t2&gt;0) printf("%d %d\n",i,t2); &#125; //ans[i]=A[i]+(A2[i]-B[i])/2+(A3[i]-3*AB[i]+2*C[i])/6&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度3</tag>
        <tag>好题</tag>
        <tag>快速傅里叶变换</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2194】快速傅立叶之二]]></title>
    <url>%2Fposts%2Ffb8e.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2194Caioj1453 题目【题目大意】请计算$C[k]=\sum a[i]*b[i-k] $ 其中k&lt;=i&lt;n,并且有n&lt;=10^5。a,b中的元素均为小于等于100的非负整数。【输入格式】第一行一个整数N,接下来N行，第i+2..i+N-1行，每行两个数，依次表示a[i],bi【输出格式】输出N行，每行一个整数，第i行输出C[i-1]【输入样例】53 12 41 12 41 4【输出样例】24121061 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-3快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 按通常的卷积形式应该是$c[k]=\sum_{i=0}^k a[i]*b[k-i]$但是本题要求的是$c[k]=\sum_{i=k}^{n-1} a[i]*b[i-k]$于是将b上下反转即可另外，将序号看作指数，反转后对于某个c的乘积和，指数和其实是相同的 自己推一推就好了…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const double PI=acos(-1.0);const int MAXN=4*100000;//*******************全局定义*******************struct complex&#123; double r,i;//real,imag complex() &#123;r=i=0;&#125; complex(double rr,double ii) &#123;r=rr;i=ii;&#125; complex operator + (complex b) &#123;return complex(r+b.r,i+b.i);&#125; complex operator - (complex b) &#123;return complex(r-b.r,i-b.i);&#125; complex operator * (complex b) &#123;return complex(r*b.r-i*b.i,r*b.i+i*b.r);&#125; //(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i //baike.baidu.com/item/复数运算法则&#125;;//*******************实现*******************int R[MAXN+10];complex omega[MAXN+10];void CalcOmega(int n,int op)&#123; double t=2*PI*op/n; omega[0]=complex(1,0); omega[1]=complex(cos(t),sin(t)); for(int k=2;k&lt;=n/2-1;k++) omega[k]=omega[k-1]*omega[1];&#125;void FFT(complex *a,int n,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); //注意判断大小不然又换回来了 for(int L=1;L&lt;=n/2;L*=2)//合并前长度 &#123; CalcOmega(L*2,op); for(int j=0;j&lt;=n-1;j+=L*2)//开头,长度=L*2 &#123; for(int k=0;k&lt;=L-1;k++) &#123; complex x=a[j+k]; complex y=omega[k]*a[j+L+k]; a[j+k]=x+y; a[j+L+k]=x-y; //蝴蝶操作 &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r=a[i].r/double(n);&#125;//*******************主函数*******************complex a[MAXN+10],b[MAXN+10];char s[MAXN+10];int ans[MAXN+10];int main()&#123; int n;scanf("%d",&amp;n);int tn=n; int m=n-1;n=n-1; for(int i=0;i&lt;=n;i++) scanf("%lf%lf",&amp;a[i].r,&amp;b[m-i].r); m=n+m+1;int log=0;n=1; while(n&lt;m) n*=2,log++; for(int i=0;i&lt;=n-1;i++) R[i]=( R[i&gt;&gt;1]&gt;&gt;1 ) | ( (i&amp;1)&lt;&lt;(log-1) ); //nlogn翻转二进制 FFT(a,n,1);FFT(b,n,1);//求值 for(int i=0;i&lt;=n-1;i++) a[i]=a[i]*b[i];//点值乘法 FFT(a,n,-1);//插值 for(int i=0;i&lt;=m-1;i++) &#123; ans[i]+=int(a[i].r+0.5); if(ans[i]&gt;=10) &#123; ans[i+1]+=ans[i]/10; ans[i]%=10; if(i==m-1) m++; &#125; &#125; for(int i=tn-1;i&lt;=2*tn-2;i++) printf("%d\n",int(a[i].r+0.5));&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2179】超大整数乘法]]></title>
    <url>%2Fposts%2F9654.html</url>
    <content type="text"><![CDATA[来源和评测点Bzoj2179Luogu1919Caioj1450Codevs3123 题目【题目大意】给出两个正整数A和B，计算A*B的值。保证A和B的位数不超过100000位。【输入格式】读入两个用空格隔开的正整数【输出格式】输出A*B的值【输入样例1】49【输出样例1】36【输入样例2】5612【输出样例2】672【输入样例3】9999【输出样例3】9801 分析快速傅里叶变换教程和题目分类参见：【OI之路】11更高级数论-4快速傅里叶变换其他快速傅里叶变换题目参见：Tag-快速傅里叶变换 将10看作x就好了注意进位 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Zory in 2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int myabs(int x) &#123;return x&gt;0?x:-x;&#125;void chmax(int &amp;x,int y) &#123;if(x&lt;y) x=y;&#125;void chmin(int &amp;x,int y) &#123;if(x&gt;y) x=y;&#125;//*******************全局常量*******************const int MAXN=210000;const double PI=acos(-1.0);//*******************全局定义*******************struct Cmplex&#123; double r,i; Cmplex(double a=0,double b=0) &#123;r=a,i=b;&#125; Cmplex operator +(Cmplex a) &#123;return Cmplex(r+a.r,i+a.i);&#125; Cmplex operator -(Cmplex a) &#123;return Cmplex(r-a.r,i-a.i);&#125; Cmplex operator *(Cmplex a) &#123;return Cmplex(r*a.r-i*a.i,r*a.i+i*a.r);&#125;&#125;;//*******************实现*******************Cmplex omega[MAXN];void calc_omega(int n,int op)&#123; omega[0]=Cmplex(1,0); omega[1]=Cmplex( cos(PI*2*op/n),sin(PI*2*op/n) ); for(int i=2;i&lt;=n/2-1;i++) omega[i]=omega[i-1]*omega[1];&#125;int n;int R[MAXN];void FFT(Cmplex *a,int op)&#123; for(int i=0;i&lt;=n-1;i++) if(i&lt;R[i]) swap(a[i],a[R[i]]); for(int L=1;L&lt;n;L&lt;&lt;=1)//合并前长度 &#123; calc_omega(L*2,op); for(int st=0;st&lt;=n-1;st+=L*2) &#123; for(int i=0;i&lt;=L-1;i++) &#123; Cmplex x=a[st+i]; Cmplex y=omega[i]*a[st+i+L]; a[st+i]=x+y; a[st+i+L]=x-y; &#125; &#125; &#125; if(op==-1) for(int i=0;i&lt;=n-1;i++) a[i].r/=double(n);&#125;//*******************主函数*******************char s[MAXN];Cmplex a[MAXN],b[MAXN];int ans[MAXN];int main()&#123; int ln;scanf("%d",&amp;ln); scanf("%s",s+1);for(int i=ln;i&gt;=1;i--) a[ln-i].r=s[i]-'0'; scanf("%s",s+1);for(int i=ln;i&gt;=1;i--) b[ln-i].r=s[i]-'0'; int m=(ln-1)+(ln-1)+1; n=1;int tmp=0; while(n&lt;m) tmp++,n*=2; for(int i=1;i&lt;=n-1;i++) R[i]= (R[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1)&lt;&lt;(tmp-1) );//debug //nlogn二进制翻转 FFT(a,1);FFT(b,1);//求值 for(int i=0;i&lt;=n-1;i++) a[i]=a[i]*b[i];//点值乘法 FFT(a,-1);//插值 for(int i=0;i&lt;=m-1;i++) &#123; ans[i]+=round(a[i].r); if(ans[i]&gt;9) &#123; ans[i+1]+=ans[i]/10; ans[i]%=10; if(i==m-1) m++; &#125; &#125; for(int i=m-1;i&gt;=0;i--) putchar('0'+ans[i]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2820】YY的GCD]]></title>
    <url>%2Fposts%2F5aa0.html</url>
    <content type="text"><![CDATA[来源和评测点一模一样的题目但数据弱化版：Bzoj2818 GCD-莫比乌斯2Bzoj2820 题目【题目大意】神犇YY虐完数论后给傻kAc出了一题给定N,M,求1≤x≤N, 1≤y≤M且gcd(x,y)为质数的(x,y)有多少对kAc这种傻kAc必然不会了，于是向你来请教……【输入格式】多组输入第一行一个整数T 表述数据组数接下来T行，每行两个正整数，表示N, M【输出格式】T行，每行一个整数表示第i组数据的结果【输入样例】210 10100 100【输出样例】302791 分析1莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 即使分块也会T！需要优化了，主要是针对素数： 转载并修改自Hzwer $ 假定n&lt;m $$$\sum_{isprime(p)} \sum_{a=1}^n \sum_{b=1}^m gcd(a,b)==p$$ 简化为： $$\sum_{isprime(p)} \sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor} \sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}gcd(a,b)==1$$ ————在我之前的教程中，下面直接被忽略————$$\sum_{isprime(p)}\sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}\sum_{d|gcd(a,b)}\mu(d)$$ $$\sum_{isprime(p)}\sum_{a=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\sum_{b=1}^{\left \lfloor \frac{m}{p} \right \rfloor}\sum_{d|a \space and \space d|b}\mu(d)$$因为：$$\sum_{d|a \space and \space d|b}1 是等于后边的{\left \lfloor \frac{n}{pd} \right \rfloor}{\left \lfloor \frac{m}{pd} \right \rfloor}的$$所以之前就直接得出了。 ————-在我之前的教程中，上面直接被忽略—————额不妨设n&lt;=m，则可以变成：$$\sum_{isprime(p)}\sum_{d=1}^{\left \lfloor \frac{n}{p} \right \rfloor}\mu(d){\left \lfloor \frac{n}{pd} \right \rfloor}{\left \lfloor \frac{m}{pd} \right \rfloor}$$ 上面的式子已经很好用了，但可以考虑加速： 将pd设为k $$\sum_{k=1}^{n}\sum_{isprime(p) \space and \space p|k}\mu(\frac{k}{p}){\left \lfloor \frac{n}{k} \right \rfloor}{\left \lfloor \frac{m}{k} \right \rfloor}$$ $$\sum_{k=1}^{n} G(k){\left \lfloor \frac{n}{k} \right \rfloor}{\left \lfloor \frac{m}{k} \right \rfloor}$$ $$G(k)就是\sum_{isprime(p) \space and \space p|k}\mu(\frac{k}{p})$$ $$也就是k的所有质因数的\mu(\frac{k}{质因数})之和$$于是就优化到了可怕的O(N)~ 那么接下来就是要解决G(k)的预处理了简单粗暴的，使用暴力枚举素数来更新，用导数可证明其复杂度的正确性 代码14332 ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXNUM=10000000,MAXPR=1000000;int prime[MAXPR],pr;ll mu[MAXNUM+10];bool v[MAXNUM+10];int G[MAXNUM+10];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXNUM;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr;j++) &#123; ll tt=ll(i)*ll(prime[j]); if(tt&gt;ll(MAXNUM)) break; v[tt]=0; if(i%prime[j]==0) &#123; mu[tt]=0; break; &#125; else mu[tt]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=pr;i++) &#123; int p=prime[i]; for(int j=1;ll(j)*ll(p)&lt;=ll(MAXNUM);j++) G[j*p]+=mu[j]; &#125; for(int i=1;i&lt;=MAXNUM;i++) G[i]+=G[i-1];&#125;ll calc(int n,int m)&#123; ll ans=0; if(n&gt;m) swap(n,m); int t=1; int last; for(int k=1;k&lt;=n;k=last+1) &#123; last=mymin(n/(n/k),m/(m/k)); ans+=(G[last]-G[k-1])*ll(n/k)*ll(m/k); &#125; return ans;&#125;int main()&#123; getmu(); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",calc(n,m)); &#125;&#125; 分析2然鹅，利用莫比乌斯函数的性质和G(k)的性质，可以得到这样的规律(用了足足一节数学课)：if(i%prime[j]==0) G[tt]=mu[i];else G[tt]=-G[i]+mu[i]; 代码23476 ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXNUM=10000000,MAXPR=1000000;int prime[MAXPR],pr;ll mu[MAXNUM+10];bool v[MAXNUM+10];int G[MAXNUM+10];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXNUM;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1,G[i]=1; for(int j=1;j&lt;=pr;j++) &#123; ll tt=ll(i)*ll(prime[j]); if(tt&gt;ll(MAXNUM)) break; v[tt]=0; if(i%prime[j]==0) &#123; mu[tt]=0; G[tt]=mu[i]; break; &#125; else &#123; mu[tt]=-mu[i]; G[tt]=-G[i]+mu[i]; &#125; &#125; &#125; for(int i=1;i&lt;=MAXNUM;i++) G[i]+=G[i-1];&#125;ll calc(int n,int m)&#123; ll ans=0; if(n&gt;m) swap(n,m); int t=1; int last; for(int k=1;k&lt;=n;k=last+1) &#123; last=mymin(n/(n/k),m/(m/k)); ans+=(G[last]-G[k-1])*ll(n/k)*ll(m/k); &#125; return ans;&#125;int main()&#123; getmu(); int T;scanf("%d",&amp;T); while(T--) &#123; int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",calc(n,m)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Zoj3435】Ideal Puzzle Bobble]]></title>
    <url>%2Fposts%2Fea1.html</url>
    <content type="text"><![CDATA[来源和评测点Author: ZHU, YukeContest: ZOJ Monthly, November 2010Zoj3435Caioj1283 题目【题目大意】给定点(x,y,z)与(1,1,1)确定一个长方体，长方体边上及内部总共有x*y*z个点，问从(1,1,1)总共能看到多少个点【输入格式】多组数据一行三个整数，x,y,z 1&lt;=a,b,c&lt;=1000000【输出格式】共1行，一个整数从(1,1,1)总共能看到多少个点【输入样例】2 2 23 3 3【输出样例】719 分析其他莫比乌斯题目参见：Tag-莫比乌斯 建议先看二维版：仪仗队 用了分块讲(x,y,z)与(1,1,1)变成(x-1,y-1,z-1)与(0,0,0)三个数的gcd是一样的，注意0答案就是：（都不是0）+（一个0）+（两个0也就是3）分别反演结果之和 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;//******************定义******************const int MAXNUM=1000000,MAXPR=100000;int mu[MAXNUM+10];//******************莫比乌斯函数******************int prime[MAXPR+10],pr;bool prv[MAXNUM+10];void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; int t=i*prime[j]; if(t&gt;MAXNUM) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//******************莫比乌斯******************ll calc1(int a,int b,int c)&#123; //已经不必强调大小了，找到最小值就好了 //其实也就模板题需要去重所以才要交换罢了 int mi=mymin(a,mymin(b,c)); ll ans=0; int last; int t=1; for(int i=1;i&lt;=mi;i=last+1)//d/t &#123; int d=i*t; last=mymin( a/(a/d), mymin( b/(b/d),c/(c/d) ) ); ans+=ll(mu[last]-mu[i-1])*( ll(a/d)*ll(b/d)*ll(c/d) ); &#125; return ans;&#125;ll calc2(int a,int b)&#123; int mi=mymin(a,b); ll ans=0; int last; int t=1; for(int i=1;i&lt;=mi;i=last+1)//d/t &#123; int d=i*t; last=mymin( a/(a/d),b/(b/d) ); ans+=ll(mu[last]-mu[i-1])*( ll(a/d)*ll(b/d) ); &#125; return ans;&#125;//******************主函数******************int main()&#123; getmu(); int x,y,z; while(scanf("%d%d%d",&amp;x,&amp;y,&amp;z)!=EOF) &#123; //都不是0+一个0+两个0 printf("%lld\n",calc1(x-1,y-1,z-1)+calc2(x-1,y-1)+calc2(y-1,z-1)+calc2(x-1,z-1)+3); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2190】仪仗队]]></title>
    <url>%2Fposts%2F24f8.html</url>
    <content type="text"><![CDATA[来源和评测点SDOI2008Bzoj2190 题目【题目大意】 作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N*N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。现在，C君希望你告诉他队伍整齐时能看到的学生人数。【输入格式】共一个数N，1≤N≤40000【输出格式】共一个数，即C君应看到的学生人数。【输入样例】4【输出样例】9 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 我代码里面用了分块，其实可能不用也可以重点是题目的转换，经别人提醒才想到和点的坐标有关假设C君在(0,0)，那么他能看到的点必须互质（注意0和任何数互质所以+2）原因：假如有点A(ak,bk)的坐标不互质,那么他必定被B(a,b)遮挡 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//************************定义************************typedef long long ll;const int MAXNUM=100000,MAXPR=10000;int mu[MAXNUM+10];//************************线性筛************************bool prv[MAXNUM+10];int prime[MAXPR+10],pr;void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; ll t=ll(i)*ll(prime[j]); if(t&gt;ll(MAXNUM)) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//************************主函数************************ll calc(int n,int m)&#123; if(n&gt;m) swap(n,m); ll ans=0; int t=1; //F[d]=sigma[ f(t) ] d|t //f(t)=sigma[ mu(d/t)*F[d] ] t|d int last=0; for(int i=1;i&lt;=n;i=last+1)//d/t &#123; int d=i*t; last=mymin( n/(n/d) , m/(m/d) ); ans+=ll(mu[last]-mu[i-1])*ll(n/d)*ll(m/d); &#125; return ans;&#125;int main()&#123; getmu(); int n;scanf("%d",&amp;n); printf("%lld\n",calc(n-1,n-1)+2);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2301】【Luogu2522】Problem_b]]></title>
    <url>%2Fposts%2F12b6.html</url>
    <content type="text"><![CDATA[来源和评测点HAOI2011Bzoj2301Luogu2522Caioj1282 题目【题目大意】对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y)=k，gcd(x,y)函数为x和y的最大公约数。【输入格式】第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k100%的数据满足：1≤n≤50000，1≤a≤b≤50000，1≤c≤d≤50000，1≤k≤50000【输出格式】共n行，每行一个整数表示满足要求的数对(x,y)的个数【输入样例】22 5 1 5 11 5 1 5 2【输出样例】143 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 嗯这次就不能硬搞了，会超时哒（bzoj上51000+到11000ms），所以要分块了而且还要用到容斥，因为下界也是变量了，画张图就灰常好理解了 至于分块，如下：采用前缀和优化+分块思想因为(n/d)*(m/d)有连续的一段是相等的，所以对莫比乌斯函数计算前缀和 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;//************************定义************************typedef long long ll;const int MAXNUM=100000,MAXPR=10000;int mu[MAXNUM+10];//************************线性筛************************bool prv[MAXNUM+10];int prime[MAXPR+10],pr;void getmu()&#123; pr=0;memset(prv,1,sizeof(prv)); mu[1]=1; for(int i=2;i&lt;=MAXNUM;i++) &#123; if(prv[i]==1) &#123; prime[++pr]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=pr;j++) &#123; ll t=ll(i)*ll(prime[j]); if(t&gt;ll(MAXNUM)) break; prv[t]=0; if(i%prime[j]==0) &#123; mu[t]=0; break; &#125; else mu[t]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//************************主函数************************ll calc(int n,int m)&#123; if(n&gt;m) swap(n,m); ll ans=0; int t=1; //F[d]=sigma[ f(t) ] d|t //f(t)=sigma[ mu(d/t)*F[d] ] t|d int last=0; for(int i=1;i&lt;=n;i=last+1)//i=d/t &#123; int d=i*t; last=mymin( n/(n/d) , m/(m/d) ); ans+=ll(mu[last]-mu[i-1])*ll(n/d)*ll(m/d); &#125; return ans;&#125;int main()&#123; getmu(); int n;scanf("%d",&amp;n); for(int tk=1;tk&lt;=n;tk++) &#123; int a,b,c,d,k;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0) &#123; printf("0\n"); continue; &#125; a=(a-1)/k,b=b/k,c=(c-1)/k,d=d/k; printf("%lld\n",calc(b,d)-calc(b,c)-calc(a,d)+calc(a,c)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj2818】GCD-莫比乌斯2]]></title>
    <url>%2Fposts%2F9151.html</url>
    <content type="text"><![CDATA[来源和评测点湖北省队互测Bzoj2818Caioj1281 一模一样的题目但数据强化版：Bzoj2820 YY的GCD 题目【题目大意】给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的数对(x,y)有多少对【输入格式】一个整数N【输出格式】对数【输入样例】4【输出样例】4 分析1莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 数据水到直接硬搞就好就是枚举每个素数p，然后n/p当作m就好了，还不用去重 代码1340 5584 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;int prime[1000000],pr;ll mu[11000000];bool v[11000000];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=10000000;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;=ll(10000000);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;//ll F[10000000],f[11000000];int main()&#123; getmu(); int n;scanf("%d",&amp;n); ll ans=0; for(int pi=1;pi&lt;=pr;pi++) &#123; int p=prime[pi];if(p&gt;n) break; int m=n/p; int t=1; for(int i=1;i&lt;=m;i++)//d/t &#123; int d=i*t; //F[d]=ll( m/d )*ll( m/d ); //ans1+=mu[i]*F[i]; ans+=mu[i]*ll( m/d )*ll( m/d ); &#125; &#125; printf("%lld\n",ans);&#125; 分析2可以采用前缀和优化+分块思想因为（m/d）有连续的一段是相等的，所以对莫比乌斯函数计算前缀和 代码2256 5276 ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;int prime[1000000],pr;ll mu[11000000];bool v[11000000];void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=10000000;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;=ll(10000000);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; else mu[i*prime[j]]=-mu[i]; &#125; mu[i]+=mu[i-1]; &#125;&#125;//ll F[10000000],f[11000000];int main()&#123; getmu(); int n;scanf("%d",&amp;n); ll ans=0; for(int pi=1;pi&lt;=pr;pi++) &#123; int p=prime[pi];if(p&gt;n) break; int m=n/p; int t=1;int last=0; for(int i=1;i&lt;=m;i=last+1)//d/t &#123; int d=i*t; last=mymin(m,m/(m/d)); ans+=(mu[last]-mu[i-1])*ll( m/d )*ll( m/d ); &#125; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hdu1695】GCD(莫比乌斯1)]]></title>
    <url>%2Fposts%2Fd395.html</url>
    <content type="text"><![CDATA[来源和评测点2008 “Sunline Cup” National Invitational ContestHdu1695Caioj1280 题目【题目大意】对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数，保证所有数据中a和c一定等于1。 注意：2，3和3，2是一种情况【输入格式】第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k【输出格式】共n行，每行一个整数表示满足要求的数对(x,y)的个数【输入样例】21 3 1 5 11 11014 1 14409 9【输出样例】9736427 分析莫比乌斯教程和题目分类参见：【OI之路】11更高级数论-2莫比乌斯其他莫比乌斯题目参见：Tag-莫比乌斯 这道题分析在教程，因为是模版题我的代码尽量贴合教程了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;typedef long long ll;const int MAXN=1000000;ll mu[MAXN+100000];bool v[MAXN+100000];int prime[MAXN+100000],pr;void getmu()&#123; mu[1]=1;pr=0; memset(v,1,sizeof(v)); for(int i=2;i&lt;=MAXN;i++) &#123; if(v[i]==1) prime[++pr]=i,mu[i]=-1; for(int j=1;j&lt;=pr and ll(i)*ll(prime[j])&lt;ll(MAXN);j++) &#123; v[ i*prime[j] ]=0; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;ll F[MAXN],f[MAXN];int main()&#123; getmu(); int n;scanf("%d",&amp;n); for(int fs=1;fs&lt;=n;fs++) &#123; int a,b,c,d,k;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf("Case %d: ",fs); if(k==0) &#123; printf("0\n"); continue; &#125; int n=b/k,m=d/k; if(n&gt;m) swap(n,m); ll ans1=0,ans2=0; int t=1; for(int i=1;i&lt;=n;i++)//d/t &#123; int d=i*t; F[d]=ll( n/d )*ll( m/d ); ans1+=mu[i]*F[i]; &#125; for(int i=1;i&lt;=n;i++)//d/t &#123; int d=i*t; F[d]=ll( n/d )*ll( n/d ); ans2+=mu[i]*F[i]; &#125; printf("%lld\n",ans1-ans2/2); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1001】狼抓兔子]]></title>
    <url>%2Fposts%2F9c9f.html</url>
    <content type="text"><![CDATA[来源和评测点BeiJing2006Bzoj1001 题目【题目大意】现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为(1,1),右下角点为(N,M)(上图中N=3,M=4)。有以下三种类型的道路：1:(x,y)&lt;==&gt;(x+1,y)2:(x,y)&lt;==&gt;(x,y+1)3:(x,y)&lt;==&gt;(x+1,y+1)道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路。你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。【输入格式】第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值.第二部分共N-1行，每行M个数，表示纵向道路的权值.第三部分共N-1行，每行M-1个数，表示斜向道路的权值.输入文件保证不超过10M【输出格式】输出一个整数，表示参与伏击的狼的最小数量.【输入样例】3 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6【输出样例】14 分析1网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他最小割题目参见：Tag-最小割 一看就是最小割 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/************************************************************** Problem: 1001 User: Zory Language: C++ Result: Accepted Time:1256 ms Memory:85196 kb****************************************************************/ //最小割#include&lt;cstdio&gt;//#include&lt;cstdlib&gt;#include&lt;cstring&gt;//#include&lt;cctype&gt;#include&lt;cmath&gt;//#include&lt;ctime&gt;//#include&lt;queue&gt;#include&lt;set&gt;//#include&lt;stack&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;/*int myabs(int a)&#123; return a&gt;0?a:-a;&#125;void myswap(int &amp;x,int &amp;y)&#123; int t=x;x=y;y=t;&#125;*/int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;//*******************定义*******************const int Maxn=1100000,Maxm=6100000;int st,ed;int hou[Maxn],h[Maxn];struct nod&#123; int y,c;int gg;&#125;e[Maxm];//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].gg=hou[x];hou[x]=ln;&#125;int getoth(int x) &#123; return (x%2==0)?x-1:x+1; &#125;int q[Maxn];bool bfs()&#123; memset(h,0,sizeof(h)); q[1]=st;h[st]=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=q[tou]; for(int k=hou[x];k&gt;0;k=e[k].gg) &#123; int y=e[k].y; if(h[y]==0 and e[k].c&gt;0 ) &#123; h[y]=h[x]+1; q[++wei]=y; if(y==ed) return 1; &#125; &#125; tou++; &#125; return 0;&#125;int dfs(int x,int s)&#123; if(x==ed) return s; int t=0; for(int k=hou[x];k&gt;0;k=e[k].gg ) &#123; int y=e[k].y; if(h[y]==h[x]+1 and e[k].c&gt;0 and t&lt;s ) &#123; int b=dfs(y,mymin(e[k].c,s-t)); e[k].c-=b;e[getoth(k)].c+=b;t+=b; if(s==t) return s; &#125; &#125; if(t==0) h[x]=0; return t;&#125;//*******************接口*******************int n,m;int pt(int x,int y)&#123; return (x-1)*m+y;&#125;//*******************主函数*******************int tx[3]=&#123;0,1,1&#125;;int ty[3]=&#123;1,0,1&#125;;int main(int argc, char *argv[])&#123; scanf("%d%d",&amp;n,&amp;m); ln=0; for(int k=0;k&lt;=2;k++) for(int i=1;i&lt;=((k==0)?n:n-1);i++) for(int j=1;j&lt;=((k==1)?m:m-1);j++) &#123; int x=pt(i,j),y=pt(i+tx[k],j+ty[k]),c=read(); ins(x,y,c);ins(y,x,c); &#125; st=1;ed=pt(n,m); int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d\n",ans);&#125; 分析2可以将网格图转化为对偶图可以参考论文：https://wenku.baidu.com/view/8f1fde586edb6f1aff001f7d 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/************************************************************** Problem: 1001 User: Zory Language: C++ Result: Accepted Time:1536 ms Memory:126332 kb****************************************************************/ //Dijkstra#include&lt;cstdio&gt;//#include&lt;cstdlib&gt;#include&lt;cstring&gt;//#include&lt;cctype&gt;#include&lt;cmath&gt;//#include&lt;ctime&gt;#include&lt;queue&gt;//#include&lt;set&gt;//#include&lt;stack&gt;//#include&lt;iostream&gt;//#include&lt;string&gt;//#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;int mymin(int a,int b)&#123; return a&gt;b?b:a;&#125;/*int myabs(int a)&#123; return a&gt;0?a:-a;&#125;void myswap(int &amp;x,int &amp;y)&#123; int t=x;x=y;y=t;&#125;*/int read()&#123; int s=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') s=s*10+c-'0',c=getchar(); return s;&#125;//*******************定义*******************const int Maxn=2100000,Maxm=8100000;struct nod1&#123; int hou,ans;&#125;p[Maxn];struct nod2&#123; int y,c;int gg;&#125;e[Maxm];int st,ed;//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].gg=p[x].hou; p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].gg=p[y].hou; p[y].hou=ln;&#125;typedef pair&lt;int,int&gt; P;priority_queue&lt; P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q;void Dijkstra()&#123; while(!q.empty()) q.pop(); p[st].ans=0; q.push(make_pair(0,st)); while(!q.empty()) &#123; P s=q.top();q.pop(); int x=s.second; if(s.first&gt;p[x].ans) continue; for(int k=p[x].hou;k&gt;0;k=e[k].gg) &#123; int y=e[k].y; if(p[y].ans&gt;p[x].ans+e[k].c) &#123; p[y].ans=p[x].ans+e[k].c; q.push(make_pair(p[y].ans,y)); &#125; &#125; &#125;&#125;//*******************接口*******************int a,b;int pt(int x,int y)&#123; return (x-1)*b+y;&#125;//*******************主函数*******************int t[3][1100][1100];int main(int argc, char *argv[])&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); if(n==1 or m==1) &#123; if(n&gt;m) swap(n,m); int ans=INF; for(int i=1,a;i&lt;m;i++) &#123; scanf("%d",&amp;a); ans=mymin(ans,a); &#125; printf("%d",ans==INF?0:ans); return 0; &#125; for(int k=0;k&lt;=2;k++) for(int i=1;i&lt;=(k==0?n:n-1);i++) for(int j=1;j&lt;=(k==1?m:m-1);j++) t[k][i][j]=read(); ln=0; a=(n-1)*2,b=m-1; int cnt=a*b; for(int i=1;i&lt;=cnt+2;i++) &#123; p[i].ans=INF; p[i].hou=0; &#125; for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++) if(i%2==0) &#123; ins(pt(i,j),pt(i-1,j),t[2][i/2][j]); &#125; else &#123; if(i&gt;1) ins(pt(i,j),pt(i-1,j),t[0][(i+1)/2][j]); if(j&lt;b) ins(pt(i,j),pt(i+1,j+1),t[1][(i+1)/2][j+1]); &#125; st=cnt+1;ed=cnt+2; for(int i=2;i&lt;=a;i+=2) ins(st,pt(i,1),t[1][i/2][1]),//左 ins(pt(i-1,b),ed,t[1][i/2][m]);//右 for(int j=1;j&lt;=b;j++) ins(st,pt(a,j),t[0][n][j]),//下 ins(pt(1,j),ed,t[0][1][j]);//上 Dijkstra(); printf("%d",p[ed].ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最短路</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>最小割</tag>
        <tag>对偶图</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1645】City Horizon城市地平线]]></title>
    <url>%2Fposts%2Feed1.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2007 Open SilverBzoj1645 题目【题目大意】约翰带着奶牛去都市观光。在落日的余晖里，他们看到了一幢接一幢的摩天高楼的轮廓在地平线上形成美丽的图案。以地平线为 X 轴，每幢高楼的轮廓是一个位于地平线上的矩形，彼此间可能有重叠的部分。奶牛一共看到了N幢高楼，第i幢楼的高度是Hi，两条边界轮廓在地平线上的坐标是Ai到Bi。请帮助奶牛们计算一下，所有摩天高楼的轮廓覆盖的总面积是多少。【输入格式】第一行：单个整数N，1≤N≤40000第二行到第N+1行：第i+1行有三个整数Ai，Bi和Hi，1≤Ai&lt;Bi≤10^9, 1≤Hi≤10^9【输出格式】单个整数：表示摩天高楼轮廓所覆盖的总面积【输入样例】42 5 19 10 46 8 24 6 3【输出样例】16【样例解释】只有第一幢楼和最后一幢楼有1个单位的重叠面积 分析线段树教程和题目分类参见：【OI之路】06树-1线段树其他线段树题目参见：Tag-线段树 我看到网上有说“扫描线”，并不知道是什么……反正我的做法就是离散化信息，然后使用线段树，区间修改，维护单点最值最后求和即可 具体可参考注释 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;typedef long long ll;struct seg&#123; int l,r,mid; int lc,rc; int mx,lz;&#125;p[200000];int ln;int build(int l,int r)&#123; int t=++ln; p[t].l=l;p[t].r=r;p[t].mid=(l+r)&gt;&gt;1; if(l&lt;r) &#123; p[t].lc=build(l,p[t].mid); p[t].rc=build(p[t].mid+1,r); &#125; return t;&#125;//lz是lazy优化（区间修改一般都有）//定义为某尚未尝试更新的值，且必须下传void pushdown(int x)&#123; if(!p[x].lz) return; p[x].mx=mymax(p[x].mx,p[x].lz); int lc=p[x].lc,rc=p[x].rc; p[lc].lz=mymax(p[lc].lz,p[x].lz); p[rc].lz=mymax(p[rc].lz,p[x].lz); p[x].lz=0;&#125;void change(int x,int l,int r,int c)&#123; if(p[x].l==l and p[x].r==r) &#123; p[x].lz=mymax(p[x].lz,c); return; &#125; pushdown(x); int lc=p[x].lc,rc=p[x].rc; if(r&lt;=p[x].mid) change(lc,l,r,c); else if(l&gt;p[x].mid) change(rc,l,r,c); else change(lc,l,p[x].mid,c),change(rc,p[x].mid+1,r,c);&#125;int ask(int w,int x)&#123; pushdown(w); if(p[w].l==p[w].r) return p[w].mx; if(x&lt;=p[w].mid) return ask(p[w].lc,x); return ask(p[w].rc,x);&#125;int n;int a[81000];int l[41000],r[41000],h[41000];int find(int x)&#123; int l=1,r=2*n; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&lt;x) l=mid+1; else if(a[mid]==x) return mid; else r=mid-1; &#125;&#125;//由于是函数，保证了相同x返回相同的值，具体是什么不重要int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d",&amp;l[i],&amp;r[i],&amp;h[i]); if(l[i]==r[i])//特判，防止空信息 &#123; i--;n--; continue; &#125; a[2*i-1]=l[i];a[2*i]=r[i]; &#125; sort(a+1,a+1+2*n); int rx=2*n; //改点区间为段区间，便于维护 ln=0;build(1,rx); for(int i=1;i&lt;=n;i++) change(1,find(l[i])+1,find(r[i]),h[i]); //二分离散化 //为了能够实现同值的结果依然同值并且获得损失的区间信息量 ll s=0; for(int i=2;i&lt;=2*n;i++) s+=ll(ask(1,i))*ll(a[i]-a[i-1]); //记得还原信息 printf("%lld",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bzoj1934】【Bzoj2768】善意的投票&冠军调查]]></title>
    <url>%2Fposts%2Fa1fb.html</url>
    <content type="text"><![CDATA[来源和评测点这两道题连样例都是一模一样的……下文以1934来分析Bzoj1934Bzoj2768 注意！Bzoj2768冠军调查数据可能和题面不同，网络流边数应开到40万而不是10万 题目【题目大意】幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。 我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？【输入格式】第一行只有两个整数n，m，保证有2≤n≤300，1≤m≤n(n-1)/2。其中n代表总人数，m代表好朋友的对数。文件第二行有n个整数，第i个整数代表第i个小朋友的意愿，当它为1时表示同意睡觉，当它为0时表示反对睡觉。接下来文件还有m行，每行有两个整数i，j。表示i，j是一对好朋友，我们保证任何两对i，j不会重复。【输出格式】只需要输出一个整数，即可能的最小冲突数。【输入样例】3 31 0 01 21 33 2【输出样例】1【样例解释】所有小朋友都投赞成票就能得到最优解 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他最小割题目参见：Tag-最小割 考验模型转化能力，难度2吧想了十多分钟？当然，已经知道是最小割了 “分配方案”、“强制站队”是我自己的理解方式，因人而异吧 一开始想着“分配方案”最大流，每个人与1、0连接，然后后面朋友间的边权依赖于前面，所以不可行 由于只有睡和不睡两种选择，考虑最小割“强制站队”，源点是睡觉的，汇点是不睡觉的每个人只能选择其中一个，形成了最小割构图：依然要拆点源点到左人、右人到汇点，边权都根据个人意愿决定，是自己意愿就是1，因为拆了就违反意愿，否则为0同理，好朋友之间边权是1 想想特例:1、所有人都不想睡觉，最大流是0好朋友之间也不会有违背，确实是0，没问题2、没有好朋友，最大流是0直接每个人依照自己意愿，确实是0，也没问题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int MAXN=1000,MAXM=410000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; lst[1]=st;p[st].h=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and t&lt;f and e[k].c&gt;0) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); st=n+n+1,ed=n+n+2;ln=0; for(int i=1;i&lt;=n;i++) &#123; int t;scanf("%d",&amp;t); if(t) ins(st,i,1); else ins(n+i,ed,1); &#125; for(int i=1;i&lt;=m;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,n+y,1);ins(y,n+x,1); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3189】Steady Cow Assignment]]></title>
    <url>%2Fposts%2Fb6a3.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2006 February GoldPoj3189Caioj1120 题目【题目大意】有N(1&lt;=N&lt;=1000)头牛，B(1&lt;=B&lt;=20)个牛圈每头牛对于牛圈都有不同的喜好程度排名，牛圈有一定的容量对于某种分配方案，假如牛1去了牛圈3，是它的第五志愿，记满意程度=5输出（所有牛的满意程度 最大值到最小值的区间）的最小值相当于 （MAX牛的满意程度）-（MIN牛的满意程度）+1重点句：Your job is to find an assignment of cows to barns such that no barn’s capacity is exceeded and the size of the range (i.e., one more than the positive difference between the the highest-ranked barn chosen and that lowest-ranked barn chosen) of barn rankings the cows give their assigned barns is as small as possible.【输入格式】第一行N和B接下来N行，每行B个数，表示喜欢的牛圈的序号，按喜欢的程度（递减）给出，（比如第一个给出的牛圈的就是最喜欢，最后一个就是最不喜欢的）接下来B个数，每个数表示牛圈最多容纳的牛的数目【输出格式】最小的“满意程度区间”【输入样例】6 41 2 3 42 3 1 44 2 3 13 1 2 41 3 4 21 4 2 32 1 3 2【输出样例】2【样例解释】牛圈1：牛1 牛5牛圈2：牛2牛圈3：牛4牛圈4：牛3 牛6满意程度 1 1 1 1 1 2答案就是 2 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 其实可以尝试着看看英文题题意我翻译好了，caioj不完整也不好理解，POJ全英文 对于区间，枚举下界，在此基础上二分答案O( B*logB*(n^3) )这做法真的狗血，好久没用过枚举了 构图：源点到牛连权值为1的边牛到牛圈连权值为1的边牛圈到汇点连权值为 该牛圈容量 的边 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=1100,MAXM=61000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int n,b;int lv[MAXN][30];int ct[30];bool check(int ll,int rr)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,1); for(int j=ll;j&lt;=rr;j++) ins(i, n+lv[i][j] ,1); &#125; for(int i=1;i&lt;=b;i++) ins(n+i,ed,ct[i]); int ans=0; while( bfs() ) ans+=dfs(st,INF); //printf("-----ll=%d rr=%d ans=%d n=%d\n",ll,rr,ans,n); return ans==n;&#125;int getans(int low)&#123; int l=1,r=b-low+1,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(low,low+mid-1)) ans=mid,r=mid-1; else l=mid+1; &#125; //printf("low=%d ans=%d\n",low,ans); return ans&lt;0?INF:ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;b); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=b;j++) scanf("%d",&amp;lv[i][j]); for(int i=1;i&lt;=b;i++) scanf("%d",&amp;ct[i]); st=n+b+1,ed=n+b+2; int mi=INF; for(int i=1;i&lt;=b;i++) mi=mymin(mi, getans(i) ); printf("%d",mi);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
        <tag>难度2</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2112】Optimal Milking]]></title>
    <url>%2Fposts%2F41bc.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2003 US OpenPoj2112Caioj1119 题目【题目大意】FJ把K个挤奶机搬进了住着C头奶牛的牧场。挤奶机的编号为1~K，奶牛的编号为K+1~K+C。每头奶牛到每台挤奶机距离不同，每台挤奶机每天最多服务M头奶牛。求一种分配方案, 使得走得最远的奶牛走过的距离最小化，输出此距离重点句：Cows can traverse several paths on the way to their milking machine. 路径the distance the furthest-walking cow travels is minimized 走最多的牛的路程最小【输入格式】数据第1行是3个整数K，C，M（1≤K≤30）（1≤C≤200）（1≤M≤15）接下来是一个（K+C）×（K+C）的距离矩阵。矩阵元素为正并不超200。距离为0表示两个点之间无边存在。【输出格式】输出一个整数，即走得最远的奶牛走过的距离的最小化值。【输入样例】2 3 20 3 2 1 13 0 3 2 02 3 0 1 01 2 1 0 21 0 0 2 0【输出样例】2 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 其实可以尝试着看看英文题 依旧是folyd，然后二分答案(反正最终还是要到达挤奶机的) 构图：从源点到牛建权值为1的边牛到挤奶机建权值为1的边（当满足二分条件时）挤奶机到汇点建权值为m的边 相比上一题Ombrophobic Bovines相当无聊，秒AC 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=310,MAXM=91000;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln].oth=ln-1;e[ln-1].oth=ln;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;//挤奶机的编号为1~K，奶牛的编号为K+1~K+Cint cst[MAXN][MAXN];int nk,nc,m;bool check(int mid)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=nc;i++) ins(st,i,1); for(int i=1;i&lt;=nc;i++) for(int j=1;j&lt;=nk;j++) if(cst[j][nk+i]&lt;=mid) ins(i,nc+j,1); for(int j=1;j&lt;=nk;j++) ins(nc+j,ed,m); int ans=0; while(bfs()) ans+=dfs(st,INF); return ans==nc;&#125;int main()&#123; scanf("%d%d%d",&amp;nk,&amp;nc,&amp;m); st=nc+nk+1,ed=nc+nk+2; int n=nk+nc; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int c;scanf("%d",&amp;c); cst[i][j]=(c==0)?INF:c; &#125; int l=0,r=0; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; int tt=cst[i][k]+cst[k][j]; if(tt&lt;cst[i][j]) cst[i][j]=tt; if(cst[i][j]!=INF and r&lt;cst[i][j]) r=cst[i][j]; &#125; int ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125; 分析2然鹅通过改进匈牙利算法实现多重二分图匹配能大幅度加快速度，从而取代网络流思路来自http://blog.csdn.net/leolin_/article/details/7195205 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;const int INF=0x3f3f3f3f;const int MAXGN=300,MAXMN=50,MAXM=15000;int hou[MAXGN];struct rod&#123; int y,g;&#125;e[MAXM];int ln;void ins(int x,int y)&#123; ln++;e[ln].y=y; e[ln].g=hou[x];hou[x]=ln;&#125;int gn,mn;int mnum[MAXMN];int match[MAXMN][20];int ask[MAXMN];int tnow;int kk,cc,mm;bool find_muniu(int x)&#123; for(int k=hou[x];k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(ask[y]&lt;tnow) &#123; ask[y]=tnow; if(mnum[y]&lt;mm) &#123; match[y][++mnum[y]]=x; return 1; &#125; else &#123; for(int z=1;z&lt;=mnum[y];z++) &#123; if(find_muniu( match[y][z] )) &#123; match[y][z]=x; return 1; &#125; &#125; &#125; &#125; &#125; return 0;&#125;int cst[MAXGN+MAXMN][MAXGN+MAXMN];bool check(int mid)&#123; ln=0; for(int i=1;i&lt;=gn;i++) &#123; hou[i]=0; for(int j=1;j&lt;=mn;j++) if(cst[kk+i][j]&lt;=mid) ins(i,j); &#125; memset(ask,0,sizeof(ask));//debug memset(mnum,0,sizeof(mnum));//debug for(tnow=1;tnow&lt;=gn;tnow++) if(find_muniu(tnow)==0) return 0; return 1;&#125;int mx;void folyd(int n)&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cst[i][j]=mymin(cst[i][k]+cst[k][j],cst[i][j]); mx=0; for(int i=1;i&lt;=kk;i++) for(int j=1;j&lt;=cc;j++) if(cst[i][j]&gt;mx and cst[i][j]&lt;INF) mx=cst[i][j];&#125;int main()&#123; scanf("%d%d%d",&amp;kk,&amp;cc,&amp;mm); for(int i=1;i&lt;=kk+cc;i++) for(int j=1;j&lt;=kk+cc;j++) &#123; int t;scanf("%d",&amp;t); cst[i][j]=(t==0)?INF:t; &#125; folyd(kk+cc); gn=cc,mn=kk; int l=0,r=mx,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
        <tag>难度2</tag>
        <tag>匈牙利</tag>
        <tag>最大流</tag>
        <tag>Floyd</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Usaco05Mar】Ombrophobic Bovines]]></title>
    <url>%2Fposts%2F44a6.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2005 March GoldBzoj1738Poj2391Caioj1118 题目【题目大意】下雨了，有F(1&lt;=F&lt;=200)个牛棚，这F个牛棚之间有P(1&lt;=P&lt;=1500)条无向边（有耗时）每个牛棚有两个值A和B（A表示一开始这个牛棚有A头牛，B表示下雨时该牛棚最多可以容纳B头牛躲雨）。问最少需要提前多少时间响“下雨警告”才能让所有牛在下雨前都能够找到可以遮雨的地方。 重点句：The paths are wide,so that any number of cows can traverse a path in either direction. 无向边Fields are small compared to the paths and require no time for cows to traverse. 将牛棚看作点【输入格式】两个整数: F 和 P接下来F行，第i行两个整数A和B（A、B的范围都是:0..1000）描述第i个牛棚接下来P行，每行三个整数。X Y L，表示牛棚X和牛棚Y之间有一条边，耗时是L（1&lt;=L&lt;=1,000,000,000）【输出格式】输出一行，即为最短的时间，如果无法使得所有牛都能够有地方避雨，那么输出 “-1”【输入样例】3 47 20 42 61 2 403 2 702 3 901 3 120【输出样例】110【样例解释】牛棚1安排4头牛到牛棚2，牛棚1再安排1头牛走到牛棚2，再走到牛棚3避雨。 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流本题入选了好题：Tag-好题 这道题建议大家像我一样仔细想想，别急着看题解，虽然你到我这个页面很可能是来膜题解的 由于边比较复杂，但又是无向图考虑Floyd获得两点之间最短耗时然后两点之间只存在一条边了 原问题转化成：选一些边来满足条件并且最长边最小条件为牛跑来跑去后每个牛棚能容纳下 考虑二分答案，从而得到满足的边，跑一遍网络流验证解的可行性 构图：从汇点到各个左牛棚，容量是每个牛棚原本的牛数量拆点，从左牛棚连到右牛棚，表示可以通过去，容量是无限从右牛棚到汇点，容量是牛棚最后的最大容纳 假如最大流=牛的数量F 表示可行 记得自己可以连自己 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=510,MAXM=110000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(f-t,e[k].c)); t+=tt;e[k].c-=tt;e[e[k].oth].c+=tt; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;/*1~n 左牛棚n+1~n+n 右牛棚n+n+1 源点n+n+2 汇点*/int n;int alc;int aa[MAXN],bb[MAXN];ll cst[MAXN][MAXN];bool check(ll mid)&#123; ln=0;for(int i=1;i&lt;=ed;i++) p[i].hou=0; for(int i=1;i&lt;=n;i++) &#123; ins(st,i,aa[i]);ins(i,n+i,INF);ins(n+i,ed,bb[i]); for(int j=1;j&lt;=n;j++) if(cst[i][j]&lt;=mid) ins(i,n+j,INF); &#125; int ans=0; while(bfs()) ans+=dfs(st,INF); //printf("mid=%d ans=%d alc=%d\n",mid,ans,alc); return ans==alc;&#125;int main()&#123; memset(cst,63,sizeof(cst)); int m;scanf("%d%d",&amp;n,&amp;m); st=n+n+1,ed=n+n+2; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;aa[i],&amp;bb[i]),alc+=aa[i]; for(int i=1;i&lt;=m;i++) &#123; int x,y;ll c;scanf("%d%d%lld",&amp;x,&amp;y,&amp;c); if(c&lt;cst[x][y]) cst[x][y]=cst[y][x]=c; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; ll nt=cst[i][k]+cst[k][j]; if(nt&lt;cst[i][j]) cst[i][j]=nt; &#125; ll l=0,r=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i-1;j++) if(cst[i][j]!=cst[0][0] and cst[i][j]&gt;r) r=cst[i][j]; ll ans=-1; while(l&lt;=r) &#123; ll mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
        <tag>最大流</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj2455】【Bzoj1733】Secret Milking Machine]]></title>
    <url>%2Fposts%2F7731.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2005 February GoldPoj2455Bzoj1733Caioj1117 题目【题目大意】给出N(2&lt;=N&lt;=200)个点和P(1&lt;=P&lt;=40000)条双向边，每条边的长度为（0~1000000）现在要求选出T(1&lt;=T&lt;=200)条“1至N”的路径，任意两条路径上的边不能重复并且要求这些路径中的最长边的长度最小注意：两个点之间有可能多条边，出发点是1，终点是N【输入格式】第一行三个整数: N,P,T下来P行,每行三个整数x,y,L,描述一条边：从点x到y的双向边，长度为Li【输出格式】求这T条路径中的的最长边的最小值【输入样例】7 9 21 2 22 3 53 7 51 4 14 3 14 5 75 7 11 6 36 7 3【输出样例】5提示：样例最后选择了两条路径 1-2-3-7 和 1-6-7 最长的路是5. 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 注意两个概念：边 和 路径（路径是由多条边组成，当然可以是一条边）这题需要建立模型重点是二分，在同学的提醒下想到这个，然后就想通了就是二分最长边长度，满足结果（可行性）有序性因为每条边只能去一次，边权为1即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125;int mymax(int x,int y) &#123;return x&gt;y?x:y;&#125;const int MAXN=210,MAXM=81000;struct pt&#123; int hou; int h;&#125;p[MAXN];struct rod&#123; int y,c,g; int oth;&#125;e[MAXM];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; ln++; e[ln].y=x;e[ln].c=c; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int m,T;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=st;i&lt;=ed;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[st].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; //printf("---x=%d f=%d\n",x,f); if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(t&lt;f and e[k].c&gt;0 and p[y].h==p[x].h+1) &#123; int fs=dfs(y,mymin(e[k].c,f-t)); t+=fs;e[k].c-=fs;e[e[k].oth].c+=fs; &#125; &#125; if(t==0) p[x].h=0; return t;&#125;int xx[MAXM],yy[MAXM],cc[MAXM];bool check(int mid)&#123; for(int i=st;i&lt;=ed;i++) p[i].hou=0; ln=0; for(int i=1;i&lt;=m;i++) if(cc[i]&lt;=mid) ins(xx[i],yy[i],1); int ans=0; while(bfs()) ans+=dfs(st,INF); return ans&gt;=T;&#125;int main()&#123; int n;scanf("%d%d%d",&amp;n,&amp;m,&amp;T); int l=INF,r=-INF; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;xx[i],&amp;yy[i],&amp;cc[i]); l=mymin(l,cc[i]);r=mymax(r,cc[i]); &#125; st=1,ed=n; int ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度2</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj3281】Dining]]></title>
    <url>%2Fposts%2F6d11.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 2007 Open GoldPoj3281Caioj1116 题目【题目大意】有F(1≤F≤1000)块不同的肉（编号1~F）和D(1≤D≤1000)罐不同的饮料（编号1~D），N(1≤N≤1000)头（编号1~N）。每头牛有自己喜欢的肉和饮料。每块肉和每罐饮料只能供给一头牛使用。求最多能满足多少头牛能同时享用到自己喜欢的肉和饮料。（注意某头牛得到满足，不要求享用自己所有喜欢的肉和饮料，只要喜欢的肉的其中一块和自己喜欢的饮料其中一罐就可以算满足）【输入格式】第一行：三个整数N,F,D接下来N行。每行描述一头牛。每行开头两个整数Fi和Di，Fi表示该牛喜欢的肉的数目，Di表示它喜欢的饮料的数目。接下来Fi个数，各表示它喜欢的肉的编号，再来Di个数，表示它喜欢的饮料的编号。（注意Fi和Di有可能为0）【输出格式】一个整数，最大满足的牛的数目【输入样例】4 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3【输出样例】3 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 类似模板题终极起点连接肉肉连接牛牛连接饮料饮料连接终极终点 但还要拆点，为了让一头牛只能选一种，把一头牛分成两个，自己连自己 所有边权都是1，这样的最大流就是方案数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAXN=5000,MAXM=1000000;struct pt&#123; int h; int hou;&#125;p[MAXN];struct edge&#123; int y,c,g; int oth;&#125;e[2*MAXM];int ln;void ins(int x,int y,int c)&#123; e[++ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln; e[++ln].y=x;e[ln].c=0; e[ln].g=p[y].hou;p[y].hou=ln; e[ln-1].oth=ln;e[ln].oth=ln-1;&#125;int st,ed;int lst[MAXN];bool bfs()&#123; for(int i=1;i&lt;=ed;i++) p[i].h=0; lst[1]=st;p[st].h=1; int tou=1,wei=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125;int dfs(int x,int f)&#123; if(x==ed) return f;//debug int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[x].h+1==p[y].h and e[k].c&gt;0 and t&lt;f) &#123; int s=dfs(y,mymin(f-t,e[k].c)); t+=s;e[k].c-=s;e[e[k].oth].c+=s; &#125; &#125; if(t==0) p[x].h=0;//debug return t;&#125;/*1~ff+1~f+nf+n+1~f+n+nf+n+n+1~f+n+n+d*/int main()&#123; int n,f,d;scanf("%d%d%d",&amp;n,&amp;f,&amp;d); int cw1=f,cw2=f+n,dk=f+n+n; st=f+n+n+d+1,ed=f+n+n+d+2; ln=0; for(int i=1;i&lt;=n;i++) &#123; int fi,di;scanf("%d%d",&amp;fi,&amp;di); for(int j=1;j&lt;=fi;j++) &#123; int t;scanf("%d",&amp;t); ins(t,cw1+i,1); &#125; for(int j=1;j&lt;=di;j++) &#123; int t;scanf("%d",&amp;t); ins(cw2+i,dk+t,1); &#125; ins(cw1+i,cw2+i,1); &#125; for(int i=1;i&lt;=f;i++) ins(st,i,1); for(int i=1;i&lt;=d;i++) ins(dk+i,ed,1); int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度1</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Poj1273】网络流模版题Drainage Ditches]]></title>
    <url>%2Fposts%2F9eca.html</url>
    <content type="text"><![CDATA[来源和评测点USACO 1993Poj1273Syzoj11772Hdu1532Caioj1115 题目【题目大意】有N条水渠,及M个池塘给出M条水渠所连接的池塘和所能流过的水量（有向）求水渠1到水渠M中所能流过的水的最大容量 （Caioj上先池塘后水渠）（Hdu上多组数据）【输入格式】第1行:2个整数N(0&lt;=N&lt;=200)和M(2&lt;=M&lt;=200)接下来M行: 每行有三个整数：x,y,c表示一条从点x到点y的有向边，流量为c(0&lt;=c&lt;=10,000,000)【输出格式】输出一个整数，即最大流量。【输入样例1】5 41 2 401 4 202 4 202 3 303 4 10【输出样例1】50 理论上可以卡最短路的数据【输入样例2】4 41 2 102 4 52 3 203 4 10【输出样例2】10 分析网络流教程和题目分类参见：【OI之路】03图论算法-4网络流其他网络流题目参见：Tag-网络流 模板题 代码我的代码n是点数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int mymin(int x,int y) &#123;return x&lt;y?x:y;&#125; const int MAXN=210;const int INF=0x3f3f3f3f; struct pt&#123; int h; int hou;&#125;p[MAXN];struct nod&#123; int y,c,g;&#125;e[MAXN*2];int ln;void ins(int x,int y,int c)&#123; ln++; e[ln].y=y;e[ln].c=c; e[ln].g=p[x].hou;p[x].hou=ln;&#125; int n;int lst[MAXN];int st,ed;bool bfs()&#123; for(int i=1;i&lt;=n;i++) p[i].h=0; int tou=1,wei=1; lst[1]=st;p[1].h=1; while(tou&lt;=wei) &#123; int x=lst[tou]; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==0 and e[k].c&gt;0) &#123; p[y].h=p[x].h+1; lst[++wei]=y; &#125; &#125; tou++; &#125; return p[ed].h&gt;0;&#125; int getoth(int k)&#123; return k%2==0?k-1:k+1;&#125; int dfs(int x,int f)&#123; if(x==ed) return f; int t=0; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].h==p[x].h+1 and e[k].c&gt;0 and t&lt;f) &#123; int tt=dfs(y,mymin(e[k].c,f-t)); t+=tt;e[k].c-=tt;e[getoth(k)].c+=tt; &#125; &#125; return t;&#125; int main()&#123; int m;scanf("%d%d",&amp;m,&amp;n);ln=0; for(int i=1;i&lt;=m;i++) &#123; int x,y,c; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); ins(x,y,c);ins(y,x,0);//反向弧 &#125; st=1;ed=n; int ans=0; while(bfs()) ans+=dfs(st,INF); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>难度1</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017游记]]></title>
    <url>%2Fposts%2Fd1a6.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017训练日记]]></title>
    <url>%2Fposts%2Ff969.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AC自动机】地图匹配]]></title>
    <url>%2Fposts%2F4c6e.html</url>
    <content type="text"><![CDATA[评测点Caioj1465 分析这道题数据的话。。好像直接来自HDU，有谁知道原题请留言然后数据中一个单词只会有一次机会，就不用考虑什么“第一个出现”之类了 从边框开始（尽量不重复）地一遍遍做AC自动机，为了方便求起始点，可以考虑倒着搜索（注意add也要倒着建）为了记录答案，s记录的是“假如是单词的开头，就表示单词编号”。因为是倒着的，c也要转向 【话说这道题应该是没有被覆盖的字符串的】 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//*******************定义*******************struct Trie&#123; int s,c[27],fail; bool b;&#125;a[200010];struct tans&#123; int x,y,c;&#125;ans[200010];//*******************实现*******************void clean(int x)&#123; a[x].s=a[x].fail=a[x].b=0; for(int f=1;f&lt;=26;f++) a[x].c[f]=-1;&#125;char s[2010];int len;int k;void add(int id)&#123; len=strlen(s+1); int x=0; for(int i=len;i&gt;=1;i--) &#123; int f=s[i]-'A'+1; if(a[x].c[f]&lt;0) &#123; a[x].c[f]=++k; clean(k); &#125; x=a[x].c[f]; &#125; a[x].s=id;&#125;int list[50010];void getfail()&#123; int tou=1,wei=2;list[1]=0; while(tou!=wei) &#123; int x=list[tou]; for(int f=1;f&lt;=26;f++) &#123; int son=a[x].c[f]; if(son&lt;0) continue; if(x==0) a[son].fail=0; else &#123; int p=a[x].fail; while(p&gt;0 and a[p].c[f]&lt;0) p=a[p].fail;//类似KMP的思想 a[son].fail=mymax(a[p].c[f],0); //可能没有一个匹配，最后出来的c[i]==-1 &#125; list[wei++]=son;if(wei&gt;50000) wei=1; &#125; tou++;if(tou&gt;50000) tou=1; &#125;&#125;int n,m;bool check(int x,int y)&#123; return x&gt;=1 and y&gt;=1 and x&lt;=n and y&lt;=m;&#125;const int tx[8]=&#123;-1,-1,0,1,1, 1, 0,-1&#125;;const int ty[8]=&#123; 0, 1,1,1,0,-1,-1,-1&#125;;char map[1010][1010];int solve(int x,int y,int c)&#123; int p=0; while(check(x,y)) &#123; int f=map[x][y]-'A'+1; while(p&gt;0 and a[p].c[f]&lt;0) p=a[p].fail; if(a[p].c[f]!=-1) p=a[p].c[f]; int k=p; while(k!=0 and a[k].b==0) &#123; if(a[k].s)//到了结尾 &#123; int o=a[k].s; ans[o].x=x; ans[o].y=y; ans[o].c=(c+4)%8;//因为倒着找，要倒过来 &#125; a[k].b=1;//经过 k=a[k].fail; &#125; x+=tx[c];y+=ty[c]; &#125;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int w;scanf("%d%d%d",&amp;n,&amp;m,&amp;w); for(int i=1;i&lt;=n;i++) scanf("%s",map[i]+1); clean(0);k=0; for(int i=1;i&lt;=w;i++) &#123; scanf("%s",s+1); add(i); &#125; //计算fail getfail(); //从边框开始（尽量不重复） for(int i=1;i&lt;=n;i++) &#123; solve(i,1,1);solve(i,1,2);solve(i,1,3);//左边 solve(i,m,5);solve(i,m,6);solve(i,m,7);//右边 &#125; for(int j=1;j&lt;=m;j++) &#123; solve(1,j,3);solve(1,j,4);solve(1,j,5);//上边 solve(n,j,7);solve(n,j,0);solve(n,j,1);//下边 &#125; for(int i=1;i&lt;=w;i++) printf("%d %d %c\n",ans[i].x-1,ans[i].y-1,ans[i].c+'A');&#125; 另外，如果你更喜欢正着搜索，就要正着add，s也放到结尾，c就不用转向了。给出不同的部分:add函数：12345678910111213141516void add(int id)&#123; ans[id].len=strlen(s+1); int x=0; for(int i=1;i&lt;=ans[id].len;i++) &#123; int f=s[i]-'A'+1; if(a[x].c[f]&lt;0) &#123; a[x].c[f]=++k; clean(k); &#125; x=a[x].c[f]; &#125; a[x].s=id;&#125; solve函数：12345678if(a[k].s)//到了结尾 &#123; int o=a[k].s; ans[o].x=x-(ans[o].len-1)*tx[c]; ans[o].y=y-(ans[o].len-1)*ty[c]; ans[o].c=c; //ans[o].c=(c+4)%8;//因为倒着找，要倒过来 &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree3]]></title>
    <url>%2Fposts%2Fa8dd.html</url>
    <content type="text"><![CDATA[评测点Caioj1432SPOJ2789 分析第三题终于修改线段树部分了，并且运用到将新编号转换回去那个yzz数组了。 2018.01.24 UP:其实蛮简单的……各位珍惜这种做较简单的中型数据结构的时光吧…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//*******************线段树*******************struct nod1&#123; int lz,rz,l,r,c; //c=0 没有 否则是第一个编号&#125;e[400010];int qq;int build(int l,int r)&#123; int t=++qq; e[t].l=l;e[t].r=r; e[t].lz=e[t].rz=-1; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; e[t].lz=build(l,mid); e[t].rz=build(mid+1,r); &#125; return t;&#125;void change(int x,int p)&#123; if(e[x].l==e[x].r) &#123; if(e[x].l!=p) printf("error1\n"); e[x].c=(e[x].c&gt;0)?0:e[x].l; return; &#125; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(p&lt;=mid) change(lc,p); else change(rc,p); e[x].c=(e[lc].c&gt;0)?e[lc].c:e[rc].c; //注意，因为树链的编号在线段树中从上往下 //所以编号越小离根节点越近&#125;int ask(int x,int l,int r)&#123; if(e[x].l==l and e[x].r==r) return e[x].c; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); int t=ask(lc,l,mid); if(t&gt;0) return t;//同理 return ask(rc,mid+1,r);&#125;//*******************定义*******************struct nod2&#123; int dep,tot,son,fa,tp; int hou;&#125;a[100010];struct nod3&#123; int y,gg;&#125;b[200010];//*******************实现*******************int pp;void ins(int x,int y)&#123; pp++; b[pp].y=y; b[pp].gg=a[x].hou; a[x].hou=pp;&#125;void dfs1(int x)&#123; a[x].tot=1;a[x].son=0; for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y==a[x].fa) continue; a[y].fa=x; //a[y].dep=a[x].dep+1; dfs1(y); a[x].tot+=a[y].tot; if(a[a[x].son].tot&lt;a[y].tot) a[x].son=y; &#125;&#125;int z,yz[100010],yzz[100010];void dfs2(int x,int tp)&#123; yz[x]=++z;yzz[z]=x; a[x].tp=tp; if(a[x].son) dfs2(a[x].son,tp); for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y!=a[x].fa and y!=a[x].son) dfs2(y,y); &#125;&#125;int solve(int x)&#123; int ans=-1; while(a[x].tp!=1)//更简单的跳法 &#123; int t=ask(1,yz[ a[x].tp ],yz[x]); if(t&gt;0) ans=t;//最近的 x=a[ a[x].tp ].fa; &#125; int t=ask(1,yz[1],yz[x]);if(t&gt;0) ans=t; if(ans&gt;0) return yzz[ans];//记得还原 return -1;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); //for(int i=1;i&lt;=n;i++) a[i].hou=0; for(int i=1;i&lt;n;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; pp=0;a[1].dep=1;a[1].fa=0;dfs1(1); qq=0;dfs2(1,1); z=0;build(1,n); while(m--) &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(a==0) change(1,yz[b]); else printf("%d\n",solve(b)); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度2</tag>
        <tag>Qtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree2]]></title>
    <url>%2Fposts%2F681c.html</url>
    <content type="text"><![CDATA[评测点Caioj1431SPOJ913 分析第二题没有修改，所以预处理后通过LCA最近公共祖先求解，相对简单如果不熟LCA可以看看这篇文章：【OI之路】06树-5最近公共祖先求距离：dis[i]=第i个点到根的距离求第k个点：很巧妙地利用了dep即深度来获得节点数量 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879int bin[31];void InitBin(void)&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1;&#125;//*******************定义*******************int hou[100010],dep[100010];int yy[200010],gg[200010],cc[200010];//*******************实现*******************int ln;void ins(int x,int y,int c)&#123; ln++; yy[ln]=y;gg[ln]=hou[x];cc[ln]=c; hou[x]=ln;&#125;int f[100010][30],dis[100010];void dfs(int x,int fa)&#123; dep[x]=dep[fa]+1;f[x][0]=fa; for(int i=1;bin[i]&lt;=dep[x];i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=hou[x];k;k=gg[k]) &#123; int y=yy[k]; if(y!=fa) &#123; dis[y]=dis[x]+cc[k]; dfs(y,x); &#125; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=30;i&gt;=0;i--) if(dep[x]-dep[y]&gt;=bin[i]) x=f[x][i]; if(x==y) return x; for(int i=30;i&gt;=0;i--) if(dep[x]&gt;=bin[i] and f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int findk(int x,int k)//找x向上（包括自己）的第k个&#123; for(int i=30;i&gt;=0;i--) if(k&gt;bin[i]) k-=bin[i],x=f[x][i]; return x;&#125;//*******************主函数*******************char ss[10];int main(int argc, char *argv[])&#123; InitBin(); int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); memset(hou,0,sizeof(hou));ln=0; for(int i=1;i&lt;n;i++) &#123; int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ins(a,b,c);ins(b,a,c); &#125; dfs(1,0); while(scanf("%s",ss) and ss[1]!='O') &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(ss[1]=='I') printf("%d\n",dis[a]+dis[b]-dis[LCA(a,b)]*2); else &#123; int k,t=LCA(a,b);scanf("%d",&amp;k); int dx=dep[a]-dep[t]+1,dy=dep[b]-dep[t]+1; printf("%d\n",(k&lt;=dx)?findk(a,k):findk( b,dy-(k-dx+1)+1 )); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>难度1</tag>
        <tag>Qtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qtree1]]></title>
    <url>%2Fposts%2F695c.html</url>
    <content type="text"><![CDATA[评测点Caioj1430SPOJ375 分析树链剖分（还没写相关文章，自行理解吧哈哈），但与Caioj1162不同的是由点权变成边权，所以稍微有难度（因为太菜），挺适合作为引子。 其实这一点如果想通了，就不难了：把每条边的权值转移为那条边下面的点的权值，这样刚好剩下根节点没有值。接下来就是赤裸裸的树链剖分了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//*******************线段树*******************struct nod1&#123; int lz,rz,l,r,mx;&#125;e[400010];int qq;int build(int l,int r)&#123; int t=++qq; e[t].l=l;e[t].r=r; e[t].lz=e[t].rz=-1; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; e[t].lz=build(l,mid); e[t].rz=build(mid+1,r); &#125; return t;&#125;void change(int x,int p,int z)&#123; if(e[x].l==e[x].r) &#123; if(e[x].l!=p) printf("error1\n"); e[x].mx=z; return; &#125; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(p&lt;=mid) change(lc,p,z); else change(rc,p,z); e[x].mx=mymax(e[lc].mx,e[rc].mx);&#125;int ask(int x,int l,int r)&#123; if(e[x].l==l and e[x].r==r) return e[x].mx; int mid=(e[x].l+e[x].r)&gt;&gt;1; int lc=e[x].lz,rc=e[x].rz; if(r&lt;=mid) return ask(lc,l,r); if(l&gt;mid) return ask(rc,l,r); else return mymax(ask(lc,l,mid),ask(rc,mid+1,r));&#125;//*******************定义*******************struct nod2&#123; int dep,tot,son,fa,tp; int hou;&#125;a[10010];struct nod3&#123; int y,gg;&#125;b[20010];struct nod4&#123; int x,y,c;&#125;c[10010];//*******************实现*******************int pp;void ins(int x,int y)&#123; pp++; b[pp].y=y; b[pp].gg=a[x].hou; a[x].hou=pp;&#125;void dfs1(int x)&#123; a[x].tot=1;a[x].son=0; for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y==a[x].fa) continue; a[y].fa=x; a[y].dep=a[x].dep+1; dfs1(y); a[x].tot+=a[y].tot; if(a[a[x].son].tot&lt;a[y].tot) a[x].son=y; &#125;&#125;int z,yz[10010];//,yzz[10010]void dfs2(int x,int tp)&#123; yz[x]=++z;//yzz[z]=x; a[x].tp=tp; if(a[x].son) dfs2(a[x].son,tp); for(int k=a[x].hou;k;k=b[k].gg) &#123; int y=b[k].y; if(y!=a[x].fa and y!=a[x].son) dfs2(y,y); &#125;&#125;int solve(int x,int y)&#123; int tx=a[x].tp,ty=a[y].tp,ans=0; while(tx!=ty) &#123; tx=a[x].tp;ty=a[y].tp; if(a[tx].dep&lt;a[ty].dep) swap(tx,ty),swap(x,y); ans=mymax(ans,ask(1,yz[tx],yz[x])); x=a[tx].fa;tx=a[x].tp; &#125; if(x==y) return ans; if(a[x].dep&lt;a[y].dep) swap(x,y); return mymax(ans,ask(1,yz[a[y].son],yz[x]));&#125;//*******************主函数*******************char ss[10];int main(int argc, char *argv[])&#123; int T;scanf("%d",&amp;T); while(T--) &#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i].hou=0; for(int i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;c[i].x,&amp;c[i].y,&amp;c[i].c); ins(c[i].x,c[i].y);ins(c[i].y,c[i].x); &#125; pp=0;a[1].dep=1;a[1].fa=0;dfs1(1); qq=0;dfs2(1,1); z=0;build(1,n); for(int i=1;i&lt;n;i++) if(a[c[i].x].dep&gt;a[c[i].y].dep) swap(c[i].x,c[i].y); for(int i=1;i&lt;n;i++) change(1,yz[c[i].y],c[i].c); while(scanf("%s",ss) and ss[0]!='D') &#123; int a,b;scanf("%d%d",&amp;a,&amp;b); if(ss[0]=='C') change(1,yz[c[a].y],b); else printf("%d\n",solve(a,b)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>树剖</tag>
        <tag>Qtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1080】乘电梯]]></title>
    <url>%2Fposts%2F2666.html</url>
    <content type="text"><![CDATA[评测点Caioj1080 题目 【输入】第一行是电梯的数量和大楼层数。然后每行是一个电梯服务的最低层和最高层。最多有200个电梯，大楼不超过10000层。显然问题是有解的。不然你是怎么上去的呢？【输出】最短时间，精确到5位小数。【输入样例】6 154 810 141 57 1113 151 13【输出样例】20.32308 分析题解视频推荐（老师的理念是成功的，令人没有翻录的欲望）http://url.cn/5fzRGrj密码：QM2K9q微云找1080 f[i]表示到达第i层的时间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;using namespace std;const int INF=0x3f3f3f3f;double mymax(double a,double b)&#123; return a&gt;b?a:b;&#125;double mymin(double a,double b)&#123; return a&gt;b?b:a;&#125;//*******************定义*******************struct nod&#123; double jl; int x,y;&#125;p[210];double f[10010];//*******************实现******************double dd(int s,int k)//电梯编号、楼层&#123; int a=p[s].y-k,b=k-p[s].x;//a是上面的层数 return (a*(a+1)+b*(b+1))/2.0/(a+b+1);&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; int n,h;scanf("%d%d",&amp;n,&amp;h); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y),p[i].jl=INF; for(int i=1;i&lt;h;i++) f[i]=INF; f[h]=0; for(int j=h;j&gt;=1;j--) &#123; for(int i=1;i&lt;=n;i++) if(p[i].x&lt;=j and j&lt;=p[i].y)//第j层在第i个电梯的服务范围内 f[j]=mymin(f[j],p[i].jl+double(p[i].y-j));//计算f[j] for(int i=1;i&lt;=n;i++) if(p[i].x&lt;=j and j&lt;=p[i].y)//第j层在第i个电梯的服务范围内 p[i].jl=mymin(p[i].jl,f[j]-double(p[i].y-j)+dd(i,j)); //保证f[j]最小的前提下，更新p[i].jl &#125; printf("%.5lf",f[1]);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Caioj1086】进攻策略]]></title>
    <url>%2Fposts%2F4a23.html</url>
    <content type="text"><![CDATA[评测点Caioj1086 题目【题意】植物大战僵尸这款游戏中，还有一个特别的玩法；玩家操纵僵尸进攻植物。首先，僵尸有m种（每种僵尸都是无限多的），玩家可以选择何时的僵尸来进攻。使用第i种僵尸需要花费wi资源，可以得到pi的攻击效果。在这里，我们认为多个僵尸总的进攻效果就是他们每个攻击效果的代数和。地图共有n行，对于第i行，最左端有若干植物，这些植物需要至少qi的攻击才能被全部消灭。若一行上的植物全部被消灭，我们认为这一行被攻破。由于资源紧张，你只有总量为k 的资源，不一定能够攻破所有行。但僵尸博士希望攻破相邻的t行，并希望t尽量的大。你能帮他算出t的值吗？【输入】第一行三个非负整数：m n k第二行m 个正整数 第i个数表示wi第三行m个正整数 第i个数表示pi第四行n个非负整数 第i个数表示qi【输出】一个正整数t【输入样例】3 11 395 2 113 1 75 3 6 10 3 2 4 200 1 1 1【输出样例】4【提示】样例说明：打掉 10 3 2 4 这相邻的4行，需要的最小代价是16+5+4+7=32，不超过39数据规模：对于70%的数据 n&lt;=1000对于100%的数据 n&lt;=200000，m&lt;=100，k&lt;=1000，所有pi ,qi&lt;=100000000(lzg PS:pi,qi固然大,可k是小于1000的啊!) 分析先dp计算出i的资源能造成总共f[i]的伤害再计算出攻下第i行的资源花费剩下的就简单了 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;using namespace std;const int INF=0x3f3f3f3f;int mymax(int a,int b)&#123; return a&gt;b?a:b;&#125;//*******************定义*******************int w[110],p[110],q[200010];int f[1010],a[200010];//*******************主函数*******************int main()&#123; int n,m,k;scanf("%d%d%d",&amp;m,&amp;n,&amp;k); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;p[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;q[i]); for(int i=1;i&lt;=m;i++) for(int j=w[i];j&lt;=k;j++) f[j]=mymax(f[j],f[j-w[i]]+p[i]); f[k+1]=INF; int tou=1,ans=0,s=0; for(int i=1;i&lt;=n;i++) &#123; int l=0,r=k,tans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(f[mid]&gt;=q[i]) tans=mid,r=mid-1; else l=mid+1; &#125; a[i]=tans;//攻下这一行的资源花费 s+=a[i]; while(s&gt;k and tou&lt;=i) s-=a[tou],tou++; ans=mymax(ans,i-tou+1); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯轮盘]]></title>
    <url>%2Fposts%2Fd3b3.html</url>
    <content type="text"><![CDATA[有人知道来源在评论说一声 题目【背景】游戏需要的器材灰常简单：一支左轮手枪和一颗子弹。通常游戏人数为两人。玩法也灰常简单：把一发子弹填入左轮手枪的弹仓，将枪轮拨转一下，这样就猜不着子弹是否上膛。接着，把枪交给一个玩家，该玩家对准自己的太阳穴扣枪机。规定如果子弹没上膛而打空的话，就换另一个玩家打，再打空就再换第一个玩家打，直到打中为止。【问题描述】小I和小强是一对灰常要好的朋友，他们经常在一起玩俄罗斯轮盘。可是有一天小I有事不能陪小强玩，这令小强很郁闷，于是他决定自己一个人玩。小强拿了一支有N个弹仓的左轮手枪，随机填入了M发子弹，然后对准自己的太阳穴连续打了K枪。他这样玩了几次之后，突然想知道打不中的概率是多少。你能帮他算算吗？ 【输入格式】输入三个整数：N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=N,1&lt;=K&lt;=1000)。【输出格式】输出N个弹仓的左轮手枪，随机填入M发子弹，对准自己的太阳穴打K枪都打不中的概率，保留六位小数。【输入样例1】62 2【输出样例1】0.400000【输入样例2】153 7【输出样例2】0.123077 分析1234等价于M个球放入N个箱子，前K个箱子没有球的概率P=C(N-K,M)/C(N,M)c(n,m)= p(n,m)/m! = n! / ( (n-m)!*m! )[ (N-K)!/( (N-K-M)!*M! ) ] / [ N!/(N-M)!/M! ] 代码12345678910int n,m,k;scanf("%d%d%d",&amp;n,&amp;m,&amp;k);if(n==m or n&lt;m+k) printf("%.6lf",1);else&#123; double s=1; for(int i=0;i&lt;=m-1;i++) s=s*(n-i-k)/(n-i); printf("%.6lf",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1159最长公共子序列LCS]]></title>
    <url>%2Fposts%2Fddc4.html</url>
    <content type="text"><![CDATA[评测点HDU1159 题目【题意】求两个字符串最长公共子序列的长度,最长公共子序列强调位置的前后关系不变，但不在乎是否连续,不唯一【输入样例】abbccdss aeebfcaadb【输出样例】4 某解释 代码1234567891011121314char s[1010],s1[1010];int f[1010][1010];int main(int argc, char *argv[])&#123; scanf("%s %s",s+1,s1+1); int l1=strlen(s+1),l2=strlen(s1+1); for(int i=1;i&lt;=l1;i++) for(int j=1;j&lt;=l2;j++) &#123; if(s[i]==s1[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=mymax(f[i-1][j],f[i][j-1]); &#125; printf("%d",f[l1][l2]);&#125; 分析：a=abcb=1abcn=3m=4i=2 4//字符串2的位置j=2 3//字符串1的位置s=0 0 0 01 1 1 10 2 2 20 0 3 3]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2528市长的海报Posters]]></title>
    <url>%2Fposts%2F96fc.html</url>
    <content type="text"><![CDATA[来历POJ2528 题目【题意】n（n&lt;=10000)个人依次贴海报,给出每张海报所贴的范围li，ri（1&lt;=li&lt;=ri&lt;=10000000)。求出最后还能看见多少张海报。（注意：没多组数据）【输入样例】51 42 68 103 47 10【输出样例】4 分析关于离散化，可以参考这里 推荐一个好的算法，但我没有这么做：如果更新次数太多的话，可以考虑从后往前更新即如果更新时发现之前已经有一张海报完全覆盖他了就可以不用更新（因为没有必要）这样的算法时间会减少很多 代码不完整，通用部分可以参考这里1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct DisNod&#123; int x,p,z;&#125;a[20010],b[20010];void Discretization(int n)//离散化&#123; for(int i=1;i&lt;=n;i+=2) &#123; scanf("%d %d",&amp;a[i].x,&amp;a[i+1].x);a[i+1].x++; a[i].p=i;a[i+1].p=i+1; b[i]=a[i];b[i+1]=a[i+1]; //拷贝 &#125; sort2(1,n);//排序 b[1].z=1; for(int i=2;i&lt;=n;i++) &#123; if(b[i].x==b[i-1].x) b[i].z=b[i-1].z; else b[i].z=b[i-1].z+1; a[b[i].p].z=b[i].z; &#125;&#125;struct Manager&#123; int l,r,tl,tr,c; bool lazy;&#125;f[40010];void update(int x)&#123; f[x].lazy=false; if(f[x].tl&gt;0 and f[x].tr&gt;0) &#123; int tl=f[x].tl,tr=f[x].tr; f[tl].lazy=f[tr].lazy=true; f[tl].c=f[tr].c=f[x].c; &#125;&#125;void change(int now,int l,int r,int c)&#123; if(l==f[now].l and r==f[now].r) &#123; f[now].c=c; f[now].lazy=true; return; &#125; if(f[now].lazy) update(now); ……&#125;int num=0;int build(int l,int r)&#123; …… f[x].lazy=false; ……&#125;char ch[5];bool v[20010]=&#123;0&#125;;int main()&#123; scanf("%d",&amp;n);n*=2; Discretization(n); build(1,b[n].z); for(int i=1;i&lt;=n;i+=2) change(1,a[i].z,a[i+1].z,i); int s=0; for(int i=1;i&lt;=num;i++) &#123; if(f[i].lazy) update(i); if(!f[i].tl and !v[f[i].c]) v[f[i].c]=1,s++; &#125; printf("%d",s);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[糖果自动管理系统]]></title>
    <url>%2Fposts%2F739e.html</url>
    <content type="text"><![CDATA[来历建议这里备用 题目【题意】糖果自动管理系统能管理N堆糖果。初始时，所有堆糖果数目为0。（1）I a b c(1≤a≤b≤N,0 &lt; c≤100)，ACM将在堆a至堆b之间（包含a和b）每堆糖果加c个。（2）C a b(1≤a≤b≤N)，将会选择a到b堆之间糖果数最多的清空。选择编号小的。给出一系列的操作，对于每个C操作，输出堆的糖果数。【输入】第一行为两个整数N，M（0&lt; N，M≤10^5），N表示糖果堆的数目，M表示操作的次数。【输出】对于每个C操作，输出小朋友能得到的糖果的数目。【输入样例】5 4I 1 5 1C 2 3I 2 2 4C 2 3【输出样例】14 代码不完整，通用部分可以参考这里12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void update(int x)&#123; f[f[x].tl].c+=f[x].lazy; f[f[x].tr].c+=f[x].lazy; f[f[x].tl].lazy+=f[x].lazy; f[f[x].tr].lazy+=f[x].lazy; f[x].lazy=0;&#125;void make(int x,int l,int r,int k)&#123; if(f[x].l==l and r==f[x].r) &#123; f[x].c+=k; f[x].lazy+=k; return; &#125; …… if(r&lt;=mid) make(fl,l,r,k); else if(l&gt;mid) make(fr,l,r,k); else &#123; make(fl,l,mid,k); make(fr,mid+1,r,k); &#125; if(f[fl].c&gt;=f[fr].c) &#123; f[x].mc=f[fl].mc; f[x].c=f[fl].c; &#125; else &#123; f[x].mc=f[fr].mc; f[x].c=f[fr].c; &#125;&#125;int fc,fmc;void qesc(int x,int l,int r)&#123; if(f[x].l==l and f[x].r==r) &#123; fc=f[x].c; fmc=f[x].mc; return; &#125; if(r&lt;=mid) qesc(fl,l,r); else if(l&gt;mid) qesc(fr,l,r); else &#123; qesc(fl,l,mid); int ac=fc,amc=fmc; qesc(fr,mid+1,r); if(ac&gt;=fc) &#123; fc=ac; fmc=amc; &#125; &#125;&#125;int main()&#123; num=0;br(1,n); for(int i=1;i&lt;=m;i++) &#123; scanf("%s%d%d",ch,&amp;a,&amp;b); if(ch[0]=='C') &#123; qesc(1,a,b); printf("%d\n",fc); make(1,fmc,fmc,-fc); &#125; else &#123; scanf("%d",&amp;d);make(1,a,b,d); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016魔法阵]]></title>
    <url>%2Fposts%2F141d.html</url>
    <content type="text"><![CDATA[评测点和题目洛谷2119 分析遇到这种有条件的题，通常把图形画出来比较直观。 如图所示，若把d点确定，设c-d距离为i，则a,b的距离就是2i，则b,c的距离&gt;2×(a-b)也就是&gt;6i，总距离大于9i，那么我们的外层循环就枚举i，再枚举d的位置，d的方案数就等于(前面所有a的方案)×(前面所有b的方案)×(当前c的方案数)，c的方案数=(前面所有a的方案)×(前面所有b的方案)×(当前d的方案数)，同理，枚举a的位置，也可以得到a与b的方案数。 什么意思呢？这可能有点绕。 我们将d不断往后枚举，而在现在的a之前所扫过的ab都符合条件，故而累加在一个变量中，a亦复如是。 注意，同样魔法值的物品，作为abcd物品的次数其实是一样的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int rn(void)&#123; char c=getchar();int s=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') &#123; s=s*10+c-'0'; c=getchar(); &#125; return s;&#125;struct nod1&#123; int w,a,b,c,d; nod1() &#123;w=a=b=c=d=0;&#125;&#125;f[15010];int h[40010];//第i个物品的魔法值需要保留，输出时要用到int main()&#123; int n,m; n=rn();m=rn(); for(int i=1;i&lt;=m;i++) &#123; h[i]=rn(); f[h[i]].w++;//表示这个值的数增加了一个 &#125; //[d&gt;9*i&lt;=n]==&gt;[9*i&lt;n],边界一定要考虑无误 for(int i=1;9*i&lt;n;i++)//cd &#123; int ab=2*i,bd=7*i+1; int ad=ab+bd;//9*i+1 int ac=ad-i; int s=0;//累加和 for(int j=n-ad;j&gt;=1;j--)//j-&gt;a //注意循环不能顺序，因为s的累加和会改变,a[j]会加上后面的c,d //而不是前面的 &#123; s+=f[j+ac].w*f[j+ad].w;//c*d元素的个数 f[j].a+=s*f[j+ab].w;//b*[c*d]==a(乘在一起，就是可能量) f[j+ab].b+=s*f[j].w;//a*[c*d]==b &#125; s=0; for(int j=ad+1;j&lt;=n;j++)//j-&gt;d &#123; s+=f[j-ad].w*f[j-bd].w;//a*b元素的个数 f[j-i].c+=s*f[j].w;//d*[a*b]==c f[j].d+=s*f[j-i].w;//c*[a*b]==d &#125; //上下两循环可以调换顺序，因为a,b,c,d只与i和w有关 //和a[],b[],c[],d[]无关 &#125; for(int i=1;i&lt;=m;i++) printf("%d %d %d %d\n",f[h[i]].a,f[h[i]].b,f[h[i]].c,f[h[i]].d);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016海港]]></title>
    <url>%2Fposts%2Fafb6.html</url>
    <content type="text"><![CDATA[评测点和题目洛谷2058 分析这道题主要收获是将总量不大的数组降维储存，从而大大减少空间 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445int rn(void)//正整数输入&#123; char c=getchar();int s=0; while(c&lt;'0' or c&gt;'9') c=getchar(); while(c&gt;='0' and c&lt;='9') &#123; s=s*10+c-'0'; c=getchar(); &#125; return s;&#125;int t[100010],k[100010],q[500010],w[500010];//t:每艘船时间 k:每艘船第一个人(类似指针)//q:每个国家人数 w:每人国家int main(int argc,char *argv[])&#123; int n=rn(); int tou=1;//当前状态指针 int ans=0;//当前状态答案 k[1]=1; for(int i=1;i&lt;=n;i++) &#123; t[i]=rn();int rs=rn(); k[i+1]=k[i]+rs; for(int j=0;j&lt;rs;j++) &#123; int p=rn(); w[j+k[i]]=p; if(q[p]==0) ans++;//如果此国家原来没人，ans+1 q[p]++;//输入每个人，并在他的国家处+1 &#125; while(t[tou]+86400&lt;=t[i]) //如果第tou艘船不符合条件，就去掉 &#123; for(int j=k[tou];j&lt;k[tou+1];j++)//枚举每一个人 &#123; q[w[j]]--; if(q[w[j]]==0) ans--; //要是此国家去掉这个人就没了，答案减一 &#125; tou++; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016总结]]></title>
    <url>%2Fposts%2Fda68.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>竞赛历程</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星球大战]]></title>
    <url>%2Fposts%2F4cfd.html</url>
    <content type="text"><![CDATA[来源bzoj1015JSOI2008 分析：有一个同学做了PPT，里面的数据演示做得不错，详细做法建议看代码，更清晰下载链接 题目【问题描述】很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。【问题大意】给你一些点和边，有K次毁灭，每次删掉一条边，输出没毁灭时的连通数以及每次操作后剩余的连通数量【输入格式】第一行包含两个整数，N(1&lt;=N&lt;=2M)和M(1&lt;=M&lt;= 200,000)，分别表示星球的数目和以太隧道的数目。星球用0~N-1的整数编号。接下来的M行，每行包括两个整数X, Y，其中（0&lt;=X&lt;&gt;Y【输出格式】输出文件的第一行是开始时星球的连通块个数。接下来的N行，每行一个整数，表示经过该次打击后现存星球的连通块个数。【输入样例】8 130 11 66 55 00 61 22 33 44 57 17 27 63 65 1 6 3 5 7【输出样例】1 1 1 2 3 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899struct nod1&#123; int hou;//最小儿子 int fa;//父亲 bool b;//是否会被炸毁 bool v;//是否存在 nod1() &#123; hou=0;b=false;v=false; &#125;&#125;point[400010];struct nod2&#123; int x; int g;//哥哥&#125;road[400010];/*注意：因为是双向路，所以要开200000*2*/void bulid(int,int);int findfa(int);int add(int);int f[400001];//这些点将被攻击int ans[400001];//答案记录//两个序列↑int roadnum;int sum;//连通块int main(int argc, char *argv[])&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) point[i].fa=i;//初始化每个点的父亲为自己 roadnum=0; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; bulid(x,y); bulid(y,x);//建边 &#125; int k; cin&gt;&gt;k; for(int i=1;i&lt;=k;i++) &#123; cin&gt;&gt;f[i]; point[f[i]].b=true;//如果不会被炸毁的先标记下来下边可以用上 &#125; //倒推大法↓ sum=0; for(int i=0;i&lt;n;i++)//是0到n-1 &#123; if(point[i].b==false)//没被炸毁的先建边 &#123; sum++; add(i); point[i].v=true;//建了边代表存在的 &#125; &#125; ans[k+1]=sum;//k+1代表最后炸毁的状态 for(int i=k;i&gt;0;i--)//模拟，一个一个把点加上去 &#123; sum++; add(f[i]);//加点 point[f[i]].v=true;//这条边存在 ans[i]=sum;//记录值 &#125; for(int i=1;i&lt;=k+1;i++) printf("%d\n",ans[i]);&#125;int add(int n)&#123; int xf=findfa(n); for(int k=point[n].hou;k&gt;0;k=road[k].g)//这个点应该加在哪里 &#123; int x=road[k].x; if(point[x].v==true)//存在 &#123; int yf=findfa(x); if(xf!=yf) &#123; point[yf].fa=n; sum--;//如果祖先不一样的话，统一祖先，连通块-1 &#125; &#125; &#125;&#125;void bulid(int x,int y)&#123; roadnum++; road[roadnum].x=y; road[roadnum].g=point[x].hou; point[x].hou=roadnum;&#125;int findfa(int x)&#123; if(x!=point[x].fa) point[x].fa=findfa(point[x].fa) return point[x].fa;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度1</tag>
        <tag>宽度优先搜索BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codevs1082线段树练习3]]></title>
    <url>%2Fposts%2F9bea.html</url>
    <content type="text"><![CDATA[Codevs1082线段树练习3 评测Codevs1082 题目【问题大意】给你N个数，有两种操作：1：给区间[a,b]的所有数增加X2：询问区间[a,b]的数的和。【输入】第一行一个正整数n，接下来n行n个整数，再接下来一个正整数Q，每行表示操作的个数，如果第一个数是1，后接3个正整数，表示在区间[a,b]内每个数增加X,如果是2，表示操作2询问区间[a,b]的和是多少。pascal选手请不要使用readln读入【输出】对于每个询问输出一行一个答案【样例输入】312321 2 3 22 2 3【样例输出】9【数据范围】(其实这个贴出来没什么用)1&lt;=n&lt;=2000001&lt;=q&lt;=200000 分析用线段树做自然是灰常简单的假如你想学习如何用树状数组实现可以参考这篇文章 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394typedef long long lld; using namespace std; struct Segment &#123; int l,r; int s1,s2; lld c; lld lazy; &#125;a[400001]; int num=0; void build(int l,int r) &#123; num++; int t=num;// a[t].c=0; a[t].l=l; a[t].r=r; a[t].lazy=0; if(l==r) &#123; a[t].s1=-1; a[t].s2=-1; return; &#125; int mid=(l+r)/2; a[t].s1=num+1;build(l,mid); a[t].s2=num+1;build(mid+1,r); &#125; void make(int x,int l,int r,int k) &#123; a[x].c=a[x].c+k*(r-l+1); if(a[x].l==l and a[x].r==r) &#123; a[x].lazy+=k; return; &#125; int mid=(a[x].r+a[x].l)/2; if(r&lt;=mid) make(a[x].s1,l,r,k); else if(l&gt;mid) make(a[x].s2,l,r,k); else &#123; make(a[x].s1,l,mid,k); make(a[x].s2,mid+1,r,k); &#125; &#125; lld qes(int x,int l,int r) &#123; if(a[x].l==l and a[x].r==r) return a[x].c; int mid=(a[x].r+a[x].l)/2; int s1=a[x].s1,s2=a[x].s2; if(a[x].lazy!=0) &#123; a[s1].c=a[s1].c+a[x].lazy*(a[s1].r-a[s1].l+1); a[s2].c=a[s2].c+a[x].lazy*(a[s2].r-a[s2].l+1); a[s1].lazy+=a[x].lazy; a[s2].lazy+=a[x].lazy; a[x].lazy=0; &#125; if(r&lt;=mid) return qes(a[x].s1,l,r); else if(l&gt;mid) return qes(a[x].s2,l,r); else return qes(a[x].s1,l,mid)+qes(a[x].s2,mid+1,r); &#125; int main(int argc, char *argv[]) &#123; int n,m; cin&gt;&gt;n; build(1,n); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); make(1,i,i,a); &#125; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) &#123; int x,a,b,c; scanf("%d %d %d",&amp;x,&amp;a,&amp;b); if(x==1) &#123; scanf("%d",&amp;c); if(a&gt;b) make(1,b,a,c); else make(1,a,b,c); &#125; else &#123; if(a&gt;b) printf("%lld\n",qes(1,b,a)); else printf("%lld\n",qes(1,a,b)); &#125; &#125; &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魏总数星星]]></title>
    <url>%2Fposts%2F4672.html</url>
    <content type="text"><![CDATA[声明好像是别人的原创题，感觉不错：来源另外，学习并查集可以参考这个：生动的故事，透彻的分析我的并查集总结 题目【问题大意】魏总，也就是dp魏，灰常喜欢星星，有一天他躺在草坪上数星星。天上共有i颗星星，魏总把天空分成了K个扇形，绕着天空的中心——月亮排布。月亮看见魏总喜欢星星，灰常不爽，她就想考一下魏总。月亮给出n队星星的相互关系，形如a b p表示b星星在a星星所在扇形区域的顺时针方向第p个扇形内（0&lt;=p&lt;=k）（p==0时表示在同一个扇形内）。最后月亮要询问m次，形如a b表示询问a b两星是否在一个扇形内，是则输出“Yes”，不是则输出“No”，不知道则输出“Unknown”。由于月亮看魏总喜欢星星变得心情急躁，可能有一些关系与前面的关系矛盾，则这些关系无效。月亮说如果不能把她的所有询问答对就要发出强光，让魏总看不到星星，而本来是大神的魏总因为想见到星星不能编程，只有把这个艰巨的任务交给你了。【输入格式】第一行四个整数i，k，n，m表示i颗星星，k个扇形，n个关系，m次询问。接下来n行，每行三个整数a b p 表示表示b星星在a星星所在扇形区域的顺时针方向第p个扇形内。接下来m行，每行两个整数a b表示询问a，b是否在同一个扇形内。【输出格式】共m行，每行为“Yes”或“No”或“Unknown”对应每一个询问【输入样例】5 5 3 31 2 12 4 24 5 21 23 41 5【输出样例】NoUnknownYes【数据范围】20%，魏总数不超过100个星星，月亮询问不超过100次，天空被分成不超过10个区域。50%，魏总数不超过4000个星星，月亮询问不超过4000次，天空被分成不超过1000个区域。100%，魏总数不超过100000个星星，月亮询问不超过100000次，天空被分成不超过10000个区域，关系数少于200000。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct star&#123; int fa,len; star() &#123; fa=len=0; &#125;;&#125;st[100010];int mod;int findfa(int now)&#123; if(st[now].fa==now) return now; int f=findfa(st[now].fa); st[now].len=(st[now].len+st[st[now].fa].len)%mod; if (st[now].len==0) st[now].len=mod; st[now].father=f; return f;&#125;void join(int a,int b,int l)&#123; int af=findfa(a),bf=findfa(b); int len=(st[a].len+l)%mod; st[bf].fa=a; if (l&gt;=st[b].len) st[bf].len=l-st[b].len; else st[bf].len=mod+l-st[b].len;&#125;int main()&#123; int n,m,k; cin&gt;&gt;n&gt;&gt;mod&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) st[i].fa=i; for(int i=1;i&lt;=m;i++) &#123; int a,b,p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; if(findfa(a)!=findfa(b)) join(a,b,p); &#125; for(int i=1;i&lt;=k;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); if (findfa(a)!=findfa(b)) printf("Unknown\n"); else &#123; if (st[a].len%mod==st[b].len%mod) printf("Yes\n"); else printf("No\n"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智捅马蜂窝]]></title>
    <url>%2Fposts%2F76b3.html</url>
    <content type="text"><![CDATA[评测rqnoj86 题目【问题大意】给出一个 N 个节点的无向图，每个节点用坐标（Xi，Yi）来表示，平平要从第1个点爬到第N个点。如果出现两线相交的情况，我们不认为它们是相通的。除了从一个节点爬向另一个相邻的节点以外，他还有一种移动方法，就是从一个节点跳下，到达正下方的某个节点（之间可隔着若干个点和边），下落所用时间满足自由落体公式t=sqrt((Yj-Yi)×2/g) （g取10）。【输入格式】两个整数N,V，N表示节点个数，V表示平平爬树的速度。接下来N行，每行包含3个整数X,Y,F，X,Y是这个点的坐标，F是他的父节点（F一定小于这个点的标号，第一行的F为0）。（1&lt;=N&lt;=100,1&lt;=V&lt;=10,0&lt;=X,Y&lt;=100）【输出格式】输出仅包括一行，从1到N所用的最少所需时间T，保留两位小数。【输入样例】9 15 0 05 5 16 5 27 6 26 9 23 6 24 5 23 2 77 2 3【输出样例】8.13 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void build(int,int,double);double calc(int,int);struct point&#123; double ans; int hou,x,y; bool v;&#125;a[110];struct road&#123; int x,y,g; double c;&#125;b[310];int n,v,k=0,l[110];int main()&#123; scanf("%d %d",&amp;n,&amp;v); for(int i=1;i&lt;=n;i++) &#123; int x,y,f; scanf("%d %d %d",&amp;x,&amp;y,&amp;f); a[i].x=x;a[i].y=y;a[i].hou=0; a[i].ans=999999;a[i].v=false; double c=calc(f,i)/v; build(i,f,c);build(f,i,c); &#125; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(a[i].x==a[j].x) //能垂直下落就建边 &#123; double c=sqrt(abs(a[i].y-a[j].y)/5.0);//不是5 if(a[i].y&gt;a[j].y) build(i,j,c); else build(j,i,c); &#125; l[1]=1; a[1].v=true; a[1].ans=0; int tou=1,wei=2; while(tou!=wei) &#123; int x=l[tou]; for(int i=a[x].hou;i&gt;0;i=b[i].g) &#123; int y=b[i].y; if(a[y].ans&gt;a[x].ans+b[i].c) &#123; a[y].ans=a[x].ans+b[i].c; if(a[y].v==false) &#123; a[y].v=true; l[wei]=y; wei++; if(wei==n+1) wei=1; &#125; &#125; &#125; a[x].v=false; tou++; if(tou==n+1) tou=1; &#125; printf("%.2lf",a[n].ans);&#125;void build(int x,int y,double t)&#123; k++; b[k].x=x;b[k].y=y;b[k].c=t; b[k].g=a[x].hou;a[x].hou=k;&#125;double calc(int x,int y)&#123; double q=a[x].x-a[y].x,w=a[x].y-a[y].y; return sqrt(q*q+w*w);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>难度1</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后的战犯]]></title>
    <url>%2Fposts%2F47fc.html</url>
    <content type="text"><![CDATA[题目【问题描述】Feli来到岩洞入口，发现岩洞其实是一个巨大的迷宫。迷宫地形极为复杂，为一个正方形，其中布满了障碍物。迷宫可以分为N乘N（2≤N≤100）个区域，每个区域或者是空地，或者是不可逾越的障碍物。小犬就躲藏在其中某一个区域内。由于小犬已经忍受了几天的饥饿，Feli进入迷宫时他已经失去思维处于迷乱状态。小犬每秒钟只会沿着他的方向直线前进，如果遇到障碍物或者迷宫边界，他会立刻向右转90度（不会花去时间），继续沿直线前进（初始方向向北）。Feli每秒钟可以自主决定往哪个方向走。如果同一时刻Feli与小犬位于同一个区域，或者相邻的区域（非对角线相邻），Feli可以立刻将小犬抓住。Feli本来打算先确定小犬的位置，然后沿最短路线抓住他，但是Feli前进时小犬同时也在移动，就不能采取这种方法了。请你帮助Feli确定一种方案，使Feli抓获小犬所用的时间最短。【输入格式】输入数据第一行是一个整数N。以下N行每行N个字符，星号表示岩洞中的障碍物，“.”表示空地，“J”表示小犬（一开始他会向北走），“F”表示Feli。上北下南左西右东。【输出格式】输出数据仅一行，如果Feli能抓到小犬，那么输出所需的最短时间，如果Feli抓不到小犬，那么这个最后的日本战犯将在岩洞中饿死（因为Feli将在离开的时候封闭岩洞的所有出口），此时输出“No solution.”，不要输出引号。1234567【输入样例】3F*J.*....【输出样例】3 声明找不到来源，保留原题目对不起啦贴着代码先 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586struct pointnode&#123;int x,y,f;&#125;;bool m[110][110],v[110][110];int stx,sty,edx,edy,n,jat=0;int tx[4]=&#123;-1,0,1,0&#125;,ty[4]=&#123;0,1,0,-1&#125;;pointnode q[10010];bool qs(void)//直接被困住&#123; for(int i=0;i&lt;=3;i++) if(m[edx+tx[i]][edy+ty[i]]) return false; return true;&#125;bool check(int x,int y)&#123; if((x==edx and abs(y-edy)&lt;=1)or(y==edy and abs(x-edx)&lt;=1)) return true; return false;&#125;void solve()//走一步&#123; while(1) &#123; int txx=edx+tx[jat],tyy=edy+ty[jat]; if(m[txx][tyy]) &#123; edx=txx; edy=tyy; return; &#125; jat++; jat%=4; &#125;&#125;void bfs(void)&#123; memset(v,0,sizeof(v)); int tou=1,wei=2; q[1].x=stx;q[1].y=sty;q[1].f=0; q[0].f=-1; v[stx][sty]=true; while(tou!=wei) &#123; int nowx=q[tou].x,nowy=q[tou].y; if(q[tou].f&gt;q[tou-1].f) solve(); //进入新的一层 for(int i=0;i&lt;=3;i++) &#123; int fx=nowx+tx[i],fy=nowy+ty[i]; if(m[fx][fy] and !v[fx][fy]) &#123; v[fx][fy]=true; q[wei].x=fx;q[wei].y=fy; q[wei].f=q[tou].f+1; if(check(fx,fy)) &#123; printf("%d",q[wei].f); return; &#125; wei++; &#125; &#125; tou++; &#125; printf("No solution.");&#125;int main()&#123; memset(m,0,sizeof(m)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; char s[110];scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; m[i][j]=(s[j]!='*'); if(s[j]=='J') &#123;edx=i;edy=j;&#125; if(s[j]=='F') &#123;stx=i;sty=j;&#125; &#125; &#125; if(qs()) printf("No solution."); else if(check(stx,sty)) printf("0"); else bfs();&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>宽度优先搜索BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密室逃脱]]></title>
    <url>%2Fposts%2F5ade.html</url>
    <content type="text"><![CDATA[题目来自于某NOIP模拟赛 【问题描述】即使czhou没有派出最强篮球阵容，机房篮球队还是暴虐了校篮球队。为了不打击校篮球队信心，czhou决定改变训练后的活动。近来，江大掌门的徒弟徒孙们纷纷事业有成，回到母校为机房捐钱捐物。财大气粗的机房组收回了五层六层的所有教室。Czhou决定将六层的教室改造为智能密室逃脱活动室。每天傍晚，神牛们可以依次逐个进入游玩。我们简单的将教室分割为n乘n个房间，K是你初始所在房间，T是你最终逃脱的房间。如果你想要逃脱房间，你必须依次找到m把钥匙。我们假定你从一个房间进入另一个房间需要花费1的时间。当然某些房间有些特殊的问题(地图上S表示)需要回答才能通过，对于机智的众牛们来说，这些问题根本不是问题。我们假定众牛们花费1的时间解决问题。（主要是出题的人表述不清，导致众牛理解困难；当然问题只需要回答一次，下次再次进入房间不需要回答了）【问题大意】有一个密室，分割为N乘N个房间，K是初始房间，T是最终逃脱的房间，并且在逃脱前要找齐M把钥匙（要按顺序取，可以经过而不取，地图上可能有多个同一种钥匙，走），“#”为墙壁（一个关闭的房间）即不可走，假定从一个到另一个房间需要1个单位时间，当然某些房间有些特殊的问题(地图上S表示)需要回答才能通过，假定要花费1的时间解决问题（当然每个问题只需要回答一次），问最少时间花费。【输入格式】第一行两个数字n,m，接下来n乘n描述地图【输出格式】逃脱密室需要的最少时间，若无解输出impossible123456789101112131415161718192021【输入样例1】31K.S##11#T【输出样例1】5【输入样例2】3 1K#T.S#1#.【输出样例2】impossible【输入样例3】32K#T.S.21.【输出样例3】8 代码对不起啦贴着代码先123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct pos&#123;int x,y,k;&#125;;char map[101][101];int n,m,ans=inf,qesn=0;int f[101][101][10],tx[4]=&#123;0,-1,0,1&#125;,ty[4]=&#123;1,0,-1,0&#125;;pos st,ed,qes[9];int mymin(int a,int b)&#123;return a&gt;b?b:a;&#125;void bfs(void)&#123; memset(f,-1,sizeof(f)); f[st.x][st.y][0]=0; queue&lt;pos&gt; q;//用滚动数组更快 q.push(st); while(q.empty()==false) &#123; pos fr=q.front(); for(int i=0;i&lt;=3;i++) &#123; pos ne; ne.x=fr.x+tx[i]; ne.y=fr.y+ty[i]; ne.k=fr.k; if(map[ne.x][ne.y]==ne.k+1) ne.k++; if(map[ne.x][ne.y]==0 or f[ne.x][ne.y][ne.k]!=-1) continue; f[ne.x][ne.y][ne.k]=f[fr.x][fr.y][fr.k]+1; q.push(ne); &#125; q.pop(); &#125;&#125;void dfs(int k,int l)//枚举每一个S&#123; if(k==qesn+1) &#123; bfs(); if(f[ed.x][ed.y][m]!=-1) ans=mymin(ans,l+f[ed.x][ed.y][m]); return; &#125; map[qes[k].x][qes[k].y]=11; dfs(k+1,l+1); map[qes[k].x][qes[k].y]=0; dfs(k+1,l);&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; char s[110];scanf("%s",s+1); for(int j=1;j&lt;=n;j++) &#123; map[i][j]=s[j]!='#'?11:0; if(s[j]=='K') &#123;st.x=i;st.y=j;&#125; if(s[j]=='T') &#123;ed.x=i;ed.y=j;&#125; if(s[j]=='S') &#123;qesn++;qes[qesn].x=i;qes[qesn].y=j;&#125; if(s[j]&gt;='0' and s[j]&lt;='9') map[i][j]=s[j]-'0'; &#125; &#125; dfs(1,0); if(ans==inf) printf("impossible"); else printf("%d",ans);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>难度1</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终极装备]]></title>
    <url>%2Fposts%2F35a8.html</url>
    <content type="text"><![CDATA[题目【问题大意】小明玩游戏时，获得了一些终极装备，但在这之前，他已经获得了一批能和终极装备媲美的装备，并且前后的数量是一致的，但人物的最大负重为M，每个装备可提升人物V[i]力量值，自身重量为W[i]（我们把这两个值称为该装备的属性），现在的目的是让人物更强大【输入】第一行3个数：M，N，T。分别为最大负重、装备数量、人物不带任何装备的能量值。接下来N行，一行4个数，V1[i],W1[i],V2[i],W2[i]（前后两组装备视为同种）【输出】人物能够达到的最大力量值，并且同种装备只能选一个。【样例输入】50 3 2012 18 23 1917 10 30 2420 20 17 20【样例输出】80【数据范围】(其实这个贴出来没什么用)1&lt;=M,T&lt;=10000,1&lt;=N&lt;=2001&lt;=W[i],V[i]&lt;=10000 代码123456789101112131415161718192021int f[10010];//f[I]=当使用I重量时，可以达到的能量int main(int argc,char *argv[])&#123; int m,n,t; scanf("%d %d %d",&amp;m,&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) &#123; int a,b,c,d; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); if(b&gt;d) &#123; int t=a;a=c;c=t;t=b;b=d;d=t; &#125; v1[i]=a;v2[i]=c;w1[i]=b;w2[i]=d; &#125; memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=w1[i];j--) if(j&gt;=w2[i]) f[j]=max3(f[j],f[j-w1[i]]+v1[i],f[j-w2[i]]+v2[i]); else f[j]=max2(f[j],f[j-w1[i]]+v1[i]); &#125; printf("%d",f[m]+t);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>难度1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】坑与计划、一些套题]]></title>
    <url>%2Fposts%2Fcbb8.html</url>
    <content type="text"><![CDATA[坑与计划、一些套题感觉对特意来到我博客的人最有帮助的应该是一些套题、合集，所以整理一下 （另外tag-好题也是可以看看的，不过可能受我当时阅历限制，主观性很强） 套题做过的所有arc AGC001到010AGC011到020AGC021到030AGC031到040ExaWizards2019atcTenka1-2019code festival 2017 qualbjsc2019-finaliroha2019-day4tkppc2016 BubbleCup9CF#512CF#545CF#548CF#549CF#573CF#576CF#583CF#PiManthan, Codefest 19 PKUWC2018PKUSC2018清华集训APIOCEOIGXOIHAOINOI2019 cojR8cojR9cojR11 牛客挑战赛32牛客练习赛42 51nod刷题计划-已弃坑计蒜客信息学4月提高组模拟赛SSerxhs和Serval的退役纪念赛 2019年3月模拟赛120190423模拟OZY退役模拟赛 坑bzoj3654cf题解HAOI2015 数组游戏]]></content>
  </entry>
  <entry>
    <title><![CDATA[【置顶】About me]]></title>
    <url>%2Fposts%2F367.html</url>
    <content type="text"><![CDATA[I am Zory, an OIer in GD.Welcome to my blog.The suggested url is zory.ink&#x627E;&#x6587;&#x7AE0;&#x8BF7;&#x4F7F;&#x7528;&#x641C;&#x7D22;&#x529F;&#x80FD;&#xFF0C;&#x8C22;&#x8C22;&#x5408;&#x4F5C; &#x7CFB;&#x5217;&#x5B66;&#x4E60;&#x7B14;&#x8BB0;&#x3010;OI&#x4E4B;&#x8DEF;&#x3011;&#x53EF;&#x5728;&#x9876;&#x90E8;&#x524D;&#x5F80;&#xFF0C;&#x5176;&#x4E2D;&#x6570;&#x5B66;&#x4E00;&#x7AE0;&#x662F;&#x975E;&#x5E38;&#x826F;&#x5FC3;&#x7684;&#xFF0C;&#x6B22;&#x8FCE;&#x6307;&#x6B63; &#x5F88;&#x83DC;&#xFF0C;&#x4F46;&#x5E0C;&#x671B;&#x80FD;&#x4E3A;&#x540E;&#x4EBA;&#x63D0;&#x4F9B;&#x4E00;&#x4E9B;&#x5E2E;&#x52A9; &#x56E0;&#x4E3A;&#x4EBA;&#x50BB;&#x5E38;&#x6570;&#x5927;&#xFF0C;&#x53EF;&#x80FD;&#x6709;&#x4E9B;&#x9898;&#x53EA;&#x8D34;&#x4E2A;tle&#x7684;&#x4EE3;&#x7801;&#x5C31;&#x8DD1;&#x8DEF;&#x4E86; &#x6709;&#x4E9B;copy&#x7684;&#x5185;&#x5BB9;&#xFF0C;&#x4F1A;&#x7528;&#x5F15;&#x7528;&#x8868;&#x793A;&#xFF0C;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x7070;&#x8272;&#x6846;&#x6211;&#x662F;&#x738B;OI&#x4E4B;&#x8DEF;&#x7B97;&#x662F;&#x67D0;&#x4E9B;&#x5B66;&#x4E60;&#x7B14;&#x8BB0;&#x5427;&#xFF0C;&#x4F46;&#x5E76;&#x4E0D;&#x662F;&#x6559;&#x7A0B;&#xFF0C;&#x4E5F;&#x6CA1;&#x6709;&#x6309;&#x96BE;&#x5EA6;&#x987A;&#x5E8F;&#xFF0C;&#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;&#x4E00;&#x4E2A;&#x6846;&#x67B6;:)&#x53EF;&#x4EE5;&#x628A;&#x5B83;&#x5F53;&#x505A;&#x4E00;&#x4E2A;&#x6559;&#x7A0B;&#x7684;&#x5408;&#x96C6;&#xFF0C;&#x901A;&#x5E38;&#x4F1A;&#x7ED9;&#x51FA;&#x4E00;&#x4E9B;&#x4E0D;&#x9519;&#x7684;&#x94FE;&#x63A5;&#x4EE5;&#x53CA;&#x81EA;&#x5DF1;&#x7684;&#x4E00;&#x4E9B;&#x5B66;&#x4E60;&#x7B14;&#x8BB0;&#x4E0D;&#x8FC7;&#x76EE;&#x524D;&#x975E;&#x5E38;&#x4E71;&#xFF0C;&#x9000;&#x5F79;&#x540E;&#x4F1A;&#x4ED4;&#x7EC6;&#x6574;&#x7406;&#xFF0C;&#x518D;&#x52A0;&#x4E2A;&#x76EE;&#x5F55;&#xFF08;&#x76EE;&#x524D;&#x53EF;&#x4EE5;&#x5728;&#x9876;&#x90E8;&#x53BB;&#xFF09; &#x90AE;&#x7BB1;&#xFF1A;zorysoftware@qq.com&#xFF08;&#x63A8;&#x8350;&#xFF09; QQ&#xFF1A;1134430323&#xFF0C;&#x6700;&#x597D;&#x5907;&#x6CE8;&#x4E00;&#x4E0B;&#x5B66;&#x6821;&#x548C;&#x540D;&#x5B57;&#x4EC0;&#x4E48;&#x7684;~&#x5982;&#x679C;zory.ink&#x5931;&#x6548;&#xFF0C;&#x53EF;&#x524D;&#x5F80;zory.coding.me&#x6216;&#x8005;zory123.github.io&#x8981;&#x8F6C;&#x8F7D;&#x4EC0;&#x4E48;&#x7684;&#x8BDD;&#x9EBB;&#x70E6;&#x8BF4;&#x4E00;&#x58F0;&#xFF0C;&#x8C22;&#x8C22;&#x5408;&#x4F5C; &#x4E00;&#x4E9B;&#x5947;&#x602A;&#x7684;&#x4E1C;&#x897F;&#x8BF7;&#x5148;&#x601D;&#x8003;&#x540E;&#x518D;&#x5C55;&#x5F00; &#x5373;&#x5F97;&#x6613;&#x89C1;&#x5E73;&#x51E1;&#xFF0C;&#x4EFF;&#x7167;&#x4E0A;&#x4F8B;&#x663E;&#x7136;&#xFF0C;&#x7559;&#x4F5C;&#x4E60;&#x9898;&#x7B54;&#x6848;&#x7565;&#xFF0C;&#x8BFB;&#x8005;&#x81EA;&#x8BC1;&#x4E0D;&#x96BE;&#x3002;&#x53CD;&#x4E4B;&#x4EA6;&#x7136;&#x540C;&#x7406;&#xFF0C;&#x63A8;&#x8BBA;&#x81EA;&#x7136;&#x6210;&#x7ACB;&#xFF0C;&#x7565;&#x53BB;&#x8FC7;&#x7A0B;Q.E.D.&#xFF0C;&#x7531;&#x4E0A;&#x53EF;&#x77E5;&#x8BC1;&#x6BD5;&#x3002; &#x5F88;&#x4E45;&#x4EE5;&#x524D;&#x770B;&#x5230;zzq&#x535A;&#x5BA2;&#x4E0A;&#x8BF4;fst on test 233&#xFF0C;&#x6211;&#x5929;&#x771F;&#x5730;&#x4EE5;&#x4E3A;&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x7B11;&#x8BDD;&#xFF0C;&#x73B0;&#x5728;&#x89C9;&#x5F97;&#xFF0C;&#x771F;&#x597D;&#x7B11;Codeforces Round #583 &#x4E00;&#x5305;&#x8336;&#xFF0C;&#x4E00;&#x888B;&#x70DF;&#xFF0C;&#x4E00;&#x9053;&#x7834;&#x9898;&#x8C03;&#x4E00;&#x5929;&#x3002; xgc&#x52E4;&#x594B;&#x5B9E;&#x5F55;&#xFF1A; &#x81EA;&#x9AD8;&#x4E8C;&#x5F00;&#x5B66;2019.09.01&#x8D77;&#xFF0C;&#x575A;&#x6301;&#x6BCF;&#x5929;&#x4E2D;&#x5348;12:00&#x98DE;&#x5954;&#x53BB;&#x996D;&#x5802;&#xFF0C;&#x6BCF;&#x665A;10:30&#x98DE;&#x5954;&#x524D;&#x5F80;&#x996D;&#x5802;&#x4E70;&#x65E9;&#x9910;&#xFF0C;&#x518D;&#x98DE;&#x5954;&#x56DE;&#x5BBF;&#x820D;&#x6D17;&#x8863;&#x670D;&#xFF0C;&#x575A;&#x6301;&#x6BCF;&#x5929;&#x6700;&#x665A;&#x53BB;&#x6253;&#x7403;&#xFF0C;&#x5DF2;&#x575A;&#x6301;&#x81F3;2019.10.23 &#x7ECF;&#x5E38;&#x4E0A;&#x6F14;&#x7684;&#x4E00;&#x5E55;&#xFF1A;&#x591C;&#x6DF1;&#x4EBA;&#x9759;&#x7684;&#x591C;&#x665A;&#xFF0C;&#x660F;&#x6697;&#x7684;&#x7ADE;&#x8D5B;&#x5BA4;&#x4E2D;&#xFF0C;&#x672A;&#x89C1;&#x5176;&#x72D7;&#x5148;&#x95FB;&#x90A3;&#x5982;&#x66B4;&#x96E8;&#x822C;&#x5BC6;&#x96C6;&#x7684;&#x952E;&#x76D8;&#x6572;&#x51FB;&#x58F0;&#xFF0C;&#x9760;&#x8FD1;&#x4E00;&#x770B;&#xFF0C;&#x53EA;&#x89C1;&#x56E0;&#x592A;&#x4E45;&#x6CA1;&#x5173;&#x673A;&#x800C;&#x95EA;&#x70C1;&#x7740;&#x7684;&#x8001;&#x5F0F;&#x663E;&#x793A;&#x5C4F;&#x540E;&#xFF0C;&#x4E00;&#x4E2A;&#x9010;&#x6E10;&#x5FD8;&#x8BB0;&#x81EA;&#x5DF1;&#x79CD;&#x65CF;&#x7684;&#x5BB6;&#x4F19;&#x6234;&#x7740;&#x8033;&#x673A;&#xFF0C;&#x6447;&#x5934;&#x6643;&#x8111;&#xFF0C;&#x624B;&#x5374;&#x4E1D;&#x6BEB;&#x4E0D;&#x53D7;&#x5F71;&#x54CD;&#x5730;&#x7EE7;&#x7EED;&#x5728;&#x952E;&#x76D8;&#x4E0A;&#x5F8B;&#x52A8;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x4E86;&#x89E3;&#x4ED6;&#x7684;&#x4EBA;&#x6015;&#x662F;&#x4F1A;&#x8BEF;&#x4EE5;&#x4E3A;&#x4ED6;&#x78D5;&#x4E86;&#x836F;&#x5427;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-7一类线性二分]]></title>
    <url>%2Fposts%2F3d1d710e.html</url>
    <content type="text"><![CDATA[一类线性二分 好像推广性还不错，说不定可以搞出一些题从log方降低为log 借教室对于二分区间$[l,r]$，把整个区间的新区间端点离散化，那么无论往哪边走，都可以先把当前的序列按照新离散化端点，合并起来（合并的时候取min作为新值），这样需要加入的区间个数、推差分标记的总量都是$O(m)$ 最小瓶颈生成树二分，如果向左边边数为mid/2，总和为m；向右边的话把左边的点用bfs缩起来，右边的新边为(r-l)/4条]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-6计算几何]]></title>
    <url>%2Fposts%2F7158.html</url>
    <content type="text"><![CDATA[计算几何more1more2 辅助函数1double atan2(double x,double y) 向量相关见线性代数一章 坐标（向量）旋转：这个很好推，$(a,b)逆时针旋转 \theta -&gt;(acos\theta -bsin\theta ,asin\theta +bcos\theta )$ 三角形的五心外心：垂直平分线交点 重心：中线交点，重心到顶点=2*重心到对边中点，平分面积，到三个顶点距离的平方和最小，坐标为平均数，到三个顶点的向量和=零向量 垂心：垂线交点，三角形垂心到任一顶点=2*其外心到对边，单位圆上为三点坐标之和 内心：角平分线交点，直角三角形内心的$r=\frac{a+b-c}{2}$，圆内三点的三角形内心=那三段圆弧的中点形成三角形的垂心 欧拉线：外心O，重心G，垂心H，三点共线，2OG=GH 几何图形求多边形（可以凹）的面积：相邻两点（逆时针的话，可以不用绝对值，所以能模了，尽管面积可能是负数，最后总是正数）到坐标原点的叉积和例题：HDU-2036 随机任意多边形的数据：[Wf2017]Airport Construction 直线交点：建议画图，一条直线与另外两点的叉积面积比=高的比=另一条直线被交点所分的两部分之比 1234567Pt check(Pt a,Pt b,Pt c,Pt d)//尚未验证正确性&#123; Pt t1=b-a,t2=d-c,t3=c-a; ll A=cross(t1,t2),B=cross(t3,t2); double xx=a.x+(double)B/A*t1.x,yy=a.y+(double)B/A*t1.y; return (Pt)&#123;xx,yy&#125;;&#125; 过圆外一点的切线：求点与圆心的直线然后用asin旋转 好题雅礼冬令营集训2019 D7t3 转载尚未学习 y&gt;=kx+b（y&lt;=kx+b同理）的半平面交的并集是一个上凸壳，我们可以把它对偶成凸包，即是将一条直线的 (k,b)视为一个点 (k,b)，然后做一个下凸壳。这样我们就可以合并半平面交了，即为做这个对偶凸包的闵可夫斯基和（就是(a,b)和(c,d)合并起来后为(a+b,c+d)。因为ax+b+cx+d=&gt;(a+c,b+d)）。而闵可夫斯基和可以双指针在两个凸壳上面移动来解决，开始时候，两个指针p1,p2都在1位置，之后判断(p1,p2+1),(p1+1,p2)和(p1,p2)的斜率哪个更大（叉积判断即可），以此来移动指针，这样相当于直接扔掉了一列或者一行。]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-5哈希]]></title>
    <url>%2Fposts%2F9bde.html</url>
    <content type="text"><![CDATA[哈希Hash 前言这东西主要用来验重而且在字符串领域比较常用但其思想的应用才是其精髓所以没有放在字符串分类 正文123456789101112typedef unsigned long long ull;ull gethash(char *s)&#123; int len=strlen(s+1); ull ans=0,p=1; for(int i=1;i&lt;=len;i++) &#123; ans=ans*p+s[i]; p*=13331; &#125; return ans;&#125; 其他应用1. 字符串匹配-kmp例题：POJ3461 Oulipo 2. 字符串匹配-ac自动机等价于用kmp搞ac机，不推荐 3. 字符串匹配-manacherO(nlogn)求最大回文子串其实就是枚举中心点，分情况讨论，然后二分长度 4. 字符串匹配-后缀数组O(n log^2⁡ n )在排序的比较函数中，套一个二分，得到最长公共前缀，比较其下一个字符，就能够比较出大小得出排名后，相邻的再同样地二分一次就好了 练习题Tag-哈希 MinHash例题：GYM101372E Nice Report 定义两个集合的 $Jaccard \ similarity(A,B)=\frac{ |A \cap B| }{ |A \cup B| }$ 然后假设现在有一个随机的完美hash函数， $Pr[minh_A=minh_B]=Jaccard \ similarity(A,B)，Pr指成立的概率$ 如果是两个集合合并，利用$$交+并=|A|+|B|$$以及$交/并=S$得到$并的大小=\frac{|A|+|B|}{S+1}$ 这种做法因为是动态维护一个真实大小，精度误差挺大的，官方正确率50/55，贴个代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; const ll MOD=1e9+7; void add(int &amp;x,int y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll r(ll l,ll r) &#123; return l+(RAND_MAX*rand()+rand())%(r-l+1); &#125; vector&lt;int&gt; go[MAX_N]; stack&lt;int&gt; sta;bool insta[MAX_N]; int dfn[MAX_N],low[MAX_N],id; int blg[MAX_N],cnt; double ans[MAX_N]; void tarjan(int x) &#123; dfn[x]=low[x]=++id; insta[x]=1;sta.push(x); for(int t=0;t&lt;(int)go[x].size();t++) &#123; int y=go[x][t]; if(!dfn[y]) tarjan(y),chmin(low[x],low[y]); else if(insta[y]) chmin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; cnt++; while(1) &#123; int now=sta.top();sta.pop(); blg[now]=cnt;ans[cnt]++;insta[now]=0; if(now==x) break; &#125; &#125; &#125; int n; vc&lt;int&gt; to[MAX_N],fm[MAX_N]; int outdeg[MAX_N]; const int TIME=100; int minhash[TIME+1][MAX_N]; int qq[MAX_N]; int aa[MAX_N]; void solve() &#123; for(int x=1;x&lt;=n;x++) for(int t=0;t&lt;(int)go[x].size();t++) &#123; int y=blg[go[x][t]],tx=blg[x]; if(tx!=y) to[tx].PB(y),outdeg[tx]++,fm[y].PB(tx); &#125; int tmp=0;for(int i=1;i&lt;=cnt;i++) &#123;if(outdeg[i]==0) sta.push(i);&#125; while(sta.size()) &#123; int x=sta.top();sta.pop();qq[++tmp]=x; for(int t=0;t&lt;(int)fm[x].size();t++) &#123; int y=fm[x][t];outdeg[y]--; if(outdeg[y]==0) sta.push(y); &#125; &#125; for(int t=1;t&lt;=TIME;t++) &#123; for(int i=1;i&lt;=n;i++) aa[i]=i;random_shuffle(aa+1,aa+n+1); for(int i=1;i&lt;=n;i++) chmin(minhash[t][blg[i]],aa[i]); &#125; for(int i=1;i&lt;=cnt;i++) &#123; int x=qq[i]; for(int t=0;t&lt;(int)to[x].size();t++) &#123; int y=to[x][t]; double tmp=0; for(int pp=1;pp&lt;=TIME;pp++) &#123; tmp+=(minhash[pp][x]==minhash[pp][y]); chmin(minhash[pp][x],minhash[pp][y]); &#125; tmp/=TIME;ans[x]=(ans[x]+ans[y])/(tmp+1); &#125; &#125; &#125; void main() &#123; memset(minhash,0x3f,sizeof minhash); //int T=qread(); //for(int cas=1;cas&lt;=T;cas++) &#123; n=qread(); /*for(int x=1;x&lt;=n;x++) &#123; int tmp=qread(); while(tmp--) &#123;int y=qread();go[x].PB(y);&#125; &#125;*/ int m=qread();for(int i=1;i&lt;=m;i++)&#123;int x=qread(),y=qread();go[x].PB(y);&#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); solve(); for(int i=1;i&lt;=n;i++) printf("%.0Lf\n",ans[blg[i]]); //double ANS=0;for(int i=1;i&lt;=n;i++) ANS+=1/ans[blg[i]]; //printf("Case #%d: %.10Lf\n",cas,ANS); id=cnt=0; for(int i=0;i&lt;=n;i++) &#123; dfn[i]=outdeg[i]=0;ans[i]=0; go[i].clear(),to[i].clear(),fm[i].clear(); for(int t=0;t&lt;=TIME;t++) minhash[t][i]=INF; &#125; &#125; &#125;&#125;;signed main()&#123; srand(time(0)); mine::main();&#125; 上述做法主要是中途需要维护真实大小，更优越的做法是，考虑一个hash映射 $a_i-&gt;[0,1]$ 然后求出在某个映射下当前节点能到达的hmin， $hmin=\frac{1}{集合大小m+1}，这个是m个[0,1]随机实数最小值的期望，可以用积分推出$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//Zory-2019#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;namespace mine&#123; typedef long long ll; #define double long double const int INF=0x3f3f3f3f; const ll LLINF=0x3f3f3f3f3f3f3f3fll; ll qread() &#123; ll ans=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') &#123;if(c=='-') f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) &#123;num=-num;putchar('-');&#125; if(num&gt;9) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);puts("");&#125; #define FR first #define SE second #define MP make_pair #define pr pair&lt;int,int&gt; #define PB push_back #define vc vector void chmax(int &amp;x,const int y) &#123;x=x&gt;y?x:y;&#125; void chmin(int &amp;x,const int y) &#123;x=x&lt;y?x:y;&#125; void chmin2(double &amp;x,const double y) &#123;x=x&lt;y?x:y;&#125; const int MAX_N=2e5+10; const ll MOD=1e9+7; void add(int &amp;x,int y)&#123;x+=y;if(x&gt;=MOD) x-=MOD;if(x&lt;0) x+=MOD;&#125; ll r(ll l,ll r) &#123; return l+(RAND_MAX*rand()+rand())%(r-l+1); &#125; double r2()&#123;return (double)( RAND_MAX*rand()+rand())*1.0/( RAND_MAX*RAND_MAX );&#125; vector&lt;int&gt; go[MAX_N]; stack&lt;int&gt; sta;bool insta[MAX_N]; int dfn[MAX_N],low[MAX_N],id; int blg[MAX_N],cnt; void tarjan(int x) &#123; dfn[x]=low[x]=++id; insta[x]=1;sta.push(x); for(int t=0;t&lt;(int)go[x].size();t++) &#123; int y=go[x][t]; if(!dfn[y]) tarjan(y),chmin(low[x],low[y]); else if(insta[y]) chmin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; cnt++; while(1) &#123; int now=sta.top();sta.pop(); blg[now]=cnt;insta[now]=0; if(now==x) break; &#125; &#125; &#125; int n; vc&lt;int&gt; fm[MAX_N]; int outdeg[MAX_N],backup[MAX_N]; const int TIME=100; double minhash[MAX_N],ans[MAX_N]; void solve() &#123; for(int x=1;x&lt;=n;x++) for(int t=0;t&lt;(int)go[x].size();t++) &#123; int y=blg[go[x][t]],tx=blg[x]; if(tx!=y) backup[tx]++,fm[y].PB(tx); &#125; for(int t=1;t&lt;=TIME;t++) &#123; memcpy(outdeg,backup,sizeof backup); for(int i=1;i&lt;=cnt;i++) minhash[i]=1; for(int i=1;i&lt;=n;i++) chmin2(minhash[blg[i]], r2() ); for(int i=1;i&lt;=cnt;i++) &#123;if(outdeg[i]==0) sta.push(i);&#125; while(sta.size()) &#123; int x=sta.top();sta.pop(); for(int t=0;t&lt;(int)fm[x].size();t++) &#123; int y=fm[x][t];outdeg[y]--;if(outdeg[y]==0) sta.push(y); chmin2(minhash[y],minhash[x]); &#125; ans[x]+=minhash[x]; &#125; &#125; &#125; void main() &#123; n=qread();int m=qread();for(int i=1;i&lt;=m;i++)&#123;int x=qread(),y=qread();go[x].PB(y);&#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);solve(); for(int i=1;i&lt;=n;i++) printf("%.0Lf\n",TIME/ans[blg[i]]-1); &#125;&#125;;signed main()&#123; srand(time(0));int tmp=rand();while(tmp--) rand();srand(rand()); mine::main();&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-4哈夫曼树]]></title>
    <url>%2Fposts%2Ff6c6.html</url>
    <content type="text"><![CDATA[哈夫曼树 定义定义树的带权路径长度（wpl）是每个叶子节点，其【权值×节点到根的带权距离】之和 定义“满足国际定义的满k叉树”是每个节点，其孩子个数不是0就是k 相关介绍：百度百科-满二叉树（借鉴一下）这里稍微有提到，省略了“国际”：百度百科-哈夫曼树 因为没有时间，不详细介绍有兴趣的童鞋可以去wiki看看专业文献 哈夫曼树（霍夫曼树）1.给出n个叶子节点，求一个k叉树结构，使得这棵树的带权路径长度和最小 2.先考虑k=2的二叉树情况由定义，可以想到一个贪心：每次取出最小的a和b，累计答案a+b，并构造父亲节点，权值为a+b（其实很多算法都是从贪心开始的，虽然不一定以此结束）必要性证明：不会充分性证明：把（a+b）×深度，拆分成父亲（深度-1）和答案里面的a+b 然后，由于带权路径长度的特殊性如果我们已经限定了k=2，生成的树一定是满足国际定义的满k叉树必要性证明：假设某个非底层位置还剩个“槽”，把某个比这里深的节点（这意味着它比这几个叶子节点小）移到这里，一定能让答案更小 例题：noip2004 合并果子把参与合并次数作为深度就好了 3.当k&gt;2呢？我们能不能改成一次拿出k个？有一个要考虑的细节：再刚才，k=2，总能取到这么多然鹅现在，有可能最后剩下&lt;k个由于上面的证明，我们需要生成满足国际定义的满k叉树，才能确保正确性其实解决办法很简单：补0，直到能生成满足国际定义的满k叉树这样就把本来应该放在顶层（其实就是非顶层里面最大的那些）放到顶层 但是怎么判断能不能生成完全k叉树呢？换句话说，生成满足国际定义的满k叉树对叶子节点数量有什么要求？结论：(n-1)%(k-1)=0充分性证明：假设有n个叶子节点，它们能生成满足国际定义的满k叉树先看根节点，隐去剩下的n-1个节点，倒过来考虑每一次，我们给它k个孩子节点，但同时它自己不再是叶子节点所以每一次，那n-1个节点，按照一次k-1个来出现所以n-1应当是k-1的倍数 upd: 类似noip蚯蚓那题可知，可以线性搞 哈夫曼Huffman编码哈夫曼有个特性，就是能够解决编码问题把每个字母、单词的出现次数统计起来，给其新的编码，总长度总是最小的（可以把次数看作权值，长度看作深度）而且，这个编码的优秀在于不会有歧义换句话说，一个编码不会是另外一个编码的前缀 做法：生成哈夫曼树，如果编码是k进制的，也就是0~k-1的那么可以理解为是k叉的，然后按照0~k-1给同一个父亲到它孩子的边赋权然后上面说的前缀，原因在于我们把字母、单词看作叶子节点从根节点到达它，经过的权，其排列是独一无二的（后缀就不一定了，但没有关系，因为解码的时候是从前往后的，先入为主） 例题：noi2015 荷马史诗 其他经典Tag-哈夫曼]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-3启发式搜索]]></title>
    <url>%2Fposts%2F5f25.html</url>
    <content type="text"><![CDATA[启发式搜索，又称A*算法 基本原则$估价f(x)&lt;=实际代价g(x)$作用：假设有两个状态非最优A，在堆内是$s(A)+f(A)$最优B，在堆内是$s(B)+f(B)$即使A先出来，会拓展出$s(C)+f(C)$也就是$s(A)+g(C)-g(A)+f(C)$既然A不是最优的，那么我们的B一定能出来 但如果违反了基本原则呢？因为$s(A)+f(A)&lt;s(B)+f(B)$所以 有可能 $s(A)+g(A)+f(C)-g(C)&lt;s(B)+f(B)$所以这个状态又要再出来一次（这里的ed不一定是最终状态） 练习题Tag-启发式搜索]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>启发式搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-2-01分数规划]]></title>
    <url>%2Fposts%2F7705.html</url>
    <content type="text"><![CDATA[01分数规划问题 问题给出数组a和b，求一组解x（只由01组成），使下面的式子最大化$\frac{ \sum a_i \times x_i }{ \sum b_i \times x_i }$ 二分法二分答案L，转化为判定性问题判定：$\frac{ \sum a_i \times x_i }{ \sum b_i \times x_i } \geq L$$\sum (a_i-L \times b_i) \times x_i \geq 0​$而这个问题的判定灰常简单，因为相互之间不影响，只要括号内是正数就是1即可判定 好文章推荐显然他们真的写得比我好、也更详细张天翔PerSeAwe 经典例题hnoi2009最小圈,code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】07其他-1网络流]]></title>
    <url>%2Fposts%2F5c7c.html</url>
    <content type="text"><![CDATA[难点就是构图也有各种变例决策类问题的法宝之一（还有贪心等） 有个不错的入门教程网络流-纳米黑客PDF 最大流解决方案Edmond-Karp 理论上界是 $nm^2$ ，但通常可以解决$10^3$ ~ $10^4$ 的规模 EK的缺点主要是，每次只找出一条增广路Dinic算法试图改进这一点 通过bfs得出残余网络中的分层图（显然是一个dag） 通过dfs得出增广路，回溯时更新流量 理论上界是 $n^2m$ ，但通常可以解决$10^4$ ~ $10^5$ 的规模特别地，对于二分图匹配，时间复杂度可以达到$O(m \sqrt n)$ 当前弧优化：当层次确定的时候，反向弧是否使用也是确定的那么如果一条边流完了，可以在边链表中去除（有点类似欧拉路径的优化）因为是层次图，不用担心 dfs 对第一个有效边数组的影响例题：order 最小割建议看胡伯涛的论文非常好的题目：【TJOI2015】线性代数 笔记：割上的净流，会统计负流，但割的容量并不统计定理：任意一个流，其净流=流的大小 费用流本质上其实就是把EK中bfs换成能处理边权的spfa（因为dinic无法处理，所以只有EK的衍生版）费用流的构图需要注意负/正环 至于zkw费用流……jzq233jzqzkw 最大权闭合子图闭合子图：只进不出的子图，可用于处理依赖关系很容易贪心地想到，最优情况是所有正权点，但为了闭合要有所割舍 考虑有网络流决策，将点分成选和不选两种，用割的模型，以是否和S连通来标识则S向所有正权点连边，边权为点权，所有负权点向T连边，边权为点权的绝对值割后，设选的点集为A，不选为B，根据点权正负细分，如图所示：如果x依赖y，则选x就要选y，此时从x到y连接一条INF的边，标识不可【选x不选y】注意一个细节（因为我这菜逼一开始忽略了）：这条边是允许选y不选x的，因为那种情况没有造成连通 此时只要是个合法的割，A一定是一个闭合子图，现在要最大化它显然割=B1-A0，而A=A1+A0故A+割=A1+A2=正权和，让割最小化即可 有下界网络流loj上有板子题，代码可以去上面看，以最新提交为准还有一道板子题：支线剧情 无源汇可行流：流量平衡下， $\sum d_i=in_i-out_i=0$先以下界为初始流，边的容量为mx-mi，然后我们希望得到一个流量平衡的流$若d&gt;0，st-&gt;i=d_i,若d&lt;0, i-&gt;ed=-d_i$这个还是比较显然的，就是给每个点一些配额去把多的流量流出去 有源汇（要把去源的、到汇的边去掉）：可行流：ed-&gt;st=INF，于是就是无源汇的了然后流量就是st-&gt;ed那条边此时的可用容量（假装流掉的真实流大小）这个思想有个不错的题目，【cf708d】Incorrect Flow最大流：用可行流的方式构造新图，然后新图上的满流就是原图的可行流，在此之上的操作都能保证其依然是可行流那么在这个残余网络上，再重新跑一个最大流（ans要清空，然后可行流大小会被st-&gt;ed统计到）费用流：这里指的是不保证流最大，而是合法流的最小、大费用做法没什么区别]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-8其他]]></title>
    <url>%2Fposts%2F5f38.html</url>
    <content type="text"><![CDATA[其他东西 最小表示法这个不难，有兴趣的可以去了解一下，不过可以被sam代替 hash基数一般用131或13331然后注意ull的话多少hash都没用，需要取模例子：CF1200E E. Compress Words然后cf比赛的时候最好rand，否则可以针对你的code来hack 123456789namespace HASH&#123; int base[2],mod[2],bs[2][N]; void prehash()&#123; base[0]=131;mod[0]=1ll*rand()*rand()+100000;base[1]=13331;mod[1]=993244853;bs[0][0]=1;bs[1][0]=1; for(int i=1;i&lt;N;i++) bs[0][i]=bs[0][i-1]*base[0]%mod[0],bs[1][i]=bs[1][i-1]*base[1]%mod[1]; &#125; pr hash(pr old,int add)&#123;return MP((old.FR*base[0]+add)%mod[0],(old.SE*base[1]+add)%mod[1]);&#125;&#125;; 策爷的ppt抄点结论，证明太容易忘了，虽然大部分不太难理解具体证明见原ppt 周期和border集合border集合表示，这个长度的前缀与后缀相同，包括0周期表示不可重叠覆盖子串的长度，即对于任意i，str[i]=str[i+周期]推论1：a和b都是s的周期，则当 $a+b-gcd(a,b) \leq |s|,gcd(a,b)也是s的周期$推论2：若字符串u和v满足 $2|u| \geq |v|$ （匹配不能无重叠），则u在v中匹配位置是个等差数列若至少匹配了3次，则公差为u的最小周期d，且 $d \leq |u|/2$ （否则显然不满足长度条件）推论3：$s中 \leq |s|/2的border构成等差数列$用推论1证明推论4：border集合按照二进制分组后，每组都是一个等差数列用归纳法证明 后面的好难难啊，先鸽着rose]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-7后缀自动机]]></title>
    <url>%2Fposts%2Fd6cf.html</url>
    <content type="text"><![CDATA[后缀自动机（SAM）目标：构造一个自动机（dag），能识别一个串的所有子串（也就是所有从根出发的合法路径都是一个子串） 以前放了一些证明之类的，仔细想了想没有太大必要，就略去吧，有兴趣可以看师弟的博客 所以主要放个框架和一些容易搞错的地方 复杂度设字符集大小为k方案一：$时间O(n)+空间O(nk)$方案二：$时间O(nlogk)+空间O(n)$，即用平衡树应对大字符集 核心思路识别所有子串是个很crazy的idea，我们需要考虑怎样将朴素的 $n^2$ 个状态压缩；考虑有没有一些子串他们对于这个串而言是相似的，比较自然的思路是合并完全相同的子串，但这种方法只在回文自动机里够用；要识别所有一般的子串，还需要定义一个end-pos（或者right）集合，表示在串中出现位置的右端点，然后把所有right集合相同的合并起来 ，这样只会有 O(n) 个节点 然后其实sam中的fail树也是很重要的部分，fail表示right集合包含当前节点且集合大小最小的位置（偏序集），也可以理解为一个出现集合不同的最长后缀 构造算法我们时刻维护字符串前面部分的sam，然后当前插入字符c（新建节点now），lst为表示前面整个串的节点从lst开始尝试跳fail，寻找一个节点a拥有字符c儿子b（用类似trie的方式记录即可）一、找不到b，则从rt连向now，$fail(now)=rt$二、存在b① $mx(a)+1=mx(b)$b只代表一种本质不同串，显然right是包含的，而且是now的最近后缀，$fail(now)=b$② $mx(a)+1&lt;mx(b)$这意味着，在原串中a和b之间隔着一些字符，同时以前为了压缩节点数而把【加入c后right不同的状态】合并在了一起；原本right相同，但是即将不同，故新建节点tmp，父亲、儿子信息从b继承， $fail(b)=tmp,fail(now)=tmp$ 应用①第k小子串：dag上dp求不同子串个数，然后贪心即可（经典例题：「TJOI2015」弦论 ，code）②最长公共后缀：fail树上两点lca③拓扑序：可以利用性质用mx排序④最小表示：因为包含了所有子串，对S+S建，跑|S|次，贪心找最小的那个⑤最长公共子串：先选一个建好，两串直接跑nxt，如果是多个就对每个节点记录其他串的min，最后选最大的节点⑥后缀树：反串的fail树 当然还有经典的LCT动态维护sam，51nod1600 Simple KMP 广义多串： 构建方法：对串逐个加入，每建完一个串，lst=1，时空复杂度和普通sam一样 如果有相同的状态，其实本质上是一个点：faill树上，打标记、找子树等操作不会有影响，dag上，永远也不会访问到无用节点 不过注意fail树不能用基数排序，因为可能和父亲的mx相同而父亲编号更大 upd：起因是看到这篇文章，不过我觉得他有些地方没说清楚，一下给的板子是广义自动机正确板子里最简短的 1234567891011121314151617181920struct SAM&#123; int id;SAM()&#123;id=1;&#125; struct Nod&#123;int son[10],fail,mx;&#125;p[N]; int insert(int lst,int c,int col) &#123; int now=++id;p[now].mx=p[lst].mx+1; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; int b=p[a].son[c]; if(!b) p[now].fail=1; else if(p[b].mx==p[a].mx+1) p[now].fail=b; else &#123; int tmp=++id;p[tmp]=p[b];p[tmp].mx=p[a].mx+1; p[b].fail=p[now].fail=tmp; while(p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; return p[lst].son[c]; &#125;&#125;sam; 不同的就是返回值：这种情况只会出现在广义，不这么做是不会影响sam的构建的，但可能得到错误的pos（即从头开始逐个向自动机输入字符到i时到达的节点），而不少题目需要用到这个信息（如bzoj5408） Trie： 这个直接dfs建复杂度是叶子节点到根路径和；bfs建就能保证是trie的大小 下面给出bzoj5408的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;using namespace std;namespace mine&#123; #define double long double typedef long long ll; #define pr pair&lt;int,int&gt; #define FR first #define SE second #define MP make_pair #define PB push_back #define vc vector #define all(x) (x).begin(),(x).end() #define SZ(x) ((int)(x).size()) #define bin(x) (1ll&lt;&lt;(x)) ll qread() &#123; ll ans=0,f=1;char c=getchar(); while(c&lt;'0' or c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans*f; &#125; void write(ll num) &#123; if(num&lt;0) putchar('-'),num=-num; if(num&gt;=10) write(num/10); putchar('0'+num%10); &#125; void write1(ll num)&#123;write(num);putchar(' ');&#125; void write2(ll num)&#123;write(num);putchar('\n');&#125; void chmax(int &amp;x,const ll y) &#123;x=(x&gt;y?x:y);&#125; void chmin(int &amp;x,const ll y) &#123;x=(x&lt;y?x:y);&#125; ll gcd(ll x,ll y)&#123;return y?gcd(y,x%y):0;&#125; const int INF=0x3f3f3f3f; const int MOD=1e9+9; inline int mm(const int x)&#123;return x&gt;=MOD?x-MOD:x;&#125; inline ll qpower(ll x,ll e) &#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=ans*x%MOD; x=x*x%MOD;e&gt;&gt;=1; &#125; return ans; &#125; inline int invm(int x)&#123;return qpower(x,MOD-2);&#125; const int N=1e6+10; namespace LCT &#123; int son[N][2],fa[N]; int cnt[N][21],tag[N][21]; #define lc(x) son[(x)][0] #define rc(x) son[(x)][1] bool tw(int x)&#123;return rc(fa[x])==x;&#125; bool isrt(int x)&#123;return son[fa[x]][tw(x)]!=x;&#125; void pushdown(int x) &#123; for(int i=1;i&lt;=20;i++) &#123; if(lc(x)) cnt[lc(x)][i]+=tag[x][i],tag[lc(x)][i]+=tag[x][i]; if(rc(x)) cnt[rc(x)][i]+=tag[x][i],tag[rc(x)][i]+=tag[x][i]; tag[x][i]=0; &#125; &#125; void rotate(int x) &#123; int f=fa[x],ff=fa[f];if(!isrt(f)) son[ff][tw(f)]=x; int cc=tw(x),tson=son[x][cc^1];son[x][cc^1]=f;son[f][cc]=tson; fa[x]=ff;fa[f]=x;if(tson) fa[tson]=f; &#125; int tmp[N]; void splay(int x) &#123; int cnt=0,tt=x;while(!isrt(tt)) tmp[++cnt]=tt,tt=fa[tt];tmp[++cnt]=tt; for(int i=cnt;i&gt;=1;i--) pushdown(tmp[i]); for(int f=fa[x];!isrt(x);rotate(x),f=fa[x]) if(!isrt(f)) tw(x)^tw(f)?rotate(x):rotate(f); &#125; void access(int x)&#123;for(int lst=0;x&gt;0;lst=x,x=fa[x]) &#123;splay(x),son[x][1]=lst;if(lst)fa[lst]=x;&#125;&#125; //y为树根 void link(int x,int y)&#123;if(min(x,y)) fa[y]=x;&#125; void cut(int x,int y)&#123;if(min(x,y)) access(y),splay(x),son[x][1]=fa[y]=0;&#125; void add(int x,int id)&#123;if(x) access(x),splay(x),cnt[x][id]++,tag[x][id]++;&#125; &#125;; using namespace LCT; struct SAM &#123; ll dif;int id;SAM()&#123;id=1;&#125; struct Nod&#123;int son[10],fail,mx;&#125;p[N]; int insert(int lst,int c,int col) &#123; int now=++id;p[now].mx=p[lst].mx+1; int a=lst;while(a and !p[a].son[c]) p[a].son[c]=now,a=p[a].fail; int b=p[a].son[c]; if(!b) p[now].fail=1; else if(p[b].mx==p[a].mx+1) p[now].fail=b; else &#123; cut(p[b].fail,b);splay(b); int tmp=++id;p[tmp]=p[b];p[tmp].mx=p[a].mx+1; for(int i=1;i&lt;=20;i++) cnt[tmp][i]=cnt[b][i]; link(p[tmp].fail,tmp);link(tmp,b); p[b].fail=p[now].fail=tmp; while(p[a].son[c]==b) p[a].son[c]=tmp,a=p[a].fail; &#125; link(p[now].fail,now);add(now,col); dif+=p[now].mx-p[p[now].fail].mx; return p[lst].son[c]; &#125; &#125;sam; int pos[N][30]; char str[20000001]; void main() &#123; int n=qread(),fuk=qread(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",str+1);pos[0][i]=1; for(int j=1,ln=strlen(str+1);j&lt;=ln;j++) pos[0][i]=sam.insert(pos[0][i],str[j]-'0',i); &#125; int lstans=0,m=qread(); for(int k=1;k&lt;=m;k++) &#123; int op=qread();memcpy(pos[k],pos[k-1],sizeof pos[k]); if(op==1) &#123; int id=qread(),c=qread();if(fuk) c=(c^lstans)%10; pos[k][id]=sam.insert(pos[k][id],c,id); &#125; else if(op==2) &#123; int x=qread(),ti=qread(),y=qread(); int now=pos[ti][x]; splay(now);write2(lstans=cnt[now][y]); &#125; else if(op==3) write2(sam.dif); else &#123; scanf("%s",str+1);int ln=strlen(str+1); int now=1;for(int i=1;i&lt;=ln;i++) now=sam.p[now].son[str[i]-'0']; if(!now) puts("0"),lstans=0;//debug 忘记写这个调了一晚上…… else &#123; splay(now);int mx=0; for(int i=1;i&lt;=n;i++) chmax(mx,cnt[now][i]); write2(lstans=mx); &#125; &#125; &#125; &#125;&#125;;int main()&#123; srand(time(0)); mine::main();&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>sam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-6后缀数组]]></title>
    <url>%2Fposts%2Fcc01.html</url>
    <content type="text"><![CDATA[后缀数组入门 sa和rk的计算rk表示第i个后缀（第i个位置后面的元素）的排名sa为其逆函数，即排名i的后缀，所在位置upd:其实并不完全是逆函数，因为rk允许重复，需要压缩相同的值 采用倍增给后缀排序然后多关键字的话，先第二关键字，然后用稳定排序来第一关键字（类似覆盖） height的计算height[i]=LCP(后缀排名i-1，后缀排名i)如果能计算出这个东西，那么询问任意两个后缀的LCP就是询问区间height最小值 然后现在希望尽量快地计算出height，那和所有字符串算法一样，尽可能地优化总势能考虑定义的特性，字典序的排名有什么性质？通过上面利用height的方式得到启发，任意两个串的LCP能保证中间的LCP的下限 具体性质： $height[rk[i]] \geq height[rk[i-1]]-1$$a=i-1,b=sa[rk[i-1]-1]$$c=i,d=sa[rk[i]-1]$现在要证明 $LCP(c,d) \leq LCP(a,b)-1$然后只考虑 $LCP(a,b) \leq 2$ 的情况，否则显然c就是a去掉了开头的一个字符，设e=b+1（去头）$LCP(e,c)=LCP(a,b)-1$然后因为是字典序，e依然会在c前面，得证 按照这个做，时间复杂度就是2n的 code1234567891011121314151617181920212223242526272829303132333435363738394041struct Sa&#123; int rk[MAX_N*2],sa[MAX_N*2],hei[MAX_N*2]; int ct[MAX_N*2],tmp[MAX_N*2],wr[MAX_N*2]; void getsa() &#123; memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[rk[i]=a[i]]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[rk[i]]--]=i; int ln=1; while(ln&lt;n) &#123; int tot=0;for(int i=1;i&lt;=n;i++) if(sa[i]+ln&gt;n) tmp[++tot]=sa[i]; for(int i=1;i&lt;=n;i++) if(sa[i]-ln&gt;=1) tmp[++tot]=sa[i]-ln; memset(wr,0,sizeof wr);//debug memset(ct,0,sizeof ct); for(int i=1;i&lt;=n;i++) ct[ wr[tmp[i]]=rk[tmp[i]] ]++; for(int i=1;i&lt;MAX_N;i++) ct[i]+=ct[i-1]; for(int i=n;i&gt;=1;i--) sa[ct[wr[tmp[i]]]--]=tmp[i]; int cnt=1;rk[sa[1]]=1; for(int i=2;i&lt;=n;i++) &#123; if(wr[sa[i-1]]!=wr[sa[i]] or wr[sa[i-1]+ln]!=wr[sa[i]+ln]) cnt++; rk[sa[i]]=cnt; &#125; ln*=2; &#125; &#125; void gethei() &#123; int lst=0; for(int i=1;i&lt;=n;i++) &#123; if(rk[i]==1) &#123;hei[1]=0;continue;&#125; int j=sa[rk[i]-1];if(lst) lst--; while(max(i,j)+lst&lt;=n and a[i+lst]==a[j+lst]) lst++; hei[rk[i]]=lst; &#125; &#125;&#125;sa; 经典例题NOI2015品酒大会，code 一些拓展树上：luogu5353【模板】树上后缀排序 思考一下，发现sa完全可以拓展到树上，基数排序多几个关键字就行了，然后把序列倍增改成树上倍增]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>sa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-5AC自动机]]></title>
    <url>%2Fposts%2Fab16.html</url>
    <content type="text"><![CDATA[AC自动机 这东西就是KMP思想和字典树的结合。首先，对于多模问题，也就是对一个母串判断多个字符串是否是它的子串时，（对于判断多个字符串是否是它的母串，kmp灰常优秀）每个都做一次KMP显然是不合理的，同时为了减小空间，采用字典树 我主要用fail“指针”实现在字典树中，假设现在有节点i，保证从【root到fail】路径上的字符串是从【root到i】的最长后缀这样，当我们失配时，退而求其次，尝试匹配它的后缀其实有种【树上kmp】的感觉 upd时间复杂度的证明主要是构造fail方面考虑链上，每个节点其fail的深度的关系$dep_{fail-i+1} \leq dep_{fail-i} - xx$$xx \leq dep_{fail-i} - dep_{fail-i+1}$显然xx的和，是和n同阶的 但如果是把一棵树放上去跑，可能会被重复的孩子卡所以应该在构造fail树的时候顺便预处理出每个节点每个字母失配的时候，应该到的节点（板子比较好的可能已经内置了） 板子CF1207G 的完整code 1234567891011121314151617181920212223242526272829char str[N];int son[N][26],id=0,fail[N];void insert(int qid,int col)&#123; int ln=strlen(str+1),now=0; for(int i=1;i&lt;=ln;i++) &#123; int to=str[i]-'a'; if(!son[now][to]) son[now][to]=++id; now=son[now][to]; &#125;&#125;queue&lt;int&gt; q;vc&lt;int&gt; fson[N];//fail树void build()&#123; q.push(0); while(q.size()) &#123; int x=q.front();q.pop(); for(int c=0;c&lt;26;c++) &#123; int y=son[x][c]; if(!y) &#123;son[x][c]=son[fail[x]][c];continue;&#125; int t=fail[x];while(t!=0 and !son[t][c]) t=fail[t]; fail[y]=(son[t][c]==y?0:son[t][c]); q.push(y);fson[fail[y]].PB(y); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-4字典树]]></title>
    <url>%2Fposts%2F7385.html</url>
    <content type="text"><![CDATA[这东西属于数据结构，还是很有趣的……这个的话我就不解释太多了，根据代码理解完全足够这个是很多东西的基础 简单的例题：统计前缀Caioj1463HDU1251 【题意】给出很多个字符串(只有小写字母组成)和很多个提问串，统计出以某个提问串为前缀的字符串数量(单词本身也是自己的前缀).【输入格式】输入n,表示有n个字符串(n&lt;=10000)接下来n行,每行一个字符串,字符串度不超过10输入m,表示有m个提问(m&lt;=100)第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.【输出格式】对于每个提问,给出以该提问为前缀的字符串的数量.【样例输入】5bananabandbeeabsoluteacm4babbandabc【样例输出】2310 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//*******************定义*******************struct Trie&#123; int s,c[27];&#125;a[500010];//*******************实现*******************void clean(int x)&#123; a[x].s=0; for(int i=1;i&lt;=26;i++) a[x].c[i]=-1;&#125;char s[20];int len,k;void add()&#123; len=strlen(s+1); int x=0; for(int i=1;i&lt;=len;i++) &#123; int t=s[i]-'a'+1; if(a[x].c[t]&lt;0) &#123; a[x].c[t]=++k; clean(k); &#125; x=a[x].c[t]; a[x].s++; &#125;&#125;int solve()&#123; len=strlen(s+1); int x=0; for(int i=1;i&lt;=len;i++) &#123; int t=s[i]-'a'+1; if(a[x].c[t]&lt;0) return 0; x=a[x].c[t]; &#125; return a[x].s;&#125;//*******************主函数*******************int main(int argc, char *argv[])&#123; clean(0);k=0; int n;scanf("%d",&amp;n); while(n--) &#123; scanf("%s",s+1); add(); &#125; int m;scanf("%d",&amp;m); while(m--) &#123; scanf("%s",s+1); printf("%d\n",solve()); &#125;&#125; 字典树练习：HDU1075HDU1800]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-3ExKMP]]></title>
    <url>%2Fposts%2F4360.html</url>
    <content type="text"><![CDATA[本文思路和图片大致来自于师兄cys大佬的论文本文会用相同颜色分别表示图片中某段的相等性upd：其实二分hash更好用，虽然慢一点upd2:这东西的国际正式名称是z算法 一、定义KMP：$str(1,nxt[i])=str(i-nxt[i]+1,i)$exKMP：$str(1,ext[i])=str(i,i+ext[i]-1)$然后接下来的过程中，思路和manacher是灰常类似的，各种分类讨论继承 二、求ext数组$ext[1]=lenb$（显而易见）因为ext[1]这个是具有一定性，所以我们基本把这东西废掉……那么我们就直接从ext[2]开始求。 A. k表示在当前搜索过的范围以内,rx=k+ext[k]-1最远（与manacher很像）故str(1,ext[k])=str(k,rx)因为$rx=k+ext[k]-1$，又得：$ext[k]=rx-k+1$代换变成：str(1,rx-k+1)=str(k,rx)因为现在要求ext[i]，截取str(i-k+1,rx-k+1)=str(i,rx) B. 设$L=ext[i-k+1]$，又得：str(1,L)=str(i-k+1,i-k+L)接下来尝试合并。因为L的不定性，需要考虑$i-k+L$和$rx-k+1$的大小 （1）i-k+L&lt;rx-k+1因为str(1,L)=str(i-k+1,i-k+L)，str(i-k+1,rx-k+1)=str(i,rx)所以在str(i,rx)中str(i,i+L-1)=str(1,L)因为str(i-k+1,rx-k+1)=str(i,rx)，得：str[i-k+L+1]=str[i+L]而因为ext[i-k+1]的定义，所以str[L+1]!=str[i-k+L+1]，得：str[i+L]!=str[L+1]，那么$ext[i]=L$小总结：主要利用【$i-k+L+1$已经扫描过】 （2）i-k+L&gt;=rx-k+1str(1,L)=str(i-k+1,i-k+L)所以str(1,rx-i+1)=str(i-k+1,rx-k+1)因为ext[k]的意义，所以str[rx+1]!=str[rx-k+2]又有可能str[rx-i+2]!=str[rx-k+2]（与rx-i+1与L的大小关系有关），那么就会得到：str[rx-i+2]!=str[rx+1]，所以$ext[i]\geq rx-i+1\geq ext[i-k+1]$ 总结：当$i-k+L&lt;rx-k+1$，$ext[i]=L$当$i-k+L\geq rx-k+1$，$ext[i]\geq ext[i-k+1]$ 三、用ext数组好啦我们要开始匹配A串（母串）和B串了定义ex数组，$B(1,ex[i])=A(i,i+ex[i]-1)$即A中每个后缀与B的最长公共前缀长度某种理解：将i-k+1看作i的对应点，将串B和串A放在同一条线上，前面用ext，后面用ex，则L为ext[i的对应点] 四、总结让我们再次对比一下kmp与exkmpKMP：$str(1,nxt[i])=str(i-nxt[i]+1,i)$exKMP：$str(1,ext[i])=str(i,i+ext[i]-1)$对于kmp，当i向后时，利用前面的信息是灰常简单的，一个比较即可；而对于exkmp，前后的i之间并没有较紧密的联系，需要较复杂地分情况讨论 那么这个“牺牲”为我们带来了什么呢？如ex一样的字符串局部信息，并且能够有从i开始的信息。 五、例题最长共同前缀长度回文串字符串的相似度 六、练习题Tag-exkmp 七、一张图快速复习exkmp]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>ExKMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-2回文算法]]></title>
    <url>%2Fposts%2F2435.html</url>
    <content type="text"><![CDATA[Manacher与回文自动机pam其实pam比sam好学，可惜没有后者的应用广泛，建议胸怀大痣的同学先学这个 单个字符串、一棵trie的本质不同回文串都是线性的证明：末端加入一个字符，最多增加一个本质不同回文串，更小的在前面一定出现了可见回文这个特性非常有趣，所以研究相关问题的时候要时刻考虑这一点 Manacher复杂度证明自己思考一下即可再次可见本质不同回文串数量也是线性的 123456789101112131415161718192021char s2[MAXN*2];char s[MAXN*2];int ma[MAXN*2];int manacher()&#123; int ln=strlen(s2+1); for(int i=1;i&lt;=ln;i++) s[2*i-1]=SPC,s[2*i]=s2[i]; ln=ln*2+1;s[ln]=SPC; int md,rx=0,ans=0; for(int i=1;i&lt;=ln;i++) &#123; if(i&lt;=rx) ma[i]=min(ma[2*md-1],rx-i+1); else ma[i]=1; while(i-ma[i]&gt;=1 and i+ma[i]&lt;=ln and s[i-ma[i]]==s[i+ma[i]]) ma[i]++; if(rx&lt;i+ma[i]-1) rx=i+ma[i]-1,md=i; chmax(ans,ma[i]-1); &#125; return ans;&#125; 例题：[国家集训队]拉拉队排练、[国家集训队]最长双回文串 回文自动机和回文树是指同一个东西比较新的玩意，2015发表的 目标：参考sam，线性时空（这里等会具体说明）内构造出一个能接收所有回文子串的自动机考虑到本质不同的回文子串是线性的（manacher复杂度），所以不用像sam一样用right集合来压缩，直接本质相同的放在一个节点就好了然后也同样应当由两部分构成：dag、fail树dag的话因为回文串的特性，加字符应当同时在两边加，所以长度不变应该有奇偶两个dagfail树的话自然类似地，定义为最长回文后缀于是初始状态为【0奇ln-1；1偶ln0；fail[1]=0】另外，细心的读者可能发现了，这个图其实一定是两棵树而不仅仅是dag，因为我们不再需要压缩节点 考虑如何构造，类似sam使用增量法，然后你会发现好写很多见图：lst在sam上就是整个串节点，这是因为sam能识别所有子串，而在pam中lst表示最长回文后缀找到lst后缀链上合适的点，如果没孩子就新建，然后考虑fail是什么就好了还有就是以当前位置结尾的更短的回文串不需要新建节点，原因也见图 复杂度的话就势能分析，和sam一样的方案也是sam一样有两种，字符集小就是时间n空间nz，大就是时间nlog空间n 例题：[APIO2014]回文串12345678910111213141516171819202122struct PAM&#123; char str[N]; int id,lst;struct Nod&#123;int len,fail,cnt,son[26];&#125;p[N]; int node(int ln)&#123;p[++id].len=ln;return id;&#125; PAM()&#123;id=-1;node(-1);node(0);&#125; int gg(int pp,int pos)&#123;while(pp&gt;0 and str[pos-1-p[pp].len]!=str[pos]) pp=p[pp].fail;return pp;&#125; void insert(int pos,int c) &#123; int pp=gg(lst,pos); if(!p[pp].son[c]) p[ p[pp].son[c]=node(p[pp].len+2) ].fail=(pp?p[ gg(p[pp].fail,pos) ].son[c]:1); p[lst=p[pp].son[c]].cnt++;//有则节点合并 &#125; void solve() &#123; scanf("%s",str+1);int n=strlen(str+1); for(int i=1;i&lt;=n;i++) insert(i,str[i]-'a'); ll ans=0;for(int i=id;i&gt;=0;i--) p[p[i].fail].cnt+=p[i].cnt,ans=max(ans,(ll)p[i].cnt*p[i].len); write(ans); &#125;&#125;pam; 还没看懂的话就看这个以及2017wwt的论文一些小结论：一个串的子串的回文自动机是这个串的回文自动机的子图 进阶前置：不基于势能分析的构造法上述算法的瓶颈在于gg函数，也就是找到一个节点对应字符串中，一个最长的跟在c后面的回文后缀考虑优化这个过程，发现 只要不是本身 就可以保存下来（因为本身前面会变啊），设为link[c]转移的话，自己思考一下就会发现，只需要考虑比fail多出来的唯一一个回文后缀————fail本身就好了那么小字符集的话时空都是n乘字符集，大的话用个可持久化数组就好了，时空 O(nlog字符集)12345678910111213141516171819202122232425262728struct PAM&#123; char str[N]; int id,lst;struct Nod&#123;int son[26],link[26],fail,len,cnt;&#125;p[N]; int node(int len)&#123;p[++id].len=len;return id;&#125; PAM()&#123;id=-1;node(-1);node(0);&#125; int gg(int pp,int pos)&#123;return (str[pos-1-p[pp].len]==str[pos])?pp:p[pp].link[str[pos]-'a'];&#125; void insert(int pos,int c) &#123; int pp=gg(lst,pos); if(!p[pp].son[c]) &#123; int now=node(p[pp].len+2);p[pp].son[c]=now; int ff=p[now].fail=(pp?p[gg(p[pp].fail,pos)].son[c]:1); memcpy(p[now].link,p[ff].link,sizeof p[now].link); p[now].link[str[pos-p[ff].len]-'a']=ff; &#125; p[lst=p[pp].son[c]].cnt++; &#125; void solve() &#123; scanf("%s",str+1);int n=strlen(str+1); for(int i=1;i&lt;=n;i++) insert(i,str[i]-'a'); ll ans=0;for(int i=id;i&gt;=0;i--) p[p[i].fail].cnt+=p[i].cnt,ans=max(ans,(ll)p[i].cnt*p[i].len); write(ans); &#125;&#125;pam; 还有一种构造法，考虑border的理论对于每个长度至少3的等差数列，公差d是第三个项的最小周期，然后画一画发现前面的每个d都是相同的那么找fail的地方依次处理那log个等差数列；节点只需要记录所在等差数列的公差和首项fail这个方法与字符集大小无关，非常适合大字符集 进阶1：支持前、后端插入、删除的回文树先考虑前端插入，因为一个节点的最长回文前缀和最长回文后缀都指向一个节点，所以指针一个即可那么就是在lst外记录一个pre，但要注意前面（后面）插入时会影响到lst（pre），特判即可例题为 HDU5421 Victor and String 或者 loj141回文子串，code然后考虑一下后端删除，一开始我很天真地以为，当时怎么加怎么还原不就好了，复杂度肯定一样啊但其实，因为他是一个均摊复杂度的东西，所以如果能删除我是可以多次重复一个极高复杂度的操作的于是必须用不基于势能分析的构造法定义重要子串：对于左端点是最长回文前缀、对于右端点是最长回文后缀剩下的大概是考虑每个节点，被其他节点压制（使无法重要）的次数，以及有多少个fail指向这里，然后处理删除操作因为没看到什么题，所以先口胡着吧 进阶2：广义先考虑字符串集合，和sam一样每次lst设为0，复杂度也同样是长度和如果要在trie上建回文树，必须用不基于势能分析的，否则复杂度最坏会达到叶子节点深度之和，这个比较显然例题：Tree Palindromes pam例题超详细pam题单 GDKOI2013 D2T4 大山王国的城市规划这题需要用到一个小定理，回文子串A是B的子串，则要么A=B，要么A是B回文后缀的子串，要么是B删除左右两端后的子串这个证明其实蛮显然的……就是想的时候有点脑残……因为第三种情况，如果B现在不是A的前、后缀，直接删除B两端就好了知道这个定理后，dag搞出来，就是最长反链了 CERC2014 Virus synthesis bzoj4044和上题类似，仔细思考发现并不需要建dag，考虑转移树和fail树每轮搞完，一定是一个偶回文串左右两边其他字符，那么对回文串dp若当前为奇回文串，那么可以直接从转移树+2若当前为偶回文串，则转移树父亲也是偶，其最后一步一定是翻转，则+1（包含了不是前后缀的j）；剩下只需要考虑是前后缀的j，则只需要在fail树上倍增找到ln&lt;=now/2的f(x)表示恰好在节点x的step，g(x)表示fail树上x到根路径上min step-ln，ans&lt;-now+g(k) Palindromeness codechef PALPROBlog的做法比较sb，介绍一个线性的，维护half指针，然后从父亲那里暴力向下跳，可以势能分析 「2017 山东一轮集训 Day4」基因 bzoj4932 loj6070开根号个pam，表示分块后每个位置向右到末尾的pam，每个节点存右端点min，整个pam再开个有序数组存rmin然后每次询问先lower_bound，然后向左添加字符，判断是否新产生回文串（同样分析后可知最多一个）时间复杂度为 $O(n \sqrt n)$ 有趣的字符串题 湖南省队集训Day2 bzoj5384数据满足字符串只包含小写字母和上题不同在于允许离线考虑border的理论 （感觉border的题目一定要多画图）那么对于每个等差数列考虑，发现刚好抵消掉，只有两个地方需要修改：于是维护好等差数列头，枚举每个等差数列在树状数组上搞， $O(nlog^2n)$ Three Palindromes HDU5340这种题属于n^2艹正解的题，一开始居然还tle，目前是wa……本机拍不出，欢迎指点……就是用到双回文串的结论，可以看套路集锦，然后偷懒用manacher判断，时间复杂度为 $O(n \sum)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int N=4e4+10;char str[N];namespace PAM&#123; int id,lst[2];struct Nod&#123;int son[27],fail,len;&#125;p[N]; int node(int len)&#123;p[++id].len=len;return id;&#125; void clear()&#123;memset(p,0,sizeof p);id=-1;node(-1);node(0);lst[0]=lst[1]=0;&#125; int gg(int pp,int pos,int op)&#123;while(str[pos+(op==1?(-1-p[pp].len):(1+p[pp].len))]!=str[pos])pp=p[pp].fail;return pp;&#125; void insert(int pos,int c,int op) &#123; int pp=gg(lst[op],pos,op); if(!p[pp].son[c]) &#123; int now=node(p[pp].len+2);p[pp].son[c]=now; p[now].fail=(pp?p[gg(p[pp].fail,pos,op)].son[c]:1); if(p[now].len==pos) lst[op^1]=now; &#125; lst[op]=p[pp].son[c]; &#125;&#125;;int ma[N];char tmp[N];bool isp(int l,int r)&#123; if((r-l+1)%2==0 or (l==r and l&amp;1) or l&gt;r) return 0; return 2*ma[(l+r)/2]-1&gt;=r-l+1;&#125;bool check()&#123; scanf("%s",tmp+1);int n=strlen(tmp+1);if(n&lt;3) return 0; int m=2*n+1;for(int i=1;i&lt;=m;i++) str[i]=(i&amp;1)?('z'+1):tmp[i/2]; ma[1]=1; for(int md=1,i=2;i&lt;=m;i++) &#123; int rmx=md+ma[md]-1; if(i&lt;=rmx) ma[i]=min(ma[2*i-md],rmx-i+1); else ma[i]=0; while(i-ma[i]&gt;=1 and i+ma[i]&lt;=m and str[i-ma[i]]==str[i+ma[i]]) ma[i]++; if(i+ma[i]-1&gt;rmx) md=i; &#125; using namespace PAM;clear(); for(int i=1;i&lt;m;i++) &#123; insert(i,str[i]-'a',1); if(isp(i+1,m) and ( ( isp(p[lst[0]].len+1,i) and p[lst[0]].len&gt;1 ) or ( isp(1,i-p[lst[1]].len) and p[lst[1]].len&gt;1) ) ) return 1; &#125; return 0;&#125;void main()&#123; int T=qread(); while(T--) puts(check()?"Yes":"No");&#125; 还有两道有空看的题：CF932G、CF722F]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>字符串</tag>
        <tag>Manacher</tag>
        <tag>pam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】06字符串-1KMP]]></title>
    <url>%2Fposts%2Fc111.html</url>
    <content type="text"><![CDATA[本质上是尽量地利用子信息、残留信息 一、说在正文前的小声明网络上有关KMP的文章灰常多，本文旨在给初学者一个大致理解，尽量以最简单最直观的方式实现kmp，而不考虑太多有关性能的问题。 参考文献（或者说建议你看看的东西）：1(并不是他原创，但原文找不到了。。)，用了个图片和栗子2 栗子比较完整，大家有兴趣可以看看，对本文无用3 阮一峰，挺好的，用了图片和前后缀角度的看法4 v_july_v，太强了，堪称完美，建议理解本文后去这里提高，目前我持膜拜状态5 matrix67，绝对经典 二、定义Knuth-Morris-Pratt字符串查找算法，简称为”KMP算法”，常用于在一个文本串S(母串)内查找一个模式串P(子串)的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H.Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。KMP算法的主要作用在于，计算出字符串B是否为字符串A的子串及其系列问题。它比简单的暴力算法更优秀的地方在于，当部分匹配失败时，暴力算法一个个字符向前回溯，KMP则通过预先根据字符串B所计算出的”假如我的下一个字符失配，我的新对应位置”（通常用Next数组表示）。由于此预处理过程只是与字符串B有关，所以很适合处理”某个字符串B验证多个字符串A是否是其母串”一类问题。 三、利用Next数组求解KMPNext的性质（你要是想成定义也行）（在实现中，通常把Next用其他更简短的单词表示，本文用p）B[1..p[i]]=B[i-p[i]+1..i]并且要求p[i]最大，从而让移动距离最小，成功可能性更大并且没有漏网之鱼，类似贪心思想 假设现在字符串A[i-1]匹配成功，字符串B[j]匹配成功伪代码：1234567891011j=0;for i=1 to lenA&#123; while(j&gt;0 and a[i]!=b[j+1]) j=p[j]; //将匹配成功的j的p[j]重新尝试对齐i-1 //此举意味着失配时，字符串B相对于字符串A向右移动了j-Next[j]位 if(a[i]==b[j+1]) j++; //此时j成功匹配 如果(j==lenb) ans++; //这句话看情况，目前表示统计的答案数+1（如果想搜出来的不重叠就加上j=0）&#125; 三、Next数组 对称不是中心对称，而是中心字符块对称，比如不是abba，而是abab这种对称 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合 “后缀”指除了最前一个字符以外，一个字符串的全部尾部组合 那么Next数组究竟怎么求？这也是网络上有关KMP最大的争议。首先，Next数组有几种定义（这也是为何初学者很容易混淆）。不过殊途同归，next本质上是相同的~ 四、Next的角度1“最大长度值”是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例。 (个人认为这个也适合作为性质去记忆而非求法，虽然听老师讲了一遍后开始折服于此) 序号 1 2 3 4 5 6 7 字符 A B C D A B D 最大长度 0 0 0 0 1 2 0 “A”的前缀和后缀都为空集，共有元素的长度为0；“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；“ABC”的前缀为[A,AB]，后缀为[BC,C]，共有元素的长度0；“ABCD”的前缀为[A,AB,ABC]，后缀为[BCD,CD,D]，共有元素的长度为0；“ABCDA”的前缀为[A,AB,ABC,ABCD]，后缀为[BCDA,CDA,DA,A]，共有元素为”A”，长度为1；“ABCDAB”的前缀为[A,AB,ABC,ABCD,ABCDA]，后缀为[BCDAB,CDAB,DAB,AB,B]，共有元素为”AB”，长度为2；“ABCDABD”的前缀为[A,AB,ABC,ABCD,ABCDA,ABCDAB]，后缀为[BCDABD,CDABD,DABD,ABD,BD,D]，共有元素的长度为0。 所以，p[i]可以说是从1到i形成的字符串中的最大长度值。其实与前面说的“s(1,p[i])=s(i-p[i]+1,i)”是一样的 1234567for(int i=2;i&lt;=lenb;i++)//X2，后缀头不变尾延长&#123; while(j&gt;0 and b[j+1]!=b[i]) j=p[j];//让前缀和后缀同时增长 //j是前缀的尾同时也是最大长度值，必然比i小所以其p已经计算出了 //失败的时候找更小一点的对称，也就从蓝色转变为红色来延长 if(b[i]==b[j+1]) p[i]=++j; else p[i]=0;&#125; 同样的代码，不同的理解方式。 另一个更贴合本理解的代码123456for(int i=2;i&lt;=lenb;i++)//图片中的X2，后缀头不变尾延长&#123; int j=p[i-1];//图片中的x1-1，因此蓝色相等 while(j&gt;0 and sb[i]!=sb[j+1]) j=p[j]; if(sb[i]==sb[j+1]) p[i]=j+1; else p[i]=0;&#125; 这两份代码可以结合图片理解，i就是x2，j是x1-1 五、Next的角度2Next数组相当于“最大长度值”整体向右移动一位，然后初始值赋为-1 序号 1 2 3 4 5 6 7 字符 A B C D A B D 最大长度 0 0 0 0 1 2 0 Next -1 0 0 0 0 1 2 其实这个角度本质上和上一个一样，只不过这样就能”在j失配时直接对j跳转“而不是”在j+1失配时对j跳转“《最大长度值》字符串B向右移动的位数[已匹配字符位置-失配字符的上一位字符的最大长度值]《Next数组》字符串B向右移动的位数[失配字符的位置-失配字符对应的Next值]上述两个值相等 六、Next的角度3用一个长长的字符串来解释 序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 符 A G C T A G C A G C T A G C T G Ne 0 0 0 0 1 2 3 1 2 3 4 5 6 7 4 0 假设当前字符位置i，子串位置j(1)递推比较把i与j+1进行比较，如果相等，直接继承为上个Next再+1，因为对称程度增加了。如果不相等，跳到(2)，很好理解 (2)回头来找对称性 t如果要存在对称性，那么对称程度肯定比前面这个c的对称程度小。要找更小的对称，必然在对称内部还存在子对称，而且这个t必须紧接着在子对称之后。 可以通过循环j=Next[j]不断找更小对称性个人感觉类似自己匹配自己 七、代码123456789101112131415161718192021222324252627282930313233343536373839//*******************定义*******************int p[11100],lenb;char b[11000];//*******************实现*******************void calcb(void)&#123; lenb=strlen(b+1); int j=0;p[1]=0; for(int i=2;i&lt;=lenb;i++) &#123; while(j&gt;0 and b[j+1!=b[i]]) j=p[j]; if(b[i]==b[j+1]) p[i]=++j; else p[i]=0; &#125;&#125;int KMP(char a[])&#123; int lena=strlen(a+1); int j=0;int ans=0; for(int i=1;i&lt;=lena;i++) &#123; while(j&gt;0 and a[i]!=b[j+1]) j=p[j]; if(a[i]==b[j+1]) j++; if(j==lenb) ans++,j=0; &#125; return ans;&#125;//*******************主函数*******************char a[11000];int main(int argc, char *argv[])&#123; int n;scanf("%d",&amp;n); while(n--) &#123; scanf("%s",b+1); calcb(); scanf("%s",a+1); printf("%d\n",KMP(a)); &#125;&#125; 检验数据：Inputalkdfjhaljhdgelqigljafiehiqhrougsgssgsgijosgsjeswsgjjiigj Output02 八、练习陶陶的名字（可以重叠的最小覆盖） 九、kmp与最小覆盖参考文献：FarmerJohn 定义：对于一个字符串，一个长度最小的满足【复制自己多次（不重叠，与陶陶的名字不同）后可以覆盖原串】的子串 结论：长度=n-next[n] 证明：先证明它是覆盖子串①next[n]&lt;=n-next[n]显而易见覆盖 ②next[n]&gt;n-next[n] 然后它也是最小的这里用反证法，假设存在一个比n-next[n]更小的C（所以蓝色&gt;0），然后截取掉强行定义一个黄色段，是C的补集，然后因为C会最小覆盖，所以是C的前缀这样的话，黄色部分比next[n]更长，不满足next[n]是最长这个定义 Q.E.D.]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-3数位dp]]></title>
    <url>%2Fposts%2Fda07.html</url>
    <content type="text"><![CDATA[很好资料感觉这东西也没什么好说的了等碰到什么不套路，有特色的题目再加上来吧 练习题Tag-数位dp]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-2-1d1d动态规划]]></title>
    <url>%2Fposts%2F4bab.html</url>
    <content type="text"><![CDATA[1D/1D动态规划状态为n，转移为n的dp方程动态规划的优化-周尚彦.pdf 单调队列主要步骤： 移除无效元素 计算队首的最优g，得到f(i)的最优结果 计算新的g，放入队列中，并维护单调性 有一道比较变态的变形题：Cut the Sequence 斜率优化这个东西学了n次，前面n-1次都没学扎实（教练水平有限）随着实力的提升，这次细细研究周尚彦的论文，终于彻底搞明白了所以我也尽力讲清楚，但开始研究之前请确保有扎实的基础（如提高一等水平） 斜率优化主要可以从数学和图形的角度去理解，数学方面的话可以看我玩具装箱的题解，本文以图形为主（更有助于后期的提升） dp方程的基本形式(不能有二维数组)：$f(i)=f(j)+w(j,i),w(j,i)=a_i+b_j+c_i \times d_j$如果j在i之前已经计算出来了，显然可以化一下式子$f(i)=(d_j) \cdot (c_i) +a_i+b_j+f(j)$不难看出这是一个一次函数，i是带入的未知元，这个可以用李超树轻松解决看到别人说要化成一次函数的形式，这是我最先想到的做法，然而这样的复杂度下限是nlogn的然而有些题，使用斜率优化可以线性解决 换一种思路，考虑将j本身的东西所谓x和y，也就是变成点那么对于i，它的决策也可以是这种形式：$f(j)+b_j=(-c_i) \cdot (d_j) +f(i)-a_i$截距：直线与y轴的交点的纵坐标那么我们的目的就是最小化截距 据说这是一个线性规划问题，但我不清楚这是什么……但这和我们要讲的无关总之就是一个直线，其斜率和i有关，从下往上移直到碰到第一个点，就是最优决策点显然只有某个凸壳上的点是有用的（min则下凸壳） 然后下面的内容就要结合题目的具体性质了A. 点的x坐标是单调的 提供的直线的斜率是单调递增的这种情况的话，显然这个凸壳内部相邻点的斜率是单调递增的，否则不会有贡献而且决策点具有单调性，左边的部分无需保留，通常用单调队列实现 提供的直线的斜率是不单调的此时决策点不单调，不过因为维护好了凸壳，可以在上面二分（某个左右都更差的位置） B. 点的x坐标是不单调的平衡树动态插入来维护或者用cdq分治处理 练习详细地讲讲这个入门好题(仅从数学的角度)：玩具装箱好文章推荐：MashiroSky 四边形不等式如果转移满足该不等式，则称满足决策单调性形式1：对于 $a \leq b \leq c \leq d,w(a,d)+w(b,c) \geq w(a,c)+w(b,d)$（简单记为：交叉小于包含）形式2： $w(a,b+1)+w(a+1,b) \geq w(a,b)+w(a+1,b+1)$考场上可以考虑暴力打出决策点的表，验证单调性 一维：$f(i)=min f(j)+w(j,i)$一维状态例题：诗人小G这个套路还是很好用的 然后还有一种写法，某些情况下可能更好写就是分治，每次暴力处理mid的决策点 二维（虽然这个不属于1d1d，但是也顺便讲讲）：$f(l,r)=min f(l,k)+f(k+1,r)+w(l,r)$如果w满足四边形不等式，则f也满足四边形不等式如果f满足四边形不等式，则 $fm(l,r-1) \leq fm(l,r) \leq fm(l+1,r)$即f的决策，在同一行、同一列上单调递增 例题：合并石子显然其w满足四边形不等式（取等），则f也满足，那么决策的区间是确定了的然后你考虑每种ln$l=1，fm(1,ln-1) -&gt; fm(2,ln)$$l=2，fm(2,ln) -&gt; fm(3,ln+1)$……也就是枚举范围连起来只有一个n（感觉这种东西谁会想到啊……）l推荐文章：https://www.cnblogs.com/mlystdcall/p/6525962.htmlhttps://blog.csdn.net/noiau/article/details/72514812]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】05动态规划-1入门]]></title>
    <url>%2Fposts%2Fb119.html</url>
    <content type="text"><![CDATA[动态规划dp 多重背包二进制拆分法：每个物品有ci次使用机会可以把每个物品拆成log个主要是利用二进制的表示法记得把余数加上就好了还是很好理解的 环形dp对于没有产生环形依赖的情况，可以把自身复制一遍到后面但如果有环形依赖，但转移简单的时候，可以用高斯消元否则有一种精妙的办法，适用于那种收尾相接情况简单的时候，就是通过多次dp，第一次不相连，第二次强行相连（通过赋初始值） 数位dpzbtrs 题单理论上都写了题解 agc002F Leftmost Ball SRM613 TaroCheckers agc001E BBQ Hard SRM625 Seatfriends HDU5181 numbers]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-11第k优解相关]]></title>
    <url>%2Fposts%2Fc623.html</url>
    <content type="text"><![CDATA[第k优解相关主要是【寻找第k优解的几种方法————俞鼎力】的学习笔记 区间k大的众多拓展暂未研究 k小生成树暂未研究 k短简单路径暂未研究 k短路无负权边下对反图上终点建最短路径树然后每个点，存储一个非树边序列因为树上父亲是当前的序列的子集，继承过来，然后加入新的非树边（单个）那么为了减少状态的出度，从最基础的【在后面直接加边】改为【排序后，有序替换】，这个感觉论文的图不错那么每个点，开一个堆去维护，因为有继承的环节，用可持久化左偏树会非常方便，复杂度为严格logn（深度限制）$O(nlogn+mlogm+klogk)$似乎实现有很多边界和细节？暂未达成： $O(nlogn+m+klogk)$ （不过反正连supergaymj都不会……）以后补代码…… k优多个数列选数例题：POJ2442 Sequence，loj6254 最优卡组code核心思想：状态不能也没必要压缩，但我们并不需要存储状态，而是像dp一样存储转移所需要的信息既然我们存储转移信息，我们就不能hash，需要保证选数方案是一棵树，也就是只有一个前继转移做法：klogk先把没有意义的ci=1的数列去除，然后每个数列递减排序并差分，按照【最大-次大】给数列间递增排序三元组(i,j,sum)表示前i行已经处理，第i行至少选择第j个，然后后面的n-i行都选择最大值$(i,j,sum)-&gt;(i,j+1,sum-a[i][j]),(i+1,2,sum-a[i+1][2])$$(i,2,sum)-&gt;(i+1,2,sum+a[i][2]-a[i+1][2])，即这行依然选择最大$]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-10其他]]></title>
    <url>%2Fposts%2Fd107.html</url>
    <content type="text"><![CDATA[杂七杂八：Dilworth定理、仙人掌、树哈希判断同构 k元环计数与k长简单路径对于k=3，例题如jsoi2017原力，将点按照度数排序 1234567for(auto x:pt)&#123; for(auto y:bb[x]) vis[y]=1; for(auto y:bb[x]) for(auto z:bb[y]) if(vis[z]) g3[x]++,g3[y]++,g3[z]++; for(auto y:bb[x]) vis[y]=0;&#125; 分析复杂度，前面两个循环为$O(m)$，最后一个等于每个点出发向后的边数，对于度数小于m根号的点显然成立，对于度数大的点后面最多有根号m个点，故总复杂度为$O(m^{3/2})$ 对于k=4，例题如tkppc2016H デバッグ（Debug），写了题解；大致思路就是在三元环的基础上处理些信息 对于每个四元环，枚举x表示度数最大节点，枚举中间点y和端点z并记录在z处，回退的时候更新y在以后作为第四点（中介点）的次数，通过向左可以让每条边被访问次数为根号，总复杂度为$O(m^{3/2})$ 1234567for(auto x:pt)&#123; for(auto y:to[x]) if(pos[y]&lt;pos[x]) for(auto z:to[y]) if(pos[z]&lt;pos[x]) g4[x]+=cc[z],g4[y]+=cc[z],g4[z]+=cc[z],cc[z]++; for(auto y:to[x]) if(pos[y]&lt;pos[x]) for(auto z:to[y]) if(pos[z]&lt;pos[x]) cc[z]--,g4[y]+=cc[z];&#125; 关于k=4简单路径计数，见tkppc2016 H デバッグ（Debug） Dilworth定理严格偏序 集的图像是dag传递闭包结果为其本身链即任意两个元素都能比较的集合反链即任意两个元素无法比较的集合极小元：没有能和他比较得更小的元素的集合 【最大反链大小=最少链（不可重）覆盖数】证明：显然每条链上只能选择最多一个，加入反链则 最大反链大小&lt;=最少链覆盖数那么如果我们能构造一种方案，使得其取到【最少链覆盖数】，即完成了证明 拆点二分图，左出右入因为路径覆盖时，每个点只有一条出边，二分图匹配，然后左边没有出度的节点就是链的终点其个数即链的数量最小可重路径覆盖，可以通过传递闭包转化为不可重，但其实更高效的做法是，网络流的时候入点-&gt;出点inf例题loj6197法克 构造：方法一：直接跑二分图的最大独立集A，取满足入度和出度都在A中的点S可行性：如果不是反链，那么会存在一条边，与最大独立集矛盾 最小性：设m为匹配数根据定理，知 $|A|=2n-m$$|A|=|S|+t（只有其中一个在A中）$然后 $t \leq n$所以 $|S| \geq n-m$现在 $|S|=n-m$ ，所以是最小方案 那么这个东东，可以构造 最小点覆盖，然后取补集具体方法在二分图一章 方法二（不会证明）：先取出每个路径的终点，作为集合A，将A走一步能到达的节点作为next(A)按照题意，$A \cap next(A)=\varnothing$ ，所以我们要有所调整取出这种元素，然后在其所属的【最小可重复点覆盖路径】上，往起点方向跳，一定能找到一个元素不属于next(A)，否则意味着整条路径都是可以被别人覆盖掉的，违反了我们先前最小的定义找到后，取代原先的元素，如此重复下去，最后总是能满足条件的；综上所述，存在一种方案，满足条件 【最少反链覆盖数=最长链长度】最长链上每个元素不能在同一条反链中构造法，每次选择极小元集合，选择【最长链长度】次就完全选完了 仙人掌圆方树还没学…… 记一下定义吧： 有向图：强连通图，每条边恰属于一个环 无向图：连通，每条边最多属于一个简单环 树哈希判断同构主要是loj2072「JSOI2016」独特的树叶，code，可能应该写双hash的偷懒没写 考虑我们设计出的hash方式需要满足一些怎样的性质 因为是无根树，我们需要计算出A树以每个节点为根的hash值，塞到一个map里面，然后对于B树考虑每个叶子节点x，去掉后这棵树以fa(x)为根的hash值，然后放到map里面查询 可见：应该满足与遍历孩子顺序无关，而且方便我们换根来求出每个点为根的值 满足这个条件基本可以$O(nlogn)$了，首先hash表之类的可能可以线性，具体怎么搞自行设计吧 目前抄的是：$f(x)=(\sum f(son)*siz_{son} \%mod) xor (siz_x*base \%mod)$]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-9二分图]]></title>
    <url>%2Fposts%2F250b.html</url>
    <content type="text"><![CDATA[博大精深的二分图 二分图顶点可以分类两个集合X和Y，所有的边关联的两个顶点，恰好一个属于集合X，另一个属于集合Y 二分图增广路的另一种理解：建立一个有向图，非匹配边看做从左向右，匹配边看做从右向左那么左边的x到右边的y存在增广路，相当于存在一条路径，非常方便 杂七杂八在平面二分图上，如果存在使边不会重叠的方案，那么其中一定有一种是边长和最小的方案也就是把合法性、可行性问题转化为求边长和最小的问题证明的话，显然如果我能够选择不跨越，边长和会变小 König定理最大 匹配数:顶点两两配对的对数最大 独立集:顶点两两不到达的点数最小 点覆盖:选一个点就能覆盖所有与它连接的边，求点覆盖所有边的点数最小 边覆盖:选一条边就能覆盖所有与它连接的点，求边覆盖所有点的边数 最小点覆盖（有时称为最小覆盖）=最大匹配数 最小边覆盖=最大独立集 最大独立集=去掉最少的点，剩下点之间没有边=n-最小点覆盖=n-匹配数 举例：经典模型 Muddy Fields 最小点覆盖自信地说，截至2018.11，没有看到更完善的证明感觉近几年没人研究这东西了……都是远古资料 对二分图先进行最大匹配，建议画图理解设匹配数为m，点覆盖集合为S 构造方法：每次从右边的非匹配点出发，找出所有【未匹配边-&gt;匹配边-&gt;…未匹配边-&gt;匹配边】的路径，经过的点打上标记则最小点覆盖方案为【A左边有标记】+【B右边没标记】 证明：一、合法性①标记-&gt;标记，可以用A覆盖②标记-&gt;无标记，可以用A覆盖③无标记-&gt;无标记，可以用B覆盖④无标记-&gt;标记，不存在对于④，如果边是匹配边，则右边的标记来自左边，变成①；如果是非匹配边，标记来自其他匹配点，将继续打标记，变成①二、最小性首先显然 $|S| \geq m$起点贡献为 $right-m$然后每次打标记，显然左标记一定会贡献一个且仅一个右标记所以 $右标记=左标记+right-m$$右非标记=m-左标记$$|S|=m$ 实现：网络流是最容易实现的匹配边总是向左，非匹配边总是向右，只走【流量=0】的边即可可以直接在上面搜索如何保证总是以匹配边结束?问出这个问题证明你对二分图匹配不熟练，请自行学习答：如果以非匹配边结束，意味着增广路！ 二分图最大匹配的必经边和可行边先从特殊的完备匹配开始考虑可以先任意找到一组匹配方案 必经边：【当前是匹配边】并且【删除后不存在从x到y的路径】因为匹配边意味着从y到x，现在又存在从x到y的路径那么就以为着 x和y属于同一个强连通分量所以必经边的判定条件可以改为：【当前是匹配边】并且【不同强连通分量中】 可行边：【当前是匹配边】或者【把x到y看做可行边后，存在连接原本另外两个匹配点的路径】因为我们刚才的建边方式，也就是另外两个原本的点之间有路径，同时原本就有匹配边把他们和x、y连接所以说条件可以改成：【当前是匹配边】或者【同一个强连通分量中】 不过，如果没有完备匹配呢？对于两种边的第二个条件，不一定非要增广x到y，而可以是到z所以就会出问题（还傻傻地以为没有问题） 怎么解决呢？接下来的内容很好懂但是我认为是神仙想出来的东西……太nb了，我也只有帮忙吹水的份 分情况去解决问题对于必经边的判定，不能只是x到y了，而是不能有任何新增广路所以我们要判断，删除之后是否存在其他增广路不过，这个增广路一定是连接x和y中某一个的，否则与此次操作无关，影响了最大匹配的“最大” 如果我们考虑用网络流解决二分图最大匹配问题，剩下的残余网络能够很清晰地得出具体的有向图方案因为对于匹配边，流量过去了，那么有效边是其反向弧，非匹配边则不变，恰好与我们提出的有向图表示法相一致 加入源点和汇点，那么匹配点也能很清晰地表示出来了然后我们可以用这个图去考虑完善判断条件 图示：a和b是非匹配点，u和v是匹配边蓝色是匹配边，红色是非匹配边然后绿色是在强连通分量中的部分 先解决必经边的判定，也就是断开原本的边，分为x和y去找两种情况 对于可行边的判定，原本是非匹配边可能x和y中只有一个匹配点，分为x和y去找两种情况也可能两个都是匹配点 综上所述，可以把原本的方案，判断强连通部分不变，对象从简单有向图变为网络流的残余网络（忽略流量为0的边） 例题：舞动的夜晚 hall定理用于判定某个图是否存在完美匹配，证明设A集合的大小更小，则对于A的所有子集T，都满足连向B的点集大小&gt;=|T| 用过的题：agc037E 最大二分图匹配（下文为早期所写，不保证正确性）1234567891011121314151617181920212223242526272829303132333435363738394041424344例题[Caioj1122](http://caioj.cn/problem.php?id=1122)## 匈牙利算法：ask[i]==true，表示这一轮中母牛i有匹配成功的可能性（每到一只新公牛t就要重置）我们每次尽量让公牛x（不一定是t）配对，那么当询问到母牛i时### ask[i]==true情况一、match[i]==0，直接成功情况二、match[i]&gt;0，之前有一只公牛y=match[i]， 尝试让y找其他母牛去匹配，从而调整搭配 在这过程中，这个公牛y以及之后为了搞定公牛y所需要调整的其他公牛y2、y3 都不能占用母牛i（先宣告主权，ask[i]=false），从而避免死循环，这是一个潜在的贪心， 递归回来之后假如一切顺利，则x也成功假如情况任意一个成功，匹配match[i]=x但无论如何，ask[i]=false（别急着问为什么，看下去先）### ask[i]==false（看文字前再明确一遍，配对公牛t时曾经询问过i）情况一、之前匹配成功了，然鹅，仔细想想，我们的递归结构中，只要有一次成功， 就全部成功了，那么x的配对就不会找到母牛i了，所里本情况不存在。情况二、之前匹配也就是调整失败，那么在同样情况下（ask没变也就是公牛t没变） 这一次必然也会失败，所以这时应当退出，达到剪枝省时的目的总而言之，当ask[i]==false时，退出即可## 决策单调性（好像语言组织得不是特别好）：为什么当情况二调整公牛y后成功则母牛i属于x，而不是x自己去再往后尝试？好吧严格而言这并不是一个证明：目前先凑合着，假如以后发生状况需要调整x时再调整疑点：“现在调整”和“满足现状”面对的状况可能不一样？解答：这应该是可行最大二分图匹配方案不唯一的一种体现吧，反正目前而言我们的目的是求出最大匹配数，所以具体方案没有关系## 加速：可以考虑运用邻接表（这条边通往的地方）和时间戳（这样就不用每次初始化ask数组）邻接表：话说这可是我们学最短路后立刻就学了的东西，适用于稀疏图时间戳：ask用int存储，如果比“当前匹配公牛编号t”小就是过时的，相当于false## 改造：解决多重二分图匹配问题[Optimal Milking](41bc.html)感觉意义不大……## 练习：[【Poj1325】Machine Schedule](7392.html)]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-8-2-SAT]]></title>
    <url>%2Fposts%2Fef65.html</url>
    <content type="text"><![CDATA[差分约束题目直观版：Tag-2-SAT经典论文：由对称性解2-SAT问题 不错的入门教程：csdn-jarjingx（不得不说，超级良心！） 话说2-sat问题好像是有很多种解法的，但我比较喜欢tarjan 正经说细节 如果要固定，某一个变量必须取某个值可以用一条单向边连接，表示如果选择了非法值，会导致矛盾 如果题目要求输出方案在scc缩点以后，不难发现，因为是个dag任意时刻一定会有出度为0的点 明确：缩点以后，边的关系就是，如果选择则必须传递选择如果我每次选择一个之前没选择而且出度为0的节点，那么一定是无害的（不选择它就不一定了）此时把对立的节点（由原本的逻辑关系产生，一定只有唯一一个，否则应合并，因为只有二元）定为不选择那么因为搞的是出度=0，可以在反图上跑拓扑 不过还有一个性质，能省去代码复杂度，不需要建立反图因为tarjan求scc的时候，编号是自下而上的（不了解的请博客中搜索“简单连通性问题”）不难发现，对于两个上下的scc之间，下面那个编号小，恰好拓扑序也是在上面之前所以可以根据两个对立scc的编号，直接确定选择与否（编号小，就选择）相当优美简洁 练习Caioj1405聚会Poj3207Panda’s TrickBzoj1997PlanarPoj3683Priest John’s Busiest Day]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-7生成树]]></title>
    <url>%2Fposts%2Fb399.html</url>
    <content type="text"><![CDATA[生成树（MST）相关 最小（大）生成树性质1：对于点集中的一个真子集a，其补集b，连接a和b的边中，边权最小的为t，则必定在最小生成树中出现证明：设有某种最小生成树并不包含t，因为连通，总有一条边连接集合a和b，替换为t后显然会不差 性质2：设f(生成树)=最大边权，则最小生成树一定有最小的f证明：设某个非最小生成树有更小的f，则总有一条边，和最小生成树的f那条边的连通性贡献相同（连接a和b点集） 这个称之为最小瓶颈生成树，不过最小瓶颈生成树可能不是最小生成树 性质3：相同权值的边，对mst的贡献总是相同的，也就是mst的边权序列总是相同的（显然边权序列相同意味着边权和相同）证明：设两个mst，边权序列（升序）最前的不同位置，设a中的e更小将e插入到b，形成了一个环，其中一定存在一条边 【权值&gt;e】（否则，因为e是第一个不同，更小意味着两棵树都有，则在a中形成环）显然是可以替换掉的，违背【都是mst】推论：【没有相同边权】的无向图，最小生成树唯一 推论2：对于权值val用了k次，只用小于val的生成最小森林后，任意一种val的边中选k条且没成环的方案，形成连通信息相同 性质4：连通图上，a到b【最长边最小】的路径，总是在kruskal生成的mst上证明：感受一下，显然很对首先，每个mst的贡献一定是一样的，这个很好推然后这个知道以后，反证一个非mst，会使当前mst变小，用类似前面的方法即可 Kruskal并查集维护连通性，每次取最小的，连接两个森林的一条边时间复杂度$O(m log m)$ Prim维护一个树，开始只有一个节点1加入n-1次，每次选择【加入这棵树的代价】最小的那个点时间复杂度如果直接暴力是 $O(n^2)$ 的，如果加入二叉堆可以变成 $O(m log_2 n)$如果logm和logn相差不大的话，写kruskal会比较好所以说prim只适用于稠密图 Boruvka并查集维护连通块，然后不断进行下面操作：枚举每条边，得到距离每个连通块最近的连通块，然后合并起来这样连通块大小在i次后至少为 $2^i$ ，故只执行log次 这东西在解决【完全图，边权为位运算的极值mst】问题时非常方便，详见这里 最小瓶颈生成树的线性求法见oi之路的【一类线性二分】 极值生成基环树森林bzoj4883 [Lydsy1705月赛]棋盘上的守卫 、jsc2019-qual E Card Collector:code 实话说这两道都是水题，你必须熟练地想到行、列建点格子建边，然后每条边选择一段挂上去而每个节点只能挂一条边，是个经典的基环树模型。 那么现在要生成基环树森林，考虑Kruskal，尝试排序后加入，如果连接一树一基环也能合并，如果是同树内就转成基环树，注意两棵基环树不能合并；考虑正确性，回忆kruskal的证明，你发现出现不同的地方就是一棵树选择转成基环树还是和另一棵基环树合并，考虑到总是在最差的那条边连接，按照优先级处理是没有问题的，然后这个改造和原本生成树也没有冲突，$O(mlogm)$ 期望最小生成树准确的说是，每条边有概率出现，对每个连通块的最小生成树求和，问和的期望；51nod1943 连通期望 感觉std的做法稍复杂？分享一下我的做法，考虑到是最小生成树，从小到大处理每条边，考虑每条边的贡献，那么就是考虑两个集合$A和B（x \in A,y \in B）$，因为这条边的出现才连通的概率，然后乘上这条边的长度 设$f(S)$表示这个点集考虑了前面的边后依然是保持目前连通块的概率，那么每次处理完一条边需要把那些仅一个端点在里面的集合乘上这条边不出现的概率，否则连通性会不同。但注意到我们合并A和B集合的时候，两个集合中间的边的概率影响会被乘两次，需要搞回来，可以记录一个in表示集合内的已出现边的失败概率乘积，则$T \to S \setminus T=\frac{in(S)}{in(T)in(S \setminus T)}$，维护这个是$O(m2^n)$ 那么对于每次转移，$f2(S)为新的f(S)，f2(A \cup B)=p*\sum_A f(A)*f(B)*\frac{in(A \cup B)}{in(A)in(B)}$ 你会发现这个式子可以用子集卷积优化，然而并没有什么卵用qaq $O(3^{n-2}m)$，应该大家做法是一样的，没卡常不知为啥登顶了 1234567891011121314151617181920212223242526272829struct Edge&#123;int x,y,c;double p;&#125;e[N];bool cmp(Edge a,Edge b)&#123;return a.c&lt;b.c;&#125;double f[1&lt;&lt;14],in[1&lt;&lt;14];void main()&#123; int n=qread(),m=qread(); fo(i,1,m) &#123;e[i].x=qread()-1,e[i].y=qread()-1,e[i].c=qread();scanf("%lf",&amp;e[i].p);e[i].p=1-e[i].p;&#125;sort(e+1,e+m+1,cmp); fo(i,0,n-1) f[bin(i)]=1; fo(i,0,bin(n)-1) in[i]=1; double ans=0; fo(k,1,m) &#123; int x=e[k].x,y=e[k].y; fd(S,bin(n)-1,1) &#123; f[S]*=((S&amp;bin(x))&gt;0)+((S&amp;bin(y))&gt;0)-1==0?1-e[k].p:1 ; if(S&amp;bin(x) and S&amp;bin(y)) &#123; int mask=S^bin(x)^bin(y); double sum=f[bin(x)]*in[bin(x)]*f[S^bin(x)]*in[S^bin(x)]; for(int T=mask;T&gt;0;T=(T-1)&amp;mask)//if(T&amp;bin(x) and (S^T)&amp;bin(y)) sum+=f[T|bin(x)]*in[T|bin(x)]*f[S^T^bin(x)]*in[S^T^bin(x)]; sum*=e[k].p/in[S];ans+=sum*e[k].c;f[S]+=sum; &#125; &#125; fo(S,0,bin(n)-1) if(S&amp;bin(x) and S&amp;bin(y)) in[S]*=1-e[k].p; &#125; printf("%.6lf",ans);&#125; 最小生成树计数例题：[JSOI2008]最小生成树计数 原题：相同权值数量在10内；边权序列相同的合法序列一定是mst，根据性质3的推论2，先求出一种mst，模拟kruskal的过程，加入小于val的树边后，选出与mst所用边数相同的合法的k条，这个方案就是对于权值val的答案，把这个乘起来就是结果，$O(m*2^{10})$ 加强版（没有上面的特殊限制，$n \le 100,m \le C_n^2$）：根据性质，这k条边连通哪些块其实已知，把所有不为val的树边加入，跑一个生成树计数即可，直接做是$O(m*n^3)$的，考虑到$\sum k=n-1,缩点后点数其实为\sum (k+1)^3=O(n^3)$ 另一些奇怪的最小生成树有位老哥做了深入研究：CF125E-MST-Company]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-6差分约束]]></title>
    <url>%2Fposts%2F62.html</url>
    <content type="text"><![CDATA[差分约束，就是要满足一定条件(形如ax-ay&lt;=c)求最值的问题。可以应用于求解不等式 其实就是把数形结合起来入门教程自行搜索 入门练习Vijos1094关系运算图Bzoj2330糖果 bzoj2788 [Poi2012]Festival对于$x_a+1=x_b,a \to b=1,b \to a=-1$；对于$x_a\le x_b,a \to b,0$ 考虑怎么求取值最大化，如果你对其缩点，两个连通块之间的边权是w的话等价于连接的那两个变量的差至少是w，你发现这个对于我们求最多取值没有意义，在dag上我们可以给左边那个即所有连向它的向上无限平移来满足要求，所以连通块间取值其实可以无交。 对于连通块内，首先不能有正环否则无解；注意到边权只有0、-1、1，最短路径权值和表示两个变量的最小差，那么可知这个连通块的贡献为$1+max_{x,y} dis(x\to y)$，可以floyd解决，$O(n^3)$ 这里因为我上面用最长路思考懒得改了求答案直接取反写的，code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-5重构树]]></title>
    <url>%2Fposts%2F4703.html</url>
    <content type="text"><![CDATA[kruskal重构树 比较简洁的教程ysner 经典例题[ONTAK2010]Peaks加强版大概就是利用重构树堆的性质找点，然后利用结构性质查询信息]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-4简单连通性问题]]></title>
    <url>%2Fposts%2F293.html</url>
    <content type="text"><![CDATA[简单连通性问题，应该算比较全面了，然而并不是教程tarjan算法无向图与有向图致敬：维基百科Robert_Tarjan 无向图连通图割点：删去该点和相关的边后，分裂为两个或以上子图桥或割边：删去该边后，分裂为两个或以上子图 tarjan算法dfn表示时间戳，low表示所有【子树内节点，能通过一条非搜索树边到达子树内的节点】的最小dfn 割点和割边的判定无向边$x\to y$是割边，当且仅当搜索树上存在x和y，满足 $dfn_x &lt; low_y$含义就是，y无法通过其他方式到达比x及更早的点，显然割边一定是搜索树上面的为了也能兼容有重边的情况，可以考虑通过记录来到这里那条边的编号来判断是否是搜索树边 对于割点，仅当搜索树上存在x的子节点y，满足 $dfn_x \leq low_y$；然而要特判**根节点必须要满足此条件至少两次* 例题：Goodbye Jiawu B新年的毒瘤（code） 双连通分量点双连通分量（v-DDC）：极大无割点连通子图显然其中任意两个点，都同时在至少一个简单环中，割点可能同时存在多个点双中另外，孤立点、两点一边，也是v-DDC 例题：bjoi2013 压力 1234567891011121314151617181920212223242526int dfnid,dfn[N],low[N],rt[N];stack&lt;int&gt; sta;bool insta[N];int cnt;vc&lt;int&gt; vdcc[N];void tarjan(int x,int root)&#123; rt[x]=root; insta[x]=1;sta.push(x);dfn[x]=low[x]=++dfnid; fo(t,0,sz(to[x])-1) &#123; int y=to[x][t]; if(!dfn[y]) &#123; tarjan(y,root),chmin(low[x],low[y]); if(low[y]&gt;=dfn[x]) &#123; cnt++;vdcc[cnt].PB(x); while(sz(sta)) &#123; int tmp=sta.top();sta.pop();insta[tmp]=0; vdcc[cnt].PB(tmp);if(tmp==y) break; &#125; &#125; &#125; else chmin(low[x],dfn[y]); &#125;&#125; 边双连通分量（e-DDC）：无向图中，极大无割边连通子图显然任意一条边，都同时在至少一个简单环中求法和缩点：去掉所有割边，剩下的就是边双连通图把每个边双连通图缩成一个点，用割边连起来，就形成一棵树（或森林） 123456789101112131415161718192021int ct,cnt;void tarjan(int x,int from)&#123; p[x].dfn=p[x].low=++ct; for(int k=p[x].hou;k&gt;0;k=e[k].g) &#123; int y=e[k].y; if(p[y].dfn==0) &#123; tarjan(y,k); p[x].low=mymin(p[x].low,p[y].low); if(p[y].low&gt;p[x].dfn)//割边 &#123; cnt++;//割边数 p[y].fa=x; dfs(y,x,y); &#125; &#125; else if(k!=oth(from)) p[x].low=mymin(p[x].low,p[y].dfn); &#125;&#125; 欧拉通路从s到t，经过每条边恰好一次判定：连通图无向图：【度数=奇】=0时，其实是欧拉回路；【度数=奇】=2时，一个起点一个终点有向图：【入度!=出度】=0时，其实是欧拉回路；【入度!=出度】=2时，【入度=出度-1】是起点，【入度=出度+1】是终点证明 欧拉回路欧拉回路：从s出发，回到s的欧拉通路 性质：如果原本是欧拉回路，拿走一个小欧拉回路（包括一个点），依然是欧拉回路 判定：首先要连通无向图：每个点度数=偶有向图：每个点入度=出度 无向图输出方案：从任意点出发，前往没有去过的边最后停止的时候一定会回到原本的点但可能漏了一些环，所以要在回溯的时候向其他分支走，然后作为一个插入但是直接插入会非常不方便，所以回溯的时候才把x（或者边）入栈，得出倒过来的路径 这样的时间复杂度较高，因为会多次尝试询问每一条边一种优化是，每次邻接表把用过的剔除掉，因为不可逆，时间降到n+m但此时空间搜索深度复杂度为m，即使linux也会爆（详见理论知识-概要），建议手写栈 模板题：uoj117，code 混合图欧拉路判定：【Poi2010】Bridges 无向图的独立集和团独立集：任意两点间没有边相连团：任意两点都有一条边相连 定理1：最大团大小=补图（对于边集的补集）的最大独立集大小定理2：见套路集锦中二分图项目 一道有趣的题目：给出一个无向图，求子图满足【选的点是团，没选的点是独立集】；问最大权值的子图或问合法子图方案数 有趣的题目2: bzoj2530 [Poi2011]Party 有向图流图只要有任意起点满足能到达每个节点该点被称为源点 有四种类型的边： 搜索树边 前向边，搜索树中x是y的祖先 后向边，搜索树中y是x的祖先 横向边，搜索树中，谁也不是谁的祖先，因为不是树边，一定满足$dfn_y &lt; dfn_x$ 弱连通将有向边看做无向边后连通 强连通强连通图：其中任意两点都能互相到达的图强连通分量(SCC)：有向图极大强连通子图 tarjan算法找scc：首先，前向边没有贡献，后向边有贡献，而横向边看其能否贡献出一条路径，从y能回到x的祖先为了利用后向边和横向边，需要维护一个栈，保存【x的祖先】和【子树内能前往x的祖先的的点】追溯值low：【在栈中，而且能够从x的子树内出发被到达的节点】的最小dfn 那么具体实现的时候 加入栈中 遍历所有边，如果没访问过就是子树内节点，递归；否则判断是不是栈中的节点，有两种可能【祖先】或者【在子树内并且能前往祖先的】这两个的dfn恰好是我们想要的（为什么这么恰好待会解释） 判断是否 $low_x = dfn_x$ ，若是，意味着没有节点能访问祖先，则弹出栈中节点直到x被弹出 之所以在栈中没有【在子树内而不能前往祖先的】，是因为这些节点已经出栈，作为其他scc的一部分了 对于能到祖先的点，显然不会满足等于自己这个条件，应该交给那个祖先去处理，所以在栈中保留 那么，对所有scc缩点后，就会得到一个dag（有向无环图） 123456789101112131415161718192021222324vc&lt;pr&gt; to[N];stack&lt;int&gt; sta;bool insta[N];int dfnid=0,dfn[N],low[N],blg[N],bbid=0;void tarjan(int x)&#123; insta[x]=1;sta.push(x); dfn[x]=low[x]=++dfnid; fo(t,0,sz(to[x])-1) &#123; int y=to[x][t].FR; if(!dfn[y]) tarjan(y),chmin(low[x],low[y]); else if(insta[y]) chmin(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; bbid++; while(1) &#123; int now=sta.top();sta.pop();insta[now]=0; blg[now]=bbid; if(now==x) break; &#125; &#125;&#125; 必经点、必经边从s到t，所有路径上都存在的点必经边也类似 在普通有向图上求据说要使用支配树不过在一个有向无环图上，可以用拓扑统计到这里的路径数量，再跑一次反图那么枚举每个点，或者边，根据乘法原理检验即可但是数字可能太大，可以考虑搞点模数来校验 至于无向图就比较简单了，可以用相应的dcc去缩点 有向无环图的最小路径点覆盖简称最小路径覆盖，就是用最少数量的简单路径，覆盖每个点恰好一次解决方法：分析题意，因为点只能覆盖一次，对于路径上面的点，入度和出度不能超过1，而且至少一个是1把每个点，拆分成入度点和出度点，那么就形成了一个二分图，按照原图的边来构图即可 【最少路径数量】=【最少的终点】=【最少的出度=0】=【最少的出度点失配】所以数量就是n-最大匹配当然，用起点也可以，入度为0也就是右边的无匹配，不影响式子 那么如果允许多次覆盖相同的点呢？这就是最小路径可重复点覆盖问题整个问题可以说变复杂了，也变简单了对于连通的两个点x和y，其实是可以直接添加一条边的，对答案没有影响这个可以用传递闭包实现 竞赛图每个点对之间，都有一条有向边相连，只是方向任意 定理：一定存在哈密顿路径证明与构造：考虑原本存在的一条路径，然后外面存在一个点P最优情况（直接放到头或者尾）下显然，而如果是这种比较坏的情况： 定理：如果图强连通，则存在哈密顿回路证明与构造：先将哈密顿路径拉出来同样，设此时1-&gt;x已经形成回路，考虑x+1e 如果 $x+1-&gt;1$ ，直接加入 如果 x+1能到环内部，则也可以加入 否则暂时跳过 练习自行搜索tagiot]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-3最近公共祖先lca]]></title>
    <url>%2Fposts%2Fdc4.html</url>
    <content type="text"><![CDATA[最近公共祖先lca的四种求法 倍增lca时间复杂度 预处理nlogn+询问logn其实也没什么好说的，结合代码注释吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Zory-2017//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000,MAXM=200000;//*******************全局定义*******************struct pt&#123; int dep,hou;&#125;p[MAXN+10];struct rod&#123; int y,g;&#125;e[MAXM+10];int bin[31];//*******************实现*******************int ln=0;void ins(int x,int y)&#123; ln++; e[ln].y=y; e[ln].g=p[x].hou; p[x].hou=ln;&#125;int f[MAXN+10][31];void dfs(int x,int fa)&#123; f[x][0]=fa;p[x].dep=p[fa].dep+1;//dep=bin[i]时只有f[x][i] for(int i=1;bin[i]&lt;=p[x].dep;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int k=p[x].hou;k&gt;0;k=e[k].g) if(e[k].y!=fa) dfs(e[k].y,x);&#125;int LCA(int x,int y)&#123; if(p[x].dep&lt;p[y].dep) swap(x,y); for(int i=30;i&gt;=0;i--) if(p[x].dep-p[y].dep&gt;=bin[i]) x=f[x][i];//从高向低消除差距 if(x==y) return x;//y是x祖先 for(int i=30;i&gt;=0;i--) if(p[x].dep&gt;=bin[i] and f[x][i]!=f[y][i])//防止跳过头 x=f[x][i],y=f[y][i];//一起向上跳 return f[x][0];&#125;//*******************主函数*******************int main()&#123; bin[0]=1;for(int i=1;i&lt;=30;i++) bin[i]=bin[i-1]&lt;&lt;1; int n,m;scanf("%d%d",&amp;n,&amp;m);ln=0; for(int i=1;i&lt;=n-1;i++) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); ins(x,y);ins(y,x); &#125; dfs(1,0); while(m--) &#123; int x,y;scanf("%d%d",&amp;x,&amp;y); printf("%d\n",LCA(x,y)); &#125;&#125; 树剖lca时间复杂度 预处理n+询问logn就是树剖跳tp的fa实现 ps：其实树剖是在线算法中最快的因为log是最坏情况下的复杂度 tarjan+并查集lca时间复杂度 预处理$O(n*\alpha(n) )$+询问1这属于离线算法 对于每个点，三种标记，0表示没访问过，1表示访问过但没有回溯（x和x的祖先）2表示访问且回溯过那么对于x的每个询问（可以建立链表去枚举），如果y是1，则lca=y如果y是2，则y向上的第一个【标记1】的节点就是lca 然后每次回溯的时候，把自己的块合并到父亲的块中这就相当于把第一个【标记1】的节点指向父亲那么每个询问的答案即findfa(y) st表lca要先求欧拉序用st表存储编号，nlogn预处理后即可O(1) 练习Caioj1236模版Caioj1237树上任意两点的距离]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-2并查集]]></title>
    <url>%2Fposts%2Fa89d.html</url>
    <content type="text"><![CDATA[并查集 其实应该放到数据结构里面的 路径压缩，均摊log另外有种优化方法叫“按秩合并”，也是启发式合并的一种应用就是每次把小的合并到大的里面，在这里可以用大小来表示那么均摊也是log 然后如果两者合并，根据tarjan的论文证明，总是小于5的 末尾回撤并查集1234567891011121314namespace DSU&#123; struct Data&#123;int fa,siz;&#125;a[N]; void clear()&#123;fo(i,0,N-1)a[i].fa=i,a[i].siz=1;&#125; int findfa(int x)&#123;return a[x].fa==x?x:findfa(a[x].fa);&#125; stack&lt; pair&lt;int,Data&gt; &gt; sta; void merg(Edge now) &#123; int x=findfa(now.x),y=findfa(now.y);if(a[x].siz&lt;a[y].siz) swap(x,y); sta.push(MP(x,a[x]));sta.push(MP(y,a[y])); if(x!=y) a[x].siz+=a[y].siz,a[y].fa=x; &#125; void back() &#123;while(sz(sta)) a[sta.top().FR]=sta.top().SE,sta.pop();&#125;&#125;; 可持久化并查集bzoj367412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long ll;ll qread()&#123; ll ans=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') c=getchar(); while('0'&lt;=c and c&lt;='9') ans=ans*10+c-'0',c=getchar(); return ans;&#125;const int MAX_N=2e5+10;int n;#define pr pair&lt;int,int&gt;#define FR first#define SE second#define MP make_pairstruct Nod&#123;int lc,rc;pr data;&#125;p[MAX_N*20*2*2];#define mid (l+r)/2int id=0;void add(int &amp;x,int l,int r,int pos,pr ss)&#123; if(x==0) x=++id; if(l==r) &#123;p[x].data=ss;return;&#125; if(pos&lt;=mid) add(p[x].lc,l,mid,pos,ss); else add(p[x].rc,mid+1,r,pos,ss);&#125;void merg(int x,int &amp;y)&#123; if(x==0) return; if(y==0) &#123;y=x;return;&#125; merg(p[x].lc,p[y].lc); merg(p[x].rc,p[y].rc);&#125;pr ask(int x,int l,int r,int pos)&#123; if(l==r) return p[x].data; if(pos&lt;=mid) return ask(p[x].lc,l,mid,pos); else ask(p[x].rc,mid+1,r,pos);&#125;int rt[MAX_N];int findfa(int now,int x)&#123; int fa=ask(rt[now],1,n,x).FR; return fa==x?x:findfa(now,fa);&#125;int main()&#123; int q;scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) add(rt[0],1,n,i,MP(i,1)); int lst=0; for(int now=1;now&lt;=q;now++) &#123; int op=qread(); if(op==1) &#123; int fx=findfa(now-1,qread()^lst),fy=findfa(now-1,qread()^lst); if(fx!=fy) &#123; int sx=ask(rt[now-1],1,n,fx).SE,sy=ask(rt[now-1],1,n,fy).SE; if(sx&lt;sy) swap(fx,fy); add(rt[now],1,n,fy,MP(fx,0)); add(rt[now],1,n,fx,MP(fx,sx+sy)); &#125; merg(rt[now-1],rt[now]); &#125; else if(op==2) merg(rt[qread()^lst],rt[now]); else &#123; merg(rt[now-1],rt[now]); int fx=findfa(now,qread()^lst),fy=findfa(now,qread()^lst); printf("%d\n",lst=(fx==fy)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】04图论-1最短路]]></title>
    <url>%2Fposts%2F8720.html</url>
    <content type="text"><![CDATA[最短路 Bellman-ford1234567//最长路fo(tim,1,n) fo(i,1,m)&#123; int x=edge[i].FR,y=edge[i].SE; if(tim&lt;n) chmax(f[y],f[x]+edge[i].val); else if(f[x]+edge[i].val)&gt;f[y]) &#123;puts("-1");return;&#125;//正环&#125; SPFA以下内容更新于2018.8.29spfa的时间复杂度为 $O(km)$在稀疏图上，k很小，但在稠密图上，有可能被卡成 $O(nm)$ 介绍两个优化策略，通常来说能稍微提高效率（似乎来自JBY09年集训队论文）SLF（Small Label First）优化（本机房俗称酸辣粉优化）：基于双端队列（deque）的思想，更新完disy后，如果它比队头小，就放在前面，否则放在后面然后如果没有负权边，可以用个堆取最小值，即堆优化spfa，但这个是没有任何意义的，spfa的唯一一点点优势就是负权边，现在这样搞，那不如写dijkstra堆优化（其实单纯写法上只是标记是否清空而已）LLL（Large Label Last）优化（本机房俗称啦啦啦优化）：维护队列的平均值，如果队首比平均值小，就丢到后面去总的来说，这两个优化策略的基本思路就是不用堆，保持能处理负权边的特性，但是又能尽量取出小的节点去拓展 最后，对于判断负权回路：bfs，一个点进入队列n次，或者记录每个节点当前最短路径的边数，超过n则跳出，通常会更快一些dfs，进入一个已经在栈中的节点，但听说可以被卡到 $2^n$ Dijkstra在无负权的图中，找最短路可防止被卡边（spfa容易被卡）时间复杂度相对没那么玄学，比较稳定（如果慢，那就真的慢） dijkstra算法基于贪心思想，每次找最小的dist来更新这是因为，当边长都是非负数的时候，全局最小的那个dist显然不会再被更新，所以已经是最短路径堆优化就是在找最小的dist的时候，用堆维护，时间复杂度从 $O(n^2)$ 变成 $O(mlogn)$ floyd这个算法用于求所有点对的最短距离，时间复杂度为O(n^3)。【无法判断、计算含有负环的图（可负边）】依次扫描每一点(k)，并以该点作为中介点，计算出通过k点的其他任意两点(i,j)的最短距离，这就是floyd算法的精髓！同时也解释了为什么k点这个中介点要放在最外层循环。其实就是运用动态规划的思想。 代码12345678910void floyd()&#123; memset(dis,127,sizeof(dis)); for(int i=1;i&lt;=n;i++) dis[i][i]=0; for(int k=1;k&lt;=n;k++)//中介点 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);&#125; up 2018.8.29floyd的正确性证明：设$dis[k][i][j]$表示只经过编号小于k的中介点（注意不包括i和j），从i到j的最小距离那么对于任意一条最短路径，可以想象为分割的，然后以k为阶段，长度递增，逐渐合并具体实现的时候，只要把k放在外面，就可以通过滚动数组，省去第一维 找无向图最小环：加入一句1ans=min(len[i][j]+dis[i][k]+dis[k][j]); 即可韵味自行理解其实就是假设这个环，编号最大那个为k不过要注意一点，就是要针对实际需求，看要不要打上i!=j等三个条件例题：POJ1734 Sightseeing trip 然后无向图的话，因为两个点也能组成（甚至一个点）所以不需要对环的大小作限制，可以直接扫一次dis[i][i]例题：vijos14231234567891011121314151617181920int w[MAX_N];int dis[MAX_N][MAX_N];void main()&#123; int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); memset(dis,63,sizeof dis); while(m--) &#123; int x,y,c;scanf("%d%d%d",&amp;x,&amp;y,&amp;c);c+=w[x]; if(c&lt;dis[x][y]) dis[x][y]=c; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(dis[i][j]&gt;dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j]; printf("%d ",dis[1][1]==INF?-1:dis[1][1]);&#125; 当然如果跑dijkstra+heap把起点更新后，d[st]=正无穷，下一次取出也是最小环长度 倍增floyd其实就是矩乘，预处理长度$\le2^k$的最短路径，这样就能快速获得与长度有关的最短路信息了，例题：bzoj4773负环 Johnson全源最短路感觉挺偏的，拓展一下视野吧应用于有负权边的情况，且点相对稀疏（相比floyd）思路是把图转化为等效的图，那么我们希望最短路集不变从超级源点向各点连0边，先跑一次spfa，得到f表示最短路（显然为非正数）然后转化图，对于边x-&gt;y=z，显然： $z-(f[y]-f[x]) \leq 0$在新的图上跑n次dij，$O(n^2logn)$每条路径长度为 $dis(st,ed)+f(st)-f(ed)$ 题边权递增最短路按边权顺序加入图中即可，发现所有合法路径都被统计，所有非法路径都没有被统计 CF449B Jzzhu and Cities题意：n个点m条边的正权图，其中一些是从1出发的特殊边，问最多删除多少条特殊边后1到每个点的最短路径长度不变，$n,m,k \le 3e5$ 做法：建出最短路径树，同长度优先用非特殊边，最后统计有多少条特殊边在树上即可 GXOI2019 旅行者题解]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-16快乐计数]]></title>
    <url>%2Fposts%2F9763.html</url>
    <content type="text"><![CDATA[快乐计数 努力更上时代潮流ing 前置：多项式全家桶、生成函数（包括拉格朗日反演） 以下计数的所有图都没有重边、自环 带标号无向图以下所有生成函数都是EGF Prufer序列背结论：带标号无根树和Prufer序列是双射，详情：matrix67 树转序列：每次找到编号最小的叶子节点，输出x的相邻节点，删除x，做n-2次 Cayley公式：n个节点完全图的生成树个数=$n^{n-2}$； 推论：设编号为i的节点度数为$d_i$，显然每个数会出现$d_i-1$次，直接多重集排列数，树的个数=$\frac{(n-2)!}{\prod (d_i-1)!}$ 基尔霍夫矩阵用来求给定图的生成树计数，也可以得到Cayley公式，结论见这里 树个数的另一种推导我更喜欢这种，而且对下面有启发意义 考虑有根树的EGF，$F(x)=xe^{F(x)},F^{-1}(x)=\frac{x}{e^x},拉格朗日反演，[x^n]F(x)=\frac{1}{n}[x^{n-1}] (F^{-1}(x)/x)^{-n}=\frac{n^{n-1}}{n!}$ 基本结构计数$$Tree(x)=\sum_{i=0} i^{i-2} \frac{x^i}{i!},Trees(x)=exp\ Tree(x) \\UndirectedGraph(x)=\sum_{i=0} 2^{C_i^2} \frac{x^i}{i!}，UndirectedConnectedGraph(x)=ln\ UndirectedGraph(x)$$ 例题：Hdu5279 YJC plays Minecraft$$对于一个块，森林生成树如上，不考虑环的话就是 2^{n} \prod ts(a_i) \\简单容斥掉，首先跨块的边要连上，设g(n)表示大小为n的去头去尾块方案数\\g(n)=\sum_{i=2}^n C_{n-2}^{i-2} i^{i-2} ts(n-i)，直接卷即可$$ 51nod1728 不动点，考虑有根树EGF转森林，$ans(k)=e^{x*ans(k-1)}$ $O(n)$求若干无向环、一次fft且以边数为上标求若干无向链：无意识的石子堆 连通图计数n个点的连通图计数见生成函数一章，这里讨论一下【n点m边k连通块】的图的计数 直接dp可能是$O(n^8)$的，不太行 设$f(n,m,k)$表示恰好，$g(n,m,k)$表示至少（对n的划分后，钦定至少k个连通块，假设每个连通块为完全图，边数=m）$$g(n,m,k)=\sum_{m2} C_{m2}^m \sum_{k2} S_2(k2,k) f(n,m2,k2)，斯特林反演 \\f(n,m,k)=\sum_{m2} C_{m2}^m (dp(n,m2,k)=\sum_{k2} S_1(k2,k)(-1)^{k2-k} g(n,m2,k2)) \\先考虑求k=1的特殊情况,dp(n,m,k)=\sum_{Graph(n,m,k)} (k-1)! (-1)^{k-1},f(n,m,1)=\sum_{m2}C_{m2}^m \sum_{k2} dp(n,m2,k2) \\dp(n,m,k)=\sum_{i=1}^n C_{n-1}^{i-1} (-1)*k*dp(n-i,m-C_i^2,k-1),O(n^5) \\可以进一步优化，注意到贡献系数是(k-1)!，我们之前只枚举1号点所在连通块大小是为了不计重 \\但我们可以让他计重，每次枚举不包括1号点的连通块从而每种方案被计重(k-1)!次，至于(-1)显然并不用考虑 \\设dp2(n,m)=\sum_{k2} dp(n,m,k2)，dp2(n,m)=\sum_{i=1}^nC_{n-1}^i (-1)*dp2(n-i,m-C_i^2),O(n^4)$$至于$k \ne 1$？不管了好像不是很好搞2333 那我们的生成函数酱去哪了？首先你需要看过生成函数一章中二元生成函数运算，那么无向图的EGF就是$\sum_i \frac{x^i}{i!} (1+y)^{C_i^2}$，就个二项式定理，对这个EGF做ln就是连通图了，理论复杂度 $O(n^3logn)$ 连通欧拉回路图计数如果你对ln熟练的话，显然我们并不关心这个连通，而只关心$f_n=n个点都是偶度数的无向图个数$，对这个ln就行了 考虑n-1个点的无向图数即$2^{C_{n-1}^2}$，然后现在把n放进去，连向那些度数为奇的点； 为什么这些点一定是偶数个？每次加一条边会让非法量变化0或2，而初始的非法为0；故$f_n=2^{C_{n-1}^2}$ 仙人掌首先仙人掌是一个很有特征的结构，就是环与环只能用点连接$$设有根仙人掌的EGF为C(x)，考虑去掉根后剩下什么，对于每个连通块分析 \\如果原本用非环边相连，则EGF=C(x)，否则设环大小为t，考虑到环可以翻转，EGF=\sum_{i=2}^{\infty} C^t(x)/2 \\常规操作地把各个连通块exp起来，C(x)=x*exp(C(x)+\sum_{i=2}^{\infty} C^t(x)/2)=x*exp(\frac{2C(x)-C^2(x)}{2-2C(x)}) \\直接牛迭，g(b)=\frac{2b-b^2}{2-2b}满足exp条件，链式法则得B=b-\frac{b-xe^{g(b)}}{1-xe^{g(b)}g’(b)} \\使用商法则g’(b)=\frac{(2-2b)^2+2(2b-b^2)}{(2-2b)^2}=\frac{1}{2}+\frac{1}{2b^2-4b+2}，巨常数O(nlogn)$$注意到我们考虑有根来便于拼接，而且能方便地从这个特殊点入手，考虑剩下的各个连通块的情况 例题：Loj6569 仙人掌计数 ，你会发现我的板子在应对这种复杂函数的时候非常好写，rose牛迭30行我6行，还跑得更快，code 点双连通图计数考虑怎样化一个跟点双有关的式子出来，设$s_i$表示大小为i的点双图的个数（$s_1=0$，EGF为S）； 一开始可能想着去掉点双的根，但这样似乎不太行 考虑用点双的方案数表示连通图的方案数，设带标号有根无向连通图个数的EGF为F 我们从连通图的根入手，根可能在多个点双内，但如果将根去掉形成若干连通块，则每个连通块恰有一个点双包含根节点，那每个连通块其实就是由中间的点双+挂在点双上点的小连通块组成的$$枚举点双大小，大小n连通块的贡献=[x^n]\sum_{i=1}^{\infty} s_{i+1} \frac{F^{i}(x)}{i!}=[x^n] S’(F(x)) \\那么考虑多个连通块拼接，F(x)=xe^{S’(F(x))}，可得F^{-1}(x)=\frac{x}{e^{S’(x)}} \\不能牛迭，而拉格朗日反演每次只能求一个系数，所以我们需要进一步化式子来快速求出S’ \\设T(F^{-1}(x))=S’(x)=ln \frac{x}{F^{-1}(x)}，T(x)=ln \frac{F(x)}{x}可计算，于是我们顺利地用复合逆表示出S’ \\直接拓展拉格朗日反演，{[x^t]} S’(x)={[x^t]} T( F^{-1}(x) )=\frac{1}{t} [x^{t-1}] T’(x) \frac{1}{(F(x)/x)^t} \\$$例题：loj6363 地底蔷薇 code$$设A’为S’只保留题目要求的位置，先求出A’，由上复杂度为O((\Sigma t)log(\Sigma t)) \\所求为B(x)=xe^{A’(B(x))}，B^{-1}(x)=\frac{x}{e^{A’(x)}} \\用普通反演搞回去就可以得到B了，ln(B^{-1}(x)/x)=-A’(x)，此处为O(nlogn) \\细节：F/x满足ln条件，直接-t次方算，A’满足exp条件$$ 边双连通图计数和上面类似的思路，但你注意到考虑删点并没有什么用……不妨考虑根所在的边双 设有根边双图的EGF为B，带标号有根无向连通图个数的EGF为F，可以任选边双上一个位置挂上一个连通图$$F(x)=\sum_{i&gt;0} \frac{ b_i x^i(e^{F(x)})^i }{i!}=B(xe^{F(x)})，不能牛迭同样考虑复合逆 \\设T(x)=xe^{F(x)},F(x)=B(T(x)),B(x)=F(T^{-1}(x))，符合拓展拉格朗日反演的式子 \\{[x^n]}B(x)={[x^n]}F(T^{-1}(x))=\frac{1}{n} [x^{n-1}]F’(x)(T(x)/x)^{-n}，O(nlogn)$$ 带标号有向图参考：国家集训队2017论文集的《A + B Problem》命题报告 为下文方便定几个符号有向生成函数DGF（瞎起的名字，出现在Johnkram的ppt里）：$S(x)=\sum_{i \ge0} a_i \frac{x^i}{i!2^{C_{i}^2}}$ 意义：$(A(x)*B(x))[x^n]=\sum_{i=0}^n C_n^i2^{i(n-i)} a_ib_{n-i}$ 即定向连边 g为DAG数，其EGF为G，DGF为GG；h为有向图数，其EGF为H，其DGF为HH；d为强连通图，其EGF为D，其DGF为DD 竞赛图相关计数核心思想：把握竞赛图的特性，缩点后一定是链，任意两个两个强连通分量间都满边且同向 强连通竞赛图计数这东西大概是有向图里面最简单的吧，不用DGF 设G为所有竞赛图，F为强连通竞赛图，为方便设$g_o=1,f_0=0$ 考虑怎么表示，一开始想着考虑1在哪里发现不好搞，但想了想发现改为枚举哪些点作为拓扑序上第一个就好了（缩完点显然是链），$g_n=[n=0]+\sum_{i=1}^{\infty}C_n^if_ig_{n-i},G=1+F*G$ 例题：luogu4233 射命丸文的笔记，code 哈密顿回路数=$(n-1)!2^{n(n-1)/2-n}$，然后有哈密顿回路的竞赛图等价于强连通的竞赛图，证明 要特判一下1和2，$O(nlogn)$ bzoj5219 Lydsy2017省队十连测 最长路径，code 先把上面的f和g处理好，考虑s表示以1所在强连通分量为开头的方案数，$s_n=\sum_{i=1}^nC_{n-1}^{i-1}f_ig_{n-i},ans_i=C_{n-1}^{i-1}s_ig_{n-i}$ 竞赛图强连通分量个数 GDOI2018 D1T4有向无环图计数例题、bzoj2863愤怒的元首$$同样考虑有根，定义根为出度=0的节点，考虑简单容斥 \\至少i个节点是根，考虑根与其他节点的连边，g_n=[n=0]+\sum_{i=1}^n(-1)^{i+1} C_n^i2^{i(n-i)}g_{n-i}$$论文上的是一个稍复杂的思路，选看： 请先思考后再展开 $$显然无根dag(G,根集合S)对应2^{|S|}个有根dag(G,S’)，设i个点j个根的无根dag为f_{i,j}，考虑将j个点删除会发生什么 \\考虑选哪些点为根以及删除的边，\sum_{实际i=0}^n f_{n,i} 2^i=\sum_{至少i=0}^n C_n^i 2^{i(n-i)} g_{n-i}\\展开次幂并翻转，\sum_{至少j=0}^n \sum_{i=j}^n f_{n,i} C_i^j=\sum_{至少i=0}^n C_n^i 2^{i(n-i)} g_{n-i} ，注意外和号等价 \\\sum_{i=0}^n (-1)^i C_n^i 2^{i(n-i)} g_{n-i}=\sum_{j=0}^n (-1)^j \sum_{i=j}^n f_{n,i} C_i^j=\sum_{i=0}^n f_{n,i} \sum_{j=0}^i C_i^j (-1)^j=\sum_{i=0}^n f_{n,i} [i=0]=[n=0]\\整理可得递推式：g_n=[n=0]-\sum_{i=1}^n (-1)^i C_n^i 2^{i(n-i)} g_{n-i}$$殊途同归，也算是某种验证吧 根据生成函数知识可得：$PP为(-1)^i的DGF，GG=-PP*GG+GG+1，GG=PP^{-1}$ 若要求弱连通，直接在EGF下ln就好了 题：CEOI2019游乐园、人类补完计划 强连通图计数例题 考虑怎么类似于上面去做，就是要把一些强连通分量替代前面枚举的根，从上面的式子出发，就是要用$(-1)^i$作为至少i个强连通块作为根组合起来的系数，故设$e_n$表示总点数为n的，若干个强连通图，且方案的系数为$(-1)^{强连通分量个数}$$$枚举1所在强连通分量大小，e_n=[n=0]-\sum_{i=1}^n C_{n-1}^{i-1} d_i e_{n-i},E=1-\int D’E,D=-\int \frac{E’}{E}=-lnE \\类似dag的推导，还是容斥，\sum_{i=0}^n C_n^i e_i 2^{i(n-i)}h_{n-i}=[n=0]，即EE=HH^{-1} \\可以理解为对h_n减一系列东西，这些东西的和是个容斥，意义为所有强连通分量根的个数&gt;0的情况，于是=0$$ 顺便说一道类似的题：bzoj3812 主旋律，$O(n3^n)$，code$$e_S=[S=\emptyset]-\sum_{T \subseteq S,lowbit(S) \in T} d_T e_{S \setminus T} 得d_S=[S=\emptyset]-e_S-\sum_{T \subset S,lowbit(S) \in T} d_T e_{S \setminus T} \\把上面的式子化一化，e_S=[S=\emptyset]-\sum_{T \subset S} 2^{to(T,S \setminus T)} e_T h_{S \setminus T} \\$$ 国家集训队互测2016R1 A+B problem（口胡）若为dag，考虑对每个点考虑自己贡献，而每个点都一样，$ans=\sum_{i=1}^n i*2^{i-1}*g2_{i-1}$ 那现在也是类似的，先搞出合法的强连通分量D2，进而求合法的E2，然后是H2，以及他们对应的DGF $ans=\sum_{i=1}^n \sum_{j=1}^i C_i^j 2^{j(i-j)} *d2_jh2_{i-j}=\sum_{i=1}^n [x^i]DD2*HH2$ 形式化来说，定义一元运算$\Delta$表示将后面的EGF转化为DGF，$[x^i]=(\Delta D2)*(\Delta (e^{-D2}))^{-1}$ 无标号图不会告辞]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-15概率论]]></title>
    <url>%2Fposts%2F3e6e.html</url>
    <content type="text"><![CDATA[概率论 一些概率论中比较有用的不等式及证明 经典的几个方法，证明一个经典问题，思想很有用 概念一些定义定义连续型随机变量为在实数域或区间上取连续值的随机变量，若不连续则为离散型概率函数（又叫分布律），为随机变量取某个元素的概率的函数 概率分布函数是概率函数的前缀和在连续型中，不存在概率函数，定义概率密度函数f满足 $概率分布函数F(x)=\int_{-\infty}^x f(t) dt$推广到高维就叫做联合概率密度函数 连续型随机变量的数学期望，要求概率密度函数的积分（即概率分布函数）收敛 期望经典柿子：$E(x)=\int_{0}^{\infty} P(x \ge t) dt-\int_{-\infty}^{0} P(x \le t) dt$若变量X和Y独立， $E(XY)=E(X)E(Y)$任意两个变量X和Y都满足 $E(X+Y)=E(X)+E(Y)$ n个[0,1]随机变量的min： $E(min x)=\frac{1}{n+1}$，可积分得出 期望有个套路的转化，恰好到达的状态的概率*步数之和，等价于所有未到达的状态（状态中包含步数）的概率之和，这个你可以通过【把当前概率推到上面的步数个祖先上】理解 入门题:OSU 方差方差记为 D(x)或Var(x)$D(x)=E[(E(x)-x)^2]=E[E^2(x)+x^2-2xE(x)]=E(x^2)-E^2(x)$协方差记为 Cov(X,Y)$Cov(X,Y)=E[(X-EX)(Y-EY)]=E(XY)-E(X)E(Y)$ 运算律：$D(cX)=c^2 D(X),D(X \pm Y)=D(X)+D(Y) \pm 2Cov(X,Y)$ 题目A NOIP2018初赛某题[0,1]上随机变量A、B，问E(|A-B|)设 $X=max-min,E(X)=Emax(A,B)-Emin(A,B)=\frac{2}{3}-\frac{1}{3}=\frac{1}{3}$另外， $D(X)=E(X^2)-E^2(X)=E(min^2+max^2-2min \times max)-1/9=1/6+5/6-2*(1/4)-1/9=1/18$ B 将1随机分为n份第k小段的期望这里随机的严谨定义为 $n-1个[0,1]上随机变量，划分为n段$如果k=1， $E=\int_0^{1/n} (1-nx)^{n-1} dx=\frac{1}{n^2}$k&gt;1考虑数学归纳法$$\begin{aligned}&amp; 已知 V1,V2..Vi，则 (V_{i+1}-V_i) \leq … (V_n-V_i)\\&amp; V_{i+1}=V_i+\frac{1- (\sum_{i=1}^i V_i)-(n-i)V_i }{(n-i)^2}\\&amp; 可得 V_k=\frac{1}{n} \sum_{i=1}^k \frac{1}{n-i+1}\end{aligned}$$如果没看懂：某文章、 zhihu C n个随机实数的第k小的期望下面我们只讨论在[0,1]间随机的情况，其他直接放缩就好了 众所周知最大可以直接积分，最小翻转一下，今天看到地震后的幻想乡，发现k任意也可以求 有两种方法：A,B B比较简单说B，就是 $\sum_{all} \frac{1}{all} a_{p_k}=\sum_{all} \frac{1}{all} [变量s \leq a_{p_k}]$ 将所有点取值情况投影到数轴，对于某种投影，共$(n+1)!$种情况，有 $k \times n!$ 种合法，即 $\frac{k}{n+1}$ 注意到每种投影的概率不同，但因为权值相同，所以没有影响 D n个随机不重整数的第k小的期望设值域为$[1,m]$，要求$n,m \le 1e18$$$\sum_{i=1}^m i*C_{i-1}^{k-1} C_{m-i}^{n-k}*\frac{1}{C_m^n}，拆开组合数得C_n^k*k* \sum_{i=1}^m \frac{C_{m-n}^{i-k}}{C_m^i}，然后就不会怎么化了……\\正确的做法是\sum_{i=1}^m k*C_i^k C_{m-i}^{n-k}*\frac{1}{C_m^n}，组合数性质得 \frac{k}{C_m^n}*C_{m+1}^{n+1}=k*\frac{m+1}{n+1}$$ E 关于展开$x^Ae^{Bx}$对普通生成函数（x=1）的贡献agc038E - Gachapon F CF605E Intergalaxy Trips$f(x)$表示x到n的期望时间，然后做期望题不急着考虑转移，而是考虑最后满足怎样的关系式 注意到转移只会从期望值小的到大的，那么设a为按f从小到大排序的编号，则一定满足： $f(a_i)=1+\sum_{j=1}^i f(a_j)p(a_i,a_j)\prod_{t=1}^{j-1}(1-p(a_i,a_t))$，将i=j的部分移到左边，就是可以转移的东西了 每次取出未拓展且最小的，更新其他未拓展的即可，$O(n^2)$ G 一种期望模型给出一个dag，删除一个点就会把所能到达的所有点删除，每次随机选择一个没有被删除的点删除，问期望步数 考虑一个点被选择的概率，等价于对期望的贡献，设有k个点可到达自己，感性理解一下应该和别的点无关，$\frac{1}{k+1}$ H 一个经典的杀人模型转化+容斥见PKUWC2018 猎人杀，另有一道不错的题：uoj390【UNR #3】百鸽笼 ZZQ的ppt做题记录CF258D Little Elephant and Broken Sorting $f(a,b)表示a&gt;b的概率，每次只修改2n个值,O(n^2)$ code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-14多项式全家桶]]></title>
    <url>%2Fposts%2F8c82.html</url>
    <content type="text"><![CDATA[多项式全家桶板子并不全，对测速、其他板子感兴趣的请看这里 upd：好像这个更全啊，各种能写的黑科技都写了 一些约定多项式的度：最高项次数； 多项式的次数界：任何一个严格大于多项式次数的数 FFT前置知识： 复数，由实数和虚数（单位为i）组成 欧拉公式 $e^{xi}=cos(x)+sin(x) i$ 单位复数根 $\omega_n^k = e^{ 2 \pi \frac{k}{n} }$ ，可见 $(\omega_n^k)^2=(\omega_n^{k+n/2})^2$ 解决的主要问题：多项式乘法设最高次项为n，则暴力为 $O(n^2)$在系数为实数域下，借助单位复数根的性质优化复杂度为nlogn 思路：将多项式看作函数从函数的系数表达法 求值 为点值表达法，最高次为n的函数，至少（倍数点的存在）需要n+1个点确定点值表达法的两个函数相乘，时间为n（相同x，x不变，y相乘）从点值表达法 插值 为系数表达法（降低为nlogn） 分治：对于 $T(x)=\sum a_i x^i$将其奇偶分离，$T(x)=A(x^2)+x \times B(x^2)$其中A为偶数，多项式长度减半，但变成两个然后因为平方相同，联想到单位根的性质，不妨将其作为x来代入所以对于当前需要带入的n个，只要带入前面n/2个即可（n都是指大于多项式次数的2的次幂）那么根据主定理可知其复杂度为 $nlogn$ ，如果不太懂可结合code然后插值的话，结论是将单位 $\omega_n^1变为 \omega_n^{-1}$ ，然后退出时将结果除以n证明见下面DFT 实现：递归版因其空间开销即常数巨大，很少使用如果每次都是将奇数位（次幂为偶数）放在前面，则最后奇偶分离的结果下, $num[i]=a[二进制翻转(i)]$ 1234567891011121314151617181920212223242526272829303132namespace PP&#123; const int LN=1&lt;&lt;21;int bin[30]; const double PI=acos(-1); struct Cp &#123; double a,b;Cp(double x=0,double y=0)&#123;a=x,b=y;&#125; Cp operator + (const Cp &amp;t)const&#123;return Cp(a+t.a,b+t.b);&#125; Cp operator - (const Cp &amp;t)const&#123;return Cp(a-t.a,b-t.b);&#125; Cp operator * (const Cp &amp;t)const&#123;return Cp(a*t.a-b*t.b,b*t.a+a*t.b);&#125; Cp operator * (const double &amp;t)const&#123;return Cp(a*t,b*t);&#125; Cp operator ~ ()const&#123;return Cp(a,-b);&#125; &#125;; struct NTT &#123; int R[LN];Cp w[LN]; NTT()&#123; bin[0]=1;for(int i=1;i&lt;30;i++) bin[i]=bin[i-1]&lt;&lt;1; for(int i=0;i&lt;LN;i++) w[i]=Cp(cos(2*PI/LN*i),sin(2*PI/LN*i)); &#125; void DFT(Cp A[],int lg,int op=0) &#123; int m=bin[lg];if(op) reverse(A+1,A+m); for(int i=1;i&lt;m;i++)&#123;R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1));if(i&lt;R[i])swap(A[i],A[R[i]]);&#125; for(int ln=1;ln&lt;m;ln&lt;&lt;=1) for(int st=0;st&lt;m;st+=ln&lt;&lt;1) for(int k=0;k&lt;ln;k++) &#123; Cp t=w[LN/(ln&lt;&lt;1)*k]*A[st+ln+k]; A[st+ln+k]=A[st+k]-t;A[st+k]=A[st+k]+t; &#125; &#125; &#125;ntt;&#125;; NTT超赞的教程笔记：当p为素数，存在其原根g，使得 $g^0,g^1,… g^{p-2}$ 互不相同然后因为我们需要分治，同样希望能按2分解，所以p的形式必须为 $t \times 2^k+1$ ，然后能处理 $n \leq 2^k$ 的数据设 $g_n=g^{(p-1)/n}$然后通过各种方式可证明其满足我们用到的单位复数根的各种性质超详细原根表、原根表2号最常见：998244353、1004535809，原根为3 卷积的应用 带通配符字符串匹配问题（具体位置）；很容易想到把字符串翻转后用卷积表示以某个位置后开始匹配的情况 1)如果是比较基础的是保证字符集大小，那么枚举每种字符，数匹配数即可，例题：bzoj4503两个串； 2)字符集不保证其实也能做，考虑怎么把a和b独立开来；如果统计$[a=b]$的话，好像不是很行，但我们只需要知道是否不存在$[a \ne b]$，那么如果是’?’的话设为0就好了，不妨考虑欧几里得距离的平方=$(a-b)^2=a^2+b^2-2ab$，这个预处理区间平方和就好了，例题：bzoj4259 残缺的字符串。 3)差不多的：bzoj3160 万径人踪灭，code，要求不连续所以要多写个manacher 解决若干个多项式的乘积的时候，像哈夫曼树那样搞个堆维护多项式可以达到速度下界，就像合并果子（以前都是用分治fft的） 常数优化还是推荐看毛啸的论文，非常多卡常技巧 fft有个利用复数的trick，将3次减少到2次：$C=A*B，构造D_i=(a_i+b_i)+(a_i-b_i)i,C_i=\frac{1}{4}real(D^2 [x^i])$ 预处理单位根，fft提精度ntt提速度 我一般写IDFT都会这样写 拆系数fft暂时只会7次的，就是设 $m0=\sqrt M$ ，然后带余除法一下，展开成4个多项式DFT后，合并起来，然后外面系数相同的有3种，IDFT共3次，然后再把系数还原samjia的 4次的板子： 123456789101112131415161718for(int i=0;i&lt;=n;i++) &#123;int t=qread();A[i]=Cp(t&gt;&gt;16,t&amp;(MOD-1));&#125;for(int i=0;i&lt;=m;i++) &#123;int t=qread();B[i]=Cp(t&gt;&gt;16,t&amp;(MOD-1));&#125;ntt.DFT(A,lg);ntt.DFT(B,lg);for(int i=0;i&lt;M;i++)&#123; int id=i?M-i:0; Cp f0=(A[i]-(~A[id]))*Cp(0,-0.5),f1=(A[i]+(~A[id]))*0.5; Cp g0=(B[i]-(~B[id]))*Cp(0,-0.5),g1=(B[i]+(~B[id]))*0.5; C[i]=f1*g1;D[i]=f1*g0+f0*g1+f0*g0*Cp(0,1);&#125;ntt.DFT(C,lg,1);ntt.DFT(D,lg,1);double fk=1.0/M;for(int i=0;i&lt;=n+m;i++)&#123; ll a=(ll)(C[i].a*fk+0.5)%p&lt;&lt;32; ll b=(ll)(D[i].a*fk+0.5)%p&lt;&lt;16; ll c=(ll)(D[i].b*fk+0.5)%p; write1(((a+b+c)%p+p)%p);&#125; 分治FFT常数优化：考虑到是循环卷积，长度并不需要倍长到$(r-l)+(mid-l)+1$，而是到$r-l+1$就行了，因为我们只需要后面的$r-mid$部分，而对一个$up(r-l+1)$做循环卷积并不会影响到（因为哪怕up没区别，都不会影响到，而现在循环长度更长） 例子：【CF553E】Kyoya and Train 有的时候你会发现要自己卷自己，例如uoj50【UR #3】链式反应，考虑每次用$[l,mid]更新[mid+1,r]$，那么我们在处理更新长度部分（$i \in[1,r-l]$）讨论一下i，$当i \le l,只会被统计一次，系数=2；当i \le mid，会被统计两次，系数=1；否则系数=0$ DFT补充一下这个，因为有些时候是不能分治的，需要求自动的循环卷积（之所以这么说，是因为通常可以手动循环卷积，不过例如在快速幂里面就会多个log和大常数）首先DFT是个循环卷积，只不过因为通常情况下，我们的n都是到2的次幂，是个线性卷积有个性质(应用于复数根和原根，称之为单位根反演)： $\frac{1}{k} \sum_{i=0}^{k-1} g_k^{ni}=[n\%k=0]$ 把式子的简化版放在这里，完整版还是看mx的吧$$\begin{aligned}C_r=&amp; \sum [(p+q) \% n=r] a_pb_q\\=&amp; \frac{1}{n} \sum_{k=0}^{n-1} (w_n^{-r})^k \times (\sum (w_n^k)^p a_p ) \times (\sum (w_n^k)^q b_q )\\&amp;所以我们就能得到DFT和IDFT的式子\\a_m&amp;=\sum_{k=0}^{n-1} (w_n^m)^k b_k，c_m=\frac{1}{n} \sum_{k=0}^{n-1} (w^{-m}_n)^k d_k\\\end{aligned}$$于是就可以全自动了，复杂度n方，例题：CC的bike（毕克的题） Bluestein’s Algorithm自动循环卷积在条件允许的时候当然可以exp，复杂度nlogn但常数巨大；手动循环卷积的话复杂度是log方的 其实我有点功利，很久以前就知道这个算法了，但当时不太想学只是知道这个算法的作用；后来学了exp后发现这个只是常数小，又不想学；直到听说HNOI2019搞了一道毒瘤题……$$\hat A_k=\sum_{i=0}^{n-1}A_i w_n^{ik}，考虑怎么拆ik \\myy论文上（疑似写错）的拆法是ik=\frac{i^2+k^2-(k-i)^2}{2}，\hat A_k=w_n^{k^2/2} \sum_{i=0}^{n-1}(A_i w_n^{i^2/2} )w_n^{(k-i)^2/2} \\貌似还行，毕竟可以上下放大，但有没有可能mod恰好不是2n的倍数？ \\二次剩余当然不是我们希望的，还有i和k大小关系的问题，网上看到一个更好的拆法 \\ik=C_{i+k}^2-C_{i}^2-C_{k}^2，\hat A_k=w_n^{-C_{k}^2} \sum_{i=0}^{n-1}(A_i w_n^{-C_{i}^2} )w_n^{C_{i+k}^2} \\IDFT也是类似，A_k=\frac{w_n^{C_{k}^2}}{n} \sum_{i=0}^{n-1}(\hat A_i w_n^{C_{i}^2} )w_n^{-C_{i+k}^2}$$ 牛顿迭代牛顿迭代是全家桶的基础，请务必透彻理解 普通的牛顿迭代就是对方程求根（y=0），然后现在把x替换成一个多项式 然后模p是模长度，可以看作一个精度，然后我们迭代就是求想要的精度，后面的所有运算都是在这个意义下的$$设当前要处理的多项式组为 B_p表示模数为p，自定义函数f，求 f(B_p)=0(\%x^p) \\对于f(B_p)在B_{\lceil p/2 \rceil}处泰勒展开，B_p-B_{\lceil p/2 \rceil}的前\lceil p/2 \rceil项都是0 \\所以只需要展开前两项就能保证当前精度 \\f(B_p)=f(B_{\lceil p/2 \rceil})+f’(B_{\lceil p/2 \rceil})(B_p-B_{\lceil p/2 \rceil})(\%x^p) \\B_p=B_{\lceil p/2 \rceil}-\frac{f(B_{\lceil p/2 \rceil})}{f’(B_{\lceil p/2 \rceil})} (\%x^p) \\请牢记，这里的f’是指 \frac{d}{db} f(b)，跟多项式没啥关系，强烈建议做题感受$$ 然后以下介绍的东西都是log的，但常数不断增加 逆元（常数6）$$f(x)=A*x-1,f’(x)=A,B_p=B_{\lceil p/2 \rceil}-\frac{A*B_{\lceil p/2 \rceil}-1}{A} (\%x^p) \\然后观察可知分子前半（上取整）都是0，可以给右边乘上B_{\lceil p/2 \rceil}*A，因为其前半=1 \\B_p=B_{\lceil p/2 \rceil}-B_{\lceil p/2 \rceil}(A*B_{\lceil p/2 \rceil}-1) (\%x^p)=2B_{\lceil p/2 \rceil}-B^2_{\lceil p/2 \rceil}A (\%x^p)$$ 不难看出一个多项式存在逆元当且仅当其常数项存在逆元；例题：bzoj3456 如果懒的话可以用ln+exp做 开方（常数18）常数项如果没保证你可能需要一个二次剩余；如果懒的话可以看做多项式求幂用exp做 $f(x)=A-x^2=0,f’(x)=-2x,B_p=B_{\lceil p/2 \rceil}-\frac{A-B^2_{\lceil p/2 \rceil}}{-2B_{\lceil p/2 \rceil}}=\frac{B_{\lceil p/2 \rceil}^2+A}{2B_{\lceil p/2 \rceil}} (\%x^p)$ （带余）除法、取模（常数12）定义： $\begin{equation} \label{div0} A(x) = D(x)B(x) + R(x) \end{equation}$设A的度为n，B为m，则D为n-m，R不超过m-1 然后我们考虑一个骚操作，对于一个度为k的多项式T， $x^k T(\frac{1}{x})$ 等价于系数反转$A^r(x)=D^r(x)B^r(x)+x^{n-m+1} R^r(x)$注意到后面的部分不会影响到D，$D^r(x)=A^r(x) \times inv( B^r(x) ) (\mod x^{n-m+1})$ ln和exp（常数9、24）可以看成是多项式丢到麦克劳森级数里面$$exp(A)=\sum A^i/i!，显然结果常数项=1 \\ln(A)=-\sum_{i=1} \frac{(1-A)^i}{i},A常数项=1故结果常数项=0 \\也可以这样理解：若常数项 \ne0，将其泰勒展开的话常数项始终非0，需要无穷项，无法收敛 \\根据链式法则，(ln A(x))’=\frac{A’(x)}{A(x)},lnA(x)=C+\int \frac{A’(x)}{A(x)}，这里C=0 \\至于求exp，f(x)=A-lnx,f’(x)=-1/x,B_p=B_{\lceil p/2 \rceil}(A+1-ln B_{\lceil p/2 \rceil}) \\$$ 多项式三角函数不会告辞，遇到再学 多点求值（常数13）不会告辞 题：快速阶乘算法、uoj182【UR #12】a^-1 + b problem 快速插值（常数16）不会告辞，遇到再学 求幂求ln后乘指数，exp即可，不写了，luogu模板加强版记得处理a0=0 全家福花费了一天各种测试搞出来的，兼顾好看（自然语言+短）以及速度 注意：做题一定要写const int MOD，本机10s-&gt;3s，洛谷7s-&gt;2s12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758inline int mm(const int x)&#123;return x&gt;=MOD?x-MOD:x;&#125;namespace PP//全家桶板子&#123; const int LN=1&lt;&lt;19;int inv[LN+1]; struct NTT &#123; vc&lt;int&gt; w[30];NTT()&#123;inv[1]=1;for(int i=2;i&lt;=LN;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD; for(int i=1;i&lt;=19;i++) &#123;w[i].PB(1);int pp=qpower(3,(MOD-1)/bin(i));for(int j=1;j&lt;bin(i-1);j++) w[i].PB(1ll*w[i][j-1]*pp%MOD);&#125; &#125; int R[LN];inline void DFT(int A[],int lg,int op=0) &#123; int m=bin(lg);GG(m&gt;LN) if(op) reverse(A+1,A+m); for(int i=1;i&lt;m;i++)&#123;R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1));if(R[i]&lt;i)swap(A[i],A[R[i]]);&#125; for(int ln=1,lgg=1;ln&lt;m;ln&lt;&lt;=1,lgg++) for(int st=0;st&lt;m;st+=2*ln) for(int k=0;k&lt;ln;k++) &#123;int t=1ll*w[lgg][k]*A[st+ln+k]%MOD;A[st+ln+k]=mm(A[st+k]+MOD-t);A[st+k]=mm(A[st+k]+t);&#125; &#125; &#125;ntt; int A[LN],B[LN],C[LN],M; struct P//此结构体内函数选择性写 &#123; vc&lt;int&gt; a;int n;void rs(int nn)&#123;a.resize(n=nn);&#125;P()&#123;rs(M);&#125; int&amp; operator [] (int x)&#123;return a[x];&#125; friend const P operator * (P a,const int &amp;b) &#123;for(int i=0;i&lt;a.n;i++) a[i]=(ll)a[i]*b%MOD;return a;&#125; inline void dft(int A[],int lg,int ln)&#123;for(int i=0;i&lt;bin(lg);i++)A[i]=(i&lt;min(ln,n)?a[i]:0);ntt.DFT(A,lg);&#125; inline void idft(int A[],int lg,int ln)&#123;ntt.DFT(A,lg,1);rs(ln);for(int i=0;i&lt;ln;i++)a[i]=1ll*A[i]*inv[bin(lg)]%MOD;&#125; const P Mul(P b,int ln) &#123; int lg=ceil(log2(ln+ln-1)),m=bin(lg);dft(A,lg,ln);b.dft(B,lg,ln); for(int i=0;i&lt;m;i++) B[i]=1ll*A[i]*B[i]%MOD;b.idft(B,lg,ln);return b; &#125; const P operator * (const P b) &#123;return Mul(b,M);&#125; &#125;; void Inv(P &amp;a,P &amp;b,int ln) &#123; if(ln==1)&#123;b.rs(1);b[0]=invm(a[0]);return;&#125;Inv(a,b,(ln+1)/2); int lg=ceil(log2(ln+ln-1)),m=bin(lg);a.dft(A,lg,ln);b.dft(B,lg,ln); for(int i=0;i&lt;m;i++) B[i]=(2+MOD-1ll*B[i]*A[i]%MOD)*B[i]%MOD;b.idft(B,lg,ln); &#125; P Ji(P a)&#123;a.rs(a.n+1);for(int i=a.n-1;i&gt;=1;i--)a[i]=1ll*a[i-1]*inv[i]%MOD;a[0]=0;return a;&#125; P Dao(P a)&#123;for(int i=0;i&lt;a.n-1;i++)a[i]=1ll*a[i+1]*(i+1)%MOD;a.rs(a.n-1);return a;&#125; P Ln(P &amp;a,int ln)&#123;P b;Inv(a,b,ln);return Ji(Dao(a).Mul(b,ln-1));&#125; void Exp(P &amp;a,P &amp;b,int ln) &#123; if(ln==1)&#123;b.rs(1);b[0]=1;return;&#125;Exp(a,b,(ln+1)/2); P pp=Ln(b,ln);for(int i=0;i&lt;ln;i++) pp[i]=mm(a[i]+MOD-pp[i]);pp[0]++; int lg=ceil(log2(ln+ln-1)),m=bin(lg);pp.dft(A,lg,ln);b.dft(B,lg,ln); for(int i=0;i&lt;m;i++) B[i]=1ll*A[i]*B[i]%MOD;b.idft(B,lg,ln); &#125; void Sqrt(P &amp;a,P &amp;b,int ln) &#123; if(ln==1)&#123;b.rs(1);b[0]=1;return;&#125;Sqrt(a,b,(ln+1)/2);P tmp=b*2,c;Inv(tmp,c,ln); int lg=ceil(log2(ln+ln-1)),m=bin(lg);a.dft(A,lg,ln);b.dft(B,lg,ln);c.dft(C,lg,ln); for(int i=0;i&lt;m;i++) A[i]=ll((ll)B[i]*B[i]+A[i])%MOD*C[i]%MOD;b.idft(A,lg,ln); &#125; P Rev(P a)&#123;reverse(a.a.begin(),a.a.end());return a;&#125; P Inv(P a,int ln)&#123;P b;Inv(a,b,ln);return b;&#125; P Div(const P &amp;a,const P &amp;b)&#123;return Rev(Rev(a).Mul( Inv(Rev(b),a.n-b.n+1),a.n-b.n+1 ) );&#125;&#125;; 拉格朗日插值众所周知，n+1个横坐标不同的点能唯一确定一个n次多项式，现在就是求这个多项式 拉格朗日基本多项式 ：$\ell_i(x)=\prod_{j=0,i!=j}^n \frac{x-x_j}{x_i-x_j}$ 注意到有些不错的性质：$\ell_i(x_i)=1,\ell_i(x_j)=0,\forall j \ne i$ （有一点点中国剩余定理的感觉） 于是可以构造出多项式 $P=\sum_{i=0}^n y_i\ell_i(x)$ 已经可以做到$n^2$，配合多项式多点求值和插值可以做到$O(nlog^2n)$ 然而我不会，听说常数巨大 重心拉格朗日插值： 稍微思考一下就会发现可以维护公共部分，需要的时候除掉，这样就可以O(n)插入了 另外你会发现你可以耍赖地切构造题了，abc137f Polynomial Construction 讲题前说个事，题目中比较常见的多项式形式是 $\sum_{x=1}^n (\sum_{j=0}^k a_jx^j)$ 然后这个整体也是个关于n的多项式，系数为n+1，这个的话我现在写成这样一定很显然（交换和号然后就是自然数幂和），不过通常后面是个隐蔽的多项式 bzoj2655 calc做法一： 设$f(i,j)$ 表示前i个数，选了j个（有序选，最后乘n!） $f(i,j)=f(i-1,j)+i*f(i,j-1)或f(i,j)=i \sum_{k=0}^{i-1} f(k,j-1)=i*s(i-1,j-1)$ 第二种的形式更舒适，观察第二种，盲猜一手可知，如果以i为未知数，应该是一个最高2j次的多项式，其中前缀和贡献+1，乘i贡献+1，当然你也可以打表 因此把前面的dp预处理好，然后拉格朗日插值，时间复杂度 $O(n^2)$ 123456789101112131415161718192021222324ll f[N][N],s[N][N],fac[N],facinv[N];void main()&#123; int A=qread(),n=qread();MOD=qread(); fac[0]=1;for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%MOD; facinv[N-1]=invm(fac[N-1]);for(int i=N-2;i&gt;=0;i--) facinv[i]=facinv[i+1]*(i+1)%MOD; s[0][0]=1; for(int i=1;i&lt;=n+n;i++) &#123; f[i][0]=s[i][0]=1; for(int j=1;j&lt;=i;j++) f[i][j]=s[i-1][j-1]*i%MOD,s[i][j]=(s[i-1][j]+f[i][j])%MOD; &#125; if(A&lt;=n+n)&#123;write(s[A][n]*fac[n]%MOD);return;&#125; ll all=1;for(int i=0;i&lt;=n+n;i++) all=all*(A-i)%MOD; ll ans=0; for(int i=n;i&lt;=n+n;i++) &#123; ll tmp=all*invm(A-i)%MOD; tmp=tmp*facinv[i]%MOD*facinv[n+n-i]%MOD;if((n+n-i)&amp;1) tmp=-tmp; ans=(ans+tmp*s[i][n]%MOD*fac[n]%MOD)%MOD; &#125; write((ans+MOD)%MOD);&#125;//x+MOD 做法二：倍增，并不是很会，见这里 做法三：lcxer的容斥$$f(n)表示长度为n序列的方案的权值和，g(n,x)表示长度为n且包含元素x的权值和 \\每种都被统计n次，f(n)=\frac{1}{n} \sum_{i=1}^A g(n,i)；然后g很好容斥，g(n,x)=\sum_{i=1}^n (-1)^{i-1} x^i f(n-i) \\f(n)=\frac{1}{n} \sum_{k=1}^n (-1)^{k-1} f(n-k) (\sum_{i=1}^A i^k) ，每个合法序列只会以某种顺序统计一次，最后乘n!$$做法四：WorldWide_D的容斥 bzoj4559 JLoi2016 成绩比较$$f(i,j)表示考虑前i门课，j个人目前被碾压，f(i,j)=(\sum_{x=1}^{u_i} x^{n-r_i}(u_i-x)^{r_i-1}) \sum_{k=j}^n f(i-1,k)C_k^jC_{n-k}^{n-r_i-j}$$ 前面那个插值即可，预处理幂后复杂度为 $O(n^3)$ code 另一种做法是注意到分数的选择跟大小方案无关，容斥出大小方案个数，乘以分数选择方案（且m门课程独立），分数选择方案也可以插值或递推，详见CQzhangyu 下降幂多项式$F(x)=\sum_{i=0}^{\infty} f_i x^{\underline i}$ 当给出连续点值的时候，会有一个不错的性质 看到点值连续考虑点值的生成函数G，$a^{\underline b}(a&lt;b)=0$ $G(x)=\sum_i f(i) \frac{x^i}{i!}=\sum_j f_j(\sum_{i=j} \frac{i^{\underline j}x^i}{i!})=\sum_j f_j x^j (\sum_{i=j} \frac{x^{i-j}}{(i-j)!})=FF*e^x$，注意这里FF是个OGF而G是EGF 所以当一个多项式给出连续点值的时候，可以在nlogn内求出多项式的下降幂形式（不用求逆，$e^{-x}$直接得系数），如果只有原多项式则多点插值（虽然我不会） 例题：uoj269 【清华集训2016】如何优雅地求和]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-13生成函数]]></title>
    <url>%2Fposts%2F68d9.html</url>
    <content type="text"><![CDATA[生成函数 可能需要一些基本达到微积分知识 文没有严谨这种东西，如果你发现有某些定义上感觉无法理解（如e、积分的法则），强烈推荐rqy当然会有一些可以看的课件，例如策的 概念幂级数：形如 $\sum_{i=0}^{\infty} a_i(x-x0)^i$ 形式幂级数：不讨论幂级数敛散性，也就是将其中的不定元x仅仅看作是一个代数对象，而不是任何具体数值的时候写出的幂级数。生成函数就是一种形式幂级数 所以这就是生成函数的精髓所在：用一个无限多项式的形式，却不需要考虑是否有意义，可以便捷地对数列做类似多项式的各种运算，最后再展开回去（如e^x就是一个数列） 下面会有些习题，懒得搞折叠了，可以学之前截个图打马赛克 一些符号：$(f \circ g)(x) = f(g(x)),\frac{\mathrm d f(x)}{\mathrm dx} = f’(x),\int f’(x) \mathrm dx = f(x) + C$ 一般生成函数OGF$$序列a的OGF：f(x)=\sum_{i=0}^{\infty} a_ix^i \\应当熟记的常见OGF： \\(1+ax)^n=\sum C_n^i (ax)^i，\frac{1}{(1-ax)^m}=\sum C_{n+m-1}^{m-1} a^nx^n\\F’(x)=\sum_n(n+1)f_{n+1}x^n,\int_0^xF(t)\mathrm{d}t=\sum_{n=1}\frac{f_{n-1}}nx^n\\$$ 序列左移：除以x，序列右移：乘x 一些练习： 证明、辅助记忆范德蒙德等式（提示：$(1+x)^{m+n}=(1+x)^m(1+x)^n$） 证明、辅助记忆二项式反演 求 $\sum i^2x^i$ 的生成函数：$(1-x)f(x)=\sum_{i=1}(2i-1)x^i,f(x)=\frac{x(x+1)}{(1-x)^3}$ 求卡特兰数的生成函数：$卡特兰数卷积形式递推,F为f的生成函数，可化出 F(x)=1+xF^2(x)\\然后考虑一下F(0)=1和洛必达法则可得 F(x)=\frac{1-\sqrt{1-4x}}{2x}，可展开验证$ 「TJOI2015」概率论 $$设g(x)为x个节点的所有二叉树叶子节点之和，G为其生成函数\\还是考虑二叉树递推，可得 G(x)=2xG(x)F(x)+x\\G(x)=\frac{x}{\sqrt{1-4x}},展开得g(x)恰好=f(x-1)$$ luogu4451 [国家集训队]整数的lqp拆分 设G为g的生成函数，$G=G*Fib+Fib-&gt;G=\frac{x}{1-2x-x^2}$ CF438E bzoj3625 The Child and Binary Tree $F=cF^2+1,牛顿迭代的话就做完了，也可以考虑洛必达法则化式子：F=\frac{1-\sqrt{1-4C}}{2C}$ ​ 虽然C没有逆元，但可以考虑怎么消掉 $F=\frac{1-(1-4C)}{2C(1+\sqrt{1-4C})}=\frac{2}{1+\sqrt{1-4C}}$ 指数生成函数EGF$$\begin{aligned}序列a的OGF： f(x)&amp;=\sum_{i=0}^n a_i \frac{x^i}{i!}，即对象是带编号的 \\F(x)*G(x) &amp;= (\sum\limits_{i = 0}^{\infty} a_i \frac{x^i}{i!})(\sum\limits_{i = 0}^{\infty} b_i \frac{x^i}{i!})= \sum\limits_{n = 0}^{\infty} (\sum\limits_{i = 0}^{\infty} {n \choose i} a_i b_{n - i}) \frac{x^n}{n!}\\\sum_{i=0}^{\infty} a^i\frac{x^i}{i!}=e^{ax}，\sum_{i=0}(-1)^i\frac{x^{2i+1}}{(2i+1)!}&amp;=sin(x),\sum_{i=0}(-1)^i\frac{x^{2i}}{(2i)!}=cos(x)，可欧拉公式推 \\ln(\frac{1}{1-x})=-ln(1-x)&amp;=\sum_{i=1} (i-1)! \frac{x^i}{i!}，\frac{-a}{1-ax}=[ln(1-ax)]’ \\\sum_{i=k}^{\infty} i^{\underline k} \frac{x^i}{i!}&amp;=x^ke^x\end{aligned}$$常见模型：长度n的序列，k种颜色随便涂的方案数=$\frac{n!}{\prod times_{col}!}$ 还有就是这东西显然和OGF是不同的，例如排列数的EGF=数列1,1,1……的OGF 序列右移：求积，序列左移：求导 ln公式证明：两边exp，左边其实是轮换，卷成置换后就是排列数的EGF，这个式子请记住其组合意义 一些练习： CF891E Lust$$\begin{aligned}考虑&amp;题意转化，发现每次乘积减少多少res就增加多少\\res&amp;=\prod a_i-E(\prod (a_i-times_i)) \\后面&amp;=\frac{k!}{n^k} \prod_i[ \sum_j (a_i-j)\frac{x^j}{j!} ] [x^k]\\&amp;=[\frac{k!}{n^k}e^{nx} * \prod_i(a_i-x)][x^k] \\&amp; =\sum_{i=0}^{min(n,k)} [\prod_t(a_t-x)][x^i]*\frac{k!}{n^i(k-i)!}\end{aligned}$$ CF632E Transforming Sequence，bzoj5381 or 收获：自变量要灵活运用$$f(n,i)(k-i)!=\sum_{j=0}^{i-1} f(n-1,j)2^j(k-j)!,设g(n,i)=f(n,i)(k-i)! \\巧妙地把2放里面，G_n(x)=G_{n-1}(2x)*(e^x-1)=\prod_{j=0}^{i-1}(e^{2^jx}-1)\\G_{2i}=G_i(x)G_i(2^ix)，倍增即可，O(nlogn)$$ 贝尔数的生成函数 稍微思考一下就知道是$e^{e^x-1}$，上标是个EGF，下面的exp表示组合起来；不过让我们练习一下怎么用递推式推导$$思考递推式B_n=\sum_{i=1}^nC_{n-1}^{i-1}B_{n-i}，不难推出Bell的生成函数B满足 B * e^x=B’ \\\int \frac{B’}{B}=\int e^x,lnB=e^x+C,B=e^{e^x+C}又因为B(0)=1,B=e^{e^x-1} \\$$ 带标号无向连通图生成函数F，无向图生成函数G，例题：bzoj3456 城市规划$$g_n=\sum_{i=1}^n C_{n-1}^{i-1}f_ig_{n-i},g_n\frac{x^{n-1}}{(n-1)!}=\sum_{i=1}^n f_i\frac{x^{i-1}}{(i-1)!}*g_{n-i}\frac{x^{n-i}}{(n-i)!}\\G’=F’*G,lnG=F+C,带入知C=-1，F=lnG+1$$ 三种简单背包计数，例题：luogu4389 付公主的背包$$Q1：体积为i（1… n）的物品有a_i种，每种物品无限个 \\Q2：体积为i（1… n）的物品有a_i种，每种物品1个 \\Q3：n种物品，第i种体积为a_i \\只需要求出\%x^n即可，大致思路：用exp和ln辅助推式子 \\exp内，枚举第k种，然后发现有值的位置满足调和级数，复杂度nlogn$$ 二元生成函数运算首先你需要会二维DFT的朴素式子，见多项式全家桶 然后我们考虑定义：$F(x,y)=\sum_i \sum_j a_{i,j}x^iy^j$ 二维卷积的快速做法：观察式子的本质，就是对行DFT然后列DFT，这样的系数矩阵对应做乘法就是二维卷积了 于是多项式全家桶依然适用，各种操作的复杂度依然是 $O(n^2logn)$ 分拆数与五边形数就是整数无序拆分，1+2和2+1是一种方案，裸题loj6268 附做题常用：$B(20)=2e2,B(40)=4e4,B(50)=2e5,B(60)=1e6,B(70)=2e7$ 如果要求拆分的数不能相同，则最多选根号种数，预处理$O(n \sqrt n)$ 然后可重复的话只能$O(n \sqrt n)$ 回答单组询问 设分拆数p(x)的生成函数 $P(x)=\prod_{i=1}^{\infty} \frac{1}{1-x^i}$ 总长是n方的，不能直接算 引入五边形数定理：$\prod_{i=1}^{\infty} (1-x^i)=1+\sum_{k=1}^{\infty} (-1)^kx^{k(3k \pm 1)/2}$，正负号位置都有系数 这玩意的证明自gdoi2018后不少：begay,cty,wiki 于是这个分母多项式有值的项只有根号个，可以 $n \sqrt n$ 手动求逆元，当然也可以fft优化 记录一个小技巧$$i(n-i)拆卷积=i(n-i)=C_{n}^2-C_{i}^2-C_{n-i}^2，考虑为两个点集间的边显然 \\准确地说应该是这种形式：a^{i(n-i)}=a^{C_n^2-C_{i}^2-C_{n-i}^2}$$ 来自loj2409「THUPC2017」小L的计算题的一个式子$$对于s \in[0,m]计算 f_s=\sum_{i=1}^n a_i^s \\这种很可能求同时求多个答案的问题考虑其生成函数F=\sum_{i=0}^{\infty}\sum_{j=1}^n (a_jx)^i=\sum_{i=1}^n (1-a_ix)^{-1} \\这玩意考虑通分的话和分治FFT很像，所以应该可以搞个多项式分数的结构体，巨大常数O(nlog^2n) \\看到分母考虑ln的导数，我们知道ln’(1-ax)=\frac{-a}{1-ax}，形式很像，考虑怎么套过去 \\(1-a_ix)^{-1}=1-x*ln’(1-a_ix),F=n-x\sum_{i=1}^n ln’(1-a_ix)=n-x*ln’[\prod_{i=1}^n(1-a_ix)] \\复杂度还是O(nlog^2n)，但常数小$$ 也有人拿去改编出题了：luogu4705玩游戏，并没有增加啥新东西但似乎蛮多人做的 不是所有推出来的东西都能用牛顿迭代搞，下面给出两个解决办法拉格朗日反演鏼爷在WC2015上的营员交流有这玩意，学习一下 zjt的博客非常详细，然而现在挂了……借助快照抄一抄 首先是一些抽象代数的知识： 通常遇到的幂级数称为F（复数域、模p数域）下的形式幂级数环$F[[x]]$ 但是这并不是域)（特殊的环，不同在于要求除零元外都有乘法逆元） 因此我们定义一个叫分式环的域$F((x))$ 然后我们考虑这会发生什么，一个多项式A如果不是零元，就可以表示为$x^tB$而B存在乘法逆元，对这个逆元$*x^{-t}$ 就是A的逆元，所以只要我们允许x的负次幂，就是一个域了 复合逆：$F^{-1}(F(x))=x$ 显然要求【F常数项=0且一次项非0】据说交换是等价的，我是一个只会背结论不会证明的呆逼 拉格朗日反演（g求f的一个系数）：$[x^n]F^{-1}(x)=\frac1n[x^{-1}]\frac1{F(x)^n}$ 证明1 证明2 然而为了方便运算咱还是把它整回到形式幂级数环，就用上面的东西自己推推就好了（求B只要/x）：$[x^n]F^{-1}(x)=\frac1n[x^{n-1}] (F(x)/x)^{-n}$ 拓展拉格朗日反演：$[x^n]G(F^{-1}(x))=\frac{1}{n}[x^{n-1}]G’(x)({F(x)/x})^n$ 例题：bzoj3684 大朋友和多叉树： $F为所求，G(x)=x-\sum_{i \in D}x^i,G(F(x))=x$ 求整个复合逆的类似BSGS的$O(n^2)$算法在他的ppt、论文上也有，有兴趣的可以了解一下 解微分方程例题：uoj50【UR #3】链式反应 即现在已知简单函数$f(B)$（可能放了一些常多项式），求解$\frac{d}{dx} B=f(B)$；考虑怎么给牛顿迭代修锅 我们继续在b（倍增上一层结果）处泰勒展开，依然只需要展开两次$$\frac{d}{dx} B=f(B)=f(b)+f’(b)(B-b),(\frac{d}{dx} B)-B * f’(b)=f(b)-f’(b)*b \\然后如果你对微积分很熟练的话（此话from炮姐，显然我不行），可以通过构造一些东西把右边搞好 \\设pp=e^{- \int f’(b)dx }，等式两边乘以pp可得（对于我这种菜鸡来说应该叫“根据积法则，不难验证等价”）\\\frac{d}{dx} (B*pp)=(f(b)-f’(b)*b)pp,B=pp^{-1}*\int pp(f(b)-f’(b)*b)\ (\%x^n)$$于是就可以倍增了，而且我们现在推导的东西具有（应该）不错的推广意义，依然是$O(nlogn)$，当然这东西套了个exp进去……常数不敢想象]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-12极限与微积分]]></title>
    <url>%2Fposts%2Fed71.html</url>
    <content type="text"><![CDATA[极限与微积分 基础内容：强烈推荐一个非常有名的up主3B1B的视频：微积分的本质 是我这种自学者的福音 __debug的数论ppt挺不错的，有很多练习题，大家可以去学习 其他 微积分实用性的精华所在：本来会有一个很复杂的式子，在dt趋于0后反而简洁了 对于某个函数，如果能求出其导函数，那么可以通过 $f’(x)=0$ 找到极值点（可导必连续） 凸函数：二阶导数非负 如果一个函数的积分存在，并且有限，则称为【可积】若定积分存在，则它是一个具体的数值，而不定积分是一个函数表达式定积分： $\int_{l}^{r}f(x)dx$ 牛顿-莱布尼茨公式： $\int_a^b f’(t)=f(b)-f(a)$ 三大微分中值定理，前一个是后一个的特例罗尔中值定理：$f(x)在(a,b)上可导且f(a)=f(b)则存在f’(pp)=0$拉格朗日中值定理：$f(x)在(a,b)上可导则存在f’(pp)=\frac{f(b)-f(a)}{b-a}$柯西中值定理：$若 f(x)、g(x)在(a,b)上可导， \forall x \in (a,b),g’(x) \neq 0$则存在pp， $\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(pp)}{g’(pp)}$ $1^2+2^2+3^2+……+n^2=\frac{n(n+1)(2n+1)}{6}$ 常用等价无穷小（当$x\to 0$时）$$(arc)sin(x)=(arc)tan(x)=x,a^x-1=x*ln(a) \\ln(1+x)=x,(1+Bx)^a-1=aBx,(1+x)^{1/n}-1=x/n \\log_a(1+x)=x/ln(a),(1+x)^a-1=ax(a≠0)$$ 拉格朗日乘数法，待学留坑，题：骑行川藏 辛普森积分，待学留坑，题：月下柠檬树 导数 复合函数求导：链式法则 $h(a)=f(g(x)),h’(a)=f’(g(x))g’(x)$ 高阶导数的表示法：$$\frac{d \frac{df}{dx}}{dx}=\frac{d^2 f}{d x^2}$$ 以此类推； 关于超实数域，权值为a的m阶无穷小记为 $a(0)^m$ ，这样有助于理解高阶微分 洛必达法则：用于求0/0或$\infty/\infty$未定式$f(x)/g(x)$的极限，$f(x)和g(x)$随x趋于a都趋于0，$f’/g’$存在极限且a某个去心邻域$g’$不为0，则两者相等 根据上面条件发现，完全可以把一阶导数继续套用求导，所以如果无穷不同阶，那么就不收敛；有个详细的推导：马同学 还有一个非常很不错的简单诠释 ，然后最近刚好碰到一道题：百度之星初赛2019R1T1 关于隐函数求导，可以把常数项c看做变量x，然后在dx意义下考虑问题 比较好看的版本 积分换元积分法$$\begin{aligned}&amp; Q：如何对 T(x)=(1-nx)^{n-1}求不定积分\\&amp; A(tkingj)：\\&amp; [f(g(x))]’=(1-nx)^{n-1}=f’(g(x))g’(x)\\&amp; 不妨猜想f为幂函数g为一次函数\\&amp; f’(x)=\frac{-1}{n}x^{n-1},f(x)=\frac{-1}{n^2}x^n\\&amp; g’(x)=-n,g(x)=1-nx\\&amp; f(g(x))=\frac{-1}{n^2} (1-nx)^n\end{aligned}$$ 关于e首先我们考虑幂函数$f(x)=a^x$ 然后发现导数总是自身的倍数，考虑这个是否存在一个a使得导数恰好为自己 这个是我比较喜欢的e的定义， 但有时人们也用这个$e=lim_{n-&gt;\infty} (1+\frac{1}{n})^n$，相关推导 所以说$e^x$可以称之为最特殊的幂函数，其他幂函数的导数可以考虑转化为这个再求导，而且lnx发散而$e^x$收敛 泰勒展开：用一个点x0的各阶函数，获得附近函数的信息，不错的教程 用多项式近似某条区间（x次多项式可求导x次），保证前n个导数相同，两个函数的差距将是高阶无穷小，然后上面a表示以x=a为切入口来近似，解方程可知 $f(x)=\sum_{i=0}^n \frac{f^i(a)}{i!}(x-a)^i+\xi$ 然后麦克劳林级数是泰勒展开在a=0时的特殊情况， $e^x=\sum_{i=0}^{\infty} \frac{x^i}{i!}$ 离散微积分YYY ，Gosper算法 贴个链接就跑路系列，大概是差分相关 对dzy-数列极限的学习笔记数列极限的定义(极限的$\epsilon—N$定义)： $\begin{matrix}\lim_{n\rightarrow \infty}x_{n}=a\Leftrightarrow\forall \epsilon &gt; 0，\exists N \in N^{+}使得n&gt;N,|x_{n}-a|&lt;\epsilon\end{matrix}$ 几何思想是数轴区间内无限、有限个点 由此可知收敛数列极限唯一，有上下界，还可以用两个夹逼另一个 收敛数列的四则运算后的极限=极限的四则运算 单调有界定理：单调且有上下界的数列必定收敛，所以调和数列（不是级数 ）是收敛的 O’Stolz定理 $若{y_n}严格单调递增到\infty（或{y_n}严格单调递减且趋于0，\lim_{n\to \infty}x_n=0），\lim_{n\rightarrow \infty}\frac{x_n-x_{n-1}}{y_n-y_{n-1}}=\lim_{n\rightarrow \infty}\frac{x_n}{y_n}$ Cauchy收敛准则：${x_n}收敛\Leftrightarrow\forall \epsilon&gt;0,\exists N,s.t. n,m&gt;N,|x_n-x_m|&lt;\epsilon$ 对dzy-函数极限的学习笔记一个函数连续指在其定义域内任一点都连续，$f(x)在x_0连续 \Leftrightarrow \lim\limits_{x\to x_0}f(x)=f(x_0)\Rightarrow \forall \epsilon&gt;0,\exists \delta &gt;0,\forall x\in O(x_0,\delta),|f(x)-f(x_0)|&lt;\epsilon$ 学不动啊跑路了]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-11集合幂级数]]></title>
    <url>%2Fposts%2Ff834.html</url>
    <content type="text"><![CDATA[集合幂级数 或者你可以直接称其为 FWT 以下主要是学习笔记（vfk在15年的论文）和自己的一些实验 所以下面的内容请配合论文来看，不然你可能会自闭的 形式集合幂级数 $f=\sum_{S \subseteq 2^U} f_S x^S$加减法很好定义，对于乘除法，我们可以自行定义各种运算 集合并卷积（你也可以叫他子集反演）核心思想：$[S_1 \bigcup S_2 \subseteq S]=[S_1 \subseteq S][S_2 \subseteq S]$ 我们不妨称现在框里的形式为点值表达法；点值表达法很好求，简单dp即可，从高到低和从低到高是一样的；不过得出结果的点值后，怎么转化回去呢？ 二项式定理可知$\sum_{s \in S} (-1)^{|s|}=[S=0]$ ，然后设f为原幂级数，g为点值表达法，然后反演来用g表达f$$g(n)=\sum_{m \in n}[n-m=0]g(m)=\sum_{m \in n} \sum_{s \in n-m}(-1)^{|s|}g(m)=\sum_{s \in n} (-1)^{|s|} \sum_{m \in n-s}g(m)=\sum_{m \in n} (-1)^{|n|-|m|} f(m)$$集合交也是类似的，就不赘述了 另一种理解思路，符号为 $g(S,k)$ 表示统计所有 $C_S T\in [1..k]$ 的子集T，从k=0开始dp，有些动态维护的题目需要这样表示（疯狂暗示其实是碰到过来加上的）；然后如果这样完整表达，你按啥顺序dp都行，例如先第一维再第二维 那么加减乘都资瓷了，这个卷积的逆运算的话，就是在点值表达法下直接除不能理解原理的话，把check写出来，不用运行你都会发现是正确的（指观察代码的形式，当然并没有考虑唯一性等问题）……所以说不定用二次剩余开根都行 ###集合对称差卷积 $[S=\emptyset]=\frac{1}{2^n} \sum_{T \subseteq U} (-1)^{|T \bigcap S|}$那么现在的式子就是 $B_S=\sum_{T \subseteq U} (-1)^{|T \bigcap S|} A_T$考虑递推，$B[S][i]$表示当前只统计和S的异或值为 $2^i-1$ 的子集的T那么每次把这一位不同、后面相同、前面任意的统计进去（然后你会发现自己没有被统计，应作为$B[S][-1]$）$B[S][i]=B[S][i-1]-B[S|2^i][i-1],B[S|2^i]=B[S][i-1]+B[S|2^i][i-1]$然后有个更简单的写法： $B[S][i]=B[S][i-1]+B[S|2^i][i-1],B[S|2^i]=B[S][i-1]-B[S|2^i][i-1]$这个就不用前面那步了，本质上是一样的，因为 $B[S|2^i][i-1]$ 里面这一位都是1，等价于把-1放到中间去乘 子集卷积或为S并为空，相当于两个不重叠集合的拼接，感觉不少状压都是这种形式将条件转化为 $a \bigcup b=S且|a|+|b|=|S|$可以看作是一个集合幂级数的或运算（异或也行）套一个形式幂级数的乘法，暴力枚举做即可，但要去除没有意义的地方（二进制与位长不符的地方）然后逆运算的话，和上面思路不太一样（显然上面的方法不能再用了）考虑每个位置在点值表达法下， $C_t=\sum A_i B_{t-i}$那么现在求B的话可以递推，把其他B移到左边，除A0即可（经典的求递推方法） 经典题【HAOI2015】按位或【WC2018】州区划分雅礼冬令营集训2019 D8t1 bzoj5092 分割序列先求出前缀异或值，然后就是 $S_j+(S_i \ xor \ S_j)$ ，当Si=1，怎么选都是1，否则如果Sj=1就是2，所以记录一个mask表示当前希望的Sj一定是mask的超集，所以fwt预处理好f(S)表示S的超集最左边在哪里 1234567891011121314151617int a[N],pp[1&lt;&lt;21];//超集void main()&#123; int n=qread();for(int i=1;i&lt;=n;i++) a[i]=qread()^a[i-1]; memset(pp,0x3f,sizeof pp);for(int i=n;i&gt;=1;i--) pp[a[i]]=i;pp[0]=0; for(int j=0;j&lt;=20;j++) for(int i=(1&lt;&lt;21)-1;i&gt;=0;i--) if((i&amp;bin(j))) chmin(pp[i^bin(j)],pp[i]); for(int i=1;i&lt;=n;i++) &#123; int ans=0,mask=0; for(int j=20;j&gt;=0;j--) &#123; if(a[i]&amp;bin(j)) ans+=bin(j); else if(pp[mask|bin(j)]&lt;=i) mask|=bin(j),ans+=bin(j+1); &#125; write2(ans); &#125;&#125; 一道类似的题：Manthan, Codefest 19 CF1208F Bits And Pieces HDU6679 度度熊与运算式 2首先转化题意，最大值一定是n+1，然后改异或的话要求不能进位即重叠，记$a_i$表示第i个？左边有多少个1，$a_{m+1}=n+1$ ，那么就是选一个集合要求最后一个元素是n+1且前面每个都是后面的子集 不难设计$dp(S)$ 表示以S为结尾的方案数，转移即 $dp(S)=\sum_{T \subset S}dp(T)$，考虑 $g(S)$ 表示S的子集和 因为要求这个必须求好前面，考虑类似分治fft的快速递推，考虑怎么动态做FMT，首先FMT如果要动态做，肯定要保留中间状态即上面所说的 $dp(S,k)$ 表示处理了k位，然后这种状态想怎么dp都行，考虑到现在是从小到大优化dp过程，所以先枚举第一维S，把$g(S)$给FMT出来，但如果当前是dp位置（即？处）的话，我们求出的只是 $dp(S)$ ，所以放到dp(S,0)处重新做一次FMT求出g $O(n2^n)$ ，然而HDU的机子很慢，比赛时myh的ac代码都会tle 12345678910111213141516171819202122char str[N];int a[(1&lt;&lt;21)+4][22];void main()&#123; int T=qread(); while(T--) &#123; scanf("%s",str+1);int n=strlen(str+1); int mx=ceil(log2(n+2));a[0][0]=1; for(int i=0;i&lt;=n+1;i++) &#123; //这里直接写成放进a[i][0]也行 if(i) a[i][0]=0; for(int j=0;j&lt;mx;j++) if(i&amp;(1&lt;&lt;j)) a[i][j+1]=mm(a[i][j]+a[i^(1&lt;&lt;j)][j]); else a[i][j+1]=a[i][j]; if(i and i&lt;=n and str[i]=='?') &#123; a[i][0]=a[i][mx]; for(int j=0;j&lt;mx;j++) if(i&amp;(1&lt;&lt;j)) a[i][j+1]=mm(a[i][j]+a[i^(1&lt;&lt;j)][j]); else a[i][j+1]=a[i][j]; &#125; &#125; printf("%d %d\n",n+1,a[n+1][mx]); &#125;&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-10积性函数及其前缀和]]></title>
    <url>%2Fposts%2F416d.html</url>
    <content type="text"><![CDATA[积性函数，及其前缀和（杜教筛、min25筛） 很多可以拿去容斥，但本章主要关注其【积性函数】这个性质 狄利克雷卷积常见积性函数： 约数函数 $\sigma_k(n)=\sum_{d|n}{d^k}$，约数个数 $\tau(n)=d(n)=\sigma_0(n)$，约数和 $\sigma(n)=\sigma_1(n)$ 莫比乌斯函数 $\mu(n)$，欧拉函数 $\varphi(n)=n \prod \frac{p_k-1}{p_k}$ 元函数（或$\epsilon$）$e(n)=[n=1]$ ；恒等函数（或1）$I(n)=1$ ；幂函数$id_k(n)=n^k$；不知叫啥的函数$\lambda(n) = (-1)^n$ 狄利克雷Dirichlet卷积：$(f*g)(n) = \sum_{d|n} f(d) g(\frac{n}{d})$，满足交换律和结合律，两个积性函数的狄利克雷卷积也是积性函数 常用式子（下面很多都可以拿去反演，而且你会发现mu在数论中是个很强的容斥系数）：莫比乌斯反演：$\mu *1=e$欧拉反演$\varphi * 1=id、\mu \ast id=\varphi$$d=1*1、1=\mu * d$$\sigma=id*1、id=\mu*\sigma、\sigma=\varphi * d$ 不一定互质两数乘积： $d(a \cdot b)=\sum_{x|a} \sum_{y|b} [gcd(x,y)=1]$$\sigma(a \cdot b)=\sum_{x|a} \sum_{y|b} [gcd(x,y)=1] \frac{ay}{x}$这个东西没接触过的话应该挺难想的吧；证明的话我不会推广，所以就不给出来了所谓推广即，多个数乘积，要求各个约数两两互质 杜教筛经典文章 假设现在是求f的前缀和F主要思路就是搞出一个 F(n)的递推式那么构造另外两个积性函数g和h，要求这个h的前缀和很好求$$\begin{aligned}&amp; h=f*g \\&amp; \sum_i h(i)=\sum_i \sum_{d|i} f(\frac{i}{d}) g(d)=\sum_d g(d) F(n/d) \\&amp; 然后我们把g(1)提出来 \\&amp; g(1)F(n)=\sum_i h(i)-\sum_{i=2}^n F(n/i)\end{aligned}$$直接递归，复杂度 $T(n)=O(\sqrt{n})+\sum_{i=1}^{\sqrt{n}}{T(i)+T(\frac{n}{i})}$然后据说只要展开一次， $T(n)=\sum_{i=1}^{\sqrt{n}}{O(\sqrt{i})+O(\sqrt{\frac{n}{i}})}=O(n^\frac{3}{4})$因为f是个积性函数，比较小的部分可以线筛，设预处理的范围为K，在 $K=O(n^{2/3})$ 的时候取到总复杂度为 $O(n^{2/3})$ ，怎么得出来的我就不太懂了……跑了大概能跑1e11，时间推导 这里保证复杂度不要求是积性函数，而是要求这个f的预处理部分能线性求出前缀和，然后能在根号x的时间内求出单个h(x)的前缀和 还有就是实测不开hash的话会很慢然后有种奇妙的快速方案，类似这样： 1#define id(x) x&lt;=UB?x:(n/(x)+UB) 测板子可以用f(i)=i phi的前缀和：$\varphi \ast I=id$mu的前缀和：$\mu \ast I=e$例题：51nod1244、【luogu3768】简单的数学题 板子：51nod1244请先思考后再展开 123456789101112131415161718192021222324252627282930313233343536bool mark[MAX_N];int pp=0,prime[MAX_N/10],mu[MAX_N];void pre()&#123; mu[1]=1; for(int i=2;i&lt;MAX_N;i++) &#123; if(!mark[i]) prime[++pp]=i,mu[i]=-1; for(int j=1;j&lt;=pp and (ll)i*prime[j]&lt;MAX_N;j++) &#123; int t=i*prime[j];mark[t]=1; if(i%prime[j]==0)&#123;mu[t]=0;break;&#125; mu[t]=-mu[i]; &#125; &#125; for(int i=2;i&lt;MAX_N;i++) mu[i]+=mu[i-1];&#125;ll N;struct M&#123; ll aa[100001],bb[100001];void clear()&#123;for(int i=0;i&lt;=100000;i++) aa[i]=bb[i]=-LLINF;&#125; ll ask(ll n)&#123;return (n&lt;=100000)?aa[n]:bb[N/n];&#125; void insert(ll n,ll num)&#123;(n&lt;=100000)?(aa[n]=num):(bb[N/n]=num);&#125;&#125;mp;ll getmu(ll n)&#123; if(n&lt;MAX_N) return mu[n]; ll tmp=mp.ask(n);if(tmp!=-LLINF) return tmp; ll ans=0;for(ll l=2,r;l&lt;=n;l=r+1) r=n/(n/l),ans+=getmu(n/l)*(r-l+1); mp.insert(n,1ll-ans);return 1ll-ans;&#125;void main()&#123; pre();ll ans; N=qread()-1;mp.clear();ans=-getmu(N); N=qread();mp.clear();ans+=getmu(N);write(ans);&#125; 洲阁筛不会告辞 min25筛另一份教程 这东西搞了足足一天……然后我并没有好好看zzt的论文，所以并不会证复杂度（其实也不知道自己复杂度对不对）甚至不确定复杂度到底是多少（论文里有证明，但我没找到结论，然后网上说法各异）大概能跑1e10zzq速度是我的5倍 然后似乎主要有两种做法（递推和递归）和两种实现（枚举最小质因子与否）然后我的做法是递推、不枚举最小质因子，这样似乎单组慢一些，但能顺便求出所有[n/i]的前缀和 首先，我们希望求的依然是积性函数的前缀和，先考虑做法，再考虑适用条件首先积性函数在x=素数时，大部分能表达为一个p相关多项式的形式，那么设当前项的次幂为k下述做法建议速览一遍后自行推导，注意到利用【f是积性函数】、【合数最小质因子在根号内】$$\begin{aligned}&amp; S(n)=\sum P_i^k，S2(n)=\sum f(P_i)，minp(n)=n的最小质因子，pp为 \sqrt n 内素数个数 \\&amp; 先考虑计算素数部分，设g(n,j)=\sum_{minp(i)&gt;P_j 或 i \in P} i^k，那么所求即g(n,pp) \\&amp; 从j-1转移，考虑要去掉什么且只能去掉什么，乘法原理组合出合数 \\&amp; g(n,j)=g(n,j-1)-[P_j^2 \leq n] P_j^k (g(n/p_j,j-1)-S(j-1)) \\&amp; 在考虑利用g求f的和，设w(n,j)=\sum_{minp(i) \leq P_j 或 i \in P} f(i) ，边界用g的多项式求 \\&amp; 从j+1转移，暴力枚举当前质因子的次幂，考虑要增加什么且只能增加什么 \\&amp; w(n,j)=w(n,j-1)+\sum_{t=1}^{P_j^{t+1} \leq n} (w(n/P_j^t,j+1)-S2(j))f(P_j^t)+\sum_{t=2}^{P_j^t \leq n} f(P_j^t)\end{aligned}$$补充一下，上面的两次容斥，都要考虑枚举范围的不等式带来的推论，形如 $n/P_j \leq P_j$ 然后我们考虑如何减小空间复杂度（时间我真管不了，不过写法会影响时间）先处理出[n/i]的所有取值，降序排序，先筛g，第二维是可以滚的，第一维离散存注意到很多时候一些n是可以直接保留j-1的值的，所以可知复杂度低于n（大雾如果仅仅是没理解这段可参考代码，很短很清晰 分析min25筛的适用条件虽然上面的求和用到了积性函数的性质，但是很多时候不是积性函数，也可以灵活地改定义去求那么这类解决方法的必须条件是：在x=素数时，要求能表达为一个多项式的形式（所以像这种 $f(p^c)=p xor (c+1)$ 就不能筛）然后还需要快速求出 $f(p^k)的值$ 板子：loj6053，单独考虑偶素数2请先思考后再展开 1234567891011121314151617181920212223242526272829303132333435363738bool mark[MAX_N];int pp=0,p[MAX_N];int S0[MAX_N],S1[MAX_N];void pre(int mxn)&#123; for(int i=2;i&lt;=mxn;i++) &#123; if(!mark[i]) p[++pp]=i,S0[pp]=pp,S1[pp]=(S1[pp-1]+i)%MOD; for(int j=1;j&lt;=pp and (ll)i*p[j]&lt;=mxn;j++) &#123; mark[i*p[j]]=1; if(i%p[j]==0) break; &#125; &#125;&#125;ll a[MAX_N],N,md;#define id(x) ((x)&lt;=md?a[(x)]:a[md+N/(x)])vector&lt;ll&gt; num;//递减int g0[MAX_N],g1[MAX_N],w[MAX_N];void main()&#123; N=qread();pre(md=sqrt(N));if(N==1) &#123;puts("1");return;&#125; for(ll l=1,r;l&lt;=N;l=r+1) r=N/(N/l),id(N/l)=num.size(),num.PB(N/l); int m=num.size(); for(int t=0;t&lt;m;t++) g0[t]=(num[t]-1)%MOD,g1[t]=(num[t]+2)%MOD*((num[t]-1)%MOD)%MOD*((MOD+1)/2)%MOD;//k=0/1 for(int j=1;j&lt;=pp;j++) for(int t=0;t&lt;m and (ll)p[j]*p[j]&lt;=num[t];t++) &#123; g0[t]=g0[t]-(g0[id(num[t]/p[j])]-S0[j-1]),g0[t]%=MOD; g1[t]=g1[t]-ll(g1[id(num[t]/p[j])]-S1[j-1])*p[j]%MOD,g1[t]%=MOD; &#125; for(int t=0;t&lt;m;t++) w[t]=g1[t]-g0[t]+(num[t]&gt;=2?2:0),w[t]%=MOD;//k=0/1 for(int j=pp;j&gt;=1;j--) for(int t=0;t&lt;m and (ll)p[j]*p[j]&lt;=num[t];t++) for(ll now=p[j],k=1;now&lt;=num[t];now=now*p[j],k++) &#123; if(now*p[j]&lt;=num[t]) w[t]+=ll( w[id(num[t]/now)]-(S1[j]-S0[j]+2) )%MOD*(p[j]^k)%MOD,w[t]%=MOD; if(k&gt;1) w[t]+=p[j]^k,w[t]%=MOD; &#125; write((w[0]+1+MOD)%MOD);&#125;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-9自然数幂和]]></title>
    <url>%2Fposts%2F1f2a.html</url>
    <content type="text"><![CDATA[自然数幂和的几种解法，可以感受一下各种数学工具的特性，也是经典的求和问题 话说这东西位置放错了来着qwq请学完全家桶、生成函数再来 方案一，知道k求关于n的多项式结论：对于某个k，自然数幂和可以表示为一个n为未知数的k+1次多项式 这个可以观察、归纳之类的，然后你看了下面的做法求出来的东西，发现也是满足的 于是可以高斯消元 $O(k^3)$ ，比较适合有的时候推式子要用，写个代码就不用背结论（如k=3、4）了 不过既然是多项式，自然的思路应当是拉格朗日插值，直接套式子，$O(k)$，就是处理前缀积和后缀积和阶乘的逆元，然后$i^k$用线性筛求 方案二，用第二类斯特林数把幂展开$a^b=\sum_{i=1}^a S_2(b,i) \cdot i! \cdot C_a^i，\sum_{i=0}^n i^k=\sum( \sum_{j=1}^k S_2(k,j) \cdot j! \cdot C_i^j )$这里的组合数是广义的（其实在这里主要是想忽略大小关系，后面都是0）因为希望和k有关，把j提出来$\sum_{j=1}^k S_2(k,j) \cdot j! \times ( \sum_{i=0}^n C_i^j )$然后根据组合数的性质$\sum_{j=1}^k S_2(k,j) \cdot j! \times C_{n+1}^{j+1}$那么预处理一下下降幂即可，时间复杂度下界为$O(klogk+qk)$ 类似思想：bzoj5093，比较套路 方案三，生成函数n固定，mlogm求所有k=[0,m]的幂和（注意这个的适用问题和另外三个不同）$$考虑S_k关于n的生成函数S(x)=\sum_{k=0}^{\infty}S_k(n)\frac{x^k}{k!}=\sum_{k=0}^{\infty}\sum_{i=0}^n i^k\frac{x^k}{k!}=\frac{e^{(n+1)x}-1}{e^x-1}$$ 那么多项式求逆即可 方案四，伯努利数这个数是怎么定义的我纯属瞎编，想了解的请看知乎$$\begin{aligned}S(x)&amp;=\frac{e^{(n+1)x}-1}{e^x-1}，考虑将于n无关的部分取出 \\&amp;=(\frac{1}{e^x-1})(e^{(n+1)x}-1),但左边并不是一个完整的EGF \\&amp;=(\frac{x}{e^x-1})(\frac{e^{(n+1)x}-1}{x})，我们不妨称左边的为Bernoulli数 \\[x^k]S(x)&amp;=\sum_{i=0}^k \frac{(n+1)^{i+1}}{(i+1)!}*\frac{B_{k-i}}{(k-i)!}\end{aligned}$$然后你会发现，这个东西处理自然数幂和非常王，数列本身跟k无关，预处理好后可以O(k)回答所有(n,k) 那么考虑怎么求这个数，首先直接用其EGF，klogk是没问题的 递推式：$[n=1]=[x^n]B(x)(e^x-1)=\sum_{i=0}^{n-1} \frac{B_i}{i!(n-i)!}$ 板子 51nod1258 序列求和 V4 （太懒了还没写），以及这个系列的其他题目，V2和V5写了题解 其他例如可以用离散微积分（第一类斯特林数处理下降幂） 还有一个叫扰动法的玩意 反正见MoebiusMeow 以及 miskcoo]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-8反演与容斥]]></title>
    <url>%2Fposts%2F3b5e.html</url>
    <content type="text"><![CDATA[反演与容斥 计数的核心技能 反演强烈推荐vfk的ppt，对初学者很友好，特别详细 因为我比较懒，如果下面式子省略太多没看懂，可以同步看cjfdf 框架一元反演的基本原理：$$f(n)=\sum_k a_{n,k}g(k),g(n)=\sum_k b_{n,k}f(k)，已知b求a \\f(n)=\sum_k a_{n,k} \sum_m b_{k,m}f(m)=\sum_m f(m) \sum_k a_{n,k}b_{k,m},即\sum_k a_{n,k}b_{k,m}=[n=m] \\$$于是本质就是找到b的逆矩阵a，用于反演，当b是特殊的数的时候用一些结论加速 组合数的反演：$ \sum_{k = 0}^{n}{(-1)^k\binom{n}{k}} = [n = 0]$，极度常见 莫比乌斯函数的反演：$\sum_{d \mid n} \mu(d) = [n = 1]$ 二元反演： 类似 $c_r = \sum_{p, q} [f(p, q) = r] a_p b_q$ 这样的东西 fft其实就是单位根反演+单位根的一些性质，fwt也有类似的思想；你会发现他们都是做正变换、搞起来、再逆回去 莫比乌斯反演（ppt中提到多重集合和莫比乌斯函数的联系，可以看看） 证明：当 $[n=1]=\sum_{d|n} \mu(d)$k为奇数显然，k为偶数用逆的二项式定理，k-i的奇偶性和i的奇偶性相同其实就是 $I \ast \mu=e$ 证明： $\sum_{d|n} \frac{\mu(d)}{d}=\frac{phi(n)}{n}$$\sum_{d|n} (\mu(d) \prod p_{oth_i}) =\prod (p_i -1)$观察法可知，两边项数相同，而且对于一个含有t个p的项，其系数由其他括号的-1贡献，次幂和左边相同 典型问题：已知$f(n)=\sum_{d|n}g(d)$ 问用g表示f 方法： 先说一句废话 $g(n)=\sum_{m|n}[n/m=1]g(m)$ 然后带入就好了，倍数版也是类似的 $g(n)=\sum_{m|n} g(m) \sum_{md|n} \mu(d)=\sum_{d|n} \mu(d)f(n/d)$ 莫反入门题表popoqqq 好题： 【WC2014】时空穿梭 百度之星2019初赛R3C 算术 ，一道不是很难的莫反题，但却教我做人 主要是考虑到i和j是等价的，不应该把D给某一方，而是 $\mu(ijD)=[gcd(i,j)=1]\mu(iD)\mu(jD)\mu(D)$ UR#5 怎样跑得更快 $$\sum_{j=1}^n f(gcd(i,j)) \cdot g(i) \cdot h(j) \cdot x_j=b_i \\考虑f(n)=\sum_{d|n}f_r(d)，实际意义是什么并不重要，反演就能求 \\\sum_{j=1}^n \sum_{d=1}^n [d|i][d|j] f_r(d) \cdot h(j) \cdot x_j=b_i/g(i) \\\sum_{d=1}^n [d|i]f_r(d)[ \sum_{d|j} h(j) \cdot x_j]=b_i/g(i) \\\sum_{d|i} f_r(d) gg(d)=gg2(i)，gg2、f_r都已知，可以反演得到gg \\gg(d)=\sum_{d|j} h(j)x_j ，反演得右边即可$$ 这就是传说中的“三次反演掷地有声——vfk”，code 二项式反演$$f_n = \sum_{i=0}^n {n \choose i} g_i \Leftrightarrow g_n = \sum_{i=0}^n (-1)^{n-i} {n \choose i} f_i$$证明，miskcoo 斯特林反演$g_k=\sum_{i=k}^n S_2(i,k) f_i \leftrightarrow f_k=\sum_{i=k}^n(-1)^{i-k} S_1(i,k) g_i$ 证明 例题：异或图 、Square（那场模拟赛的C） 单位根反演快速多项式乘法和本反演用的应该是单位根（复数和原根）的不同性质（当然循环卷积部分用的是一样的） $[n\%d=0]=\frac{1}{d} \sum_{k=0}^{d-1} \omega_d^{nk}$，证明考虑等比数列 然后这个东西配合生成函数的理论很好用 另外对于d=2蛮常见的，可以不看做是单位根反演$$现在有一个函数 f(x)=\sum_{i=0}^N a_ix^i，求g(x)=\sum_{i=0}^n a_i[i\%d=0] \\= \sum_{i=0}^n a_i \frac{1}{d}\sum_{k=0}^{d-1}\omega_{d}^{ik}= \frac{1}{d} \sum_{k=0}^{d-1} \sum_{i=0}^n a_i(\omega_{d}^k)^i= \frac{1}{d} \sum_{k=0}^{d-1} f(w_d^k) \\$$这样就可以计算某些f点值很好算而要求算倍数项系数的题目了，比较常见的是f套二项式定理 loj6485 LJJ 学二项式定理,code$$\begin{aligned}f(x)&amp;=\sum_{i=0}^nC_n^iS^ix^i=S^n(S^{-1}+x)^n \\ans&amp;=\frac{1}{4} \sum_{r=0}^3 a_r \sum_{k=0}^3 \omega_4^{-rk}f(\omega_4^k) \\\end{aligned}$$bzoj3328 PYXFIB，记得模数不定要自己求原根来着……code$$fib用矩乘A^i算，然后A和I都是正方形，二项式定理同样适用\\f(x)=\sum_{i=0}^n C_n^i A^i*I^{n-i} \ x^i=(Ax+I)^n\\ans=\frac{1}{k}\sum_{i=0}^{k-1} f(\omega_k^i)$$uoj450 【集训队作业2018】复读机,code$$\begin{aligned}考虑EGF，ans&amp;=(\sum_{i=0}^\infty [d|i]\frac{x^i}{i})^k n![x^n] \\单位根反演&amp;=\frac{n!}{d} (\sum_{j=0}^{d-1} \sum_{i=0}^\infty \frac{( \omega_d^j x)^i}{i})^k [x^n] \\&amp;=\frac{n!}{d} (\sum_{j=0}^{d-1} e^{\omega_d^jx}) [x^n] \\分类讨论d的值，&amp;然后二项式展开来计算，然后把e^t还原 \\k=2,ans&amp;=\frac{n!}{2^k}(\sum_{i=0}^k C_k^ie^{(2i-k)x}) [x^n]=\frac{1}{2^k}\sum_{i=0}^k C_k^i (2i-k)^n \\k=3,ans&amp;=\frac{1}{3^k}\sum_{i=0}^k \sum_{j=0}^{k-i}C_k^iC_{k-i}^j (i+\omega_3^1j+\omega_3^2(k-i-j))^n\end{aligned}.0$$ min-max容斥（最值反演）（2019.8 重写了一遍） 注意下面的大小关系都是可以我们自己定义的，并不一定是数字的大小，比较常见的应用是期望 然后我们假定容斥系数只跟集合的大小有关（核心），然后假设我们现在求的是第k小$$枚举非空子集T，kth(S)=\sum_{T \subseteq S} A(|T|) min(T)，考虑第n小元素的系数 \\[n=k]=\sum_{i=0}^{|S|-n} C_{|S|-n}^i A(i+1)，考虑化成二项式反演的形式 \\C(x)=[|S|-x=k]=\sum_{i=0}^x C_x^i (B(i)=A(i+1)) ) \\B(x)=\sum_{i=0}^x (-1)^{x-i}C_x^i [|S|-i=k]=(-1)^{x-(|S|-k)}C_x^{|S|-k} \\kth(S)=\sum_{T \subseteq S} (-1)^{(|T|-1)-(|S|-k)} C_{|T|-1}^{|S|-k} min(T) \\特例：max(S)=\sum_{T \subseteq S} (-1)^{(|T|-1)} min(T)$$题：HAOI2015 按位或、luogu4707 重返现世 UNR1 合唱队形、PKUWC2018 随机游走 这个也可以推到gcd和lcm中，就是对每个质因子考虑其次数 $lcm(S)=\prod_{T \subseteq S} gcd(T)^{(-1)^{|T|}-1}$ 例题：bzoj4833 [Lydsy1704月赛]最小公倍佩尔数 （需要掌握fib的那几条性质，见定理杂烩）$$枚举非空子集T，g(n)=\prod_{D=1}^n (P_D)^{ f(D)=\sum_T [gcd=D] (-1)^{|T|+1} }\\f(D)=\sum_d \mu(d)\sum_{d|num}^{n/D}\sum\sum … (-1)^{|T|+1}，mx=\lfloor \frac{n}{dD} \rfloor \\考虑二项式定理，f(D)=\sum_d \mu(d)(-\sum_{t=1}^{mx} C_{mx}^t (-1)^t) \\=\sum_d \mu(d)(-(mx^0-1))=-\sum_d \mu(d)[dD \le n] \\g(n)=\prod_{D=1}^n (P_D)^{ sum\mu(n/D) } \\考虑到\lfloor (n-1)/D \rfloor \ne \lfloor n/D \rfloor 当且仅当 D|n$$ 故预处理好mu及其逆元，nlogn预处理每个数的约数，逐个求出g即可，$O(nlogn)$ 然而不知道为什么奇慢无比，不满3e6的nlogn本机都要5s，bzoj过不去…… 1234567891011121314151617181920212223242526vc&lt;int&gt; dd[N];int P[N],invP[N];void main()&#123; pre(); for(int i=1;i&lt;N;i++) for(int j=i;j&lt;N;j+=i) dd[j].PB(i); P[1]=invP[1]=1; int T=qread(); while(T--) &#123; int n=qread();MOD=qread(); int ans=1; for(int i=2,gg=1;i&lt;=n;i++) &#123; if(i&gt;1) P[i]=((ll)P[i-1]+P[i-1]+P[i-2])%MOD,invP[i]=invm(P[i]); for(int t=0;t&lt;(int)dd[i].size();t++) &#123; int D=dd[i][t]; if(mu[i/D]==1) gg=(ll)gg*P[D]%MOD; else if(mu[i/D]==-1) gg=(ll)gg*invP[D]%MOD; &#125; ans=(ans+(ll)gg*i)%MOD; &#125; write2(ans); &#125;&#125; 51nod1355 斐波那契的最小公倍数 ，比这题更简单 其他反演欧拉反演：$n=\sum_{d|n} \varphi(d)$空集反演：$[S=\emptyset]=\frac{1}{2^n} \sum_{T \subseteq U} (-1)^{|T \bigcap S|}$ 容斥并没有werkeytom强，讲些简单的 一个经典例子是dwjshift夺WC-CTSC-APIO三金的故事 对于每个人，设其贡献大小为i，总贡献大小为n，$系数=\sum_{i=1}^n C_n^i(-1)^{i+1}=-([n=0]-1)=1$ 广义容斥先不讲了，大概就是二项式反演，见经典题bzoj4665已经没有什么好害怕的了、HAOI2018 染色 有的时候你需要对带权值的东西容斥，例如CEOI2019游乐园，因具有一定针对性，就写在那边了；类似的还有uoj193【UR#14】人类补完计划 然后还有一道可以做的题：玲珑学院1138 震惊，99%+的中国人都会算错的问题$$ans=\sum_{集合S} f(|S|) \lfloor \frac{n}{lcm(S)} \rfloor,其中f为容斥系数，我们希望\sum_{i=1}^nC_n^if_i=n\%2，这里f可以n^2求，但其实是可以计算的 \\二项式反演，f_n=\sum_{奇i=1}^n(-1)^{n-i}C_n^i=(-1)^{n-1} \sum_{奇i=1}^nC_n^i=(-2)^{n-1}，因为组合数的系数项和偶数项相等$$ 题单理论上都写了题解 agc005 D - ~K Perm Counting 各种图计数，都挺不错的，见【快乐计数】 【ZJOI2016】小星星 ARC093F Dark Horse]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>斯特林反演</tag>
        <tag>二项式反演</tag>
        <tag>单位根反演</tag>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-7组合数学]]></title>
    <url>%2Fposts%2F5905.html</url>
    <content type="text"><![CDATA[组合数学 组合数$$P(n,m)=n\times (n-1)\times (n-2)……(n-m+1)=\frac{n!}{(n-m)!}$$ $$C(n,m)=\frac{P(n,m)}{P(m,m)}=\frac{n!}{m!(n-m)!}$$ 性质：详见这里补充： 除n=0，奇数和偶数项之和相等，证明:$\sum_{i=0}^n(-1)^iC_n^i=[n=0]$，把奇数i移到等式右边即可 $\sum_{i=j}^n C_i^j=C_{n+1}^{j+1}$，证明可以考虑组合意义：路径数$\sum_{i=0}^r C_{m+i}^i=C_{m+r+1}^r，用组合递推证明$$\sum_{i=a}^n C_i^a C_{n-i}^b = C_{n+1}^{a+b+1}$，第一眼看去可能会觉得是$C_n^{a+b}$，然而注意到位置i上不一定是第a个；考虑怎么修，不妨加入一个，变成在n+1中选a+b+1个，然后枚举第a+1个在i+1处，左边i选a，右边n-i选b$C_n^i C_i^j=C_n^j C_{n-j}^{i-j}$，证明：组合意义范德蒙德卷积： $\sum_{i=0}^k C_n^i C_m^{k-i} = C_{n+m}^k$ 证明：生成函数 题：【Arc102E】Stop. Otherwise、「SHOI2017」组合数问题 多重集也就是允许元素重复的广义集合，表示为$S={a_1 \cdot n_1,a_2 \cdot n_2,…a_k \cdot n_k}$，其中a表示元素 全排列=$\frac{n!}{n_1! \times n_2! … \times n_k!}$ 组合：设选r个，先考虑较为特殊的$r \leq n_i (\forall i \in [1,k])$，例题：Counting Swaps然后我们就能直接把问题转化为求 $S={r \cdot 0,(k-1) \cdot 1}$ 的全排列，所以得到 $\frac{ (r+k-1)! }{r! \times (k-1)!}=C_{r+k-1}^{r}$ 那如果不是这样特殊的r个呢？对问题取补，$ans=C_{r-k+1}^{r}-非法数量$而非法数量，就是说存在一个i，取的数量达到了$n_i+1$ 那么我们枚举出每个数的非法情况，然后每个非法的数字，都先定向删除$n_i+1$个，然后照常取【$r-已经删除的数量$】个 因为状态的重复，联想一下小学的时候学的简单容斥，不难算出如果非法数量num是奇数，就减去，偶数就补回去；具体实现可以枚举二进制数来搞 例题：CF451E Devu and Flowers 二项式定理$$(a+b)^n=\sum_{i=0}^nC_n^i \timesa^i \timesb^{n-i}$$深入运用 牛顿广义二项式定理，将k拓展到实数域条件： $0 \leq |a| \le |b|$$(a+b)^k=\sum_{i=0}^\infty {k \choose i} a^i b^{k-i}$其中组合数：显然这个广义是兼容狭义的 Catalan数与拓展组合意义：有多少个【1和-1都是n个】的序列满足【任意前缀$\ge0$】、不同形态二叉树 $Cat_n=C_{2n}^n-C_{2n}^{n-1}=\frac{C_{2n}^n}{n+1}=\sum Cat_a \times Cat_{n-a-1}$ 左边推中间下面讲，右边推过去我只会生成函数搞，并不会怎么组合意义 Catalan数： 首先总量是 $C_{2n}^n$ ，然后考虑对于每个非法方案，一定存在一个最小的x使得$[1]-[-1]&lt;0$（其实一定是-1），将1到m部分翻转，一定唯一对应一个$(n+1,n-1)$的序列，而且反过来考虑这个序列最小的m，你会发现它是个双射 拓展：n个1m个-1，求多少个方案满足存在一个最小m使得$[1]-[-1]\ge k$ 即当前是$(x+k,x)+(n-x-k,m-x)$同样考虑翻转左边 $(x,x+k)+(n-x-k,m-x)=(n-k,m+k)$ 和上面类似，也是个双射，故方案为 $C_{n+m}^{m+k}$ （另需特判特殊情况） 这个拓展主要是做CF1204E Natasha, Sasha and the Prefix Sums收获的 斯特林数Stirling数各种性质（不知道有没有用） 然后洛谷的4个板子都可以做一做 第一类Stirling数（斯特林轮换数）组合意义：n个不同的人，放入m个圆排列（内部顺序不同为不同方案），不能有空递推式可考虑n放入新的排列，或者放在前面n-1个人中某个的右边 $S_1(n,m)=S_1(n-1,m-1)+(n-1)S_1(n-1,m)$边界： $S_1(0,0)=1，S_1(n,0)=0 (n \geq 1)，x^{\overline{n}} = \sum_{i=0}^{n} S_1(n,i) x^i$ 求一行：用分治fft求上升幂求系数，$T(n)=2T(n/2)+nlogn=nlog^2n$ 然后存在一个log的做法，主要思路是 $T(n)=T(n/2)+nlogn=nlogn$ ，也就是通过倍增，只分治一边，那么我们的目标就是用前者求出 $f_{2n}(n)=f_n(n)f_n(n+x)$ 中的后者，code$$\begin{aligned}F_n(x+n)&amp;=\sum_{i=0}^{n}a_i (x+n)^i=\sum_{i=0}^{n}a_i\sum_{j=0}^i{i\choose j}n^{i-j}x^j\\&amp;=\sum_{j=0}^{n} ( b_j=\sum_{i=j}^{n} n^{i-j} {i \choose j} a_i ) x^j\\A[i-j]&amp;=\frac{n^{i-j}}{(i-j)!},B[n-i]=i!a_i,C[n-j]=j!b_j\end{aligned}$$ 求一列：正所谓斯特林轮换数，考虑轮换，$S_1(xxx,m)的EGF为=\frac{1}{m!} (\sum_{i=1}^{\infty} (i-1)! \frac{x^i}{i!})^m，O(nlogn)$，注意要平移符合ln的定义域，code 第二类Stirling数（斯特林子集数）n个不同的球，进入m个相同的盒子中，不可有空盒子的方案数递推式可考虑n放入新排列，或者放在已有的盒子中，$S_2(n,m)=m S_2(n-1,m)+S_2(n-1,m-1)$非递推式的话，考虑容斥即可，为了方便处理先假设m个盒子互不相同 求一行：考虑空盒子直接容斥$S_2(n,m)=\frac{1}{m!} \sum (-1)^k {m \choose k} (m-k)^n$还有一种理解，也是枚举颜色数，发现是一个下降幂多项式，二项式反演，殊途同归$$x^n = \sum_{i=0}^{n} {n \brace i} x^{\underline{i}}=\sum_{i=0}^n {n \brace i} C_x^i i!，m!{n \brace m} = \sum_{i=0}^{m} (-1)^{m-i} {m \choose i} i^n$$ 求一列：同理，其EGF=$(e^x-1)^m /m!$ 例题： loj2058 「TJOI / HEOI2016」求和，把容斥的式子放进去就做完了，也可以推一下生成函数 $ans=\sum_{i=0}^{n}\sum_{j=0}^{i}S_2(i,j)2^j j!=\sum_{i=0}^nf(i)$ $f(n)=2\sum_{i=1}^nC_n^if(n-i),设EGF为F，F=1+2e^x*F，O(nlogn)$ bzoj2159 Crash的文明世界、HDU4625 JZPTREE，bzoj太麻烦HDU的code $S(i)=\sum_{j=1}^ndis(i,j)^k，不好二项式定理考虑斯特林把它展开=\sum_{t=0}^kS_2(k,t)t!(\sum_{1}^n C_{dis}^t)$ 然后利用组合数的递推式就可以$O(nk)$了 CF932E Team Work，组合数比次幂友善，把次幂展开 $\sum_{i=1}^nC_n^ii^k=\sum_{j=0}^kS_2(k,j)j! \sum_{i=j}^n C_n^iC_{n-j}^{i-j}=\sum_{j=0}^k S_2(k,j)P_n^j max(2^{n-j},1)$ code 错排问题问题本身没啥，但有启发性思想 原问题求有多少个n的排列，满足每个$a_i \neq i$ 本质：两组各n个数配对，n个ban满足相互独立 直接容斥：不是本文重点，$D_n=\sum (-1)^i C_n^i (n-i)!=\sum (-1)^i \frac{n!}{i!}$ 递推：设在$b_1=a（n-1种）$，若$b_a=1$，转化为$D_{n-2}$； 否则$b_a \ne 1$，此时这个新条件与其他条件独立，转化为$D_{n-1}$ 故$D_n=(n-1)(D_{n-1}+D_{n-2})$ 变例luogu4931 情侣？给我烧了！（加强版）,code 先转化一下题意，$ans_k=(C_n^kP_n^k)2^kg(n-k)$，g为变例错排数，注意到只和n与k的差有关，试图预处理 考虑$左1=a(2n种)，右1=b(2n-2种)$，若$rev(a)与rev(b)$配对，转化为$g(n-2)$，有(n-1)个位置且可互换；否则要求$rev(a)不与rev(b)$配对，这是独立的条件，转化为$g(n-1)$；综上所述，$g(n)=(2n)(2n-2)(g(n-2)*2(n-1)+g(n-1))$]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-6线性代数]]></title>
    <url>%2Fposts%2Fc6a2.html</url>
    <content type="text"><![CDATA[线性代数 矩阵乘法其实广义来说，满足结合律就好；例如矩乘做倍增floyd 高斯消元讲一下模非质数意义下怎么做 线性基很有用，自行了解 真·线性代数（这部分不想看可跳过）选择性证明一些比较好证明的吧……不好证的我就跑路了:D 普适的代价是抽象，所以我们从基础说起就是3B1B视频的一些笔记；下面的图片都是偷的 其他笔记： 某篇笔记；自为风雨马前卒的笔记，没那么长 线性变换：1. 直线依然是直线 2. 原点固定 列空间：所有列向量张成的空间； 秩r(A)：变换后（列空间）的维数，满秩表示与列数相同；也可以理解为极大线性无关组大小，然后秩相当于是对det=0的压缩程度的表示 零空间（核）：变换后落在原点的向量集合 向量点积（维数相同，也叫数量级、内积）： 代数理解：相应坐标配对，显然满足交换律 几何理解：A在B上的带符号投影乘B的长度，不显然满足交换律，如何用直观的方式理解？先考虑两个向量的模一样时显然成立，然后你把某个伸缩依然成立 然后也可以理解为从n维变换到1维，即把某个向量横过来做矩阵乘法（$a \cdot b=a^Tb$） 行列式$det(A)、|A|$：就是线性变换前后的高维体积比，若=0显然线性相关，而且显然满足分配律 叉积（向量积、外积、叉乘）： 首先结果是一个向量，与【两个向量所在平面】垂直，$模长=|a||b|sin \theta，二维下=x1y2-x2y1$方向：右手法则，四指从a到b，大拇指的朝向，向上为正 对于二维叉积比较好理解，就是两个基向量变换过去，用基变换的行列式表示面积 三维叉积（v*w）的计算方式（带基向量的行列式）的本质： 考虑存在一个函数，在固定的v和w下返回自变量p与它们张成的平行六边形的体积；然后这是一个线性变换，而根据对偶性这个线性变换的矩阵可以竖起来变成一个向量h与p做点积 然后你发现，其实这个h就是一个【与v、w所在平面垂直且长度为其平行四边形】的一个向量，即v和w的叉积 因此，在右边填上三个单位向量算是某种技巧，每个单位向量的系数就是线性变换的系数，这个线性变换对应着的向量就是v和w的叉积 最后说一下向量的本质 对于线性代数，向量这个东西的本质应当是具有线性性质（formally，具备向量加法和数乘的八条公理）的任何事物，常见的如坐标、一组数、函数……但他们的系统都含有线性的运算，所以上述内容对这些事物都具有普适性 接下来的是没那么具体的（主要抄自雅礼201903的课件）n阶方阵：就是大小为$n \times n$ 的矩阵 矩阵的转置$A^{T}$ ：$a_{i,j}^T=a_{j,i}$ 单位矩阵：主对角线上为1，其他为0，符号为$I或E$ 行列式的计算公式（并不会推）：$\sum_P (-1)^{p的逆序对个数} \prod_{i}a_{i,p_i}$ 奇异方阵：行列式=0的方阵 行列式的性质（非常重要！！）： 根据通项公式，行列地位平等，转置不影响行列式 三角矩阵和某些特殊的矩阵的行列式是主对角线元素乘积，因为合法p只有对角线 交换任意两行、列后行列式取反（所以用高斯消元求行列式的话要注意），证明：其实就是证排列交换两个元素后逆序对数的奇偶性必定变化，考虑到交换相邻一定改变，而现在要做奇数次相邻交换，证毕。 性质2的推论，两行完全相同下行列式=0；进一步发现，两行成比例的话也=0，因为可以把比例系数放到行列式的外面；于是你发现我们对行列式的几何理解与我们现在的数学推导是吻合的（当然我并不知道怎么相互推导） 可以把某一行拆分成序列A和序列B的和，然后行列式就是两个其他行不变的矩阵的行列式之和。这个比较显然，和性质3放在一起可知，做初等行列变换（带系数叠加去某行）不影响行列式。 $|A*B|=|A||B|$，证明考虑行与列做点积 余子式$M_{i,j}$：删除第i行和第j列后矩阵的行列式，代数余子式$A_{i,j}=(-1)^{i+j}M_{i,j}$ 拉普拉斯展开：$\forall i，det(A)=\sum_{j=1}^n a_{i,j}A_{i,j}$ ，写成$(-1)^{(n-i)+(n-j)}$ 就会变得很显然 推论：$det(A)[i=j]=\sum_{k=1}^n a_{i,k}A_{j,k}$ ，证明：本质上就是第i行代替第j行后求行列式=0 范德蒙行列式：对一个序列Q，$F_{i,j}=Q_i^{j-1}$ ，当然你可以旋转，主要是 $det(F)=\prod_{i&lt;j} (Q_j-Q_i)$ 克莱姆法则：众所周知线性方程组可以表示为 $Ax=c，其中x和c都是列向量$ $当det(A) \ne 0，x_i=\frac{det(A_i)}{det(A)}，其中A_i表示用c取代A的第i列得到的矩阵$ 证明：将 $A_{i,k}$乘到第i个方程然后对n个方程求和可知，$\sum_{j=1}^n( \sum_{i=1}^n a_{i,j}A_{i,k} )x_j=\sum_{i=1}^n c_iA_{i,k}$ 然后右边就是$det(A_i)$ ，左边考虑拉普拉斯展开的推论可得 $det(A)x_k$ k阶子式：选k行k列组成的k阶方阵的行列式 逆矩阵：联系几何意义可知要求行列式不为0，也可以数学推导：$A^{-1}A=E,|A^{-1}||A|=1,|A| \ne 0$ 先明确：$(AB)^{-1}=B^{-1}(A^{-1}A)B(AB)^{-1}=B^{-1}A^{-1}$ ，其实几何意义下显然 考虑利用初等变换矩阵，而一个可逆矩阵经过有限次初等变换后显然是$I$ $(一堆初等变换矩阵)A=E，A^{-1}A=E$ ，如果你认可A的逆矩阵唯一（几何意义不难理解），那么求矩阵的逆就是将A高斯消元成E，然后按原顺序将过程中所做的初等变换在E上做一次，洛谷板子 余子矩阵：将原矩阵的$a_{i,j}$ 替换为代数余子式$A_{i,j}$得到的矩阵 伴随矩阵：$A*=余子矩阵^T$，$A*=|A|A^{-1}$ ，这个也不难理解，两边同时乘上A，这样左边就是个拉普拉斯展开的推论；于是我们可以快速求出余子矩阵 分块矩阵：做矩乘的时候，行分块、列分块然后看做元素是矩阵的矩阵做乘法，这样和直接乘是等价的 向量组的等价：A和B可线性表示对方；故向量组和其极大线性无关组是等价的 n元齐次方程组： $Ax=0$ 有非0解的充要条件是$r(A)&lt;n$；且不难发现他的解集是一个向量空间 通过初等变换搞成左上角E右上角有东西下面n-r行都是0的形式 然后具体怎么求解好像没啥好说的，推一推就会发现向量空间的维护=自由元个数 正交：$a^Tb（即a \cdot b）=0$； 正交向量组：非零向量两两正交，一定线性无关，证明： $a1\cdot (a1)展开发现=0$ 正交矩阵A： $AA^{T}=E$ ；模拟矩乘发现列/行向量组是正交向量组且所有列/行向量模长=1 相似矩阵：n阶方阵A和B，要求存在可逆矩阵P满足 $B=P^{-1}AP$，可以理解为不同基向量下的线性变换，故不难理解一个性质：$B^k=P^{-1}A^kP$；定理：相似矩阵的特征多项式和特征值相同 可对角化矩阵A：能找到一个B是对角矩阵且与A相似，即$B=diag(\lambda_1,\lambda_2,..\lambda_n)$ $P^{-1}AP=diag(\lambda_1,\lambda_2,..\lambda_n),AP=Pdiag(\lambda_1,\lambda_2,..\lambda_n),AP_i=\lambda P_i$ ，即P的每个列向量都是A的特征向量，又因P可逆，故A可对角化的充要条件是有n个线性无关的特征向量（而任意n阶方阵最多n个）。 特征向量（没有离开其张成的直线）：$A\vec x=\lambda \vec x，其中\lambda为特征值表示缩放程度，\vec x为特征向量，求\vec x则变形成(A-\lambda E)\vec x=0$ 这是一个齐次线性递推，前面说过条件为$det(A-\lambda E)=0$ ，行列式展开后是一个关于$\lambda$的n次多项式，称为A的特征多项式，记作 $f(\lambda)$，然后就是求零点。特殊的，三角矩阵的特征值为主对角线上的n个元素，因为$A-\lambda E$仍是三角矩阵，其行列式为主对角线上乘积 常系数线性齐次递推（可能除这个外其他都不是必学）常系数：递推系数和下标n无关；线性：递推式中每一项的次数都是1；齐次：递推式常数项等于0 Hamilton-Cayley theorem：$f(A)=0$ （A的特征多项式），并不是什么前沿科技其实，dzy的证明 模板：bzoj4161 Shlw loves matrixl；例题：loj547「LibreOJ β Round #7」匹配字符串 考虑本题的转移矩阵，考虑计算其行列式，不妨在第一行拉普拉斯展开，然后你发现去掉第一行及任意一列后得到的矩阵非常特别，其行列式用排列p的式子计算只有一种合法排列：主对角线，所以其行列式很好表达$$A-\lambda I=\left[\begin{matrix}a_1-\lambda &amp; a_2 &amp;…&amp; a_n \\1 &amp; -\lambda &amp;…&amp; 0 \\0 &amp; 1 &amp; -\lambda &amp; 0 \\0 &amp; 0 &amp; 1 &amp; -\lambda \\\end{matrix}\right]，g=\left[\begin{matrix}a_{n-1} \a_{n-2} \… \a_0 \\end{matrix}\right]\\f(\lambda)=det(A-\lambda I)=(-\lambda)^n+\sum_{j=1}^n a_j (-1)^{j+1} (-\lambda)^{n-j}=(-\lambda)^n+(-1)^{n+1}\sum_{j=1}^n a_j \lambda^{n-j} \\f(A)=0,A^n=\sum_{j=1}^n a_jA^{n-j} ，可见任何 A^k都可以被表示为 A^{0 \sim n-1}的线性组合 \\ans=(A^eG)[n,1]，考虑表示为 A^{0 \sim n-1}的线性组合即 \sum_{i=0}^{n-1}q_i(A^iG)[n,1]=\sum_{i=0}^{n-1}q_ih_i，h为所求序列 \\考虑这个q以及f(A)=0，你发现我们其实就是在做矩阵多项式模，A^e=f(A)p(A)+q(A) \\考虑怎么用n相关的复杂度计算多项式模，你发现我们左边是个幂，所以我们不妨用快速幂来搞 \\A^{2k}=A^k \times A^k(\% f(A))，暴力做（用解线性组合做取模）就是O(m^2logn)，写全家桶就是O(mlogmlogn)$$没有加任何优化然后 时限80s我跑了79s可还行；另有luogu的板子要求写全家桶 12345678910111213141516ll a[N],h[N],C[N];int n;void mul(ll A[],ll B[])&#123; for(int i=0;i&lt;n+n;i++) C[i]=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) C[i+j]=(C[i+j]+A[i]*B[j])%MOD; for(int i=n+n-1;i&gt;=n;i--) for(int t=1;t&lt;=n;t++) C[i-t]=(C[i-t]+C[i]*a[t])%MOD; for(int i=0;i&lt;n;i++) A[i]=C[i];&#125;ll q[N],tmp[N];void main()&#123; int e=qread();n=qread(); for(int i=1;i&lt;=n;i++) a[i]=qread();for(int i=0;i&lt;n;i++) h[i]=qread(); q[0]=tmp[1]=1;while(e)&#123;if(e&amp;1)mul(q,tmp);mul(tmp,tmp);e&gt;&gt;=1;&#125; ll ans=0;for(int i=0;i&lt;n;i++) ans=(ans+q[i]*h[i])%MOD;write((ans+MOD)%MOD);&#125; bzoj4162 Shlw loves matrix II如果并不是上面那样特殊的矩阵（常系数齐次线性递推），我们可以 $O(n^4+n^2loge)$ 做矩阵快速幂（显然要卡只能把e搞大），思路就是求出特征多项式，然后后面就上上题一样了 求特征多项式的话，考虑拉格朗日插值，那么现在考虑怎么求对$\lambda_i$求点值，弄出 $A-\lambda_iI$ 然后高斯消元成三角矩阵，然后行列式就是对角积了（口胡ing…… Matrix-Tree树定理作用：计算给定图的生成树个数；对于自环，显然对答案没有影响，去掉 先考虑简单无向图： 拉普拉斯矩阵(Laplacian matrix)C：度数矩阵（是个对角矩阵）D-邻接矩阵AA，根据任意行、列的和为0及考虑初等变换可知行列式为0（辅助记忆、好像证明也要用） Matrix-Tree树定理：无向简单图的生成树个数=C的任意一个代数余子式值；证明1、证明-lca 对于重边，就是边有权值，生成树的权值为各边权值之积，然后对所有生成树权值求和 那么对于边带权，称之为变元矩阵树定理，D改为相连各边权值和，AA改为边权； 对于有向图，$AA_{i,j}=(i \to j)$，求外向树的话D为入度（列的和=0），内向树就出度（行的和=0）；点x为根就是$代数余子式A_{x,x}$ 例题：luoguP3790文艺数学题、[SDOI2014]重建、[SHOI2016]黑暗前的幻想乡 best定理存在欧拉回路的图，deg=入度=出度，任一点出发外向树个数相同（记为cnt） $从st出发的个数\ = \ cnt*deg_{st} \ \prod (deg_x-1)!$ 并不知道有啥用。有人闲着没事出了数据；bzoj3659]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-5模意义数域]]></title>
    <url>%2Fposts%2F57d0.html</url>
    <content type="text"><![CDATA[模意义数域 逆元逆元(严格来说叫乘法逆元)$a\times inv(a)=1 (\mod p)$ 条件：gcd(a,p)=1这个条件是由其定义$a \times inv(a)=1 (\mod p)$得来的，因为对于一个同余方程组，左边、右边和模数会有相同的质因子（除非是0），而现在右边是1，则$gcd(a \times inv(a),p)=1$，即$gcd(a,p)=1$ 求法1:欧拉-费马定理$a^{\varphi(p)}=1 (\mod p) \rightarrow inv(a)=a^{-1}=a^{\varphi(p)-1} (\mod p)$ 求法2:扩展欧几里德算法条件：gcd(a,p)=1 【扩展欧几里德要求K（这里的1）是gcd(A,B)的倍数】$a\times x+p\times y=1$$a\times x\%p+p\times y\%p=1\%p$$a\times x\%p=1\%p$$x=inv(a) (\mod p)$复杂度O(loga)，记得取最小正整数解 求法3：当p是个质数的时候有$inv(a)=(p-\lfloor p/a \rfloor)\times inv(p\%a)\%p$ 证明：设$x=p\%a,y=\lfloor p/a \rfloor 【a&lt;p】$于是有$y\times a+x=p$ 【就是整数除法定义嘛】$y\times a+x=0 (\mod p)$$x=(-y)\times a (\mod p)$$inv(a)=(p-y)\times inv(x) (\mod p)$$inv(a)=(p-\lfloor p/a \rfloor)\times inv(p\%a) (\mod p)$ upd！！！：其实严格来说p不是质数也能线性递推，只要你保证使用的位置与mod互质即可 BSGS用于解决高次同余问题$a^x=b (\mod p)$，求最小正整数x 条件：$gcd(a,p)=1$然后这样就能用欧拉定理了当然等会在式子的移项中，也会暗中用到逆元。 我们只需要验证在$x=0~ \varphi(x)-1$中是否有解就行了如果这中间都不行，那么后面都是循环，也就没可能了然后如果对复杂度没有什么要求的话，就没必要算phi了，现在确保是在p以内就好了 如果直接枚举x，显然过慢我们引入分块思想中的根号，换一种方式枚举x 设$x=i \times m-j,m=\lceil \sqrt p \rceil$，其中$1 \leq i \leq m , 0 \leq j \leq m$那么原方程就能变形为$(a^m)^i=b \times a^j (\mod p)$那么只要把$b \times a^j (\mod p)$全部塞到一个hash表或者map里面，再枚举$(a^m)^i (\mod p)$来查找即可 有个小细节：预处理时可能得到相同的结果，为了保证得到最小的答案，需要把后面的j覆盖前面的j 核心思想就是【分块+预处理】相辅相成，复杂度下降到根号然后为了能满足条件，强行对式子进行修改 exBSGS算法观察式子，a和p的公约数，b中也一定会有（除非b是0），否则无解。设d=gcd(a,p)，那么把一个a拉出来，同时把a、b、p除以d如果操作的次数为num，直到$d=gcd(a,\frac{p}{d^{num}})=1$，式子变成：$(\frac{a}{d})^{num} \times a^{x-num}=\frac{b}{d^{num}} (\mod \frac{p}{d^{num}})$然后此时$gcd(\frac{a^{num}}{d^{num}}),\frac{p}{d^{num}})=1$所以可以把它逆元一下，放到右边去最后$x=BSGS(a,\frac{b}{d^{num}} \times inv(\frac{a}{d})^{num}),\frac{p}{d^{num}})+num$不过这样以后，我们强行使$x \geq num$，这样就漏了（例如a=4,x=0,b=1,c=4）不过我们观察一下，发现$num&lt;=log_2 c$，所以直接枚举出前面的$0到num-1$就好了，复杂度不变 中国剩余定理CRT中国剩余定理CRT 其实真正用来解同余方程组的很少，更重要的理解是对模$m=\prod (a_i=p_i^{k_i})$的拆分（故a互素），这样用逆元什么的会很方便 $求出b_i=num\%a_i,num=\prod b_i \frac{m}{a_i}*inv(\frac{m}{a_i},a_i) (\%m)$，正确性不难验证 入门题：bzoj1951 [Sdoi2010]古代猪文 费马小定理条件：质数p，gcd(a,p)=1结果：$a^{p-1}=1 (\mod p)$顺便提一下，如果使用 $a^p=a (\mod p)$ 的形式，不需要满足gcd(a,p)=1证明：不会应用：1.求逆元：【OI之路】11更高级数论-2逆元2.某些数据范围巨大的题目如Gauss Fibonacci矩阵游戏 注意，在cf、atc上可能会看到Lagrange’s theorem，应该就是指费马小定理 欧拉定理欧拉定理： 当gcd(a,m)=1，$a^{\varphi(m)}=1 (\mod m)$ 拓展欧拉定理：$a^t=a^{min(t,t \% \varphi(p)+\varphi(p))}(\%p)$yww、sam张、maijing 当 $gcd(a,p)=1$ 时，满足 $a^x=1 (mod p)$ 的最小正整数x一定是 $\varphi(p)$ 的约数证明：运用反证法假设存在最小的x0，不是其约数，则$\varphi(p)=t \times x0 + r (0&lt;r&lt;x0)$那么因为$a^{x0}=1 (\mod m)$，$a^{t \times x0}=1 (\mod m)$又因为$a^{\varphi(m)}=1 (\mod m)$，所以$a^r=1 (\mod m)$这与x0的最小相矛盾。 例题：bzoj4869 bzoj3884 上帝与集合的正确用法,code$$出题人（po姐）做法：设p=2^kq，思考一下发现ans(p)=2^k(2^{2^{2…}-k} \% q)=2^k(2^{ans(\varphi(q))-k}\%q)，O(p+Tlogp)，见phi的深度\\其实也可以不分解直接用拓展欧拉定理，ans(p)=2^{2^{2…}}\%p=2^{2^{2…}\%\varphi(p)+\varphi(p)}=2^{2^{2…}}\%p=2^{ans(\varphi(p))+\varphi(p)}\%p，本质上是一样的$$ 威尔逊定理当p是质数 $(p-1)! = -1 (\mod p)$ 这个定理也是判断p是否是质数的充要条件 在atcTenka1-2019E用过 高斯推广：$\prod_{gcd(i&lt;m,m)=1}i=-1(\%m),当m=4,p^t,2p^{t}$ p为奇素数，然后其他情况=1，证明 指数详细的资料：riteme a的阶（次数）：最小的自然数e满足$a^e=1(\%m)$ 指标：$a=g^l(\%m)$ 原根求原根的结论： 求最小原根的结论：暴力枚举原根g，尝试验证； 对 $\varphi(m)$ 质因数分解，对每个验证 $g^{\frac{\varphi(m)}{p_i}} \neq 1 (\% m)$ 速度的话1e9基本没问题 m存在原根，当且仅当 $m=1,2,4,p^a,2p^a$ ，数量为 $\varphi( \varphi(m) )$ 数量的 证明可以看dh 应用：$O(\sqrt n)$ 解决高次剩余问题，例题对模数的原根求离散对数，化乘法为加法，例题 更详细的资料：hdxrie riteme Lucas定理条件：Mod是素数公式：$C_n^m=C_{n/Mod}^{m/Mod} \times C_{n \mod Mod}^{m \mod Mod} (\mod Mod)$证明 可以用MOD进制理解，有些题也是从这个思路出的，例如uoj275组合数问题、【CTSC2017】吉夫特 拓展Lucas定理先考虑Mod是素数的次幂，即$Mod=p^k$ 做法：将阶乘分解为$A*p^t$ 也就是把t提出来，那么我们就只关心与Mod互质的部分了； 把p的次幂取出，只会取log次，每次统计t的同时还会产生一个新的阶乘 $(\lfloor n/p \rfloor)!$ 然后其他的部分考虑循环节Mod，于是就是前面$\lfloor n/Mod \rfloor$ 段完整的，可以用快速幂高斯推广的威尔逊定理（上面有），以及后面的一段，预处理后MOD内不完整段后，回答询问的复杂度是log的 对于更为一般的$Mod=p_1^{k_1} \times p_2^{k_2} … \times p_t^{k_t}$，CRT合并即可 例题：礼物、【HNOI2017】抛硬币 二次剩余个人感觉czy的有一点小瑕疵，可和begay的一起看 模p意义下，求 $b^2=a(\%p) $ 为了方便叙述以下内容都在模p意义下然后我们如果要找到一个p在质数下的算法，则只需要考虑a&gt;0且m&gt;2的情况先考虑怎么判断a是否是模p的二次剩余（指a是否存在一个这样的b） 结论1：a要么不是模p的二次剩余，要么恰有两个根证明：首先 $x \ne -x$ 然后如果存在另一个解y，$(x+y)(x-y)=0 \to y=\pm x$根据结论1，以及每个根只能被覆盖一次，可知$1\to p-1$有一半是二次剩余一半不是 然后判断是否存在应该这样思考：$bc=a$ 这样的c是唯一的，只是要考虑是否=b欧拉判别法：如果a是二次剩余，则$a^{(p-1)/2}=1$ 否则-1证明：如果是，则$a=b^2,1=b^{p-1}=a^{(p-1)/2}$否则，bc是二元环，将1到p-1分成若干个二元环，则$(p-1)!=a^{(p-1)/2}$根据威尔逊定理可证。这个判别法有助于进一步推导性质。 方案A：bsgs+原根，$g^A=a,b=g^{A/2}，由欧拉判别法+费马小定理可知A为偶数，O(\sqrt n)$ 方案B：Cipolla 复杂度$O(logn)$ rand一个d满足不是二次剩余（由上面的定理可知期望=2）定义一个高妙的类似复数的数域$(x+yw),w^2=d^2-a$ 则$b=(d+1w)^{(p+1)/2}$考虑证明：首先 $w^p=w*(w^2)^{(p-1)/2}=-w,(x+y)^p=x^p+y^p（组合数被模掉）$因此 $b^2=(d+1w)^{p+1}=(d^p+w^p)(d+w)=d^2-w^2=a$ 那么最后的问题就是这样求出来的b，为什么w的系数一定是0,似乎说用到了拉格朗日定理 目前在知识储备之外 1234567891011121314151617181920ll a,d;pr gg(pr x,pr y) &#123;return MP( (x.FR*y.FR+x.SE*y.SE%MOD*(d*d-a))%MOD,(x.FR*y.SE+x.SE*y.FR)%MOD );&#125;void main()&#123; int T=qread(); while(T--) &#123; a=qread();MOD=qread();a%=MOD; if(MOD==2)&#123;puts("1");continue;&#125; if(qpower(a,(MOD-1)/2)!=1)&#123;puts("No root");continue;&#125; d=rand()%MOD;while(qpower((d*d-a+MOD)%MOD,(MOD-1)/2)==1) d=rand()%MOD; int e=(MOD+1)/2;pr ans=MP(1,0),now=MP(d,1); while(e) &#123; if(e&amp;1) ans=gg(ans,now); now=gg(now,now);e&gt;&gt;=1; &#125; ll x=(ans.FR+MOD)%MOD,y=MOD-x;if(x&gt;y)swap(x,y);printf("%lld %lld\n",x,y); &#125;&#125;//x+MOD 二次互反律： $\left(\frac{p}{q}\right)\left(\frac{q}{p}\right)=(-1)^{\frac{p-1}{2}\frac{q-1}{2}}$ CodeChef-FN 就是因为 $mod\%5=\pm1是5的二次剩余，然后用上面推出5也是mod的二次剩余$ Fib数列模意义下，fib是存在循环节的，基本就是一堆定理 先将模数分解质因数，$ans=lcm(G(p_i^{k_i})=G(p_i)p_i^{k-1})$ $若5是模p的二次剩余，则G(p)|(p-1)，否则G(p)|(2p+2)$ 如果是小素数直接判 例题：HDU3977、 HDU4794 贝尔数$B_{n+p}=B_n+B_{n+1}(\%p),p为质数$ begay 一些题bzoj1129 [POI2008]Per对$O(nlogn)$的做法奋战最后顺利bzoj和洛谷rk1，做法和cls的基本一样 首先如果m为质数就是道简单题，逐位考虑，$设now_j为后缀中j的次数，ans(k)=ans(k+1)+\frac{(n-k)!}{\prod_j now_j!}(\sum_j now_j)$ 一开始用树状数组预处理出每个数后面更小的数字和，这样就是$O(nlogn)$的 现在m比较一般，可以有很多种处理方法，这里只介绍最直接自然的CRT，设当前模数为$d^k$，那么因为有阶乘除法需要把d提出来算，不妨搞个二元组$(a,b)=a+d^b$，把阶乘之类的用这个二元组搞，定义一下乘除法就好了，网上也基本上是这样，然而复杂度还是log方，主要是求逆元的问题。 cls用的是线性递推逆元，这我不是很理解在$p^k$的k&gt;1的时候为什么能用，故我采用的是线筛+欧拉定理，因为素数为分布约为n/ln，然后注意到$p^k$只会超过$\sqrt m$最多一次，可以用exgcd求逆元；综合复杂度为$O(nlogn)$ code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-4博弈论]]></title>
    <url>%2Fposts%2F83b5.html</url>
    <content type="text"><![CDATA[博弈论 平等博弈有向图游戏在一个DAG中，只由一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负P为必败点，N为必胜点 公平组合游戏ICG 两个玩家交替行动 能执行的操作与具体玩家无关 不能行动的玩家判负 mex运算与SG函数定义mex为，非负整数集合S中，最小的不属于集合S的非负整数 对于状态x，有k个后继状态y，$SG(x)=mex( { SG(y_1),SG(y_2)…SG(y_k) } )$定理：有向图游戏的某个局面必胜，当且仅当其对应节点，sg函数值大于0（即能到达必败终点） 而对于多个有向图游戏，定义有向图游戏的和为，它们sg(起点)的异或和 斐波那契博弈有一堆石子共有N个，A、B两个人轮流拿，A先拿，拿到最后1颗石子的人获胜每次拿的数量最少1个，最多不超过对手上一次拿的数量的2倍（A第1次拿时要求不能全拿走）结论：先手必胜，当且仅当，原本的石子数量为斐波那契数 巴什博弈 Bash Games只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个，最后取光者得胜。 直接套sg，不难发现sg=tot%(m+1) NIM博弈n堆物品，每堆有ai个，两个玩家轮流任选一堆来取物品，但不能不取，取走最后一个物品者获胜（不能取的玩家判负）不难发现NIM博弈是由n个有向图游戏组成的 定理：先手必胜，当且仅当sg异或和 $\neq 0$证明可用数学归纳法，从游戏结束开始分析，每次给对面一个平衡状态（异或和=0） 拓展 Nimk，即同时取k堆（可以不同） 这个挺神奇的，就是每一位sum%(m+1)=0 阶梯博弈，每次把某个阶梯上若干个石头往下一个阶梯移动 首先，不要考虑石子，而是考虑隔板的前移，那么石头相当于相对距离 把两个隔板两两捆绑（奇数个的时候，把第 1 个和边界 0 捆绑） 所以如果不考虑奇数的移动情况，就是一个 nim 游戏 所以对于先手，如果他是赢家，一定按照 nim 来 这个时候如果后手突然移动奇数，那么先手把偶数等距离向前移动， 就能还原出相同局面，而且一定能实现 而如果先手是输家，那么和上面同理无法改变结局 树上例：CF812E Sagheer and Apple Tree 一条到根链ln+1个隔板只有根上面那个隔板是定死的其他都是动的，那么叶子节点下面那个隔板一定是组的二号，故sg=与叶子节点深度奇偶性相同的点异或和，code 二分图博弈前置故事：bzoj2463在这道题中，做法正确性的证明是，数量为偶数个是，总能用1乘2的骨牌填充，然后我总是在骨牌内移动，所以问题总是留给对手解决那如果依然在棋盘上，但不是规则的棋盘呢？ 模型：二分图上，轮流移动棋子，离开的时候删除原本的节点结论：先手必胜当且仅当当前点在所有最大匹配中 注意到我们（或者说题目）提到了必胜，也是就说这是一个可预测的公平组合游戏那首先我们如何构造必胜策略呢？二分图上很多问题都跟其最大匹配有关，先求出来（假设只有一个）假设先手在所有最大匹配中，那么一定存在必胜策略，下面给出策略：沿着匹配边走向匹配点，后手只能沿着未匹配边或者gg，如果现在在匹配点，那么情况重复，我总有方法不死如果在未匹配点，则走未匹配边到匹配点y（其匹配了x），因为我们在所有最大匹配中，那么强行把现在这个未匹配点与y匹配起来就好了 总而言之，我们总有办法把自己当做匹配点来走匹配边，把问题留给对手解决具体做法的话，就是尝试删除这个点，看最大匹配会不会减少 平等博弈-最后bibi几句其实研究这几个博弈有点伤感如果你具体分析情况而非利用sg，你会发现，这些游戏还没开始就被注定了结局…… 不平等博弈曾点开一道可能不该点开的题，留坑 「清华集训 2017」福若格斯，官方题解，xvyixuan的题解]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-3抽象代数]]></title>
    <url>%2Fposts%2F998a.html</url>
    <content type="text"><![CDATA[抽象代数 群论nosta、xym_CSDN 群G：一个集合S，一个定义在集合上的二元运算$\cdot$，且二元运算需要满足：结合律、单位元存在、逆元存在、运算封闭性 群的阶：所含元素个数 元素的阶：就是模意义那个阶的拓展，即S中最小正整数k满足$a^k=e$，若不存在则阶为无穷大 置换f：有限集合到自身的一一映射 定理Burnside引理：在置换群G中的置换F意义下，有C(F)个经过F置换后保持不变的方案，则总的本质不同的等价类数量有 $\frac{\sum_{F \in G} C(f)}{|G|}$ 个 Pόlya定理：设用k种颜色让染色，考虑C中每个循环一定染成同种颜色，等价类=$\frac{\sum_{F \in G} k^{循环数量} }{|G|}$ 模板luogu模板 考虑本题的置换群G，就是a=1到n-1的旋转方案，每种方案的循环节长度ln= $lcm(n,a)/a$循环的数量= $n/ln=n \times a/lcm(n,a)=gcd(n,a)$则$ans=\frac{1}{n} \sum_{a=1}^{n-1} n^{gcd(n,a)}$那么枚举gcd，dfs顺便求个phi即可（用vector求好根号内次幂即可），因为约数个数在2000内，时间为 $O(1000^2 log n)$ 例题好几道题 欧拉公式的一种理解（我不知道我在吹啥幂函数将加法群（实滑动+虚滑动）映射到乘法群（缩放+旋转），e^x下，加法群上移i，乘法群逆时针旋转1rad，然后就可以推导欧拉公式，至于为什么是e，似乎需要用到向量微积分]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-2定理杂烩]]></title>
    <url>%2Fposts%2Fa06a.html</url>
    <content type="text"><![CDATA[定理杂烩 模意义的定理放在模意义数域一章了 秦九韶算法（霍纳法则）$2x^3+4x^2+3x+1=((2*x+4)*x+3)*x+1$，即线性求值 约数个数与和$G=p1^{a1}\times p2^{a2}\times p3^{a3}\times …\times pk^{ak}$$约数个数=(a₁+1)(a₂+1)(a₃+1)…(ak+1)$$和=(p1^0+p1^1+…p1^{a1})(p2^0+p2^1+…p2^{a2})…(pk^0+pk^1+…pk^{ak})$其实就是乘法原理 神仙欧拉的另一个公式本公式属于拓扑学的研究范围不过之前做一道叫planar的题目用到过对于一个平面图，一定满足$m \leq 3n-6$ 原公式：点数n+面数r-边数m=连通块数量cnt（当做无向图）+1对于当前的平面图判定，每条边最多给两个面使用，每个面至少有3条边也就是说，$r \leq \frac{2m}{3}$原式化为 $m=n+r-cnt-1$ 后带入，得到 $m \leq n+\frac{2}{3} m -cnt-1$$3m \leq 3n+2m-3cnt-3$显然cnt最小为1，则 $m \leq 3n-6$ 特征方程rxz、dh gcd的奇妙定理$gcd(a^m-b^m,a^n-b^n)=a^{gcd(n,m)}-b^{gcd(n,m)}$，证明$gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1$，证明在这里和这里。例题 HDU5780 斐波那契数列$$F(0)=0,F(1)=1,F(n)=F(n-1)+F(n-2)=\frac{\sqrt 5}{5}((\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n) \\\sum_{i=1}^n F(i)=F(n+2)-1、\sum_{i=1}^n F(i)^2=F(n)F(n+1) \\\sum_{i=1}^n iF(i)=nF(n+2)-F(n+3)+2 \\\sum_{i=1}^n F(2i-1)=F(2n),\sum_{i=1}^n F(2i)=F(2n+1)-1 \\$$证明 $$A. gcd(F(i),F(i+1))=gcd(F(i),F(i-1))=gcd(F(0),F(1))=1 \\B. 考虑fib(n)的组合意义：用1*2的骨牌填充2*(n-1)的表格方案数 \\考虑n与n+1间是否断开,F(n+m)=F(n)F(m-1)+F(n+1)F(m) \\C. gcd(F(n+m),F(n))=gcd(F(m-1)F(n)+F(m)F(n+1),F(n))=gcd(F(m),F(n)) \\仔细观察发现fib的下标也在辗转相减，gcd(F(n),F(m))=F(gcd(n,m)) \\$$ 于是我们做个练习（例题：最小公倍佩尔数）： 佩尔数$P(n)=2P(n-1)+P(n-2)$，首先A是一样的，然后B是竖着放有两种方案，但式子是一样的，故C也一样 差分表教程1，教程2，教程3$$设当前有n次多项式f，设\Delta_0 f(x)=f(x),\Delta_{t+1} f(x)=\Delta_t f(x)-\Delta_t f(x-1) \\那么我们称f的第0条对角线为\Delta_0 f(0)…\Delta_n f(0) \\牛顿插值：f(x)=\sum_{k=0}^n \Delta_k f(0) C_x^k \\根据组合数的性质，可知\sum_{k=0}^m f(k)=\sum_{k=0}^n \Delta_k f(0) C_{m+1}^k$$题目：cf407c Kummer定理$$p在n!中次数=\sum_{i=1} \lfloor n/p^i \rfloor=\sum_{i=1}\sum_{j=i}c_jp^{j-i}=\sum_{j=1}c_j\sum_{i=1}^jp^{j-i} \\=\sum_{j=1}c_j\sum_{i=0}^{j-1} p^i=\sum_{j=1}c_j \frac{p^j-1}{p-1}=\frac{(n-c_0)-\sum_{j=1} c_j}{p-1}=\frac{n-sc(n)}{p-1} \\p在C_{n+m}^n中次数=\frac{sc(n)+sc(m)-sc(n+m)}{p-1}=n+m在p进制下进位个数$$ 这个定理的形式和意义都很优美；例题：GDOI2019D2T1 其他知识 通过$O(\sqrt n)$枚举出n的所有约数 推论: n的约数总数，上限$2 \sqrt n$ 通过$O(n log_2 n)$枚举d，更新其倍数得到1~n的所有约数 复杂度证明：调和级数 推论：1~n的所有约数个数，上限$n log_2 n$ 对于int范围内的x，其质因子数量&lt;10 证明就是把最小那几个乘起来，然后指数总和&lt;31 素数分布数量，n内大致上看作$n/ln n$ 一个我曾搞错的trick： $\forall a,b,c\in\mathbb{Z},\left\lfloor\frac{a}{bc}\right\rfloor=\left\lfloor\frac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor$ 略证： $$\begin{split} &amp;\frac{a}{b}=\left\lfloor\frac{a}{b}\right\rfloor+r(0\leq r&lt;1)\ \Rightarrow \\ &amp;\left\lfloor\frac{a}{bc}\right\rfloor =\left\lfloor\frac{a}{b}\cdot\frac{1}{c}\right\rfloor =\left\lfloor \frac{1}{c}\left(\left\lfloor\frac{a}{b}\right\rfloor+r\right)\right\rfloor =\left\lfloor \frac{\left\lfloor\frac{a}{b}\right\rfloor}{c} +\frac{r}{c}\right\rfloor =\left\lfloor \frac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor\ \end{split}$$ phi小性质A：对于n&gt;1，1~n中与n互质的数的和为$n \times \varphi(n)/2$ ，证明：$gcd(n,x)=gcd(n,n-x)$ phi小性质B：深度为log级别。考虑n为偶数，则$\varphi(n)\le n/2$；若n为奇数，$\varphi(n)$一定是偶数]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】03数学-1传统数论]]></title>
    <url>%2Fposts%2F60ff.html</url>
    <content type="text"><![CDATA[传统数论 %和mod都表示C++中的取余运算$\lfloor x \rfloor$就是向下取整 取余和取模基本思路：①$c=a/b$ ②$r=a-c\times b$取余：在①中，向0方向取整取模：在①中，向负无穷方向取整举个栗子：(4)/(-3)≈-1.3$4 rem (-3)=4-(-1)\times (-3)=1$$4 mod (-3)=4-(-2)\times (-3)=-2$C++中的%运算符其实是rem，但为了方便我比较习惯用mod表示，小心混淆划重点：数论中为了化公式，经常要变成$r=a-\lfloor a/b \rfloor \times b$的形式 最大公约数Greatest Common Divisor$gcd(x,y)=x和y的最大公约数$定义：$gcd(x,0)=x$划重点：约数的定义域是自然数，所以x和y不能是负数！ 最小公倍数Least Common Multiplelcm(x,y)=x和y的最小公倍数公共倍数中最小的 x*y=最小公倍数*最大公倍数证明：设两个数为x和y,其最大公约数为a,则最小公倍数为$(x/a)\times (y/a)\times a=x\times y/a$最大公约数和最小公倍数的乘积为$(a)\times (x\times y/a)=x\times y$ 欧几里得算法Euclid又名辗转相除法，对于大小关系没有要求内容： $gcd(a,b)=gcd(b,a\%b)$证明： 设d是a,b的一个约数，所以a/d,b/d为整数 $r=a-k\times b 【0\leq r&lt;b，k为整】$同时除以d，$r/d=a/d-kb/d$因为$a/d-k\times (b/d)$为整数所以r/d也是整数，所以r是d的倍数 d本身就是a,b的约数,又d是r的约数，所以是a,b,a%b的公约数既然公约数是一样的（因为d并非定值，可以应用于所有公约数）最大公约数也必然相等，得证1int gcd(int a,int b)&#123;return b==0?a:gcd(b,a%b);&#125; 时间复杂度：$O(log2b)$，证明 扩展欧几里德算法ExEuclid目标1：解$ax+by=gcd(a,b),a,b \in N$ 考虑到$d=gcd(a,b)=gcd(b,a\%b)$，递归求解 假设当前要求gcd(a,b)，并求出了一组x和y使得$ax+by=GCD$已经求出gcd(b,a%b)并求出了一组tx和ty使得$b\times tx+(a\%b)\times ty=GCD$那么这两个相邻的状态之间是否存在某种关系呢？$ax+by=GCD=b\times tx+(a\%b)\times ty$$ax+by=b\times tx+(a-\lfloor{a/b}\rfloor \times b)\times ty$$ax+by=b\times tx-\lfloor{a/b}\rfloor \times b\times ty+a\times ty$$ax+by=b\times (tx-\lfloor{a/b}\rfloor \times ty)+a\times ty$所以$x=ty,y=tx-\lfloor{a/b}\rfloor\times ty$这个其实挺好推的，不推荐死记硬背 目标2：解$ax+by=C$，有解当且仅当$gcd(a,b)|C$，相关内容可搜索丢番图方程，总之直接放缩 目标3：表示出上述方程的通解，结论是$a(x+t*(b/d))+b(y-t*(a/d))=C,t \in Z$ 目标4：求上述方程中x的最小非负整数解，根据上面的通解可知，$tmp=b/d,x=(x\%tmp+tmp)\%tmp$ Code1234567ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1,y=0;return a;&#125; ll tx,ty,d=ExEuclid(b,a%b,tx,ty); x=ty;y=tx-(a/b)*ty; return d;&#125; 然后它也被称之为拓展中国剩余定理，因为它能够解同余方程组且不要求各模数互质 设方程组为$num=b_i(\% m_i),i \in [1,n]$；基本思路就是合并相邻的两个方程组，最后只有一个方程$$合并num=b1+m1*x1,num=b2+m2*x2,b1&lt;b2 \\即num=b1+m1*x1=b2+m2*x2\\m1*(x1)+m2*(-x2)=b2-b1，解出一组x \\num=b1+m1*x1(\% lcm(m1,m2))$$例题：Poj2891，过不去是懒得写高精度 1234if(b1&gt;b2) swap(b1,b2),swap(m1,m2);ll x1,x2,d=exgcd(m1,m2,x1,x2),C=b2-b1;if(C%d!=0) gg=1;x1=x1*(C/d);ll tmp=m2/d;x1=(x1%tmp+tmp)%tmp;b1=b1+m1*x1;m1=m1/gcd(m1,m2)*m2;b1%=m1; 线性筛选素数线性筛选素数，也就是O(n)条件：积性函数，常见如素数函数、莫比乌斯函数、欧拉函数精髓：每个合数都只被它的最小质因子筛出注意，作为素数的循环j是在内部的那么当i%prime[j]==0，意味着i中已经包含了prime[j]那后面的数中，prime[j]一定会比prime[t]小那么 至少 最小质因数不会是prime[t]12345678910111213141516const int MAXN=21000000;int prime[1100000],pr;bool v[MAXN];void calcprime()&#123; for(int i=2;i&lt;=MAXN;i++) &#123; if(v[i]==0) prime[++pr]=i; if(pr==1000000) return;//满意而归 for(int j=1;j&lt;=pr and i*prime[j]&lt;=MAXN;j++) &#123; if(i%prime[j]==0) break; v[ i*prime[j] ]=1; &#125; &#125;&#125; 类欧几里得$$\begin{aligned}f(n,a,b,c)&amp;=\sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\a=0或n=0,f(n,a,b,c)&amp;=(n+1)\lfloor b/c \rfloor \\max(a,b) \geq c,f(n,a,b,c)&amp;=n(n+1)/2*\lfloor a/c \rfloor+(n+1)\lfloor b/c \rfloor+f(n,a\%c,b\%c,c) \\f(n,a,b,c)&amp;=\sum_{i=0}^n \sum_{j=0}^{m-1} [\lfloor \frac{ai+b}{c} \rfloor \geq j+1]=\sum_{i=0}^n \sum_{j=0}^{m-1} [ai&gt;cj+c-b-1] \\&amp;=\sum_{i=0}^n \sum_{j=0}^{m-1} [i&gt; \lfloor \frac{cj+c-b-1}{a} \rfloor]=mn-f(m-1,c,c-b-1,a) \\\end{aligned}$$ 复杂度：观察a和c，发现a&gt;=c则%，否则交换，所以类似欧几里得…… miller-rabin费马测试：尝试几个x，若都满足$x^{p-1}=1(\%p)$ 则p为质数很不幸的是x=561（Carmichael Number）满足所有p……qwq 二次探测定理：$a \in[2,p-2],若a^2=1(\%p)，则p不是质数$ ，证明：用平方差公式拆开所以大致思路就是费马测试+二次探测定理 随机一个a，先做费马测试，然后分解$p-1=u2^t$ ，二次探测如果$a^{u2^i}=1，那么判断a^{u2^{i-1}}=\pm1$ ，这个过程最坏是log方的据说：一次正确率是$\frac{1}{4}$ ，如果p在int内a=2,7,61，ll内a=前12个素数可得到精确解模板：loj143 质数判定 code 123456789101112131415161718192021222324252627282930ll MUL(ll x,ll y,ll mod)&#123; ll tmp=(long double)x/mod*y+0.5;tmp=x*y-tmp*mod; return tmp&lt;0?tmp+mod:tmp;//利用LIMIT这个模数相同，做差得精确值&#125;ll PP(ll x,ll e,ll mod)&#123; ll ans=1; while(e) &#123; if(e&amp;1) ans=MUL(ans,x,mod); x=MUL(x,x,mod);e&gt;&gt;=1; &#125;return ans;&#125;ll aa[20]=&#123;2,3,5,7,11,13,17,19,23,29,31,37&#125;;bool miller_rabin(ll p)&#123; if(p&lt;2) return 0;if(p==2) return 1;if(!(p&amp;1)) return 0; for(int t=0;t&lt;12;t++) &#123; ll tmp=p-1;if(aa[t]==p)return 1; while(1) &#123; ll now=PP(aa[t],tmp,p); if(now!=1 and now!=p-1) return 0; if(now!=1 or tmp&amp;1) break;tmp/=2; &#125; &#125; return 1;&#125; Pollard’s rho教程——xyx简介：对于给定n，在期望$O(n^{1/4}\alpha(n))$的时间内分解为两个非平凡因子，其中$\alpha(n)$为求gcd的复杂度思路： 想象一个%n数域的有向图A，以及n的某个质因子p（确定n不是质数后，显然$p \le \sqrt n$）形成的有向图B，每条路径的结尾都是一个环，设大小为N和P，则显然$P|N$，据说根据生日悖论，A的期望环大小为$\sqrt n$，B的期望环大小为$\sqrt p$；考虑floyd判圈法 设有随机函数f（一般设为$f(x)=x^2+C$，可以理解为一种hash）%n下生成数列x，若$\exists i,x_i=x_{2i}(\% p)$，求出$d=gcd(x_i-x_{2i},n)$后，若d=0，继续找；若d=n，则我们的hash函数不太行，导致我们搞出了环而没找到因子，需要更换hash函数（C++）；否则d就是我们想到的；据说这个过程的期望尝试i的次数=环大小即$O(\sqrt p)$ 板子bzoj3667 一组快乐数据：999999726000014413=999999797*999999929 123456789101112131415161718ll pollard_rho(ll n)&#123; if(miller_rabin(n)) return n; if(!(n&amp;1)) return max(2ll,pollard_rho(n/2)); int C=1; while(C++) &#123; ll x=rand()%(n-10)+2,y=x;ll d=0; while(1) &#123; x=MUL(x,x,n)+C;if(x&gt;=n) x-=n; y=MUL(y,y,n)+C;if(y&gt;=n) y-=n; y=MUL(y,y,n)+C;if(y&gt;=n) y-=n; d=gcd(abs(x-y),n);if(d==n) break; if(d!=1) return max(pollard_rho(d),pollard_rho(n/d)); &#125; &#125;return -1;&#125; 如果嫌不够快，可以按每127个分组来做（gcd&gt;1则具体找），并没有实现过]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-15树上问题]]></title>
    <url>%2Fposts%2F86909ea3.html</url>
    <content type="text"><![CDATA[树上问题 zjp-最基本的一些技能 ZJOI2007 Hide 捉迷藏那题之前写过题解，用的是支持边权的做法，无边权可以用括号序列做，但个人认为这种做法拓展性强的同时其实也不算很难想很难写 题题意：给定一棵树，操作是插入链或询问跟某条链相交的链个数 做法：链的点-边=1，考虑点+1边-1，那么回答询问只需要回答链上求和 长链剖分用于快速维护一些只和深度有关的信息 经典题是hotel，这个算法值得学习，billyang写的不错，然后内存池的写法需要掌握 形式化就是$T(n)=T(a)+T(b)+min(dep_a,dep_b)=O(n)$ 树上动态dpnoip2018的守卫王国可以用这个，见我之前写的题解；然后洛谷也有板子 教程]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-14析合树]]></title>
    <url>%2Fposts%2F3d5b.html</url>
    <content type="text"><![CDATA[析合树参考文献：OI-wiki、PPT：简单的连续段数据结构 WC2019营员交流 *by CommonAnts* 概念区间、段：段A要求能在排列p上选择一个区间使得上下界为A 不动点、连续段：对于排列P，$(P,[l,r])$ 表示区间 $P_{l \sim r}$是值域连续的，置换p的段集合记为 $I_p$ 不难发现：两个连续段的交是连续段且以某个作为全集时交的补集也是连续段、两个相交连续段的并是连续段 基、生成基：连续段集合B能通过交和相交并生成 $I_p$ 中任意元素；极小基的真子集不存在基 本原连续段、本源段：一个连续段且不存在【与之相交而不包含的连续段】；由上可知本源连续段是基；可见只有相离和包含关系，是一个经典的树形结构，我们称之为析合树。注意到所有非叶子节点都有至少两个孩子，所以节点数是 $O(n)$ 的。 给出一张OI-wiki的图（节点的区间都是值域区间）： 孩子序列$S_x$：按照在p中出现位置排序的孩子们；孩子排列$P_x$：如上图所示，将值域区间离散化 合点、正点：$P_x$有序，包括叶子节点；析点、异点：非合点 合点的$S_x$的任意区间都是连续段，析点的$S_x$的任意非平凡区间（长度&gt;1且非所有）都不是连续段 证明：考虑一个非平凡区间是连续段故非本源段，我们可以证明最后$P_x$有序；考虑与这个连续段相交且不包含的另一个连续段，注意到他们是有序的，然后我们再处理两个连续段的并，最后就可以得到若干个区间覆盖所有孩子节点，对每个区间继续这样思考知道没法处理后，你会发现我们得到的就是孩子排列，而且是有序的。 还有一些可能有用的性质： 析点的孩子数&gt;=4，因为小于4的排列都至少存在一个非平凡连续段；同时，当n&gt;=4，一定存在有n个孩子的析点，证明考虑构造，n偶就是$2,4,6,\dots,n,1,3,5,\dots,n-1$，n奇就是$4,6,8,\dots,n-1,1,3,5,\dots,n,2$ 任意一棵满足孩子数量且钦定了所有非叶节点的析合性的树，都至少存在一个合法的对应排列 构造算法先咕着…… 可以搞的题Asia East Continent Finals 2018 B Mysterious … Host、loj6632不用析合树的解释：吉老师的题解 wxh的题解 口胡：有了析合树的概念，就是树计数，考虑OGF，$F=(x+\sum_{i=2}^{\infty} F^i)+(\sum_{i=4}^{\infty}F^i)$ 已经可以n方做了 考虑牛顿迭代：$f(F)=F^4+2F^2-F+x-Fx=0,f’(F)=4F^3+4F-1-x$ 可nlogn实现 CERC2017 Intrinsic Interval并没有细看不用析合树的做法，似乎是离线的 口胡：建出析合树求lca就好了 CF997E Good Subsegments口胡：倍增预处理出每个节点为左、右端点时，在兄弟中的方案数，询问的时候特判lca处]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>析合树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-13左偏树]]></title>
    <url>%2Fposts%2F1197.html</url>
    <content type="text"><![CDATA[左偏树，可并堆的一种便利实现hyh论文的学习笔记 话说hyh原来是我校的……外节点：不是两个孩子距离：到子树内最近的外节点距离考虑固定一个距离，那么那么节点数最少的形态一定是二叉树根据左偏性质，根节点的距离为log级别 删除某个已知节点的操作，我yy了一下，不保证正确性……可能是直接向上跳，但发现距离不变时退出因为距离的变化是单向的，而且只有log次变化，所以复杂度为log级别]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-12虚树]]></title>
    <url>%2Fposts%2F3915.html</url>
    <content type="text"><![CDATA[虚树 主要应用于①树不大，多组询问，询问设计一些点，点总数和n同阶②树很大，但有用节点的不多 构造方式给有用的节点打上标记，点和点的lca也需要在虚树内听起来点数会很多，但我们可以通过构造的方法，证明点数和n同阶 然后我自己yy了一种方法（欢迎hack）：按照dfs序从小到大处理用一个栈维护当前虚树，最后一个节点向上的虚树上的点（即向上的链） 设当前加入的点为now，栈顶为top，最后一个被pop掉的元素是lst（用数组即可便利记录）因为有可能中间存在必要的lca，没有被pop的点以及最后一个被pop的点，不向上连边①如果now在top子树内，加入栈中 ②否则，循环执行【lst连向top，pop掉top】直到栈空或者now在top子树内，如果lca(now,lst)=top，则lst连向top；否则lst连向lca，将lca和now插入栈中；最后清空lst 每个now加入完成后，将栈清空，并连边即可 显然总点数不超过2n 模板：【HNOI2014】世界树]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-11点分治]]></title>
    <url>%2Fposts%2Fb350.html</url>
    <content type="text"><![CDATA[重心及点分治 重心dfs序上，最右边的，$sz_x*2 \ge n$的点 重心可能有两个（对称的情况） 一般只是dfs（dp）求，这个性质可以用来动态维护重心（线段树上二分，树剖维护siz） 提醒任何与原本结构有关的信息，必须在原树上查询若在点分树上两点有lca，则原树上两点路径一定会经过lca 经典入门题bzoj2599. [IOI2011]Race bzoj1468. Tree 询问树上多少条路径值域连续：如果序列上就是一车讨论+分治，现在改成树分治其实差不多]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-10整体二分]]></title>
    <url>%2Fposts%2F55c7.html</url>
    <content type="text"><![CDATA[基于值域的整体分治 推荐资料2013许昊然论文-《浅谈数据结构题的几个非经典解法》 复杂度保证的关键通常而言，我们能通过一个log来把问题转化为局部子问题但这要求我们在判定二分的时候，所需要的时间不能和n有关，而只能和当前的局部区间长度有关 例题Dynamic Rankings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Zory-2018#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;namespace mine&#123; const int INF=0x3f3f3f3f; typedef long long ll; const int MAX_N=110000*3; int n; int bit[MAX_N]; int lowbit(int x) &#123;return x&amp;-x;&#125; void change(int x,int c) &#123; while(x&lt;=n) &#123; bit[x]+=c; x+=lowbit(x); &#125; &#125; int sum(int x) &#123; int ans=0; while(x&gt;=1) &#123; ans+=bit[x]; x-=lowbit(x); &#125; return ans; &#125; struct Qes &#123; int op; int l,r,k;//0询问 int pos,d,num;//1修改 int id; &#125;q[MAX_N],q1[MAX_N],q2[MAX_N]; int ans[MAX_N]; void solve(int l,int r,int fl,int fr) &#123; if(l&gt;r or fl&gt;fr) return; if(l==r) &#123; for(int i=fl;i&lt;=fr;i++) if(q[i].op==0) ans[q[i].id]=l; return; &#125; //printf("(%d,%d,%d,%d)\n",l,r,fl,fr); int mid=(l+r)/2,tot1=0,tot2=0; for(int i=fl;i&lt;=fr;i++) &#123; if(q[i].op==0) &#123; int left=sum(q[i].r)-sum(q[i].l-1); if(q[i].k&lt;=left) q1[++tot1]=q[i]; else q2[++tot2]=q[i],q2[tot2].k-=left; &#125; else &#123; if(q[i].d&lt;=mid) change(q[i].pos,q[i].num),q1[++tot1]=q[i]; else q2[++tot2]=q[i]; &#125; &#125; for(int i=1;i&lt;=tot1;i++) if(q1[i].op==1) change(q1[i].pos,-q1[i].num); for(int i=1;i&lt;=tot1;i++) q[fl+i-1]=q1[i]; for(int i=1;i&lt;=tot2;i++) q[fl+tot1+i-1]=q2[i]; solve(l,mid,fl,fl+tot1-1); solve(mid+1,r,fl+tot1,fr); &#125; int a[MAX_N]; void main() &#123; int m;scanf("%d%d",&amp;n,&amp;m); int tot=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); q[++tot]=(Qes)&#123;1,0,0,0,i,a[i],1,0&#125;; &#125; for(int now=1;now&lt;=m;now++) &#123; char str[5];scanf("%s",str); if(str[0]=='Q') &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); q[++tot]=(Qes)&#123;0,l,r,k,0,0,0,now&#125;; &#125; else &#123; int pos,t;scanf("%d%d",&amp;pos,&amp;t); q[++tot]=(Qes)&#123;1,0,0,0,pos,a[pos],-1,0&#125;; q[++tot]=(Qes)&#123;1,0,0,0,pos,a[pos]=t,1,0&#125;; &#125; &#125; memset(ans,-1,sizeof ans);//debug solve(0,INF,1,tot); for(int i=1;i&lt;=m;i++) if(ans[i]&gt;-1) printf("%d\n",ans[i]); &#125;&#125;int main()&#123; mine::main();&#125; loj2169「POI2011 R3 Day2」流星 Meteors]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-9-cdq分治]]></title>
    <url>%2Fposts%2Fd12f.html</url>
    <content type="text"><![CDATA[又称为基于时间的分治算法 要求 修改操作之间相互独立 允许离线 推荐资料2013许昊然论文-《浅谈数据结构题的几个非经典解法》 大致基本思想以时间轴排序每次分成两段，将左边的修改处理到右边后，就能分成两个子问题那么每一段的复杂度是与当前长度相关的，而不是总长度 题目自行搜索tag]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-8线段树]]></title>
    <url>%2Fposts%2Fb1b7.html</url>
    <content type="text"><![CDATA[博大精深的线段树 很多东西可能是可以自己yy的，但名字能方便交流 基本线段树例题：JSOI2014 奇怪的计算器 区间查询，复杂度log的证明假设某一次要同时访问左右两边，后面一定是刚进入就退出的（区间的连续性）所以说其实只有一次需要同时访问两边，复杂度为深度即log区间修改同样如此 upd:注意，这并不代表【同时访问左右两边】这部分每次只会执行一次 势能线段树主要考虑线段树的深度以及被操作次数 开方，$log_2(log_{10}x)$次（次幂/2），BZOJ3211花神游历各国 取模，logx次（被减少的数/2） 整除，logx次（区间极差/2） zkw线段树统计的力量-线段树全接触-张昆玮只学了最基础的：堆式编号下，我们是可以直接得到叶子节点的编号的；转化为为开区间就能非递归了 123456789101112131415161718namespace ZKW&#123; int a[1&lt;&lt;19],M=1&lt;&lt;18; #define lc x&lt;&lt;1 #define rc x&lt;&lt;1|1 void build()&#123;fd(x,M-1,1) a[x]=max(a[lc],a[rc]);&#125; void change(int x,int val)&#123;x+=M;a[x]=val;while(x&gt;1) x&gt;&gt;=1,a[x]=max(a[lc],a[rc]);&#125; int ask(int l,int r) &#123; l+=M-1,r+=M+1;int ans=0; while((l^r)!=1) &#123; if(!(l&amp;1)) chmax(ans,a[l+1]); if(r&amp;1) chmax(ans,a[r-1]); l&gt;&gt;=1;r&gt;&gt;=1; &#125;return ans; &#125;&#125;; 李超线段树比较常见的应用是维护线段单点查询，见bzoj适者 其主要思路就是，记录当前区间内，完全覆盖的线段中交mid最高的那个然后因为只能和当前层有关，只能标记永久化，当一个线段被淘汰的时候，就往某侧下传更新（自行推导具体方向） 修改复杂度，若直线直接log，线段要处理log个区间，故log方；询问就是单点询问log 另外还有一些跟前后缀min/max有关的应用：主要是写出一个solve函数后，有些特殊的solve调用（如访问右孩子的solve，附带的是左孩子的min，这种东西是可以记录下来的，带修的话只会调用log次solve） 【bzoj2957】楼房重建见之前写的题解 jsc2019 H Distinct Integers题解 码队的跑团历险最后一定是)))(((这样的，先只考虑计算右括号，然后反过来做即可 这种右括号就是其前缀和从0开始递减（左括号+1右括号-1），于是又变成求递减序列长度了，只不过多了个修改的标记维护 吉老师线段树-弱要求：区间改min，询问区间max或区间和 做法：记录最大值m1，最大值出现次数cnt，严格次大值m2，区间和sum 123if(x&gt;=m1) return;if(x&gt;m2) &#123;m1=x;update tag,update sum;return;&#125;递归两侧 时间复杂度：做递归的时候，这个节点内不同值个数–，初始所有节点不同值个数的上界就是复杂度，$O(nlogn)$ 猫树以一道题引入：维护序列，1e6次后面插入，1e7次询问区间最值，强制在线 线段树复杂度主要就是在找分界点和前后缀答案，那现在考虑通过预处理加速这个过程 注意到答案满足结合律，对于每个线段树节点都维护前缀、后缀答案，这个很好维护(nlogn)，然后每次询问找到区间第一次在线段树上分开的位置p，把两段合并即可；考虑怎么找p，感受一下p的左右端点都是可以用一些log之类求到的；具体而言，对于一般的堆式编号（满二叉树），p=二进制下l和r的lcp immortalCO的blog 线段树分治bzoj4025 二分图 经典例题 「CTSC2016」时空旅行（口胡） 题意：维护n个集合，呈以0为根的树状，集合元素为四元组$(x,y,z,c)$，根有一个元素$(0,0,0,c_0)$，每个集合由父亲转移，区别为插入或删除一个元素；m次询问对于某个集合s和横坐标xx，求$min_{i\in s}\ (x_i-xx)^2+c_i$（y和z是来卖萌的） $|x|,|y|,|z|\le1e6,c\le1e12,n,m\le 5e5$ 化化式子发现是个斜率优化，注意地球不能加进去，因为斜率为0；不难发现求dfs序后就是区间插入、删除直线，线段树常用套路把直线作为区间（nlogn个）放进去，而且一开始排好序插入的话斜率就是有序的，然后你发现如果把询问也放进去（单点nlogn个），可以用单调队列维护，故总复杂度nlogn；你发现我们的线段树就是一个不错的离线分治结构 线段树合并计算一下线段树合并的复杂度，主要就是公共区域考虑每个叶子，只会被合并一次，此后再经过其祖先不算是他的贡献，那么就是深度也就是log所以说个人认为这个东西并不是由启发式保证的，而是只会被合并一次，严格和不公共的地方无关 例题：bzoj2212 [Poi2011]Tree Rotations、hnoi永无乡 「TJOI / HEOI2016」排序 （加强）：资瓷在线区间求和 可以split线段树，类似求第k大，复杂度和合并一样是log；合并暴力合，求和套个平衡树，$O(nlog^2n)$；然后这里split不想写可以考虑用splay，空间也少个log，splay的有序合并也是log的 线段树维护动态直径前置知识：直径的一些性质，可以在套路集锦里面找到 模板题：「CEOI2019」动态直径 朴素的做法是log方的，就是线段树统计dfs序区间内直径的两个端点，然后用性质枚举端点保留最大的那个,这样写的话如果要带修需要写个树状数组维护每个点的dis，是log方的 然而是可以log做的，就是用更为友好的欧拉序，众所周知lca是欧拉序区间内dis最小的，但因为我们只是求直径，所以出现不是最小的dis也没有影响（尽可能减少限制条件） 故考虑维护以下信息：$ls[x]=dep_A-2dep_B(dfn_A\le dfnB),rs[x]=dep_D-2dep_C(dfn_C\le dfn_D)$ $ss[x]=dep_X+dep_Y-2dep_Z$ ，然后维护就是组合ls和rs、维护lazy标记，复杂度为 $O(nlogn)$ 且常数相对小，code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>精品文章</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-7动态树LCT]]></title>
    <url>%2Fposts%2Fe23c.html</url>
    <content type="text"><![CDATA[LCT（动态树） 这个东西对于省选及以上选手非常有用，请不要因为部分板子太长而逃避（好吧说的就是以前的我 文章师兄写的浅谈LCT实现及应用.pdf 板子1234567891011121314151617181920212223242526272829303132namespace LCT&#123; int son[N][2],fa[N]; int cnt[N][21],tag[N][21]; #define lc(x) son[(x)][0] #define rc(x) son[(x)][1] bool tw(int x)&#123;return son[fa[x]][1]==x;&#125; bool isrt(int x)&#123;return son[fa[x]][tw(x)]!=x;&#125; void pushdown(int x) &#123; for(int i=1;i&lt;=20;i++) &#123; cnt[lc(x)][i]+=tag[x][i];tag[lc(x)][i]+=tag[x][i]; cnt[rc(x)][i]+=tag[x][i];tag[rc(x)][i]+=tag[x][i]; tag[x][i]=0; &#125; &#125; void rotate(int x) &#123; int f=fa[x],ff=fa[f];if(!isrt(f)) son[ff][tw(f)]=x; int cc=tw(x),tson=son[x][cc^1];son[x][cc^1]=f;son[f][cc]=tson; fa[x]=ff;fa[f]=x;if(tson) fa[tson]=f; &#125; int tmp[N]; void splay(int x) &#123; int cnt=0,tt=x;tmp[0]=x;while(!isrt(tt)) tmp[++cnt]=tt,tt=fa[tt]; for(int i=cnt;i&gt;=0;i--) pushdown(tmp[i]); for(int f=fa[x];!isrt(x);rotate(x),f=fa[x]) if(!isrt(f)) tw(x)^tw(f)?rotate(x):rotate(f); &#125; void access(int x)&#123;for(int lst=0;x;lst=x,x=fa[x]) splay(x),son[x][1]=lst,fa[lst]=x;&#125;&#125;; makeroot这东西能不写就不写了吧（例如sam里面），毕竟多维护一个标记 要写就是$access(x)+splay(x)+reverse(x)$ 不用makeroot下的cut：$access(y)+splay(x),son[x][1]=fa[y]=0$ 好题CF#545F]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-6主席树]]></title>
    <url>%2Fposts%2Fd299.html</url>
    <content type="text"><![CDATA[主席树 6.6.0 背景对于两颗上下界相同的线段树，其结构唯一，节点一一对应。至于主席树来历之类的八卦，请自行上网搜索。某大佬：http://blog.csdn.net/xgc_woker/article/details/78018297 6.6.1 性质主席树，主要用于解决区间大小关系询问类问题，当然也用到了身为区间问题始祖的前缀和。其实它本质上是一颗权值线段树，所以比较大小就比较方便啦。 由于它存储的值是，对应某段区间，在他管辖范围内的这些数字总共出现了多少次。也正是由于出现次数满足可加性，前缀和可以很好的解决。 对于长度为1的一个区间，如果只看有用的信息，它的形状大致是一根链（空间logn），所以应该看成残缺的线段树（否则就会需要大量空间导致MLE）利用前缀和思想，用n颗主席树分别维护1~i区间内的信息，合并重复信息即可。 哦对了因为是权值线段树，所以要离散化，既减少空间，也避免下标出现负数。 6.6.2 例题应用Caioj1441Poj2104Hud2665 区间第k小（大）询问先利用前缀和获得对应区间信息，然后根据左右儿子的信息值，找到k在哪里，不断缩小范围，最后找到他的值。 caioj和HDU都AC然鹅，POJ却RE，至今迷离，放弃治疗…… 6.6.3 例题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Zory-2018//*******************头文件*******************#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;//*******************全局常量*******************const int MAXN=100000;const int NUL=0;//*******************全局定义*******************struct nod&#123; int x,p,z;&#125;d[MAXN+10];//*******************离散化*******************bool cmp(nod a,nod b)&#123; return a.x&lt;=b.x;&#125;void lsh(int n)&#123; sort(d+1,d+1+n,cmp); for(int i=1;i&lt;=n;i++) d[d[i].p].z=i;&#125;//*******************主席树*******************struct mg&#123; int lc,rc; int c;&#125;s[20*MAXN];int ln;//因为动态建树，l、r要放这里void add(int &amp;x,int l,int r,int c)&#123; if(x==NUL) &#123; x=++ln; s[x].c=0; s[x].lc=s[x].rc=NUL; &#125; s[x].c++; if(l==r) return; int mid=(l+r)/2; if(c&lt;=mid) add(s[x].lc,l,mid,c); else add(s[x].rc,mid+1,r,c);&#125;void merg(int x,int &amp;y)&#123; if(x==NUL) return; if(y==NUL) &#123;y=x;return;&#125; s[y].c+=s[x].c; merg(s[x].lc,s[y].lc); merg(s[x].rc,s[y].rc);&#125;//x、y是节点编号，l、r是离散化值即排名int ask(int x,int y,int l,int r,int rk)&#123; if(l==r) return d[l].x;//排名为l的原值 int xlc=s[x].lc,ylc=s[y].lc; int ls=s[ylc].c-s[xlc].c; int mid=(l+r)/2; if(rk&lt;=ls) return ask(xlc,ylc,l,mid,rk); return ask(s[x].rc,s[y].rc,mid+1,r,rk-ls);&#125;//*******************主函数*******************int ys[MAXN+10];int main()&#123; //int t;scanf("%d",&amp;t); //while(t--) //&#123; ln=0;memset(ys,NUL,sizeof(ys)); int n,m;scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;d[i].x),d[i].p=i; lsh(n); for(int i=1;i&lt;=n;i++) &#123; add(ys[i],1,n,d[i].z);//插入一条链 merg(ys[i-1],ys[i]);//合并从而形成前缀和 &#125; while(m--) &#123; int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",ask(ys[l-1],ys[r],1,n,k)); //注意前缀和的-1 &#125; //&#125;&#125; 6.6.4 练习Bzoj1901 Zju2112Dynamic RankingsSPOJ3267 D-query 6.4.7 所有题目Tag-主席树]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-6莫队Mo's algorithm]]></title>
    <url>%2Fposts%2F343e.html</url>
    <content type="text"><![CDATA[莫队Mo’s algorithm 普通的莫队要求：可离线，无修 设端点移动的复杂度为1，一般来说是等比例缩放计算复杂度，例如用set带个log 不分块的莫队指求平面曼哈顿最小生成树，因为遍历树的话大致上每条边经过两次；但一般不这样搞，比较麻烦 一个比较接近下界的方法是设块大小阈值B分块，左端点在同个块的一组，组内右端点递增，那么对于每个组，复杂度为$q_iB+n$，共n/B组即$qB+n^2/B，当n=q时取B=n^{0.5}$最优 bzoj2038 小Z的袜子：mt的经典题 bzoj3585：求区间mex，普通莫队本质上就是n根号个修改以及n个询问；那么权值分块一下，修改是O(1)的，询问是根号的顺便说说主席树的做法：开n棵表示前缀，位置i表示数字i的位置，那么询问就是在第r棵上二分（维护区间最小值） 带修莫队要求：可离线 一般做法：左右端点都要分块，块内时间有序，按这三个关键字排序；然后对于每个左块，考虑右块间的切换，总长还是n，而同块的两个询问间依然是B，所以区别不是很大，时间的话就是$(n/B)^2tim$，综合而言大概是$(n/B)^2tim+n^2/B+qB$，如果$n=tim=q取B=n^{2/3}，则为n^{5/3}$ bzoj2120 数颜色：经典题 CF940F Machine Learning：首先次数值域与n同阶，那么现在就是怎么求mex，值域分块，记录每个块当前被填充的大小即可，不影响复杂度，因为移动虽多询问还是q次，每次跑个根号求mex罢了，code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-5-kdtree]]></title>
    <url>%2Fposts%2F23c.html</url>
    <content type="text"><![CDATA[kdtree 入门： K-DTree-n+e.pdf以下内容不会证：这个东西如果是用来查询二维区间的话据说是根号的，高维形式化就是 $O(n^{1-\frac{1}{k}})$然后带插入的需要采用类似替罪羊树的操作，如果子树不平衡度达到3/4，就重构，复杂度为nlogn 练习SJY摆棋子最近点对Hide and Seek 练习题Tag-kdtree]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-4树上启发式合并]]></title>
    <url>%2Fposts%2Fb144.html</url>
    <content type="text"><![CDATA[dsu on tree 挺好用的 基本思路维护子树信息的时候，dfs处理每个节点，信息全局维护然后重儿子的信息保留给父亲，轻儿子重新遍历，逐个加入 （所以能遍历地维护一些平时很麻烦的东西）复杂度的话考虑每个节点被访问的次数，比较显然 入门题bzoj5040]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>树上启发式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-3splay]]></title>
    <url>%2Fposts%2Faf961dad.html</url>
    <content type="text"><![CDATA[splay 6.4.1 定义伸展树是一种相当灵活的平衡树结构（灵活：便于添加和删除）比较少直接使用，能应用于LCT 6.4.2 模版题我把最重要的讲解放在这里面了【Caioj1130】【Codevs4543】【Bzoj3224】普通平衡树 6.4.5 练习Codevs3303文艺平衡树Bzoj3196二逼平衡树Bzoj1500维修数列 6.4.5 其他题目Caioj1131 Bzoj1588 Codevs1296 HNOI2002 HNOI2014 营业额统计Caioj1132 Bzoj1503 Codevs1286 NOI2004 郁闷的出纳员Caioj1133 Bzoj1208 CCodevs1285 HNOI2004 宠物收养所Caioj1137 Bzoj1058 Codevs1429 ZJOI2007 报表统计 6.4.6 总结重点是利用伸展树的灵活性另外，每次Splay既是加速也是重要的更新（pushdown/pushup） 如果还看不懂，阔以看看介个文章：FlashHu 6.4.7 所有题目Tag-伸展树 update说说我对前驱后继操作的理解我的写法是兼容【参数不存在】的情况的findip会找到一个存在元素，可能不满足条件，但一定是在那个方向最接近的（如果比d小，那么一定是其中最大的，反之亦然）那么为了确保找到正确答案，不能直接找父亲什么的，要旋转到根，然后往那个方向按具体需求去找 目前已知的只有splay能实现，而set不能的功能： 找第k大等，与具体值没有关系，而且k不是首尾的操作（这里没必要用主席树） logn合并两个splay，就是按照值顺序插入，据说是因为它满足finger search，我也不知道这是啥 目前已知的只有主席树能实现的东西：区间第k大（如果像二逼平衡树那样树套树也行） 板子12345678910111213141516171819struct Splay&#123; struct Nod&#123;int son[2],fa;&#125;p[MAX_N]; int id;spt()&#123;memset(p,0,sizeof p);id=0;&#125; bool son(int x) &#123;return p[p[x].fa].son[1]==x;&#125; void rotate(int x) &#123; int f=p[x].fa,ff=p[f].fa;p[ff].son[son(f)]=x; int w=son(x),t=p[x].son[w^1];p[f].son[w]=t;p[x].son[w^1]=f; p[x].fa=f;p[f].fa=x;p[t].fa=f; &#125; bool isroot(int x) &#123;return p[x].fa==0;&#125; int tmp[MAX_N]; void splay(int x,int rt) &#123; for(int f=p[x].fa;!isroot(x);rotate(x),f=p[x].fa) if(!isroot(y)) son(x)^son(y)?rotate(x):rotate(f); &#125;&#125;spt;]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-2树状数组]]></title>
    <url>%2Fposts%2F1650.html</url>
    <content type="text"><![CDATA[国际名称：Fenwick tree 本质上是个只保留左孩子信息的zkw线段树 一般在对常数要求较高或维护的信息非常简单的时候使用]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】02数据结构-1分块]]></title>
    <url>%2Fposts%2F2aa7.html</url>
    <content type="text"><![CDATA[文章参考网页版：http://hzwer.com/8053.html 好吧，实话说已经灰常详细了，暂时不知道说些什么好…… 学习指导：Hzwer题表 所有题目Tag-分块]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-5二叉树]]></title>
    <url>%2Fposts%2F212a.html</url>
    <content type="text"><![CDATA[初赛常考内容随便说点性质 树上的度指子节点数量，和通常一般图上说的不同！设ni为二叉树上，度为i的节点数量则n0=n2+1证明： n=n0+n1+n2 孩子节点总数=n1+2n2 显然n=n1+2n2+1 所以得证 树的层次，从第0层开始一棵树的高度，为其层数-1，所以和深度最大的节点，数值相同（根深度为0） 完美二叉树 Perfect Binary Tree: 没有度为0的节点完全二叉树 Complete Binary Tree：除最后一层都满完满二叉树 Full Binary Tree：即国内通常指的满二叉树]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-4原码反码补码]]></title>
    <url>%2Fposts%2Fa619.html</url>
    <content type="text"><![CDATA[初赛常考内容 5.1.1 基本概念字节：8个位（bit）。字长：若干个字节。到底是几个字节？具体看是哪种CPU。 比如2010普及组第11题就假设一个字长只有一个字节8个位。接下来原码、反码，补码都是建立在机器数在一个字长上的表示。为了方便理解，我们假设字长为一个字节。读者要注意事实上为32位CPU字长为4个字节，64位CPU字长为8个字节。 5.1.2 原码首位为符号位，其余为真值。比如：原码总结：范围：比如字长为8位，则范围为 11111111（－255） 至 01111111（＋255）。缺点：0有两个表示，分别为正零（00000000）和负零（10000000），给计算机计算带来不便。 5.1.3 反码首位为符号位，其它位分正数和负数两种情况。反码正数：所有位和原码一样；反码负数：除了符号位和原码一样，其他位相反。比如：77的反码表示为01001101 -77的反码表示为10110010补码总结：同样0有两个表示，也没有原码简单，反码存在的意义就是为了连接原码和补码。 5.1.4 补码分正数和负数两种情况。补码正数：所有位和反码一样，当然也和原码一样。补码负数：等于反码加1。简单的一句话，其实很麻烦。比如：77的补码表示为01001101（和原码、反码一致） -77的补码表示为10110011 加1之后会有进位，因为补码没有符号位，所以负零的补码表示也是00000000。补码总结：特点：表示比反码更麻烦。但是解决了一个问题：0只有一种表示。 原码 反码 补码 正零 00000000 00000000 00000000 负零 10000000 11111111 00000000 5.1.5 位运算不错的参考~和!都是取反，但~对符号位取反，!则不会]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-3操作符和优先级]]></title>
    <url>%2Fposts%2Fd010.html</url>
    <content type="text"><![CDATA[表格 记忆方法：–摘自《C语言程序设计实用问答》 问题：如何记住运算符的15种优先级和结合性？解答：C语言中运算符种类比较繁多，优先级有15种，结合性有两种。如何记忆两种结合性和15种优先级？下面讲述一种记忆方法。结合性有两种，一种是自左至右，另一种是自右至左，大部分运算符的结合性是自左至右，只有单目运算符、三目运算符的赋值运算符的结合性自右至左。 优先级有15种。记忆方法如下：记住一个最高的：构造类型的元素或成员以及小括号。记住一个最低的：逗号运算符。剩余的是一、二、三、赋值。意思是单目、双目、三目和赋值运算符。在诸多运算符中，又分为：算术、关系、逻辑。两种位操作运算符中，移位运算符在算术运算符后边，逻辑位运算符在逻辑运算符的前面。再细分如下：1234算术运算符分 * / %高于+ -关系运算符中 &gt; &gt;= &lt; &lt;=高于== !=逻辑运算符中，除了逻辑求反(!)是单目外，逻辑与(&amp;&amp;)高于逻辑或(||)逻辑位运算符中，除了逻辑按位求反(~）外，按位与(&amp;)高于按位半加(^)高于按位或(|) 这样就将15种优先级都记住了，再将记忆方法总结如下：去掉一个最高的，去掉一个最低的，剩下的是一、二、三、赋值。双目运算符中，顺序为算术、关系和逻辑，移位和逻辑位插入其中。]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-2STL]]></title>
    <url>%2Fposts%2Fa012.html</url>
    <content type="text"><![CDATA[深刻教训： 注意！multiset的count复杂度和对应元素数量相关注意！set等非随机访问结构的lower_bound，必须调用结构内部的，用stl的那个函数会线性 字符串读取整行，getline(cin,s);123456789101112#include&lt;string&gt;string s1; //定义一个字符串s1，并初始化为空string s2(s1); //用s1初始化s2string s3("value"); //将s3初始化为"value"string s4(n,'c'); //将s4初始化为字符'c'的n个副本，简单来说就是n个'c'字符s.empty() //若s为空串，则返回true，否则为falses.size() //返回s中字符的个数，s.length()与其相同s.insert(pos,s2) //在s下标为pos的元素前插入字符串s2s.substr(pos,len) //返回s中下标为pos起的长度为len的子串s.replace(pos,l,s2) //替换s中下标为pos起的长度l个字符为字符串s2s.find(s2,pos) //在s中查找s2第一次出现的位置s.c_str() //返回一个C风格的字符串临时指针 vector123vector&lt;int&gt; vvvv.pop_back() 字面意思vv.back() 返回最后元素 数组堆123make_heap(vv.begin(),vv.end())push(num)就是vv.push_back(num),push_heap(vv.begin(),vv.end())pop()就是pop_heap(vv.begin(),vv.end()),vv.pop_back() pbds的可并堆123#include&lt;ext/pb_ds/priority_queue.hpp&gt;__gnu_pbds::priority_queue&lt;T&gt; A,B;A.join(B); mapmap &lt;类型1,类型2&gt; 变量名;在一些应用中，使用map容器来作为一个有序的映射表对map单次操作的时间复杂度为log(n) 123456789101112#include&lt;map&gt;ma["abc"]=2; //将字符串"abc"映射到整数2cout&lt;&lt;ma["abc"]; //输出为2ma.begin() //返回map中第一个元素的迭代器（指针）ma.end() //返回最后一个元素后一个的迭代器（指针）ma.size() //返回map中元素的个数ma.count(key) //判断关键字key是否存在map中ma.clear() //初始化mapma.lower_bound() //返回键值大于等于给定元素的第一个位置,一旦map中的一个元素被访问，不论它之前是否已经被赋值，它都被视为存在，所以试探最好用countoperator[] //访问map中的元素，若该元素不存在,则创建一个新元素，并返回类型2初始值获得iterater：ma.find("abc") 关于unordered相关的信息：尽管在正式比赛中不能用，一般做题还是会用 set返回迭代器（直接减去begin()得到下标即排名，加上*得到值）begin()–返回指向第一个元素的迭代器end()–返回指向最后一个元素的迭代器find()–返回一个指向被查找到元素的迭代器，不存在则返回end()lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器，可外面，不存在则返回end()upper_bound()–返回大于某个值元素的迭代器，可外面，不存在则返回end() 用multiset可以完全代替优先队列，还可以同时小根、大根支持删除（s.erase(s.find())即可，只会删一个，如果传入值删除所有）、搜索元素 12得到最小值*(s.begin())最大值*(--s.end()) Zebras 迭代器123456map&lt;string,int&gt; m;for(map&lt;string,int&gt;::iterator i=m.begin();i!=m.end();i++)&#123; //或 cout&lt;&lt;i-&gt;first&lt;&lt;" "&lt;&lt;i-&gt;second&lt;&lt;endl; cout&lt;&lt;(*i).first&lt;&lt;" "&lt;&lt;(*i).second&lt;&lt;endl;&#125; 如果要反向枚举，可以从rbegin的结尾，到rend，注意遍历的时候要用++这样会方便很多，不用预处理st和edsort的时候（主要是vector）也会很方便：sort( a.rbegin(),a.rend() )这可以从大到小 bitset定义、初始化与赋值bitset 表示二进制长度为8默认初始值为0bs[0]=1 表示将最后一位设为1，而不是首位（bin[0]） 函数返回boolbs.any() 是否存在值为1的二进制位bs.none() 是否不存在值为1的二进制位，也就是0bs.count() 值为1的个数 返回bitsetbs.flip() 全部位逐位取反，等效于 ~bs 返回下标找1_Find_first()_Find_next(pos)Zebras 其他所有位运算，除了“!”，不知道原因赋值：set()全部1，reset()全部0 转化bs.to_string()bs.to_ulong() 变成 unsigned longbs.to_ullong() 变成 unsigned long longbs=”0001010”bs=31 优秀的空间复杂度 长度 bitset字节 bool[]字节 16 4 16 32 4 32 64 8 64 简而言之，每8位1个字节其实和用int存储是一样的，例如32位是4字节 时间复杂度每次操作，位数/32 其他nth_element(start, start+n, end)使第n大元素处于第n位置（从0开始,其位置是下标为 n的元素）常用于KD-Tree原理其实就是手写二分排序一样，然后只搞某一侧 deque与queue不同在于能任意访问其中的元素（因为是连续的空间），并且能在前面插入元素（与vector不同）（这是手写队列也无法做到的，虽然不常用，因为oi不考stl，只是作为工具） equal_range参数和lower_bound等类似能够返回容器内，等值区间，而且同样是左闭右开区间]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】01语法与STL-1概要与常识]]></title>
    <url>%2Fposts%2F5fe4.html</url>
    <content type="text"><![CDATA[这些可能在NOIP初赛、日常做题比较有用当然也是计算机领域的一些常识 double与long double的范围double 300位long double 3000位 均摊分析（势能分析）zzd 系统dfs栈windows默认60000左右，linux默认250000左右解决方法：手写栈 主定理用来分析复杂度的东东$T(n)=aT(\frac{n}{b})+f(n)$如果 $f(n)&lt;O(n^{log_b a}),T(n)=O(n^{log_b a})$如果 $f(n)=O(n^{log_b a}log^k n),T(n)=O(n^{log_b a} log^{k+1} n)$否则， $T(n)=O(f(n))$很多分治算法不太好计算，就可以用这个 切比雪夫距离就是max(dx,dy)曼哈顿转切比雪夫，(x,y)-&gt;(x+y,x-y)这个证明比较好证 指针引用： 1int a=10;int &amp;b=a;b=2;write(a);//2 指针： 12345678910111213141516171819202122int a=10;int *x=&amp;i;int y=*x;y=3;(*x)=6;write1(a);write(y);//6 3//空指针为NULL，指针可以与数加减得指针const int tmp=3;const int *b=&amp;tmp;b=x;//指向常量的指针int *const c=&amp;y;//常量指针，不可更改指向对象//下标可为负数的数组int _a[N+N],*const a=_a+N;a[-3]=3;//函数传数组void solve(int *zz)//或void solve(int zz[])或void solve(int zz[实际大小])//交换数组int _a[100],_b[100];int *a=_a,*b=_b;//使用普通指针代替for(int i=0;i&lt;4;++i) a[i]=1;swap(a,b);for(int i=0;i&lt;4;++i) printf("%d",b[i]);//1 1 1 1//简略typedef char* PCHAR;PCHAR pa,pb;//等价于char *pa, *pb;//函数指针，这样可以给函数传函数void func(const int &amp;x)&#123;write(x);&#125;void (*p)(const int&amp;);//定义函数指针p=&amp;func;p(4); 初赛易错 主频1 GHZ=1000 MHz 区位码转国际码，分别加上32；国际码转机内码，分别加128 LAN 局域网，MAN 城域网， WAN 广域网 网络协议应用层：telnet（远程登陆），ftp，e-mail传输层：TCP（传输控制协议）， Udp（用户数据报协议）网络层：IP 网际协议，ICMP（网际控制报文协议），IGMP（组管理协议）网络结构层：设备驱动程序 DNS域名系统，将域名转化为地址 电子邮件：简单邮件传输协议SMTP，电子邮件拓展协议MIME，POP协议 不稳定排序：选择排序，希尔排序，快排，堆排， 只有堆排和归并最坏nlogn 16位色指有 $2^{16}$ 种颜色，即每个像素2字节（8个bit） 面向对象的语言：C#，c++，java，smalltalk，eiffel 第一种高级语言：Fortran 浮点数分阶码和尾数两部分，阶码位数越多，可表示的数的范围越大；尾数越多，所表示的数的精度越高 复杂度包括时间和空间P问题：存在多项式解法的问题NP问题：多项式时间内验证答案的问题NP-hard问题：所有NP问题可以在多项式复杂度内归约到它NPC问题：所有NP问题可以在多项式复杂度内归约到它，而且是NP问题详细资料 IP0.0.0.0 对应于当前主机255.255.255.255当前子网的广播地址127.0.0.1 代表本机IP地址 oth原码、补码、反码操作符和优先级可变参数数据类型的对照]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】贪心]]></title>
    <url>%2Fposts%2F2d0202e9.html</url>
    <content type="text"><![CDATA[一些纯贪心 noip国王游戏见之前题解 「JSOI2007」建筑抢修做法：这种有终止时间的题可以考虑按这个排序来处理，设当前处理到的结束时间为D 记录当前时间tim，如果能放进去就放；不能的时候，此时如果存在$t_i&gt;t_{now}$，替换掉一定更优，可以用大根堆找这样的i，$O(nlogn)$，code 「HEOI2015」兔子与樱花做法：发现只关心每个节点的$key_x=c_x+son_x$，然后删除点就是$key_x+=key_{son}-1$ 注意到删除点只关心点集而不是顺序，从下往上删除，每次如果要删除孩子，肯定选key最小的那个，然后如果能删一定会选择删，因为既然现在合法一定是现在删不劣，$O(nlogn)$ HDU4582 DFS spanning tree题意：给出一个没有自环的有向图，前n-1条边构成dfs树（以1为根），现在需要选最少的边，使得每个【由若干树边和一条非树边构成的环】上最少一条边被选中 做法：注意到是dfs搜索树，所以没有横叉边；要选肯定选树边，每个这种环的树边构成一条向上的简单链 对于每个区间至少选一个点的问题，如果在序列上就是按左端点排序，每次处理到还没有被覆盖的区间就贪心放右端点；现在放在树上，保证是向上的链，所以并没有什么不同，$O(Tmlogm)$ CF521D shop题意：长度为k的序列，在n种操作中选m个并构造顺序执行，使得最后序列每个数乘积最大；操作有三种，分别是赋值、加法、乘法（操作位置给定），$k,m,n \le 1e5,值 \le 1e6$ 做法：首先各个位置独立，而且操作肯定是按照赋值、加法、乘法顺序去做的，其中乘法对于乘积的贡献可以任意排序做，可以忽略。对于每个位置，首先考虑赋值，选最大那个出来，将增量看做加法，于是赋值操作也没有了；现在只剩加法，如果一个位置要搞t个肯定是选最大的t个，于是排好序的序列肯定是考虑新选这个数与上个数相比的贡献，然后我就微扰到去世了。 其实再转化一次就好了，对于任意相邻两个元素a和b，前面和为front，看做两个乘法：$\frac{front+a}{front},\frac{front+a+b}{front+a}$ 最后我们会选择最大的m个乘法，我们需要证明$\frac{front+a}{front}&gt;\frac{front+a+b}{front+a}$，两边都-1后，右边分母更大分子更小，证毕 选出那m个乘法后，循环三次把三种操作取出即可，$O(nlogn)$，code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【OI之路】模拟与讨论大合集]]></title>
    <url>%2Fposts%2Fba43.html</url>
    <content type="text"><![CDATA[模拟与讨论大合集（仅散题） 因为经常碰到模拟、讨论就做很久，丢几道题在这里 但似乎也没啥好说的，就放题意和代码好了 CF878B Teams Formation一个长度n的串复制m次，去掉连续相同的每k个，求最后长度 $n \le1e5,m ,k\le 1e9$，code]]></content>
      <categories>
        <category>OI之路</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
